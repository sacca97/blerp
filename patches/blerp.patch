diff --git a/nimble/controller/include/controller/ble_ll_ctrl.h b/nimble/controller/include/controller/ble_ll_ctrl.h
index 89502a45..96f44e8b 100644
--- a/nimble/controller/include/controller/ble_ll_ctrl.h
+++ b/nimble/controller/include/controller/ble_ll_ctrl.h
@@ -29,155 +29,151 @@ extern "C" {
  * It is used to determine which LL control procedure is currently running
  * in a connection and which ones may be pending.
  */
-#define BLE_LL_CTRL_PROC_CONN_UPDATE    (0)
-#define BLE_LL_CTRL_PROC_CHAN_MAP_UPD   (1)
-#define BLE_LL_CTRL_PROC_ENCRYPT        (2)
-#define BLE_LL_CTRL_PROC_FEATURE_XCHG   (3)
-#define BLE_LL_CTRL_PROC_VERSION_XCHG   (4)
-#define BLE_LL_CTRL_PROC_TERMINATE      (5)
+#define BLE_LL_CTRL_PROC_CONN_UPDATE (0)
+#define BLE_LL_CTRL_PROC_CHAN_MAP_UPD (1)
+#define BLE_LL_CTRL_PROC_ENCRYPT (2)
+#define BLE_LL_CTRL_PROC_FEATURE_XCHG (3)
+#define BLE_LL_CTRL_PROC_VERSION_XCHG (4)
+#define BLE_LL_CTRL_PROC_TERMINATE (5)
 #define BLE_LL_CTRL_PROC_CONN_PARAM_REQ (6)
-#define BLE_LL_CTRL_PROC_LE_PING        (7)
-#define BLE_LL_CTRL_PROC_DATA_LEN_UPD   (8)
-#define BLE_LL_CTRL_PROC_PHY_UPDATE     (9)
-#define BLE_LL_CTRL_PROC_SCA_UPDATE     (10)
-#define BLE_LL_CTRL_PROC_CIS_CREATE     (11)
-#define BLE_LL_CTRL_PROC_SUBRATE_REQ    (12)
+#define BLE_LL_CTRL_PROC_LE_PING (7)
+#define BLE_LL_CTRL_PROC_DATA_LEN_UPD (8)
+#define BLE_LL_CTRL_PROC_PHY_UPDATE (9)
+#define BLE_LL_CTRL_PROC_SCA_UPDATE (10)
+#define BLE_LL_CTRL_PROC_CIS_CREATE (11)
+#define BLE_LL_CTRL_PROC_SUBRATE_REQ (12)
 #define BLE_LL_CTRL_PROC_SUBRATE_UPDATE (13)
-#define BLE_LL_CTRL_PROC_NUM            (14)
-#define BLE_LL_CTRL_PROC_IDLE           (255)
+#define BLE_LL_CTRL_PROC_NUM (14)
+#define BLE_LL_CTRL_PROC_IDLE (255)
 
 /* Checks if a particular control procedure is running */
-#define IS_PENDING_CTRL_PROC(sm, proc)  (sm->pending_ctrl_procs & (1 << proc))
+#define IS_PENDING_CTRL_PROC(sm, proc) (sm->pending_ctrl_procs & (1 << proc))
 #define CLR_PENDING_CTRL_PROC(sm, proc) (sm->pending_ctrl_procs &= ~(1 << proc))
 
 /* LL control procedure timeout */
-#define BLE_LL_CTRL_PROC_TIMEOUT_MS     (40000) /* ms */
+#define BLE_LL_CTRL_PROC_TIMEOUT_MS (40000) /* ms */
 
 /*
  * LL CTRL PDU format
  *  -> Opcode   (1 byte)
  *  -> Data     (0 - 26 bytes)
  */
-#define BLE_LL_CTRL_CONN_UPDATE_IND     (0x00)
-#define BLE_LL_CTRL_CHANNEL_MAP_REQ     (0x01)
-#define BLE_LL_CTRL_TERMINATE_IND       (0x02)
-#define BLE_LL_CTRL_ENC_REQ             (0x03)
-#define BLE_LL_CTRL_ENC_RSP             (0x04)
-#define BLE_LL_CTRL_START_ENC_REQ       (0x05)
-#define BLE_LL_CTRL_START_ENC_RSP       (0x06)
-#define BLE_LL_CTRL_UNKNOWN_RSP         (0x07)
-#define BLE_LL_CTRL_FEATURE_REQ         (0x08)
-#define BLE_LL_CTRL_FEATURE_RSP         (0x09)
-#define BLE_LL_CTRL_PAUSE_ENC_REQ       (0x0A)
-#define BLE_LL_CTRL_PAUSE_ENC_RSP       (0x0B)
-#define BLE_LL_CTRL_VERSION_IND         (0x0C)
-#define BLE_LL_CTRL_REJECT_IND          (0x0D)
-#define BLE_LL_CTRL_PERIPH_FEATURE_REQ   (0x0E)
-#define BLE_LL_CTRL_CONN_PARM_REQ       (0x0F)
-#define BLE_LL_CTRL_CONN_PARM_RSP       (0x10)
-#define BLE_LL_CTRL_REJECT_IND_EXT      (0x11)
-#define BLE_LL_CTRL_PING_REQ            (0x12)
-#define BLE_LL_CTRL_PING_RSP            (0x13)
-#define BLE_LL_CTRL_LENGTH_REQ          (0x14)
-#define BLE_LL_CTRL_LENGTH_RSP          (0x15)
-#define BLE_LL_CTRL_PHY_REQ             (0x16)
-#define BLE_LL_CTRL_PHY_RSP             (0x17)
-#define BLE_LL_CTRL_PHY_UPDATE_IND      (0x18)
-#define BLE_LL_CTRL_MIN_USED_CHAN_IND   (0x19)
-#define BLE_LL_CTRL_CTE_REQ             (0x1A)
-#define BLE_LL_CTRL_CTE_RSP             (0x1B)
-#define BLE_LL_CTRL_PERIODIC_SYNC_IND   (0x1C)
-#define BLE_LL_CTRL_CLOCK_ACCURACY_REQ  (0x1D)
-#define BLE_LL_CTRL_CLOCK_ACCURACY_RSP  (0x1E)
-#define BLE_LL_CTRL_CIS_REQ             (0x1F)
-#define BLE_LL_CTRL_CIS_RSP             (0x20)
-#define BLE_LL_CTRL_CIS_IND             (0x21)
-#define BLE_LL_CTRL_CIS_TERMINATE_IND   (0x22)
-#define BLE_LL_CTRL_POWER_CONTROL_REQ   (0x23)
-#define BLE_LL_CTRL_POWER_CONTROL_RSP   (0x24)
-#define BLE_LL_CTRL_POWER_CHANGE_IND    (0x25)
-#define BLE_LL_CTRL_SUBRATE_REQ         (0x26)
-#define BLE_LL_CTRL_SUBRATE_IND         (0x27)
-#define BLE_LL_CTRL_CHAN_REPORTING_IND  (0x28)
-#define BLE_LL_CTRL_CHAN_STATUS_IND     (0x29)
+#define BLE_LL_CTRL_CONN_UPDATE_IND (0x00)
+#define BLE_LL_CTRL_CHANNEL_MAP_REQ (0x01)
+#define BLE_LL_CTRL_TERMINATE_IND (0x02)
+#define BLE_LL_CTRL_ENC_REQ (0x03)
+#define BLE_LL_CTRL_ENC_RSP (0x04)
+#define BLE_LL_CTRL_START_ENC_REQ (0x05)
+#define BLE_LL_CTRL_START_ENC_RSP (0x06)
+#define BLE_LL_CTRL_UNKNOWN_RSP (0x07)
+#define BLE_LL_CTRL_FEATURE_REQ (0x08)
+#define BLE_LL_CTRL_FEATURE_RSP (0x09)
+#define BLE_LL_CTRL_PAUSE_ENC_REQ (0x0A)
+#define BLE_LL_CTRL_PAUSE_ENC_RSP (0x0B)
+#define BLE_LL_CTRL_VERSION_IND (0x0C)
+#define BLE_LL_CTRL_REJECT_IND (0x0D)
+#define BLE_LL_CTRL_PERIPH_FEATURE_REQ (0x0E)
+#define BLE_LL_CTRL_CONN_PARM_REQ (0x0F)
+#define BLE_LL_CTRL_CONN_PARM_RSP (0x10)
+#define BLE_LL_CTRL_REJECT_IND_EXT (0x11)
+#define BLE_LL_CTRL_PING_REQ (0x12)
+#define BLE_LL_CTRL_PING_RSP (0x13)
+#define BLE_LL_CTRL_LENGTH_REQ (0x14)
+#define BLE_LL_CTRL_LENGTH_RSP (0x15)
+#define BLE_LL_CTRL_PHY_REQ (0x16)
+#define BLE_LL_CTRL_PHY_RSP (0x17)
+#define BLE_LL_CTRL_PHY_UPDATE_IND (0x18)
+#define BLE_LL_CTRL_MIN_USED_CHAN_IND (0x19)
+#define BLE_LL_CTRL_CTE_REQ (0x1A)
+#define BLE_LL_CTRL_CTE_RSP (0x1B)
+#define BLE_LL_CTRL_PERIODIC_SYNC_IND (0x1C)
+#define BLE_LL_CTRL_CLOCK_ACCURACY_REQ (0x1D)
+#define BLE_LL_CTRL_CLOCK_ACCURACY_RSP (0x1E)
+#define BLE_LL_CTRL_CIS_REQ (0x1F)
+#define BLE_LL_CTRL_CIS_RSP (0x20)
+#define BLE_LL_CTRL_CIS_IND (0x21)
+#define BLE_LL_CTRL_CIS_TERMINATE_IND (0x22)
+#define BLE_LL_CTRL_POWER_CONTROL_REQ (0x23)
+#define BLE_LL_CTRL_POWER_CONTROL_RSP (0x24)
+#define BLE_LL_CTRL_POWER_CHANGE_IND (0x25)
+#define BLE_LL_CTRL_SUBRATE_REQ (0x26)
+#define BLE_LL_CTRL_SUBRATE_IND (0x27)
+#define BLE_LL_CTRL_CHAN_REPORTING_IND (0x28)
+#define BLE_LL_CTRL_CHAN_STATUS_IND (0x29)
 
 /* Maximum opcode value */
-#define BLE_LL_CTRL_OPCODES             (BLE_LL_CTRL_CHAN_STATUS_IND + 1)
+#define BLE_LL_CTRL_OPCODES (BLE_LL_CTRL_CHAN_STATUS_IND + 1)
 
 extern const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES];
 
 /* Maximum LL control PDU size */
 #if MYNEWT_VAL(BLE_ISO)
-#define BLE_LL_CTRL_MAX_PDU_LEN         (42)
+#define BLE_LL_CTRL_MAX_PDU_LEN (42)
 #elif MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
-#define BLE_LL_CTRL_MAX_PDU_LEN         (35)
+#define BLE_LL_CTRL_MAX_PDU_LEN (35)
 #else
-#define BLE_LL_CTRL_MAX_PDU_LEN         (27)
+#define BLE_LL_CTRL_MAX_PDU_LEN (27)
 #endif
 
 /* LL control connection update request */
-struct ble_ll_conn_upd_req
-{
-    uint8_t winsize;
-    uint16_t winoffset;
-    uint16_t interval;
-    uint16_t latency;
-    uint16_t timeout;
-    uint16_t instant;
+struct ble_ll_conn_upd_req {
+	uint8_t winsize;
+	uint16_t winoffset;
+	uint16_t interval;
+	uint16_t latency;
+	uint16_t timeout;
+	uint16_t instant;
 };
-#define BLE_LL_CTRL_CONN_UPD_REQ_LEN        (11)
+#define BLE_LL_CTRL_CONN_UPD_REQ_LEN (11)
 
 /* LL control channel map request */
-struct ble_ll_chan_map_req
-{
-    uint8_t chmap[5];
-    uint16_t instant;
+struct ble_ll_chan_map_req {
+	uint8_t chmap[5];
+	uint16_t instant;
 };
-#define BLE_LL_CTRL_CHAN_MAP_LEN            (7)
+#define BLE_LL_CTRL_CHAN_MAP_LEN (7)
 
 /*
  * LL control terminate ind
  *  -> error code (1 byte)
  */
-#define BLE_LL_CTRL_TERMINATE_IND_LEN      (1)
+#define BLE_LL_CTRL_TERMINATE_IND_LEN (1)
 
 /* LL control enc req */
-struct ble_ll_enc_req
-{
-    uint8_t rand[8];
-    uint16_t ediv;
-    uint8_t skdm[8];
-    uint32_t ivm;
+struct ble_ll_enc_req {
+	uint8_t rand[8];
+	uint16_t ediv;
+	uint8_t skdm[8];
+	uint32_t ivm;
 };
 
-#define BLE_LL_CTRL_ENC_REQ_LEN             (22)
+#define BLE_LL_CTRL_ENC_REQ_LEN (22)
 
 /* LL control enc rsp */
-struct ble_ll_enc_rsp
-{
-    uint8_t skds[8];
-    uint32_t ivs;
+struct ble_ll_enc_rsp {
+	uint8_t skds[8];
+	uint32_t ivs;
 };
 
-#define BLE_LL_CTRL_ENC_RSP_LEN             (12)
+#define BLE_LL_CTRL_ENC_RSP_LEN (12)
 
 /* LL control start/pause enc request and response */
-#define BLE_LL_CTRL_START_ENC_REQ_LEN       (0)
-#define BLE_LL_CTRL_START_ENC_RSP_LEN       (0)
-#define BLE_LL_CTRL_PAUSE_ENC_REQ_LEN       (0)
-#define BLE_LL_CTRL_PAUSE_ENC_RSP_LEN       (0)
+#define BLE_LL_CTRL_START_ENC_REQ_LEN (0)
+#define BLE_LL_CTRL_START_ENC_RSP_LEN (0)
+#define BLE_LL_CTRL_PAUSE_ENC_REQ_LEN (0)
+#define BLE_LL_CTRL_PAUSE_ENC_RSP_LEN (0)
 
 /*
  * LL control unknown response
  *  -> 1 byte which contains the unknown or un-supported opcode.
  */
-#define BLE_LL_CTRL_UNK_RSP_LEN             (1)
+#define BLE_LL_CTRL_UNK_RSP_LEN (1)
 
 /*
  * LL control feature req and LL control feature rsp
  *  -> 8 bytes of data containing features supported by device.
  */
-#define BLE_LL_CTRL_FEATURE_LEN             (8)
+#define BLE_LL_CTRL_FEATURE_LEN (8)
 
 /*
  * LL control version ind
@@ -188,57 +184,54 @@ struct ble_ll_enc_rsp
  *  -> sub_ver_num: Contains a unique value for implementation or revision of
  *      the bluetooth controller.
  */
-struct ble_ll_version_ind
-{
-    uint8_t ble_ctrlr_ver;
-    uint16_t company_id;
-    uint16_t sub_ver_num;
+struct ble_ll_version_ind {
+	uint8_t ble_ctrlr_ver;
+	uint16_t company_id;
+	uint16_t sub_ver_num;
 };
 
-#define BLE_LL_CTRL_VERSION_IND_LEN         (5)
+#define BLE_LL_CTRL_VERSION_IND_LEN (5)
 
 /*
  * LL control reject ind
  *  -> error code (1 byte): contains reason why request was rejected.
  */
-#define BLE_LL_CTRL_REJ_IND_LEN             (1)
+#define BLE_LL_CTRL_REJ_IND_LEN (1)
 
 /*
  * LL control slave feature req
  *  -> 8 bytes of data containing features supported by device.
  */
-#define BLE_LL_CTRL_PERIPH_FEATURE_REQ_LEN   (8)
+#define BLE_LL_CTRL_PERIPH_FEATURE_REQ_LEN (8)
 
 /* LL control connection param req and connection param rsp */
-struct ble_ll_conn_params
-{
-    uint16_t interval_min;
-    uint16_t interval_max;
-    uint16_t latency;
-    uint16_t timeout;
-    uint8_t pref_periodicity;
-    uint16_t ref_conn_event_cnt;
-    uint16_t offset0;
-    uint16_t offset1;
-    uint16_t offset2;
-    uint16_t offset3;
-    uint16_t offset4;
-    uint16_t offset5;
+struct ble_ll_conn_params {
+	uint16_t interval_min;
+	uint16_t interval_max;
+	uint16_t latency;
+	uint16_t timeout;
+	uint8_t pref_periodicity;
+	uint16_t ref_conn_event_cnt;
+	uint16_t offset0;
+	uint16_t offset1;
+	uint16_t offset2;
+	uint16_t offset3;
+	uint16_t offset4;
+	uint16_t offset5;
 };
 
-#define BLE_LL_CTRL_CONN_PARAMS_LEN     (23)
+#define BLE_LL_CTRL_CONN_PARAMS_LEN (23)
 
 /* LL control reject ind ext */
-struct ble_ll_reject_ind_ext
-{
-    uint8_t reject_opcode;
-    uint8_t err_code;
+struct ble_ll_reject_ind_ext {
+	uint8_t reject_opcode;
+	uint8_t err_code;
 };
 
-#define BLE_LL_CTRL_REJECT_IND_EXT_LEN  (2)
+#define BLE_LL_CTRL_REJECT_IND_EXT_LEN (2)
 
 /* LL control ping req and ping rsp (contain no data) */
-#define BLE_LL_CTRL_PING_LEN            (0)
+#define BLE_LL_CTRL_PING_LEN (0)
 
 /*
  * LL control length req and length rsp
@@ -247,65 +240,62 @@ struct ble_ll_reject_ind_ext
  *  -> max_tx_bytes (2 bytes): defines connMaxTxOctets. Range 27 to 251
  *  -> max_tx_time (2 bytes): defines connMaxTxTime. Range 328 to 2120 usecs.
  */
-struct ble_ll_len_req
-{
-    uint16_t max_rx_bytes;
-    uint16_t max_rx_time;
-    uint16_t max_tx_bytes;
-    uint16_t max_tx_time;
+struct ble_ll_len_req {
+	uint16_t max_rx_bytes;
+	uint16_t max_rx_time;
+	uint16_t max_tx_bytes;
+	uint16_t max_tx_time;
 };
 
-#define BLE_LL_CTRL_LENGTH_REQ_LEN      (8)
+#define BLE_LL_CTRL_LENGTH_REQ_LEN (8)
 
 /* PHY request/response */
-#define BLE_LL_CTRL_PHY_REQ_LEN         (2)
-#define BLE_LL_CTRL_PHY_RSP_LEN         (2)
-#define BLE_LL_CTRL_PHY_UPD_IND_LEN     (4)
+#define BLE_LL_CTRL_PHY_REQ_LEN (2)
+#define BLE_LL_CTRL_PHY_RSP_LEN (2)
+#define BLE_LL_CTRL_PHY_UPD_IND_LEN (4)
 
 /* Min used channels */
-#define BLE_LL_CTRL_MIN_USED_CHAN_LEN   (2)
+#define BLE_LL_CTRL_MIN_USED_CHAN_LEN (2)
 
 /* CTE REQ */
-#define BLE_LL_CTRL_CTE_REQ_LEN         (1)
+#define BLE_LL_CTRL_CTE_REQ_LEN (1)
 
 /* CTE RSP (contains no data) */
-#define BLE_LL_CTRL_CTE_RSP_LEN     (0)
+#define BLE_LL_CTRL_CTE_RSP_LEN (0)
 
 /* Periodic Sync Transfer IND */
-#define BLE_LL_CTRL_PERIODIC_SYNC_IND_LEN   (34)
+#define BLE_LL_CTRL_PERIODIC_SYNC_IND_LEN (34)
 
 /* Clock accuracy request/response */
-#define BLE_LL_CTRL_CLOCK_ACCURACY_REQ_LEN  (1)
-#define BLE_LL_CTRL_CLOCK_ACCURACY_RSP_LEN  (1)
+#define BLE_LL_CTRL_CLOCK_ACCURACY_REQ_LEN (1)
+#define BLE_LL_CTRL_CLOCK_ACCURACY_RSP_LEN (1)
 
 /* BLE ISO */
-#define BLE_LL_CTRL_CIS_REQ_LEN         (42)
-#define BLE_LL_CTRL_CIS_RSP_LEN         (8)
-#define BLE_LL_CTRL_CIS_IND_LEN         (15)
-#define BLE_LL_CTRL_CIS_TERMINATE_LEN   (3)
-
-#define BLE_LL_CTRL_POWER_CONTROL_REQ_LEN       (3)
-#define BLE_LL_CTRL_POWER_CONTROL_RSP_LEN       (4)
-#define BLE_LL_CTRL_POWER_CHANGE_IND_LEN        (4)
-#define BLE_LL_CTRL_SUBRATE_REQ_LEN             (10)
-#define BLE_LL_CTRL_SUBRATE_IND_LEN             (10)
-#define BLE_LL_CTRL_CHAN_REPORTING_IND_LEN      (3)
-#define BLE_LL_CTRL_CHAN_STATUS_IND_LEN         (10)
+#define BLE_LL_CTRL_CIS_REQ_LEN (42)
+#define BLE_LL_CTRL_CIS_RSP_LEN (8)
+#define BLE_LL_CTRL_CIS_IND_LEN (15)
+#define BLE_LL_CTRL_CIS_TERMINATE_LEN (3)
+
+#define BLE_LL_CTRL_POWER_CONTROL_REQ_LEN (3)
+#define BLE_LL_CTRL_POWER_CONTROL_RSP_LEN (4)
+#define BLE_LL_CTRL_POWER_CHANGE_IND_LEN (4)
+#define BLE_LL_CTRL_SUBRATE_REQ_LEN (10)
+#define BLE_LL_CTRL_SUBRATE_IND_LEN (10)
+#define BLE_LL_CTRL_CHAN_REPORTING_IND_LEN (3)
+#define BLE_LL_CTRL_CHAN_STATUS_IND_LEN (10)
 
 /* API */
 struct ble_ll_conn_sm;
-void ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc,
-                            void *data);
+void ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc, void *data);
 void ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc);
 int ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om);
 void ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm);
 void ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm);
 int ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode);
-uint8_t ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm,
-                                     uint8_t *rsp,
+uint8_t ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm, uint8_t *rsp,
                                      struct ble_ll_conn_params *req);
-int ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm,
-                                uint8_t rej_opcode, uint8_t err);
+int ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm, uint8_t rej_opcode,
+                                uint8_t err);
 int ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm);
 int ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf *rxpdu);
 int ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr *pkthdr);
@@ -317,8 +307,7 @@ void ble_ll_hci_ev_datalen_chg(struct ble_ll_conn_sm *connsm);
 void ble_ll_hci_ev_rem_conn_parm_req(struct ble_ll_conn_sm *connsm,
                                      struct ble_ll_conn_params *cp);
 void ble_ll_hci_ev_conn_update(struct ble_ll_conn_sm *connsm, uint8_t status);
-void ble_ll_hci_ev_rd_rem_used_feat(struct ble_ll_conn_sm *connsm,
-                                      uint8_t status);
+void ble_ll_hci_ev_rd_rem_used_feat(struct ble_ll_conn_sm *connsm, uint8_t status);
 void ble_ll_hci_ev_rd_rem_ver(struct ble_ll_conn_sm *connsm, uint8_t status);
 void ble_ll_hci_ev_encrypt_chg(struct ble_ll_conn_sm *connsm, uint8_t status);
 int ble_ll_hci_ev_ltk_req(struct ble_ll_conn_sm *connsm);
@@ -338,13 +327,13 @@ void ble_ll_hci_ev_send_vs_assert(const char *file, uint32_t line);
 void ble_ll_hci_ev_send_vs_printf(uint8_t id, const char *fmt, ...);
 void ble_ll_hci_ev_send_vs_llcp_trace(uint8_t type, uint16_t handle, uint16_t count,
                                       void *pdu, size_t length);
-
+void ble_ll_ctrl_set_repairing_flag(int val);
 uint8_t ble_ll_ctrl_phy_tx_transition_get(uint8_t phy_mask);
 uint8_t ble_ll_ctrl_phy_from_phy_mask(uint8_t phy_mask);
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-void ble_ll_hci_ev_sca_update(struct ble_ll_conn_sm *connsm,
-                              uint8_t status, uint8_t peer_sca);
+void ble_ll_hci_ev_sca_update(struct ble_ll_conn_sm *connsm, uint8_t status,
+                              uint8_t peer_sca);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
@@ -352,8 +341,7 @@ void ble_ll_hci_ev_subrate_change(struct ble_ll_conn_sm *connsm, uint8_t status)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_HCI_VS_CONN_STRICT_SCHED)
-void ble_ll_hci_ev_send_vs_css_slot_changed(uint16_t conn_handle,
-                                            uint16_t slot_idx);
+void ble_ll_hci_ev_send_vs_css_slot_changed(uint16_t conn_handle, uint16_t slot_idx);
 #endif
 
 #ifdef __cplusplus
diff --git a/nimble/controller/src/ble_ll.c b/nimble/controller/src/ble_ll.c
index 998f8d4f..bcb870e2 100644
--- a/nimble/controller/src/ble_ll.c
+++ b/nimble/controller/src/ble_ll.c
@@ -84,211 +84,179 @@ int8_t g_ble_ll_rx_power_compensation;
 
 /* Supported states */
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-#define BLE_LL_S_NCA                    ((uint64_t)1 << 0)
-#define BLE_LL_S_SA                     ((uint64_t)1 << 1)
+#define BLE_LL_S_NCA ((uint64_t) 1 << 0)
+#define BLE_LL_S_SA ((uint64_t) 1 << 1)
 #else
-#define BLE_LL_S_NCA                    ((uint64_t)0 << 0)
-#define BLE_LL_S_SA                     ((uint64_t)0 << 1)
+#define BLE_LL_S_NCA ((uint64_t) 0 << 0)
+#define BLE_LL_S_SA ((uint64_t) 0 << 1)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-#define BLE_LL_S_CA                     ((uint64_t)1 << 2)
-#define BLE_LL_S_HDCA                   ((uint64_t)1 << 3)
+#define BLE_LL_S_CA ((uint64_t) 1 << 2)
+#define BLE_LL_S_HDCA ((uint64_t) 1 << 3)
 #else
-#define BLE_LL_S_CA                     ((uint64_t)0 << 2)
-#define BLE_LL_S_HDCA                   ((uint64_t)0 << 3)
+#define BLE_LL_S_CA ((uint64_t) 0 << 2)
+#define BLE_LL_S_HDCA ((uint64_t) 0 << 3)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-#define BLE_LL_S_PS                     ((uint64_t)1 << 4)
-#define BLE_LL_S_AS                     ((uint64_t)1 << 5)
+#define BLE_LL_S_PS ((uint64_t) 1 << 4)
+#define BLE_LL_S_AS ((uint64_t) 1 << 5)
 #else
-#define BLE_LL_S_PS                     ((uint64_t)0 << 4)
-#define BLE_LL_S_AS                     ((uint64_t)0 << 5)
+#define BLE_LL_S_PS ((uint64_t) 0 << 4)
+#define BLE_LL_S_AS ((uint64_t) 0 << 5)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-#define BLE_LL_S_INIT                   ((uint64_t)1 << 6)
+#define BLE_LL_S_INIT ((uint64_t) 1 << 6)
 #else
-#define BLE_LL_S_INIT                   ((uint64_t)0 << 6)
+#define BLE_LL_S_INIT ((uint64_t) 0 << 6)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-#define BLE_LL_S_PERIPH                 ((uint64_t)1 << 7)
+#define BLE_LL_S_PERIPH ((uint64_t) 1 << 7)
 #else
-#define BLE_LL_S_PERIPH                  ((uint64_t)0 << 7)
+#define BLE_LL_S_PERIPH ((uint64_t) 0 << 7)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER) && MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-#define BLE_LL_S_NCA_PS                 ((uint64_t)1 << 8)
-#define BLE_LL_S_SA_PS                  ((uint64_t)1 << 9)
+#define BLE_LL_S_NCA_PS ((uint64_t) 1 << 8)
+#define BLE_LL_S_SA_PS ((uint64_t) 1 << 9)
 #else
-#define BLE_LL_S_NCA_PS                 ((uint64_t)0 << 8)
-#define BLE_LL_S_SA_PS                  ((uint64_t)0 << 9)
+#define BLE_LL_S_NCA_PS ((uint64_t) 0 << 8)
+#define BLE_LL_S_SA_PS ((uint64_t) 0 << 9)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) && MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-#define BLE_LL_S_CA_PS                  ((uint64_t)1 << 10)
-#define BLE_LL_S_HDCA_PS                ((uint64_t)1 << 11)
+#define BLE_LL_S_CA_PS ((uint64_t) 1 << 10)
+#define BLE_LL_S_HDCA_PS ((uint64_t) 1 << 11)
 #else
-#define BLE_LL_S_CA_PS                  ((uint64_t)0 << 10)
-#define BLE_LL_S_HDCA_PS                ((uint64_t)0 << 11)
+#define BLE_LL_S_CA_PS ((uint64_t) 0 << 10)
+#define BLE_LL_S_HDCA_PS ((uint64_t) 0 << 11)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER) && MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-#define BLE_LL_S_NCA_AS                 ((uint64_t)1 << 12)
-#define BLE_LL_S_SA_AS                  ((uint64_t)1 << 13)
+#define BLE_LL_S_NCA_AS ((uint64_t) 1 << 12)
+#define BLE_LL_S_SA_AS ((uint64_t) 1 << 13)
 #else
-#define BLE_LL_S_NCA_AS                 ((uint64_t)0 << 12)
-#define BLE_LL_S_SA_AS                  ((uint64_t)0 << 13)
+#define BLE_LL_S_NCA_AS ((uint64_t) 0 << 12)
+#define BLE_LL_S_SA_AS ((uint64_t) 0 << 13)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) && MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-#define BLE_LL_S_CA_AS                  ((uint64_t)1 << 14)
-#define BLE_LL_S_HDCA_AS                ((uint64_t)1 << 15)
+#define BLE_LL_S_CA_AS ((uint64_t) 1 << 14)
+#define BLE_LL_S_HDCA_AS ((uint64_t) 1 << 15)
 #else
-#define BLE_LL_S_CA_AS                  ((uint64_t)0 << 14)
-#define BLE_LL_S_HDCA_AS                ((uint64_t)0 << 15)
+#define BLE_LL_S_CA_AS ((uint64_t) 0 << 14)
+#define BLE_LL_S_HDCA_AS ((uint64_t) 0 << 15)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER) && MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-#define BLE_LL_S_NCA_INIT               ((uint64_t)1 << 16)
-#define BLE_LL_S_SA_INIT                ((uint64_t)1 << 17)
-#define BLE_LL_S_NCA_CENTRAL            ((uint64_t)1 << 18)
-#define BLE_LL_S_SA_CENTRAL             ((uint64_t)1 << 19)
+#define BLE_LL_S_NCA_INIT ((uint64_t) 1 << 16)
+#define BLE_LL_S_SA_INIT ((uint64_t) 1 << 17)
+#define BLE_LL_S_NCA_CENTRAL ((uint64_t) 1 << 18)
+#define BLE_LL_S_SA_CENTRAL ((uint64_t) 1 << 19)
 #else
-#define BLE_LL_S_NCA_INIT               ((uint64_t)0 << 16)
-#define BLE_LL_S_SA_INIT                ((uint64_t)0 << 17)
-#define BLE_LL_S_NCA_CENTRAL             ((uint64_t)0 << 18)
-#define BLE_LL_S_SA_CENTRAL              ((uint64_t)0 << 19)
+#define BLE_LL_S_NCA_INIT ((uint64_t) 0 << 16)
+#define BLE_LL_S_SA_INIT ((uint64_t) 0 << 17)
+#define BLE_LL_S_NCA_CENTRAL ((uint64_t) 0 << 18)
+#define BLE_LL_S_SA_CENTRAL ((uint64_t) 0 << 19)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER) && MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-#define BLE_LL_S_NCA_PERIPH             ((uint64_t)1 << 20)
-#define BLE_LL_S_SA_PERIPH               ((uint64_t)1 << 21)
+#define BLE_LL_S_NCA_PERIPH ((uint64_t) 1 << 20)
+#define BLE_LL_S_SA_PERIPH ((uint64_t) 1 << 21)
 #else
-#define BLE_LL_S_NCA_PERIPH              ((uint64_t)0 << 20)
-#define BLE_LL_S_SA_PERIPH               ((uint64_t)0 << 21)
+#define BLE_LL_S_NCA_PERIPH ((uint64_t) 0 << 20)
+#define BLE_LL_S_SA_PERIPH ((uint64_t) 0 << 21)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER) && MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
 /* We do not support passive scanning while initiating yet */
-#define BLE_LL_S_PS_INIT                ((uint64_t)0 << 22)
+#define BLE_LL_S_PS_INIT ((uint64_t) 0 << 22)
 /* We do not support active scanning while initiating yet */
-#define BLE_LL_S_AS_INIT                ((uint64_t)0 << 23)
-#define BLE_LL_S_PS_CENTRAL             ((uint64_t)1 << 24)
-#define BLE_LL_S_AS_CENTRAL             ((uint64_t)1 << 25)
+#define BLE_LL_S_AS_INIT ((uint64_t) 0 << 23)
+#define BLE_LL_S_PS_CENTRAL ((uint64_t) 1 << 24)
+#define BLE_LL_S_AS_CENTRAL ((uint64_t) 1 << 25)
 #else
-#define BLE_LL_S_PS_INIT                ((uint64_t)0 << 22)
-#define BLE_LL_S_AS_INIT                ((uint64_t)0 << 23)
-#define BLE_LL_S_PS_CENTRAL              ((uint64_t)0 << 24)
-#define BLE_LL_S_AS_CENTRAL              ((uint64_t)0 << 25)
+#define BLE_LL_S_PS_INIT ((uint64_t) 0 << 22)
+#define BLE_LL_S_AS_INIT ((uint64_t) 0 << 23)
+#define BLE_LL_S_PS_CENTRAL ((uint64_t) 0 << 24)
+#define BLE_LL_S_AS_CENTRAL ((uint64_t) 0 << 25)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER) && MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-#define BLE_LL_S_PS_PERIPH              ((uint64_t)1 << 26)
-#define BLE_LL_S_AS_PERIPH              ((uint64_t)1 << 27)
+#define BLE_LL_S_PS_PERIPH ((uint64_t) 1 << 26)
+#define BLE_LL_S_AS_PERIPH ((uint64_t) 1 << 27)
 #else
-#define BLE_LL_S_PS_PERIPH               ((uint64_t)0 << 26)
-#define BLE_LL_S_AS_PERIPH               ((uint64_t)0 << 27)
+#define BLE_LL_S_PS_PERIPH ((uint64_t) 0 << 26)
+#define BLE_LL_S_AS_PERIPH ((uint64_t) 0 << 27)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-#define BLE_LL_S_INIT_CENTRAL           ((uint64_t)1 << 28)
+#define BLE_LL_S_INIT_CENTRAL ((uint64_t) 1 << 28)
 #else
-#define BLE_LL_S_INIT_CENTRAL            ((uint64_t)0 << 28)
+#define BLE_LL_S_INIT_CENTRAL ((uint64_t) 0 << 28)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-#define BLE_LL_S_LDCA                   ((uint64_t)1 << 29)
+#define BLE_LL_S_LDCA ((uint64_t) 1 << 29)
 #else
-#define BLE_LL_S_LDCA                   ((uint64_t)0 << 29)
+#define BLE_LL_S_LDCA ((uint64_t) 0 << 29)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) && MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-#define BLE_LL_S_LDCA_PS                ((uint64_t)1 << 30)
-#define BLE_LL_S_LDCA_AS                ((uint64_t)1 << 31)
+#define BLE_LL_S_LDCA_PS ((uint64_t) 1 << 30)
+#define BLE_LL_S_LDCA_AS ((uint64_t) 1 << 31)
 #else
-#define BLE_LL_S_LDCA_PS                ((uint64_t)0 << 30)
-#define BLE_LL_S_LDCA_AS                ((uint64_t)0 << 31)
+#define BLE_LL_S_LDCA_PS ((uint64_t) 0 << 30)
+#define BLE_LL_S_LDCA_AS ((uint64_t) 0 << 31)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) && MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-#define BLE_LL_S_CA_INIT                ((uint64_t)1 << 32)
-#define BLE_LL_S_HDCA_INIT              ((uint64_t)1 << 33)
-#define BLE_LL_S_LDCA_INIT              ((uint64_t)1 << 34)
-#define BLE_LL_S_CA_CENTRAL             ((uint64_t)1 << 35)
-#define BLE_LL_S_HDCA_CENTRAL           ((uint64_t)1 << 36)
-#define BLE_LL_S_LDCA_CENTRAL           ((uint64_t)1 << 37)
+#define BLE_LL_S_CA_INIT ((uint64_t) 1 << 32)
+#define BLE_LL_S_HDCA_INIT ((uint64_t) 1 << 33)
+#define BLE_LL_S_LDCA_INIT ((uint64_t) 1 << 34)
+#define BLE_LL_S_CA_CENTRAL ((uint64_t) 1 << 35)
+#define BLE_LL_S_HDCA_CENTRAL ((uint64_t) 1 << 36)
+#define BLE_LL_S_LDCA_CENTRAL ((uint64_t) 1 << 37)
 #else
-#define BLE_LL_S_CA_INIT                ((uint64_t)0 << 32)
-#define BLE_LL_S_HDCA_INIT              ((uint64_t)0 << 33)
-#define BLE_LL_S_LDCA_INIT              ((uint64_t)0 << 34)
-#define BLE_LL_S_CA_CENTRAL              ((uint64_t)0 << 35)
-#define BLE_LL_S_HDCA_CENTRAL            ((uint64_t)0 << 36)
-#define BLE_LL_S_LDCA_CENTRAL            ((uint64_t)0 << 37)
+#define BLE_LL_S_CA_INIT ((uint64_t) 0 << 32)
+#define BLE_LL_S_HDCA_INIT ((uint64_t) 0 << 33)
+#define BLE_LL_S_LDCA_INIT ((uint64_t) 0 << 34)
+#define BLE_LL_S_CA_CENTRAL ((uint64_t) 0 << 35)
+#define BLE_LL_S_HDCA_CENTRAL ((uint64_t) 0 << 36)
+#define BLE_LL_S_LDCA_CENTRAL ((uint64_t) 0 << 37)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-#define BLE_LL_S_CA_PERIPH              ((uint64_t)1 << 38)
-#define BLE_LL_S_HDCA_PERIPH            ((uint64_t)1 << 39)
-#define BLE_LL_S_LDCA_PERIPH            ((uint64_t)1 << 40)
+#define BLE_LL_S_CA_PERIPH ((uint64_t) 1 << 38)
+#define BLE_LL_S_HDCA_PERIPH ((uint64_t) 1 << 39)
+#define BLE_LL_S_LDCA_PERIPH ((uint64_t) 1 << 40)
 #else
-#define BLE_LL_S_CA_PERIPH               ((uint64_t)0 << 38)
-#define BLE_LL_S_HDCA_PERIPH             ((uint64_t)0 << 39)
-#define BLE_LL_S_LDCA_PERIPH             ((uint64_t)0 << 40)
+#define BLE_LL_S_CA_PERIPH ((uint64_t) 0 << 38)
+#define BLE_LL_S_HDCA_PERIPH ((uint64_t) 0 << 39)
+#define BLE_LL_S_LDCA_PERIPH ((uint64_t) 0 << 40)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) && MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-#define BLE_LL_S_INIT_PERIPH            ((uint64_t)1 << 41)
+#define BLE_LL_S_INIT_PERIPH ((uint64_t) 1 << 41)
 #else
-#define BLE_LL_S_INIT_PERIPH             ((uint64_t)0 << 41)
-#endif
-
-#define BLE_LL_SUPPORTED_STATES             \
-(                                           \
-    BLE_LL_S_NCA                    |       \
-    BLE_LL_S_SA                     |       \
-    BLE_LL_S_CA                     |       \
-    BLE_LL_S_HDCA                   |       \
-    BLE_LL_S_PS                     |       \
-    BLE_LL_S_AS                     |       \
-    BLE_LL_S_INIT                   |       \
-    BLE_LL_S_PERIPH                  |       \
-    BLE_LL_S_NCA_PS                 |       \
-    BLE_LL_S_SA_PS                  |       \
-    BLE_LL_S_CA_PS                  |       \
-    BLE_LL_S_HDCA_PS                |       \
-    BLE_LL_S_NCA_AS                 |       \
-    BLE_LL_S_SA_AS                  |       \
-    BLE_LL_S_CA_AS                  |       \
-    BLE_LL_S_HDCA_AS                |       \
-    BLE_LL_S_NCA_INIT               |       \
-    BLE_LL_S_SA_INIT                |       \
-    BLE_LL_S_NCA_CENTRAL             |       \
-    BLE_LL_S_SA_CENTRAL              |       \
-    BLE_LL_S_NCA_PERIPH              |       \
-    BLE_LL_S_SA_PERIPH               |       \
-    BLE_LL_S_PS_INIT                |       \
-    BLE_LL_S_AS_INIT                |       \
-    BLE_LL_S_PS_CENTRAL              |       \
-    BLE_LL_S_AS_CENTRAL              |       \
-    BLE_LL_S_PS_PERIPH               |       \
-    BLE_LL_S_AS_PERIPH               |       \
-    BLE_LL_S_INIT_CENTRAL            |       \
-    BLE_LL_S_LDCA                   |       \
-    BLE_LL_S_LDCA_PS                |       \
-    BLE_LL_S_LDCA_AS                |       \
-    BLE_LL_S_CA_INIT                |       \
-    BLE_LL_S_HDCA_INIT              |       \
-    BLE_LL_S_LDCA_INIT              |       \
-    BLE_LL_S_CA_CENTRAL              |       \
-    BLE_LL_S_HDCA_CENTRAL            |       \
-    BLE_LL_S_LDCA_CENTRAL            |       \
-    BLE_LL_S_CA_PERIPH               |       \
-    BLE_LL_S_HDCA_PERIPH             |       \
-    BLE_LL_S_LDCA_PERIPH             |       \
-    BLE_LL_S_INIT_PERIPH)
+#define BLE_LL_S_INIT_PERIPH ((uint64_t) 0 << 41)
+#endif
+
+#define BLE_LL_SUPPORTED_STATES                                                       \
+	(BLE_LL_S_NCA | BLE_LL_S_SA | BLE_LL_S_CA | BLE_LL_S_HDCA | BLE_LL_S_PS |           \
+	 BLE_LL_S_AS | BLE_LL_S_INIT | BLE_LL_S_PERIPH | BLE_LL_S_NCA_PS | BLE_LL_S_SA_PS | \
+	 BLE_LL_S_CA_PS | BLE_LL_S_HDCA_PS | BLE_LL_S_NCA_AS | BLE_LL_S_SA_AS |             \
+	 BLE_LL_S_CA_AS | BLE_LL_S_HDCA_AS | BLE_LL_S_NCA_INIT | BLE_LL_S_SA_INIT |         \
+	 BLE_LL_S_NCA_CENTRAL | BLE_LL_S_SA_CENTRAL | BLE_LL_S_NCA_PERIPH |                 \
+	 BLE_LL_S_SA_PERIPH | BLE_LL_S_PS_INIT | BLE_LL_S_AS_INIT | BLE_LL_S_PS_CENTRAL |   \
+	 BLE_LL_S_AS_CENTRAL | BLE_LL_S_PS_PERIPH | BLE_LL_S_AS_PERIPH |                    \
+	 BLE_LL_S_INIT_CENTRAL | BLE_LL_S_LDCA | BLE_LL_S_LDCA_PS | BLE_LL_S_LDCA_AS |      \
+	 BLE_LL_S_CA_INIT | BLE_LL_S_HDCA_INIT | BLE_LL_S_LDCA_INIT | BLE_LL_S_CA_CENTRAL | \
+	 BLE_LL_S_HDCA_CENTRAL | BLE_LL_S_LDCA_CENTRAL | BLE_LL_S_CA_PERIPH |               \
+	 BLE_LL_S_HDCA_PERIPH | BLE_LL_S_LDCA_PERIPH | BLE_LL_S_INIT_PERIPH)
 
 /* The global BLE LL data object */
 struct ble_ll_obj g_ble_ll_data;
@@ -296,71 +264,71 @@ struct ble_ll_obj g_ble_ll_data;
 /* Global link layer statistics */
 STATS_SECT_DECL(ble_ll_stats) ble_ll_stats;
 STATS_NAME_START(ble_ll_stats)
-    STATS_NAME(ble_ll_stats, hci_cmds)
-    STATS_NAME(ble_ll_stats, hci_cmd_errs)
-    STATS_NAME(ble_ll_stats, hci_events_sent)
-    STATS_NAME(ble_ll_stats, bad_ll_state)
-    STATS_NAME(ble_ll_stats, bad_acl_hdr)
-    STATS_NAME(ble_ll_stats, no_bufs)
-    STATS_NAME(ble_ll_stats, rx_adv_pdu_crc_ok)
-    STATS_NAME(ble_ll_stats, rx_adv_pdu_crc_err)
-    STATS_NAME(ble_ll_stats, rx_adv_bytes_crc_ok)
-    STATS_NAME(ble_ll_stats, rx_adv_bytes_crc_err)
-    STATS_NAME(ble_ll_stats, rx_data_pdu_crc_ok)
-    STATS_NAME(ble_ll_stats, rx_data_pdu_crc_err)
-    STATS_NAME(ble_ll_stats, rx_data_bytes_crc_ok)
-    STATS_NAME(ble_ll_stats, rx_data_bytes_crc_err)
-    STATS_NAME(ble_ll_stats, rx_adv_malformed_pkts)
-    STATS_NAME(ble_ll_stats, rx_adv_ind)
-    STATS_NAME(ble_ll_stats, rx_adv_direct_ind)
-    STATS_NAME(ble_ll_stats, rx_adv_nonconn_ind)
-    STATS_NAME(ble_ll_stats, rx_adv_ext_ind)
-    STATS_NAME(ble_ll_stats, rx_scan_reqs)
-    STATS_NAME(ble_ll_stats, rx_scan_rsps)
-    STATS_NAME(ble_ll_stats, rx_connect_reqs)
-    STATS_NAME(ble_ll_stats, rx_scan_ind)
-    STATS_NAME(ble_ll_stats, rx_aux_connect_rsp)
-    STATS_NAME(ble_ll_stats, rx_pdu_on_scan_disabled)
-    STATS_NAME(ble_ll_stats, adv_txg)
-    STATS_NAME(ble_ll_stats, adv_late_starts)
-    STATS_NAME(ble_ll_stats, adv_resched_pdu_fail)
-    STATS_NAME(ble_ll_stats, adv_drop_event)
-    STATS_NAME(ble_ll_stats, sched_state_conn_errs)
-    STATS_NAME(ble_ll_stats, sched_state_adv_errs)
-    STATS_NAME(ble_ll_stats, scan_starts)
-    STATS_NAME(ble_ll_stats, scan_stops)
-    STATS_NAME(ble_ll_stats, scan_req_txf)
-    STATS_NAME(ble_ll_stats, scan_req_txg)
-    STATS_NAME(ble_ll_stats, scan_rsp_txg)
-    STATS_NAME(ble_ll_stats, aux_missed_adv)
-    STATS_NAME(ble_ll_stats, aux_scheduled)
-    STATS_NAME(ble_ll_stats, aux_received)
-    STATS_NAME(ble_ll_stats, aux_fired_for_read)
-    STATS_NAME(ble_ll_stats, aux_allocated)
-    STATS_NAME(ble_ll_stats, aux_freed)
-    STATS_NAME(ble_ll_stats, aux_sched_cb)
-    STATS_NAME(ble_ll_stats, aux_conn_req_tx)
-    STATS_NAME(ble_ll_stats, aux_conn_rsp_tx)
-    STATS_NAME(ble_ll_stats, aux_conn_rsp_err)
-    STATS_NAME(ble_ll_stats, aux_scan_req_tx)
-    STATS_NAME(ble_ll_stats, aux_scan_rsp_err)
-    STATS_NAME(ble_ll_stats, aux_chain_cnt)
-    STATS_NAME(ble_ll_stats, aux_chain_err)
-    STATS_NAME(ble_ll_stats, aux_scan_drop)
-    STATS_NAME(ble_ll_stats, adv_evt_dropped)
-    STATS_NAME(ble_ll_stats, scan_timer_stopped)
-    STATS_NAME(ble_ll_stats, scan_timer_restarted)
-    STATS_NAME(ble_ll_stats, periodic_adv_drop_event)
-    STATS_NAME(ble_ll_stats, periodic_chain_drop_event)
-    STATS_NAME(ble_ll_stats, sync_event_failed)
-    STATS_NAME(ble_ll_stats, sync_received)
-    STATS_NAME(ble_ll_stats, sync_chain_failed)
-    STATS_NAME(ble_ll_stats, sync_missed_err)
-    STATS_NAME(ble_ll_stats, sync_crc_err)
-    STATS_NAME(ble_ll_stats, sync_rx_buf_err)
-    STATS_NAME(ble_ll_stats, sync_scheduled)
-    STATS_NAME(ble_ll_stats, sched_state_sync_errs)
-    STATS_NAME(ble_ll_stats, sched_invalid_pdu)
+STATS_NAME(ble_ll_stats, hci_cmds)
+STATS_NAME(ble_ll_stats, hci_cmd_errs)
+STATS_NAME(ble_ll_stats, hci_events_sent)
+STATS_NAME(ble_ll_stats, bad_ll_state)
+STATS_NAME(ble_ll_stats, bad_acl_hdr)
+STATS_NAME(ble_ll_stats, no_bufs)
+STATS_NAME(ble_ll_stats, rx_adv_pdu_crc_ok)
+STATS_NAME(ble_ll_stats, rx_adv_pdu_crc_err)
+STATS_NAME(ble_ll_stats, rx_adv_bytes_crc_ok)
+STATS_NAME(ble_ll_stats, rx_adv_bytes_crc_err)
+STATS_NAME(ble_ll_stats, rx_data_pdu_crc_ok)
+STATS_NAME(ble_ll_stats, rx_data_pdu_crc_err)
+STATS_NAME(ble_ll_stats, rx_data_bytes_crc_ok)
+STATS_NAME(ble_ll_stats, rx_data_bytes_crc_err)
+STATS_NAME(ble_ll_stats, rx_adv_malformed_pkts)
+STATS_NAME(ble_ll_stats, rx_adv_ind)
+STATS_NAME(ble_ll_stats, rx_adv_direct_ind)
+STATS_NAME(ble_ll_stats, rx_adv_nonconn_ind)
+STATS_NAME(ble_ll_stats, rx_adv_ext_ind)
+STATS_NAME(ble_ll_stats, rx_scan_reqs)
+STATS_NAME(ble_ll_stats, rx_scan_rsps)
+STATS_NAME(ble_ll_stats, rx_connect_reqs)
+STATS_NAME(ble_ll_stats, rx_scan_ind)
+STATS_NAME(ble_ll_stats, rx_aux_connect_rsp)
+STATS_NAME(ble_ll_stats, rx_pdu_on_scan_disabled)
+STATS_NAME(ble_ll_stats, adv_txg)
+STATS_NAME(ble_ll_stats, adv_late_starts)
+STATS_NAME(ble_ll_stats, adv_resched_pdu_fail)
+STATS_NAME(ble_ll_stats, adv_drop_event)
+STATS_NAME(ble_ll_stats, sched_state_conn_errs)
+STATS_NAME(ble_ll_stats, sched_state_adv_errs)
+STATS_NAME(ble_ll_stats, scan_starts)
+STATS_NAME(ble_ll_stats, scan_stops)
+STATS_NAME(ble_ll_stats, scan_req_txf)
+STATS_NAME(ble_ll_stats, scan_req_txg)
+STATS_NAME(ble_ll_stats, scan_rsp_txg)
+STATS_NAME(ble_ll_stats, aux_missed_adv)
+STATS_NAME(ble_ll_stats, aux_scheduled)
+STATS_NAME(ble_ll_stats, aux_received)
+STATS_NAME(ble_ll_stats, aux_fired_for_read)
+STATS_NAME(ble_ll_stats, aux_allocated)
+STATS_NAME(ble_ll_stats, aux_freed)
+STATS_NAME(ble_ll_stats, aux_sched_cb)
+STATS_NAME(ble_ll_stats, aux_conn_req_tx)
+STATS_NAME(ble_ll_stats, aux_conn_rsp_tx)
+STATS_NAME(ble_ll_stats, aux_conn_rsp_err)
+STATS_NAME(ble_ll_stats, aux_scan_req_tx)
+STATS_NAME(ble_ll_stats, aux_scan_rsp_err)
+STATS_NAME(ble_ll_stats, aux_chain_cnt)
+STATS_NAME(ble_ll_stats, aux_chain_err)
+STATS_NAME(ble_ll_stats, aux_scan_drop)
+STATS_NAME(ble_ll_stats, adv_evt_dropped)
+STATS_NAME(ble_ll_stats, scan_timer_stopped)
+STATS_NAME(ble_ll_stats, scan_timer_restarted)
+STATS_NAME(ble_ll_stats, periodic_adv_drop_event)
+STATS_NAME(ble_ll_stats, periodic_chain_drop_event)
+STATS_NAME(ble_ll_stats, sync_event_failed)
+STATS_NAME(ble_ll_stats, sync_received)
+STATS_NAME(ble_ll_stats, sync_chain_failed)
+STATS_NAME(ble_ll_stats, sync_missed_err)
+STATS_NAME(ble_ll_stats, sync_crc_err)
+STATS_NAME(ble_ll_stats, sync_rx_buf_err)
+STATS_NAME(ble_ll_stats, sync_scheduled)
+STATS_NAME(ble_ll_stats, sched_state_sync_errs)
+STATS_NAME(ble_ll_stats, sched_invalid_pdu)
 STATS_NAME_END(ble_ll_stats)
 
 static void ble_ll_event_rx_pkt(struct ble_npl_event *ev);
@@ -390,114 +358,111 @@ uint8_t g_random_addr[BLE_DEV_ADDR_LEN];
  *
  * @param pdu_type
  */
-static void
-ble_ll_count_rx_adv_pdus(uint8_t pdu_type)
+static void ble_ll_count_rx_adv_pdus(uint8_t pdu_type)
 {
-    /* Count received packet types  */
-    switch (pdu_type) {
-    case BLE_ADV_PDU_TYPE_ADV_EXT_IND:
-        STATS_INC(ble_ll_stats, rx_adv_ext_ind);
-        break;
-    case BLE_ADV_PDU_TYPE_ADV_IND:
-        STATS_INC(ble_ll_stats, rx_adv_ind);
-        break;
-    case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
-        STATS_INC(ble_ll_stats, rx_adv_direct_ind);
-        break;
-    case BLE_ADV_PDU_TYPE_ADV_NONCONN_IND:
-        STATS_INC(ble_ll_stats, rx_adv_nonconn_ind);
-        break;
-    case BLE_ADV_PDU_TYPE_SCAN_REQ:
-        STATS_INC(ble_ll_stats, rx_scan_reqs);
-        break;
-    case BLE_ADV_PDU_TYPE_SCAN_RSP:
-        STATS_INC(ble_ll_stats, rx_scan_rsps);
-        break;
-    case BLE_ADV_PDU_TYPE_CONNECT_IND:
-        STATS_INC(ble_ll_stats, rx_connect_reqs);
-        break;
-    case BLE_ADV_PDU_TYPE_AUX_CONNECT_RSP:
-        STATS_INC(ble_ll_stats, rx_aux_connect_rsp);
-        break;
-    case BLE_ADV_PDU_TYPE_ADV_SCAN_IND:
-        STATS_INC(ble_ll_stats, rx_scan_ind);
-        break;
-    default:
-        break;
-    }
+	/* Count received packet types  */
+	switch (pdu_type) {
+	case BLE_ADV_PDU_TYPE_ADV_EXT_IND:
+		STATS_INC(ble_ll_stats, rx_adv_ext_ind);
+		break;
+	case BLE_ADV_PDU_TYPE_ADV_IND:
+		STATS_INC(ble_ll_stats, rx_adv_ind);
+		break;
+	case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
+		STATS_INC(ble_ll_stats, rx_adv_direct_ind);
+		break;
+	case BLE_ADV_PDU_TYPE_ADV_NONCONN_IND:
+		STATS_INC(ble_ll_stats, rx_adv_nonconn_ind);
+		break;
+	case BLE_ADV_PDU_TYPE_SCAN_REQ:
+		STATS_INC(ble_ll_stats, rx_scan_reqs);
+		break;
+	case BLE_ADV_PDU_TYPE_SCAN_RSP:
+		STATS_INC(ble_ll_stats, rx_scan_rsps);
+		break;
+	case BLE_ADV_PDU_TYPE_CONNECT_IND:
+		STATS_INC(ble_ll_stats, rx_connect_reqs);
+		break;
+	case BLE_ADV_PDU_TYPE_AUX_CONNECT_RSP:
+		STATS_INC(ble_ll_stats, rx_aux_connect_rsp);
+		break;
+	case BLE_ADV_PDU_TYPE_ADV_SCAN_IND:
+		STATS_INC(ble_ll_stats, rx_scan_ind);
+		break;
+	default:
+		break;
+	}
 }
 
-struct os_mbuf *
-ble_ll_rxpdu_alloc(uint16_t len)
+struct os_mbuf *ble_ll_rxpdu_alloc(uint16_t len)
 {
-    struct os_mbuf *om_ret;
-    struct os_mbuf *om_next;
-    struct os_mbuf *om;
-    struct os_mbuf_pkthdr *pkthdr;
-    uint16_t databuf_len;
-    int rem_len;
-
-    /*
-     * Make sure that data in mbuf are word-aligned with and without packet
-     * header. This is essential for proper and quick copying of received PDUs
-     * into mbufs.
-     */
-    _Static_assert((offsetof(struct os_mbuf, om_data) & 3) == 0,
-                   "Unaligned om_data");
-    _Static_assert(((offsetof(struct os_mbuf, om_data) +
-                     sizeof(struct os_mbuf_pkthdr) +
-                     sizeof(struct ble_mbuf_hdr)) & 3) == 0,
-                   "Unaligned data trailing packet header");
-
-    om_ret = os_msys_get_pkthdr(len, sizeof(struct ble_mbuf_hdr));
-    if (!om_ret) {
-        goto rxpdu_alloc_fail;
-    }
-
-    /* Set complete PDU length in packet header */
-    pkthdr = OS_MBUF_PKTHDR(om_ret);
-    pkthdr->omp_len = len;
-
-    rem_len = len;
-
-    /*
-     * Calculate length of data in memory block. We assume length is rounded
-     * down to word size so PHY can do word-size aligned data copy to mbufs
-     * (except for last one) and leave remainder unused.
-     *
-     * Note that there likely won't be any remainder here since all pools have
-     * block size aligned to word size anyway.
-     */
-    databuf_len = om_ret->om_omp->omp_databuf_len & ~3;
-
-    /*
-     * First mbuf can store less data due to packet header. Also we reserve one
-     * word for leading space to prepend header when necessary (like for data
-     * PDU before handing over to HCI)
-     */
-    om_ret->om_data += 4;
-    rem_len -= databuf_len - om_ret->om_pkthdr_len - 4;
-
-    /* Allocate and chain mbufs until there's enough space to store complete PDU */
-    om = om_ret;
-    while (rem_len > 0) {
-        om_next = os_msys_get(rem_len, 0);
-        if (!om_next) {
-            os_mbuf_free_chain(om_ret);
-            goto rxpdu_alloc_fail;
-        }
-
-        SLIST_NEXT(om, om_next) = om_next;
-        om = om_next;
-
-        rem_len -= databuf_len;
-    }
-
-    return om_ret;
+	struct os_mbuf *om_ret;
+	struct os_mbuf *om_next;
+	struct os_mbuf *om;
+	struct os_mbuf_pkthdr *pkthdr;
+	uint16_t databuf_len;
+	int rem_len;
+
+	/*
+	 * Make sure that data in mbuf are word-aligned with and without packet
+	 * header. This is essential for proper and quick copying of received PDUs
+	 * into mbufs.
+	 */
+	_Static_assert((offsetof(struct os_mbuf, om_data) & 3) == 0, "Unaligned om_data");
+	_Static_assert(((offsetof(struct os_mbuf, om_data) +
+	                 sizeof(struct os_mbuf_pkthdr) + sizeof(struct ble_mbuf_hdr)) &
+	                3) == 0,
+	               "Unaligned data trailing packet header");
+
+	om_ret = os_msys_get_pkthdr(len, sizeof(struct ble_mbuf_hdr));
+	if (!om_ret) {
+		goto rxpdu_alloc_fail;
+	}
+
+	/* Set complete PDU length in packet header */
+	pkthdr = OS_MBUF_PKTHDR(om_ret);
+	pkthdr->omp_len = len;
+
+	rem_len = len;
+
+	/*
+	 * Calculate length of data in memory block. We assume length is rounded
+	 * down to word size so PHY can do word-size aligned data copy to mbufs
+	 * (except for last one) and leave remainder unused.
+	 *
+	 * Note that there likely won't be any remainder here since all pools have
+	 * block size aligned to word size anyway.
+	 */
+	databuf_len = om_ret->om_omp->omp_databuf_len & ~3;
+
+	/*
+	 * First mbuf can store less data due to packet header. Also we reserve one
+	 * word for leading space to prepend header when necessary (like for data
+	 * PDU before handing over to HCI)
+	 */
+	om_ret->om_data += 4;
+	rem_len -= databuf_len - om_ret->om_pkthdr_len - 4;
+
+	/* Allocate and chain mbufs until there's enough space to store complete PDU */
+	om = om_ret;
+	while (rem_len > 0) {
+		om_next = os_msys_get(rem_len, 0);
+		if (!om_next) {
+			os_mbuf_free_chain(om_ret);
+			goto rxpdu_alloc_fail;
+		}
+
+		SLIST_NEXT(om, om_next) = om_next;
+		om = om_next;
+
+		rem_len -= databuf_len;
+	}
+
+	return om_ret;
 
 rxpdu_alloc_fail:
-    STATS_INC(ble_ll_stats, no_bufs);
-    return NULL;
+	STATS_INC(ble_ll_stats, no_bufs);
+	return NULL;
 }
 
 /**
@@ -511,131 +476,128 @@ rxpdu_alloc_fail:
  *
  * @return int
  */
-int
-ble_ll_is_rpa(const uint8_t *addr, uint8_t addr_type)
+int ble_ll_is_rpa(const uint8_t *addr, uint8_t addr_type)
 {
-    int rc;
-
-    if (addr_type && ((addr[5] & 0xc0) == 0x40)) {
-        rc = 1;
-    } else {
-        rc = 0;
-    }
-    return rc;
+	int rc;
+
+	if (addr_type && ((addr[5] & 0xc0) == 0x40)) {
+		rc = 1;
+	}
+	else {
+		rc = 0;
+	}
+	return rc;
 }
 
-int
-ble_ll_addr_is_id(uint8_t *addr, uint8_t addr_type)
+int ble_ll_addr_is_id(uint8_t *addr, uint8_t addr_type)
 {
-    return !addr_type || ((addr[5] & 0xc0) == 0xc0);
+	return !addr_type || ((addr[5] & 0xc0) == 0xc0);
 }
 
-int
-ble_ll_addr_subtype(const uint8_t *addr, uint8_t addr_type)
+int ble_ll_addr_subtype(const uint8_t *addr, uint8_t addr_type)
 {
-    if (!addr_type) {
-        return BLE_LL_ADDR_SUBTYPE_IDENTITY;
-    }
-
-    switch (addr[5] >> 6) {
-    case 0:
-        return BLE_LL_ADDR_SUBTYPE_NRPA; /* NRPA */
-    case 1:
-        return BLE_LL_ADDR_SUBTYPE_RPA; /* RPA */
-    default:
-        return BLE_LL_ADDR_SUBTYPE_IDENTITY; /* static random */
-    }
+	if (!addr_type) {
+		return BLE_LL_ADDR_SUBTYPE_IDENTITY;
+	}
+
+	switch (addr[5] >> 6) {
+	case 0:
+		return BLE_LL_ADDR_SUBTYPE_NRPA; /* NRPA */
+	case 1:
+		return BLE_LL_ADDR_SUBTYPE_RPA; /* RPA */
+	default:
+		return BLE_LL_ADDR_SUBTYPE_IDENTITY; /* static random */
+	}
 }
 
-static int
-ble_ll_is_valid_addr(const uint8_t *addr)
+static int ble_ll_is_valid_addr(const uint8_t *addr)
 {
-    int i;
+	int i;
 
-    for (i = 0; i < BLE_DEV_ADDR_LEN; ++i) {
-        if (addr[i]) {
-            return 1;
-        }
-    }
+	for (i = 0; i < BLE_DEV_ADDR_LEN; ++i) {
+		if (addr[i]) {
+			return 1;
+		}
+	}
 
-    return 0;
+	return 0;
 }
 
 /* Checks to see that the device is a valid random address */
-int
-ble_ll_is_valid_random_addr(const uint8_t *addr)
+int ble_ll_is_valid_random_addr(const uint8_t *addr)
 {
-    int i;
-    int rc;
-    uint16_t sum;
-    uint8_t addr_type;
-
-    /* Make sure all bits are neither one nor zero */
-    sum = 0;
-    for (i = 0; i < (BLE_DEV_ADDR_LEN -1); ++i) {
-        sum += addr[i];
-    }
-    sum += addr[5] & 0x3f;
-
-    if ((sum == 0) || (sum == ((5*255) + 0x3f))) {
-        return 0;
-    }
-
-    /* Get the upper two bits of the address */
-    rc = 1;
-    addr_type = addr[5] & 0xc0;
-    if (addr_type == 0xc0) {
-        /* Static random address. No other checks needed */
-    } else if (addr_type == 0x40) {
-        /* Resolvable */
-        sum = addr[3] + addr[4] + (addr[5] & 0x3f);
-        if ((sum == 0) || (sum == (255 + 255 + 0x3f))) {
-            rc = 0;
-        }
-    } else if (addr_type == 0) {
-        /* non-resolvable. Cant be equal to public */
-        if (!memcmp(g_dev_addr, addr, BLE_DEV_ADDR_LEN)) {
-            rc = 0;
-        }
-    } else {
-        /* Invalid upper two bits */
-        rc = 0;
-    }
-
-    return rc;
+	int i;
+	int rc;
+	uint16_t sum;
+	uint8_t addr_type;
+
+	/* Make sure all bits are neither one nor zero */
+	sum = 0;
+	for (i = 0; i < (BLE_DEV_ADDR_LEN - 1); ++i) {
+		sum += addr[i];
+	}
+	sum += addr[5] & 0x3f;
+
+	if ((sum == 0) || (sum == ((5 * 255) + 0x3f))) {
+		return 0;
+	}
+
+	/* Get the upper two bits of the address */
+	rc = 1;
+	addr_type = addr[5] & 0xc0;
+	if (addr_type == 0xc0) {
+		/* Static random address. No other checks needed */
+	}
+	else if (addr_type == 0x40) {
+		/* Resolvable */
+		sum = addr[3] + addr[4] + (addr[5] & 0x3f);
+		if ((sum == 0) || (sum == (255 + 255 + 0x3f))) {
+			rc = 0;
+		}
+	}
+	else if (addr_type == 0) {
+		/* non-resolvable. Cant be equal to public */
+		if (!memcmp(g_dev_addr, addr, BLE_DEV_ADDR_LEN)) {
+			rc = 0;
+		}
+	}
+	else {
+		/* Invalid upper two bits */
+		rc = 0;
+	}
+
+	return rc;
 }
-int
-ble_ll_is_valid_own_addr_type(uint8_t own_addr_type, const uint8_t *random_addr)
+int ble_ll_is_valid_own_addr_type(uint8_t own_addr_type, const uint8_t *random_addr)
 {
-    int rc;
+	int rc;
 
-    switch (own_addr_type) {
-    case BLE_HCI_ADV_OWN_ADDR_PUBLIC:
+	switch (own_addr_type) {
+	case BLE_HCI_ADV_OWN_ADDR_PUBLIC:
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PRIVACY)
-    case BLE_HCI_ADV_OWN_ADDR_PRIV_PUB:
+	case BLE_HCI_ADV_OWN_ADDR_PRIV_PUB:
 #endif
-        rc = ble_ll_is_valid_addr(g_dev_addr);
-        break;
-    case BLE_HCI_ADV_OWN_ADDR_RANDOM:
+		rc = ble_ll_is_valid_addr(g_dev_addr);
+		break;
+	case BLE_HCI_ADV_OWN_ADDR_RANDOM:
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PRIVACY)
-    case BLE_HCI_ADV_OWN_ADDR_PRIV_RAND:
+	case BLE_HCI_ADV_OWN_ADDR_PRIV_RAND:
 #endif
-        rc = ble_ll_is_valid_addr(random_addr);
-        break;
-    default:
-        rc = 0;
-        break;
-    }
+		rc = ble_ll_is_valid_addr(random_addr);
+		break;
+	default:
+		rc = 0;
+		break;
+	}
 
-    return rc;
+	return rc;
 }
 
-int
-ble_ll_set_public_addr(const uint8_t *addr)
+int ble_ll_set_public_addr(const uint8_t *addr)
 {
-    memcpy(g_dev_addr, addr, BLE_DEV_ADDR_LEN);
+	memcpy(g_dev_addr, addr, BLE_DEV_ADDR_LEN);
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -648,53 +610,52 @@ ble_ll_set_public_addr(const uint8_t *addr)
  *
  * @return int 0: success
  */
-int
-ble_ll_set_random_addr(const uint8_t *cmdbuf, uint8_t len, bool hci_adv_ext)
+int ble_ll_set_random_addr(const uint8_t *cmdbuf, uint8_t len, bool hci_adv_ext)
 {
-    const struct ble_hci_le_set_rand_addr_cp *cmd = (const void *) cmdbuf;
+	const struct ble_hci_le_set_rand_addr_cp *cmd = (const void *) cmdbuf;
 
-    if (len < sizeof(*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len < sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    /* If the Host issues this command when scanning or legacy advertising is
-     * enabled, the Controller shall return the error code Command Disallowed.
-     *
-     * Test specification extends this also to initiating.
-     */
+	/* If the Host issues this command when scanning or legacy advertising is
+	 * enabled, the Controller shall return the error code Command Disallowed.
+	 *
+	 * Test specification extends this also to initiating.
+	 */
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (g_ble_ll_conn_create_sm.connsm) {
-        return BLE_ERR_CMD_DISALLOWED;
-    }
+	if (g_ble_ll_conn_create_sm.connsm) {
+		return BLE_ERR_CMD_DISALLOWED;
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    if (ble_ll_scan_enabled()){
-        return BLE_ERR_CMD_DISALLOWED;
-    }
+	if (ble_ll_scan_enabled()) {
+		return BLE_ERR_CMD_DISALLOWED;
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-    if (!hci_adv_ext && ble_ll_adv_enabled()) {
-        return BLE_ERR_CMD_DISALLOWED;
-    }
+	if (!hci_adv_ext && ble_ll_adv_enabled()) {
+		return BLE_ERR_CMD_DISALLOWED;
+	}
 #endif
 
-    memcpy(g_random_addr, cmd->addr, BLE_DEV_ADDR_LEN);
+	memcpy(g_random_addr, cmd->addr, BLE_DEV_ADDR_LEN);
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-    /* For instance 0 we need same address if legacy advertising might be
-     * used. If extended advertising is in use than this command doesn't
-     * affect instance 0.
-     */
-    if (!hci_adv_ext)
-        ble_ll_adv_set_random_addr(cmd->addr, 0);
+	/* For instance 0 we need same address if legacy advertising might be
+	 * used. If extended advertising is in use than this command doesn't
+	 * affect instance 0.
+	 */
+	if (!hci_adv_ext)
+		ble_ll_adv_set_random_addr(cmd->addr, 0);
 #endif
 #endif
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -706,24 +667,24 @@ ble_ll_set_random_addr(const uint8_t *cmdbuf, uint8_t len, bool hci_adv_ext)
  *
  * @return int 0: not our device address. 1: is our device address
  */
-int
-ble_ll_is_our_devaddr(uint8_t *addr, int addr_type)
+int ble_ll_is_our_devaddr(uint8_t *addr, int addr_type)
 {
-    int rc;
-    uint8_t *our_addr;
-
-    if (addr_type) {
-        our_addr = g_random_addr;
-    } else {
-        our_addr = g_dev_addr;
-    }
-
-    rc = 0;
-    if (!memcmp(our_addr, addr, BLE_DEV_ADDR_LEN)) {
-        rc = 1;
-    }
-
-    return rc;
+	int rc;
+	uint8_t *our_addr;
+
+	if (addr_type) {
+		our_addr = g_random_addr;
+	}
+	else {
+		our_addr = g_dev_addr;
+	}
+
+	rc = 0;
+	if (!memcmp(our_addr, addr, BLE_DEV_ADDR_LEN)) {
+		rc = 1;
+	}
+
+	return rc;
 }
 
 /**
@@ -733,14 +694,13 @@ ble_ll_is_our_devaddr(uint8_t *addr, int addr_type)
  *
  * @return pointer to identity address of given type.
  */
-uint8_t*
-ble_ll_get_our_devaddr(uint8_t addr_type)
+uint8_t *ble_ll_get_our_devaddr(uint8_t addr_type)
 {
-    if (addr_type) {
-        return g_random_addr;
-    }
+	if (addr_type) {
+		return g_random_addr;
+	}
 
-    return g_dev_addr;
+	return g_dev_addr;
 }
 
 /**
@@ -750,60 +710,59 @@ ble_ll_get_our_devaddr(uint8_t addr_type)
  *
  * @param arg
  */
-void
-ble_ll_wfr_timer_exp(void *arg)
+void ble_ll_wfr_timer_exp(void *arg)
 {
-    int rx_start;
-    uint8_t lls;
+	int rx_start;
+	uint8_t lls;
 
-    rx_start = ble_phy_rx_started();
-    lls = g_ble_ll_data.ll_state;
+	rx_start = ble_phy_rx_started();
+	lls = g_ble_ll_data.ll_state;
 
-    ble_ll_trace_u32x3(BLE_LL_TRACE_ID_WFR_EXP, lls, ble_phy_xcvr_state_get(),
-                       (uint32_t)rx_start);
+	ble_ll_trace_u32x3(BLE_LL_TRACE_ID_WFR_EXP, lls, ble_phy_xcvr_state_get(),
+	                   (uint32_t) rx_start);
 
-    /* If we have started a reception, there is nothing to do here */
-    if (!rx_start) {
-        switch (lls) {
+	/* If we have started a reception, there is nothing to do here */
+	if (!rx_start) {
+		switch (lls) {
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-        case BLE_LL_STATE_ADV:
-            ble_ll_adv_wfr_timer_exp();
-            break;
+		case BLE_LL_STATE_ADV:
+			ble_ll_adv_wfr_timer_exp();
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-        case BLE_LL_STATE_CONNECTION:
-            ble_ll_conn_wfr_timer_exp();
-            break;
+		case BLE_LL_STATE_CONNECTION:
+			ble_ll_conn_wfr_timer_exp();
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-        case BLE_LL_STATE_SCANNING:
-            ble_ll_scan_wfr_timer_exp();
-            break;
+		case BLE_LL_STATE_SCANNING:
+			ble_ll_scan_wfr_timer_exp();
+			break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-        case BLE_LL_STATE_SCAN_AUX:
-            ble_ll_scan_aux_wfr_timer_exp();
-            break;
+		case BLE_LL_STATE_SCAN_AUX:
+			ble_ll_scan_aux_wfr_timer_exp();
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV)
-        case BLE_LL_STATE_SYNC:
-            ble_ll_sync_wfr_timer_exp();
-            break;
+		case BLE_LL_STATE_SYNC:
+			ble_ll_sync_wfr_timer_exp();
+			break;
 #endif
 #endif
 #if MYNEWT_VAL(BLE_LL_DTM)
-        case BLE_LL_STATE_DTM:
-            ble_ll_dtm_wfr_timer_exp();
-            break;
+		case BLE_LL_STATE_DTM:
+			ble_ll_dtm_wfr_timer_exp();
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_EXT)
-        case BLE_LL_STATE_EXTERNAL:
-            ble_ll_ext_wfr_timer_exp();
-            break;
-#endif
-        default:
-            break;
-        }
-    }
+		case BLE_LL_STATE_EXTERNAL:
+			ble_ll_ext_wfr_timer_exp();
+			break;
+#endif
+		default:
+			break;
+		}
+	}
 }
 
 /**
@@ -815,44 +774,43 @@ ble_ll_wfr_timer_exp(void *arg)
  *
  */
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-static void
-ble_ll_tx_pkt_in(void)
+static void ble_ll_tx_pkt_in(void)
 {
-    uint16_t handle;
-    uint16_t length;
-    uint16_t pb;
-    struct os_mbuf_pkthdr *pkthdr;
-    struct os_mbuf *om;
-    os_sr_t sr;
-
-    /* Drain all packets off the queue */
-    while (STAILQ_FIRST(&g_ble_ll_data.ll_tx_pkt_q)) {
-        /* Get mbuf pointer from packet header pointer */
-        pkthdr = STAILQ_FIRST(&g_ble_ll_data.ll_tx_pkt_q);
-        om = (struct os_mbuf *)((uint8_t *)pkthdr - sizeof(struct os_mbuf));
-
-        /* Remove from queue */
-        OS_ENTER_CRITICAL(sr);
-        STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_tx_pkt_q, omp_next);
-        OS_EXIT_CRITICAL(sr);
-
-        /* Strip HCI ACL header to get handle and length */
-        handle = get_le16(om->om_data);
-        length = get_le16(om->om_data + 2);
-        os_mbuf_adj(om, sizeof(struct hci_data_hdr));
-
-        /* Do some basic error checking */
-        pb = handle & 0x3000;
-        if ((pkthdr->omp_len != length) || (pb > 0x1000) || (length == 0)) {
-            /* This is a bad ACL packet. Count a stat and free it */
-            STATS_INC(ble_ll_stats, bad_acl_hdr);
-            os_mbuf_free_chain(om);
-            continue;
-        }
-
-        /* Hand to connection state machine */
-        ble_ll_conn_tx_pkt_in(om, handle, length);
-    }
+	uint16_t handle;
+	uint16_t length;
+	uint16_t pb;
+	struct os_mbuf_pkthdr *pkthdr;
+	struct os_mbuf *om;
+	os_sr_t sr;
+
+	/* Drain all packets off the queue */
+	while (STAILQ_FIRST(&g_ble_ll_data.ll_tx_pkt_q)) {
+		/* Get mbuf pointer from packet header pointer */
+		pkthdr = STAILQ_FIRST(&g_ble_ll_data.ll_tx_pkt_q);
+		om = (struct os_mbuf *) ((uint8_t *) pkthdr - sizeof(struct os_mbuf));
+
+		/* Remove from queue */
+		OS_ENTER_CRITICAL(sr);
+		STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_tx_pkt_q, omp_next);
+		OS_EXIT_CRITICAL(sr);
+
+		/* Strip HCI ACL header to get handle and length */
+		handle = get_le16(om->om_data);
+		length = get_le16(om->om_data + 2);
+		os_mbuf_adj(om, sizeof(struct hci_data_hdr));
+
+		/* Do some basic error checking */
+		pb = handle & 0x3000;
+		if ((pkthdr->omp_len != length) || (pb > 0x1000) || (length == 0)) {
+			/* This is a bad ACL packet. Count a stat and free it */
+			STATS_INC(ble_ll_stats, bad_acl_hdr);
+			os_mbuf_free_chain(om);
+			continue;
+		}
+
+		/* Hand to connection state machine */
+		ble_ll_conn_tx_pkt_in(om, handle, length);
+	}
 }
 #endif
 
@@ -864,45 +822,47 @@ ble_ll_tx_pkt_in(void)
  * @param hdr
  * @param len
  */
-static void
-ble_ll_count_rx_stats(struct ble_mbuf_hdr *hdr, uint16_t len, uint8_t pdu_type)
+static void ble_ll_count_rx_stats(struct ble_mbuf_hdr *hdr, uint16_t len, uint8_t pdu_type)
 {
-    uint8_t crcok;
-    bool connection_data;
+	uint8_t crcok;
+	bool connection_data;
 
-    crcok = BLE_MBUF_HDR_CRC_OK(hdr);
+	crcok = BLE_MBUF_HDR_CRC_OK(hdr);
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    connection_data = (BLE_MBUF_HDR_RX_STATE(hdr) == BLE_LL_STATE_CONNECTION);
+	connection_data = (BLE_MBUF_HDR_RX_STATE(hdr) == BLE_LL_STATE_CONNECTION);
 #else
-    connection_data = false;
+	connection_data = false;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_DTM)
-    /* Reuse connection stats for DTM */
-    if (!connection_data) {
-        connection_data = (BLE_MBUF_HDR_RX_STATE(hdr) == BLE_LL_STATE_DTM);
-    }
-#endif
-
-    if (crcok) {
-        if (connection_data) {
-            STATS_INC(ble_ll_stats, rx_data_pdu_crc_ok);
-            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_ok, len);
-        } else {
-            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_ok);
-            STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_ok, len);
-            ble_ll_count_rx_adv_pdus(pdu_type);
-        }
-    } else {
-        if (connection_data) {
-            STATS_INC(ble_ll_stats, rx_data_pdu_crc_err);
-            STATS_INCN(ble_ll_stats, rx_data_bytes_crc_err, len);
-        } else {
-            STATS_INC(ble_ll_stats, rx_adv_pdu_crc_err);
-            STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_err, len);
-        }
-    }
+	/* Reuse connection stats for DTM */
+	if (!connection_data) {
+		connection_data = (BLE_MBUF_HDR_RX_STATE(hdr) == BLE_LL_STATE_DTM);
+	}
+#endif
+
+	if (crcok) {
+		if (connection_data) {
+			STATS_INC(ble_ll_stats, rx_data_pdu_crc_ok);
+			STATS_INCN(ble_ll_stats, rx_data_bytes_crc_ok, len);
+		}
+		else {
+			STATS_INC(ble_ll_stats, rx_adv_pdu_crc_ok);
+			STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_ok, len);
+			ble_ll_count_rx_adv_pdus(pdu_type);
+		}
+	}
+	else {
+		if (connection_data) {
+			STATS_INC(ble_ll_stats, rx_data_pdu_crc_err);
+			STATS_INCN(ble_ll_stats, rx_data_bytes_crc_err, len);
+		}
+		else {
+			STATS_INC(ble_ll_stats, rx_adv_pdu_crc_err);
+			STATS_INCN(ble_ll_stats, rx_adv_bytes_crc_err, len);
+		}
+	}
 }
 
 /**
@@ -913,83 +873,82 @@ ble_ll_count_rx_stats(struct ble_mbuf_hdr *hdr, uint16_t len, uint8_t pdu_type)
  * Context: Link layer task
  *
  */
-static void
-ble_ll_rx_pkt_in(void)
+static void ble_ll_rx_pkt_in(void)
 {
-    os_sr_t sr;
-    uint8_t pdu_type;
-    uint8_t *rxbuf;
-    struct os_mbuf_pkthdr *pkthdr;
-    struct ble_mbuf_hdr *ble_hdr;
-    struct os_mbuf *m;
-
-    /* Drain all packets off the queue */
-    while (STAILQ_FIRST(&g_ble_ll_data.ll_rx_pkt_q)) {
-        /* Get mbuf pointer from packet header pointer */
-        pkthdr = STAILQ_FIRST(&g_ble_ll_data.ll_rx_pkt_q);
-        m = (struct os_mbuf *)((uint8_t *)pkthdr - sizeof(struct os_mbuf));
-
-        /* Remove from queue */
-        OS_ENTER_CRITICAL(sr);
-        STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_rx_pkt_q, omp_next);
-        OS_EXIT_CRITICAL(sr);
-
-        /* Note: pdu type wont get used unless this is an advertising pdu */
-        ble_hdr = BLE_MBUF_HDR_PTR(m);
-        rxbuf = m->om_data;
-        pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
-        ble_ll_count_rx_stats(ble_hdr, pkthdr->omp_len, pdu_type);
-
-        /* Process the data or advertising pdu */
-        /* Process the PDU */
-        switch (BLE_MBUF_HDR_RX_STATE(ble_hdr)) {
+	os_sr_t sr;
+	uint8_t pdu_type;
+	uint8_t *rxbuf;
+	struct os_mbuf_pkthdr *pkthdr;
+	struct ble_mbuf_hdr *ble_hdr;
+	struct os_mbuf *m;
+
+	/* Drain all packets off the queue */
+	while (STAILQ_FIRST(&g_ble_ll_data.ll_rx_pkt_q)) {
+		/* Get mbuf pointer from packet header pointer */
+		pkthdr = STAILQ_FIRST(&g_ble_ll_data.ll_rx_pkt_q);
+		m = (struct os_mbuf *) ((uint8_t *) pkthdr - sizeof(struct os_mbuf));
+
+		/* Remove from queue */
+		OS_ENTER_CRITICAL(sr);
+		STAILQ_REMOVE_HEAD(&g_ble_ll_data.ll_rx_pkt_q, omp_next);
+		OS_EXIT_CRITICAL(sr);
+
+		/* Note: pdu type wont get used unless this is an advertising pdu */
+		ble_hdr = BLE_MBUF_HDR_PTR(m);
+		rxbuf = m->om_data;
+		pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
+		ble_ll_count_rx_stats(ble_hdr, pkthdr->omp_len, pdu_type);
+
+		/* Process the data or advertising pdu */
+		/* Process the PDU */
+		switch (BLE_MBUF_HDR_RX_STATE(ble_hdr)) {
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-        case BLE_LL_STATE_CONNECTION:
-            ble_ll_conn_rx_data_pdu(m, ble_hdr);
-            /* m is going to be free by function above */
-            m = NULL;
-            break;
+		case BLE_LL_STATE_CONNECTION:
+			ble_ll_conn_rx_data_pdu(m, ble_hdr);
+			/* m is going to be free by function above */
+			m = NULL;
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-        case BLE_LL_STATE_ADV:
-            ble_ll_adv_rx_pkt_in(pdu_type, rxbuf, ble_hdr);
-            break;
+		case BLE_LL_STATE_ADV:
+			ble_ll_adv_rx_pkt_in(pdu_type, rxbuf, ble_hdr);
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-        case BLE_LL_STATE_SCANNING:
-            ble_ll_scan_rx_pkt_in(pdu_type, m, ble_hdr);
-            break;
+		case BLE_LL_STATE_SCANNING:
+			ble_ll_scan_rx_pkt_in(pdu_type, m, ble_hdr);
+			break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV)
-        case BLE_LL_STATE_SYNC:
-            ble_ll_sync_rx_pkt_in(m, ble_hdr);
-            break;
+		case BLE_LL_STATE_SYNC:
+			ble_ll_sync_rx_pkt_in(m, ble_hdr);
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-        case BLE_LL_STATE_SCAN_AUX:
-            ble_ll_scan_aux_rx_pkt_in(m, ble_hdr);
-            break;
+		case BLE_LL_STATE_SCAN_AUX:
+			ble_ll_scan_aux_rx_pkt_in(m, ble_hdr);
+			break;
 #endif
 #endif
 #if MYNEWT_VAL(BLE_LL_DTM)
-        case BLE_LL_STATE_DTM:
-            ble_ll_dtm_rx_pkt_in(m, ble_hdr);
-            break;
+		case BLE_LL_STATE_DTM:
+			ble_ll_dtm_rx_pkt_in(m, ble_hdr);
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_EXT)
-        case BLE_LL_STATE_EXTERNAL:
-            ble_ll_ext_rx_pkt_in(m, ble_hdr);
-            break;
-#endif
-        default:
-            /* Any other state should never occur */
-            STATS_INC(ble_ll_stats, bad_ll_state);
-            break;
-        }
-        if (m) {
-            /* Free the packet buffer */
-            os_mbuf_free_chain(m);
-        }
-    }
+		case BLE_LL_STATE_EXTERNAL:
+			ble_ll_ext_rx_pkt_in(m, ble_hdr);
+			break;
+#endif
+		default:
+			/* Any other state should never occur */
+			STATS_INC(ble_ll_stats, bad_ll_state);
+			break;
+		}
+		if (m) {
+			/* Free the packet buffer */
+			os_mbuf_free_chain(m);
+		}
+	}
 }
 
 /**
@@ -997,14 +956,13 @@ ble_ll_rx_pkt_in(void)
  *
  * @param rxpdu Pointer to received PDU
  */
-void
-ble_ll_rx_pdu_in(struct os_mbuf *rxpdu)
+void ble_ll_rx_pdu_in(struct os_mbuf *rxpdu)
 {
-    struct os_mbuf_pkthdr *pkthdr;
+	struct os_mbuf_pkthdr *pkthdr;
 
-    pkthdr = OS_MBUF_PKTHDR(rxpdu);
-    STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_rx_pkt_q, pkthdr, omp_next);
-    ble_ll_event_add(&g_ble_ll_data.ll_rx_pkt_ev);
+	pkthdr = OS_MBUF_PKTHDR(rxpdu);
+	STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_rx_pkt_q, pkthdr, omp_next);
+	ble_ll_event_add(&g_ble_ll_data.ll_rx_pkt_ev);
 }
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
@@ -1013,17 +971,16 @@ ble_ll_rx_pdu_in(struct os_mbuf *rxpdu)
  *
  * @param txpdu Pointer to transmit packet
  */
-void
-ble_ll_acl_data_in(struct os_mbuf *txpkt)
+void ble_ll_acl_data_in(struct os_mbuf *txpkt)
 {
-    os_sr_t sr;
-    struct os_mbuf_pkthdr *pkthdr;
-
-    pkthdr = OS_MBUF_PKTHDR(txpkt);
-    OS_ENTER_CRITICAL(sr);
-    STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_tx_pkt_q, pkthdr, omp_next);
-    OS_EXIT_CRITICAL(sr);
-    ble_ll_event_add(&g_ble_ll_data.ll_tx_pkt_ev);
+	os_sr_t sr;
+	struct os_mbuf_pkthdr *pkthdr;
+
+	pkthdr = OS_MBUF_PKTHDR(txpkt);
+	OS_ENTER_CRITICAL(sr);
+	STAILQ_INSERT_TAIL(&g_ble_ll_data.ll_tx_pkt_q, pkthdr, omp_next);
+	OS_EXIT_CRITICAL(sr);
+	ble_ll_event_add(&g_ble_ll_data.ll_tx_pkt_ev);
 }
 
 /**
@@ -1033,10 +990,9 @@ ble_ll_acl_data_in(struct os_mbuf *txpkt)
  * Context: Interrupt
  *
  */
-void
-ble_ll_data_buffer_overflow(void)
+void ble_ll_data_buffer_overflow(void)
 {
-    ble_ll_event_add(&g_ble_ll_data.ll_dbuf_overflow_ev);
+	ble_ll_event_add(&g_ble_ll_data.ll_dbuf_overflow_ev);
 }
 #endif
 
@@ -1045,10 +1001,9 @@ ble_ll_data_buffer_overflow(void)
  *
  * Context: Interrupt
  */
-void
-ble_ll_hw_error(void)
+void ble_ll_hw_error(void)
 {
-    ble_npl_callout_reset(&g_ble_ll_data.ll_hw_err_timer, 0);
+	ble_npl_callout_reset(&g_ble_ll_data.ll_hw_err_timer, 0);
 }
 
 /**
@@ -1056,18 +1011,17 @@ ble_ll_hw_error(void)
  *
  * @param arg
  */
-static void
-ble_ll_hw_err_timer_cb(struct ble_npl_event *ev)
+static void ble_ll_hw_err_timer_cb(struct ble_npl_event *ev)
 {
-    if (ble_ll_hci_ev_hw_err(BLE_HW_ERR_HCI_SYNC_LOSS)) {
-        /*
-         * Restart callout if failed to allocate event. Try to allocate an
-         * event every 50 milliseconds (or each OS tick if a tick is longer
-         * than 100 msecs).
-         */
-        ble_npl_callout_reset(&g_ble_ll_data.ll_hw_err_timer,
-                         ble_npl_time_ms_to_ticks32(50));
-    }
+	if (ble_ll_hci_ev_hw_err(BLE_HW_ERR_HCI_SYNC_LOSS)) {
+		/*
+		 * Restart callout if failed to allocate event. Try to allocate an
+		 * event every 50 milliseconds (or each OS tick if a tick is longer
+		 * than 100 msecs).
+		 */
+		ble_npl_callout_reset(&g_ble_ll_data.ll_hw_err_timer,
+		                      ble_npl_time_ms_to_ticks32(50));
+	}
 }
 
 /**
@@ -1083,62 +1037,60 @@ ble_ll_hw_err_timer_cb(struct ble_npl_event *ev)
  *   = 0: Continue to receive frame. Dont go from rx to tx
  *   > 0: Continue to receive frame and go from rx to tx when done
  */
-int
-ble_ll_rx_start(uint8_t *rxbuf, uint8_t chan, struct ble_mbuf_hdr *rxhdr)
+int ble_ll_rx_start(uint8_t *rxbuf, uint8_t chan, struct ble_mbuf_hdr *rxhdr)
 {
-    int rc;
-    uint8_t pdu_type;
+	int rc;
+	uint8_t pdu_type;
 
-    /* Advertising channel PDU */
-    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
+	/* Advertising channel PDU */
+	pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
 
-    ble_ll_trace_u32x2(BLE_LL_TRACE_ID_RX_START, g_ble_ll_data.ll_state,
-                       pdu_type);
+	ble_ll_trace_u32x2(BLE_LL_TRACE_ID_RX_START, g_ble_ll_data.ll_state, pdu_type);
 
-    switch (g_ble_ll_data.ll_state) {
+	switch (g_ble_ll_data.ll_state) {
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_STATE_CONNECTION:
-        rc = ble_ll_conn_rx_isr_start(rxhdr, ble_phy_access_addr_get());
-        break;
+	case BLE_LL_STATE_CONNECTION:
+		rc = ble_ll_conn_rx_isr_start(rxhdr, ble_phy_access_addr_get());
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-    case BLE_LL_STATE_ADV:
-        rc = ble_ll_adv_rx_isr_start(pdu_type);
-        break;
+	case BLE_LL_STATE_ADV:
+		rc = ble_ll_adv_rx_isr_start(pdu_type);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    case BLE_LL_STATE_SCANNING:
-        rc = ble_ll_scan_rx_isr_start(pdu_type, &rxhdr->rxinfo.flags);
-        break;
+	case BLE_LL_STATE_SCANNING:
+		rc = ble_ll_scan_rx_isr_start(pdu_type, &rxhdr->rxinfo.flags);
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV)
-    case BLE_LL_STATE_SYNC:
-        rc = ble_ll_sync_rx_isr_start(pdu_type, rxhdr);
-        break;
+	case BLE_LL_STATE_SYNC:
+		rc = ble_ll_sync_rx_isr_start(pdu_type, rxhdr);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-    case BLE_LL_STATE_SCAN_AUX:
-        rc = ble_ll_scan_aux_rx_isr_start(pdu_type, rxhdr);
-        break;
+	case BLE_LL_STATE_SCAN_AUX:
+		rc = ble_ll_scan_aux_rx_isr_start(pdu_type, rxhdr);
+		break;
 #endif
 #endif
 #if MYNEWT_VAL(BLE_LL_DTM)
-    case BLE_LL_STATE_DTM:
-        rc = ble_ll_dtm_rx_isr_start(rxhdr, ble_phy_access_addr_get());
-        break;
+	case BLE_LL_STATE_DTM:
+		rc = ble_ll_dtm_rx_isr_start(rxhdr, ble_phy_access_addr_get());
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_EXT)
-    case BLE_LL_STATE_EXTERNAL:
-        rc = ble_ll_ext_rx_isr_start(pdu_type, rxhdr);
-        break;
-#endif
-    default:
-        /* Should not be in this state! */
-        rc = -1;
-        STATS_INC(ble_ll_stats, bad_ll_state);
-        break;
-    }
-
-    return rc;
+	case BLE_LL_STATE_EXTERNAL:
+		rc = ble_ll_ext_rx_isr_start(pdu_type, rxhdr);
+		break;
+#endif
+	default:
+		/* Should not be in this state! */
+		rc = -1;
+		STATS_INC(ble_ll_stats, bad_ll_state);
+		break;
+	}
+
+	return rc;
 }
 
 /**
@@ -1154,200 +1106,191 @@ ble_ll_rx_start(uint8_t *rxbuf, uint8_t chan, struct ble_mbuf_hdr *rxhdr)
  *      == 0: Success. Do not disable the PHY.
  *       > 0: Do not disable PHY as that has already been done.
  */
-int
-ble_ll_rx_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
+int ble_ll_rx_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
 {
-    int rc;
-    int badpkt;
-    uint8_t pdu_type;
-    uint8_t len;
-    uint8_t crcok;
-    struct os_mbuf *rxpdu;
+	int rc;
+	int badpkt;
+	uint8_t pdu_type;
+	uint8_t len;
+	uint8_t crcok;
+	struct os_mbuf *rxpdu;
 
-    /* Get CRC status from BLE header */
-    crcok = BLE_MBUF_HDR_CRC_OK(rxhdr);
+	/* Get CRC status from BLE header */
+	crcok = BLE_MBUF_HDR_CRC_OK(rxhdr);
 
-    /* Get advertising PDU type and length */
-    pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
-    len = rxbuf[1];
+	/* Get advertising PDU type and length */
+	pdu_type = rxbuf[0] & BLE_ADV_PDU_HDR_TYPE_MASK;
+	len = rxbuf[1];
 
-    ble_ll_trace_u32x3(BLE_LL_TRACE_ID_RX_END, pdu_type, len,
-                       rxhdr->rxinfo.flags);
+	ble_ll_trace_u32x3(BLE_LL_TRACE_ID_RX_END, pdu_type, len, rxhdr->rxinfo.flags);
 
 #if MYNEWT_VAL(BLE_LL_EXT)
-    if (BLE_MBUF_HDR_RX_STATE(rxhdr) == BLE_LL_STATE_EXTERNAL) {
-        rc = ble_ll_ext_rx_isr_end(rxbuf, rxhdr);
-        return rc;
-    }
+	if (BLE_MBUF_HDR_RX_STATE(rxhdr) == BLE_LL_STATE_EXTERNAL) {
+		rc = ble_ll_ext_rx_isr_end(rxbuf, rxhdr);
+		return rc;
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_DTM)
-    if (BLE_MBUF_HDR_RX_STATE(rxhdr) == BLE_LL_STATE_DTM) {
-        rc = ble_ll_dtm_rx_isr_end(rxbuf, rxhdr);
-        return rc;
-    }
+	if (BLE_MBUF_HDR_RX_STATE(rxhdr) == BLE_LL_STATE_DTM) {
+		rc = ble_ll_dtm_rx_isr_end(rxbuf, rxhdr);
+		return rc;
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (BLE_MBUF_HDR_RX_STATE(rxhdr) == BLE_LL_STATE_CONNECTION) {
-        rc = ble_ll_conn_rx_isr_end(rxbuf, rxhdr);
-        return rc;
-    }
+	if (BLE_MBUF_HDR_RX_STATE(rxhdr) == BLE_LL_STATE_CONNECTION) {
+		rc = ble_ll_conn_rx_isr_end(rxbuf, rxhdr);
+		return rc;
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV) && MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    if (BLE_MBUF_HDR_RX_STATE(rxhdr) == BLE_LL_STATE_SYNC) {
-        rc = ble_ll_sync_rx_isr_end(rxbuf, rxhdr);
-        return rc;
-    }
-#endif
-
-    /* If the CRC checks, make sure lengths check! */
-    badpkt = 0;
-    if (crcok) {
-        switch (pdu_type) {
-        case BLE_ADV_PDU_TYPE_SCAN_REQ:
-        case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
-            if (len != BLE_SCAN_REQ_LEN) {
-                badpkt = 1;
-            }
-            break;
-        case BLE_ADV_PDU_TYPE_SCAN_RSP:
-        case BLE_ADV_PDU_TYPE_ADV_IND:
-        case BLE_ADV_PDU_TYPE_ADV_SCAN_IND:
-        case BLE_ADV_PDU_TYPE_ADV_NONCONN_IND:
-            if ((len < BLE_DEV_ADDR_LEN) || (len > BLE_ADV_SCAN_IND_MAX_LEN)) {
-                badpkt = 1;
-            }
-            break;
-        case BLE_ADV_PDU_TYPE_AUX_CONNECT_RSP:
-            break;
-        case BLE_ADV_PDU_TYPE_ADV_EXT_IND:
-            break;
-        case BLE_ADV_PDU_TYPE_CONNECT_IND:
-            if (len != BLE_CONNECT_REQ_LEN) {
-                badpkt = 1;
-            }
-            break;
-        default:
-            badpkt = 1;
-            break;
-        }
-
-        /* If this is a malformed packet, just kill it here */
-        if (badpkt) {
-            STATS_INC(ble_ll_stats, rx_adv_malformed_pkts);
-        }
-    }
-
-    /* Hand packet to the appropriate state machine (if crc ok) */
-    rxpdu = NULL;
-    switch (BLE_MBUF_HDR_RX_STATE(rxhdr)) {
+	if (BLE_MBUF_HDR_RX_STATE(rxhdr) == BLE_LL_STATE_SYNC) {
+		rc = ble_ll_sync_rx_isr_end(rxbuf, rxhdr);
+		return rc;
+	}
+#endif
+
+	/* If the CRC checks, make sure lengths check! */
+	badpkt = 0;
+	if (crcok) {
+		switch (pdu_type) {
+		case BLE_ADV_PDU_TYPE_SCAN_REQ:
+		case BLE_ADV_PDU_TYPE_ADV_DIRECT_IND:
+			if (len != BLE_SCAN_REQ_LEN) {
+				badpkt = 1;
+			}
+			break;
+		case BLE_ADV_PDU_TYPE_SCAN_RSP:
+		case BLE_ADV_PDU_TYPE_ADV_IND:
+		case BLE_ADV_PDU_TYPE_ADV_SCAN_IND:
+		case BLE_ADV_PDU_TYPE_ADV_NONCONN_IND:
+			if ((len < BLE_DEV_ADDR_LEN) || (len > BLE_ADV_SCAN_IND_MAX_LEN)) {
+				badpkt = 1;
+			}
+			break;
+		case BLE_ADV_PDU_TYPE_AUX_CONNECT_RSP:
+			break;
+		case BLE_ADV_PDU_TYPE_ADV_EXT_IND:
+			break;
+		case BLE_ADV_PDU_TYPE_CONNECT_IND:
+			if (len != BLE_CONNECT_REQ_LEN) {
+				badpkt = 1;
+			}
+			break;
+		default:
+			badpkt = 1;
+			break;
+		}
+
+		/* If this is a malformed packet, just kill it here */
+		if (badpkt) {
+			STATS_INC(ble_ll_stats, rx_adv_malformed_pkts);
+		}
+	}
+
+	/* Hand packet to the appropriate state machine (if crc ok) */
+	rxpdu = NULL;
+	switch (BLE_MBUF_HDR_RX_STATE(rxhdr)) {
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-    case BLE_LL_STATE_ADV:
-        if (!badpkt) {
-            rxpdu = ble_ll_rxpdu_alloc(len + BLE_LL_PDU_HDR_LEN);
-            if (rxpdu) {
-                ble_phy_rxpdu_copy(rxbuf, rxpdu);
-            }
-        }
-        rc = ble_ll_adv_rx_isr_end(pdu_type, rxpdu, crcok);
-        break;
+	case BLE_LL_STATE_ADV:
+		if (!badpkt) {
+			rxpdu = ble_ll_rxpdu_alloc(len + BLE_LL_PDU_HDR_LEN);
+			if (rxpdu) {
+				ble_phy_rxpdu_copy(rxbuf, rxpdu);
+			}
+		}
+		rc = ble_ll_adv_rx_isr_end(pdu_type, rxpdu, crcok);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    case BLE_LL_STATE_SCANNING:
-        if (!badpkt) {
-            rxpdu = ble_ll_rxpdu_alloc(len + BLE_LL_PDU_HDR_LEN);
-            if (rxpdu) {
-                ble_phy_rxpdu_copy(rxbuf, rxpdu);
-            }
-        }
-        rc = ble_ll_scan_rx_isr_end(rxpdu, crcok);
-        break;
+	case BLE_LL_STATE_SCANNING:
+		if (!badpkt) {
+			rxpdu = ble_ll_rxpdu_alloc(len + BLE_LL_PDU_HDR_LEN);
+			if (rxpdu) {
+				ble_phy_rxpdu_copy(rxbuf, rxpdu);
+			}
+		}
+		rc = ble_ll_scan_rx_isr_end(rxpdu, crcok);
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-    case BLE_LL_STATE_SCAN_AUX:
-        if (!badpkt) {
-            rxpdu = ble_ll_rxpdu_alloc(len + BLE_LL_PDU_HDR_LEN);
-            if (rxpdu) {
-                ble_phy_rxpdu_copy(rxbuf, rxpdu);
-            }
-        }
-        rc = ble_ll_scan_aux_rx_isr_end(rxpdu, crcok);
-        break;
-#endif
-#endif
-    default:
-        rc = -1;
-        STATS_INC(ble_ll_stats, bad_ll_state);
-        break;
-    }
-
-    /* Hand packet up to higher layer (regardless of CRC failure) */
-    if (rxpdu) {
-        ble_ll_rx_pdu_in(rxpdu);
-    }
-
-    return rc;
+	case BLE_LL_STATE_SCAN_AUX:
+		if (!badpkt) {
+			rxpdu = ble_ll_rxpdu_alloc(len + BLE_LL_PDU_HDR_LEN);
+			if (rxpdu) {
+				ble_phy_rxpdu_copy(rxbuf, rxpdu);
+			}
+		}
+		rc = ble_ll_scan_aux_rx_isr_end(rxpdu, crcok);
+		break;
+#endif
+#endif
+	default:
+		rc = -1;
+		STATS_INC(ble_ll_stats, bad_ll_state);
+		break;
+	}
+
+	/* Hand packet up to higher layer (regardless of CRC failure) */
+	if (rxpdu) {
+		ble_ll_rx_pdu_in(rxpdu);
+	}
+
+	return rc;
 }
 
-uint8_t
-ble_ll_tx_mbuf_pducb(uint8_t *dptr, void *pducb_arg, uint8_t *hdr_byte)
+uint8_t ble_ll_tx_mbuf_pducb(uint8_t *dptr, void *pducb_arg, uint8_t *hdr_byte)
 {
-    struct os_mbuf *txpdu;
-    struct ble_mbuf_hdr *ble_hdr;
+	struct os_mbuf *txpdu;
+	struct ble_mbuf_hdr *ble_hdr;
 
-    txpdu = pducb_arg;
-    BLE_LL_ASSERT(txpdu);
-    ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
+	txpdu = pducb_arg;
+	BLE_LL_ASSERT(txpdu);
+	ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
 
-    os_mbuf_copydata(txpdu, ble_hdr->txinfo.offset, ble_hdr->txinfo.pyld_len,
-                     dptr);
+	os_mbuf_copydata(txpdu, ble_hdr->txinfo.offset, ble_hdr->txinfo.pyld_len, dptr);
 
-    *hdr_byte = ble_hdr->txinfo.hdr_byte;
+	*hdr_byte = ble_hdr->txinfo.hdr_byte;
 
-    return ble_hdr->txinfo.pyld_len;
+	return ble_hdr->txinfo.pyld_len;
 }
 
-uint8_t
-ble_ll_tx_flat_mbuf_pducb(uint8_t *dptr, void *pducb_arg, uint8_t *hdr_byte)
+uint8_t ble_ll_tx_flat_mbuf_pducb(uint8_t *dptr, void *pducb_arg, uint8_t *hdr_byte)
 {
-    struct os_mbuf *txpdu;
-    struct ble_mbuf_hdr *ble_hdr;
+	struct os_mbuf *txpdu;
+	struct ble_mbuf_hdr *ble_hdr;
 
-    txpdu = pducb_arg;
-    BLE_LL_ASSERT(txpdu);
-    ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
+	txpdu = pducb_arg;
+	BLE_LL_ASSERT(txpdu);
+	ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
 
-    memcpy(dptr, txpdu->om_data, ble_hdr->txinfo.pyld_len);
+	memcpy(dptr, txpdu->om_data, ble_hdr->txinfo.pyld_len);
 
-    *hdr_byte = ble_hdr->txinfo.hdr_byte;
+	*hdr_byte = ble_hdr->txinfo.hdr_byte;
 
-    return ble_hdr->txinfo.pyld_len;
+	return ble_hdr->txinfo.pyld_len;
 }
 
-static void
-ble_ll_event_rx_pkt(struct ble_npl_event *ev)
+static void ble_ll_event_rx_pkt(struct ble_npl_event *ev)
 {
-    ble_ll_rx_pkt_in();
+	ble_ll_rx_pkt_in();
 }
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-static void
-ble_ll_event_tx_pkt(struct ble_npl_event *ev)
+static void ble_ll_event_tx_pkt(struct ble_npl_event *ev)
 {
-    ble_ll_tx_pkt_in();
+	ble_ll_tx_pkt_in();
 }
 
-static void
-ble_ll_event_dbuf_overflow(struct ble_npl_event *ev)
+static void ble_ll_event_dbuf_overflow(struct ble_npl_event *ev)
 {
-    ble_ll_hci_ev_databuf_overflow();
+	ble_ll_hci_ev_databuf_overflow();
 }
 
-static void
-ble_ll_event_comp_pkts(struct ble_npl_event *ev)
+static void ble_ll_event_comp_pkts(struct ble_npl_event *ev)
 {
-    ble_ll_conn_num_comp_pkts_event_send(NULL);
+	ble_ll_conn_num_comp_pkts_event_send(NULL);
 }
 #endif
 
@@ -1358,24 +1301,23 @@ ble_ll_event_comp_pkts(struct ble_npl_event *ev)
  *
  * @param arg
  */
-void
-ble_ll_task(void *arg)
+void ble_ll_task(void *arg)
 {
-    struct ble_npl_event *ev;
+	struct ble_npl_event *ev;
 
-    /* Init ble phy */
-    ble_phy_init();
+	/* Init ble phy */
+	ble_phy_init();
 
-    /* Set output power to default */
-    g_ble_ll_tx_power = ble_ll_tx_power_round(MIN(MYNEWT_VAL(BLE_LL_TX_PWR_DBM),
-                                                  MYNEWT_VAL(BLE_LL_TX_PWR_MAX_DBM)));
-    g_ble_ll_tx_power_phy_current = INT8_MAX;
+	/* Set output power to default */
+	g_ble_ll_tx_power = ble_ll_tx_power_round(
+		MIN(MYNEWT_VAL(BLE_LL_TX_PWR_DBM), MYNEWT_VAL(BLE_LL_TX_PWR_MAX_DBM)));
+	g_ble_ll_tx_power_phy_current = INT8_MAX;
 
-    while (1) {
-        ev = ble_npl_eventq_get(&g_ble_ll_data.ll_evq, BLE_NPL_TIME_FOREVER);
-        BLE_LL_ASSERT(ev);
-        ble_npl_event_run(ev);
-    }
+	while (1) {
+		ev = ble_npl_eventq_get(&g_ble_ll_data.ll_evq, BLE_NPL_TIME_FOREVER);
+		BLE_LL_ASSERT(ev);
+		ble_npl_event_run(ev);
+	}
 }
 
 /**
@@ -1387,14 +1329,13 @@ ble_ll_task(void *arg)
  *
  * @param ll_state
  */
-void
-ble_ll_state_set(uint8_t ll_state)
+void ble_ll_state_set(uint8_t ll_state)
 {
-    g_ble_ll_data.ll_state = ll_state;
+	g_ble_ll_data.ll_state = ll_state;
 
-    if (ll_state == BLE_LL_STATE_STANDBY) {
-        BLE_LL_DEBUG_GPIO(SCHED_ITEM, 0);
-    }
+	if (ll_state == BLE_LL_STATE_STANDBY) {
+		BLE_LL_DEBUG_GPIO(SCHED_ITEM, 0);
+	}
 }
 
 /**
@@ -1406,10 +1347,9 @@ ble_ll_state_set(uint8_t ll_state)
  *
  * @return ll_state
  */
-uint8_t
-ble_ll_state_get(void)
+uint8_t ble_ll_state_get(void)
 {
-    return g_ble_ll_data.ll_state;
+	return g_ble_ll_data.ll_state;
 }
 
 /**
@@ -1419,10 +1359,9 @@ ble_ll_state_get(void)
  *
  * @param ev Event to add to the Link Layer event queue.
  */
-void
-ble_ll_event_add(struct ble_npl_event *ev)
+void ble_ll_event_add(struct ble_npl_event *ev)
 {
-    ble_npl_eventq_put(&g_ble_ll_data.ll_evq, ev);
+	ble_npl_eventq_put(&g_ble_ll_data.ll_evq, ev);
 }
 
 /**
@@ -1432,10 +1371,9 @@ ble_ll_event_add(struct ble_npl_event *ev)
  *
  * @param ev Event to remove from the Link Layer event queue.
  */
-void
-ble_ll_event_remove(struct ble_npl_event *ev)
+void ble_ll_event_remove(struct ble_npl_event *ev)
 {
-    ble_npl_eventq_remove(&g_ble_ll_data.ll_evq, ev);
+	ble_npl_eventq_remove(&g_ble_ll_data.ll_evq, ev);
 }
 
 /**
@@ -1443,10 +1381,9 @@ ble_ll_event_remove(struct ble_npl_event *ev)
  *
  * @return uint8_t bitmask of supported features.
  */
-uint64_t
-ble_ll_read_supp_states(void)
+uint64_t ble_ll_read_supp_states(void)
 {
-    return BLE_LL_SUPPORTED_STATES;
+	return BLE_LL_SUPPORTED_STATES;
 }
 
 /**
@@ -1454,10 +1391,9 @@ ble_ll_read_supp_states(void)
  *
  * @return uint64_t bitmask of supported features.
  */
-uint64_t
-ble_ll_read_supp_features(void)
+uint64_t ble_ll_read_supp_features(void)
 {
-    return g_ble_ll_data.ll_supp_features;
+	return g_ble_ll_data.ll_supp_features;
 }
 
 /**
@@ -1465,60 +1401,59 @@ ble_ll_read_supp_features(void)
  *
  * @return HCI command status
  */
-int
-ble_ll_set_host_feat(const uint8_t *cmdbuf, uint8_t len)
+int ble_ll_set_host_feat(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_set_host_feature_cp *cmd = (const void *) cmdbuf;
-    uint64_t mask;
+	const struct ble_hci_le_set_host_feature_cp *cmd = (const void *) cmdbuf;
+	uint64_t mask;
 
-    if (len != sizeof(*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    if (!SLIST_EMPTY(&g_ble_ll_conn_active_list)) {
-        return BLE_ERR_CMD_DISALLOWED;
-    }
+	if (!SLIST_EMPTY(&g_ble_ll_conn_active_list)) {
+		return BLE_ERR_CMD_DISALLOWED;
+	}
 #endif
 
-    if ((cmd->bit_num > 0x3F) || (cmd->bit_val > 1)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if ((cmd->bit_num > 0x3F) || (cmd->bit_val > 1)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    mask = (uint64_t)1 << (cmd->bit_num);
-    if (!(mask & BLE_LL_HOST_CONTROLLED_FEATURES)) {
-        return BLE_ERR_UNSUPPORTED;
-    }
+	mask = (uint64_t) 1 << (cmd->bit_num);
+	if (!(mask & BLE_LL_HOST_CONTROLLED_FEATURES)) {
+		return BLE_ERR_UNSUPPORTED;
+	}
 
-    if (cmd->bit_val == 0) {
-        g_ble_ll_data.ll_supp_features &= ~(mask);
-    } else {
-        g_ble_ll_data.ll_supp_features |= mask;
-    }
+	if (cmd->bit_val == 0) {
+		g_ble_ll_data.ll_supp_features &= ~(mask);
+	}
+	else {
+		g_ble_ll_data.ll_supp_features |= mask;
+	}
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 /**
  * Flush a link layer packet queue.
  *
  * @param pktq
  */
-static void
-ble_ll_flush_pkt_queue(struct ble_ll_pkt_q *pktq)
+static void ble_ll_flush_pkt_queue(struct ble_ll_pkt_q *pktq)
 {
-    struct os_mbuf_pkthdr *pkthdr;
-    struct os_mbuf *om;
-
-    /* FLush all packets from Link layer queues */
-    while (STAILQ_FIRST(pktq)) {
-        /* Get mbuf pointer from packet header pointer */
-        pkthdr = STAILQ_FIRST(pktq);
-        om = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
-
-        /* Remove from queue and free the mbuf */
-        STAILQ_REMOVE_HEAD(pktq, omp_next);
-        os_mbuf_free_chain(om);
-    }
+	struct os_mbuf_pkthdr *pkthdr;
+	struct os_mbuf *om;
+
+	/* FLush all packets from Link layer queues */
+	while (STAILQ_FIRST(pktq)) {
+		/* Get mbuf pointer from packet header pointer */
+		pkthdr = STAILQ_FIRST(pktq);
+		om = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
+
+		/* Remove from queue and free the mbuf */
+		STAILQ_REMOVE_HEAD(pktq, omp_next);
+		os_mbuf_free_chain(om);
+	}
 }
 
 /**
@@ -1533,33 +1468,31 @@ ble_ll_flush_pkt_queue(struct ble_ll_pkt_q *pktq)
  * @param pdulen
  * @param hdr
  */
-void
-ble_ll_mbuf_init(struct os_mbuf *m, uint8_t pdulen, uint8_t hdr)
+void ble_ll_mbuf_init(struct os_mbuf *m, uint8_t pdulen, uint8_t hdr)
 {
-    struct ble_mbuf_hdr *ble_hdr;
-
-    /* Set mbuf length and packet length */
-    m->om_len = pdulen;
-    OS_MBUF_PKTHDR(m)->omp_len = pdulen;
-
-    /* Set BLE transmit header */
-    ble_hdr = BLE_MBUF_HDR_PTR(m);
-    ble_hdr->txinfo.flags = 0;
-    ble_hdr->txinfo.offset = 0;
-    ble_hdr->txinfo.pyld_len = pdulen;
-    ble_hdr->txinfo.hdr_byte = hdr;
+	struct ble_mbuf_hdr *ble_hdr;
+
+	/* Set mbuf length and packet length */
+	m->om_len = pdulen;
+	OS_MBUF_PKTHDR(m)->omp_len = pdulen;
+
+	/* Set BLE transmit header */
+	ble_hdr = BLE_MBUF_HDR_PTR(m);
+	ble_hdr->txinfo.flags = 0;
+	ble_hdr->txinfo.offset = 0;
+	ble_hdr->txinfo.pyld_len = pdulen;
+	ble_hdr->txinfo.hdr_byte = hdr;
 }
 
-static void
-ble_ll_validate_task(void)
+static void ble_ll_validate_task(void)
 {
 #ifdef MYNEWT
 #ifndef NDEBUG
-    struct os_task_info oti;
+	struct os_task_info oti;
 
-    os_task_info_get(&g_ble_ll_task, &oti);
+	os_task_info_get(&g_ble_ll_task, &oti);
 
-    BLE_LL_ASSERT(oti.oti_stkusage < oti.oti_stksize);
+	BLE_LL_ASSERT(oti.oti_stkusage < oti.oti_stksize);
 #endif
 #endif
 }
@@ -1574,188 +1507,189 @@ ble_ll_validate_task(void)
  * @return int The ble error code to place in the command complete event that
  * is returned when this command is issued.
  */
-int
-ble_ll_reset(void)
+int ble_ll_reset(void)
 {
-    uint8_t phy_mask;
-    int rc;
-    os_sr_t sr;
+	uint8_t phy_mask;
+	int rc;
+	os_sr_t sr;
 
-    /* do sanity check on LL task stack */
-    ble_ll_validate_task();
+	/* do sanity check on LL task stack */
+	ble_ll_validate_task();
 
-    OS_ENTER_CRITICAL(sr);
-    ble_phy_disable();
-    ble_ll_sched_stop();
+	OS_ENTER_CRITICAL(sr);
+	ble_phy_disable();
+	ble_ll_sched_stop();
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    ble_ll_scan_reset();
+	ble_ll_scan_reset();
 #endif
-    ble_ll_rfmgmt_reset();
-    OS_EXIT_CRITICAL(sr);
+	ble_ll_rfmgmt_reset();
+	OS_EXIT_CRITICAL(sr);
 
 #if MYNEWT_VAL(BLE_LL_EXT)
-    ble_ll_ext_reset();
+	ble_ll_ext_reset();
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-    /* Stop any advertising */
-    ble_ll_adv_reset();
+	/* Stop any advertising */
+	ble_ll_adv_reset();
 #endif
 
 #if MYNEWT_VAL(BLE_LL_DTM)
-    ble_ll_dtm_reset();
+	ble_ll_dtm_reset();
 #endif
 
-    /* Stop sync */
+	/* Stop sync */
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV) && MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    ble_ll_sync_reset();
+	ble_ll_sync_reset();
 #endif
 
-    /* reset power compensation */
-    g_ble_ll_tx_power_compensation = 0;
-    g_ble_ll_rx_power_compensation = 0;
+	/* reset power compensation */
+	g_ble_ll_tx_power_compensation = 0;
+	g_ble_ll_rx_power_compensation = 0;
 
-    /* Set output power to default */
-    g_ble_ll_tx_power = ble_ll_tx_power_round(MIN(MYNEWT_VAL(BLE_LL_TX_PWR_DBM),
-                                                  MYNEWT_VAL(BLE_LL_TX_PWR_MAX_DBM)));
-    g_ble_ll_tx_power_phy_current = INT8_MAX;
+	/* Set output power to default */
+	g_ble_ll_tx_power = ble_ll_tx_power_round(
+		MIN(MYNEWT_VAL(BLE_LL_TX_PWR_DBM), MYNEWT_VAL(BLE_LL_TX_PWR_MAX_DBM)));
+	g_ble_ll_tx_power_phy_current = INT8_MAX;
 
-    /* FLush all packets from Link layer queues */
-    ble_ll_flush_pkt_queue(&g_ble_ll_data.ll_tx_pkt_q);
-    ble_ll_flush_pkt_queue(&g_ble_ll_data.ll_rx_pkt_q);
+	/* FLush all packets from Link layer queues */
+	ble_ll_flush_pkt_queue(&g_ble_ll_data.ll_tx_pkt_q);
+	ble_ll_flush_pkt_queue(&g_ble_ll_data.ll_rx_pkt_q);
 
-    /* Reset LL stats */
-    STATS_RESET(ble_ll_stats);
+	/* Reset LL stats */
+	STATS_RESET(ble_ll_stats);
 
-    /* Reset any preferred PHYs */
-    phy_mask = BLE_PHY_MASK_1M;
+	/* Reset any preferred PHYs */
+	phy_mask = BLE_PHY_MASK_1M;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_2M_PHY)
-    phy_mask |= BLE_PHY_MASK_2M;
+	phy_mask |= BLE_PHY_MASK_2M;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-    phy_mask |= BLE_PHY_MASK_CODED;
+	phy_mask |= BLE_PHY_MASK_CODED;
 #endif
-    phy_mask &= MYNEWT_VAL(BLE_LL_CONN_PHY_DEFAULT_PREF_MASK);
-    BLE_LL_ASSERT(phy_mask);
-    g_ble_ll_data.ll_pref_tx_phys = phy_mask;
-    g_ble_ll_data.ll_pref_rx_phys = phy_mask;
+	phy_mask &= MYNEWT_VAL(BLE_LL_CONN_PHY_DEFAULT_PREF_MASK);
+	BLE_LL_ASSERT(phy_mask);
+	g_ble_ll_data.ll_pref_tx_phys = phy_mask;
+	g_ble_ll_data.ll_pref_rx_phys = phy_mask;
 
-    /* Enable all channels in channel map */
-    g_ble_ll_data.chan_map_used = BLE_PHY_NUM_DATA_CHANS;
-    memset(g_ble_ll_data.chan_map, 0xff, BLE_LL_CHAN_MAP_LEN - 1);
-    g_ble_ll_data.chan_map[4] = 0x1f;
+	/* Enable all channels in channel map */
+	g_ble_ll_data.chan_map_used = BLE_PHY_NUM_DATA_CHANS;
+	memset(g_ble_ll_data.chan_map, 0xff, BLE_LL_CHAN_MAP_LEN - 1);
+	g_ble_ll_data.chan_map[4] = 0x1f;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    /* Reset connection module */
-    ble_ll_conn_module_reset();
+	/* Reset connection module */
+	ble_ll_conn_module_reset();
 #endif
 
-    /* All this does is re-initialize the event masks so call the hci init */
-    ble_ll_hci_init();
+	/* All this does is re-initialize the event masks so call the hci init */
+	ble_ll_hci_init();
 
-    /* Reset scheduler */
-    ble_ll_sched_init();
+	/* Reset scheduler */
+	ble_ll_sched_init();
 
-    /* Set state to standby */
-    ble_ll_state_set(BLE_LL_STATE_STANDBY);
+	/* Set state to standby */
+	ble_ll_state_set(BLE_LL_STATE_STANDBY);
 
-    /* Reset our random address */
-    memset(g_random_addr, 0, BLE_DEV_ADDR_LEN);
+	/* Reset our random address */
+	memset(g_random_addr, 0, BLE_DEV_ADDR_LEN);
 
-    /* Clear the whitelist */
-    ble_ll_whitelist_clear();
+	/* Clear the whitelist */
+	ble_ll_whitelist_clear();
 
-    /* Reset resolving list */
+	/* Reset resolving list */
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PRIVACY)
-    ble_ll_resolv_list_reset();
+	ble_ll_resolv_list_reset();
 #endif
 
 
 #if MYNEWT_VAL(BLE_FEM_PA)
-    ble_fem_pa_init();
+	ble_fem_pa_init();
 #endif
 #if MYNEWT_VAL(BLE_FEM_LNA)
-    ble_fem_lna_init();
+	ble_fem_lna_init();
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ISO)
-    ble_ll_isoal_reset();
+	ble_ll_isoal_reset();
 #endif
 #if MYNEWT_VAL(BLE_LL_ISO_BROADCASTER)
-    ble_ll_iso_big_reset();
+	ble_ll_iso_big_reset();
 #endif
 
-    /* Re-initialize the PHY */
-    rc = ble_phy_init();
+	/* Re-initialize the PHY */
+	rc = ble_phy_init();
 
-    return rc;
+	return rc;
 }
 
-uint16_t
-ble_ll_pdu_max_tx_octets_get(uint32_t usecs, int phy_mode)
+uint16_t ble_ll_pdu_max_tx_octets_get(uint32_t usecs, int phy_mode)
 {
-    uint32_t header_tx_time;
-    uint16_t octets = 0;
-
-    BLE_LL_ASSERT(phy_mode < BLE_PHY_NUM_MODE);
-
-    header_tx_time = ble_ll_pdu_us(0, phy_mode);
-
-    /*
-     * Current conn max tx time can be too short to even send a packet header
-     * and this can happen if we changed connection form uncoded to coded phy.
-     * However, the lower bound for conn max tx time (all of them) depends on
-     * current phy (uncoded/coded) but it always allows to send at least 27
-     * bytes of payload thus we always return at least 27 from here.
-     *
-     * Reference:
-     * Core v5.0, Vol 6, Part B, section 4.5.10
-     * see connEffectiveMaxTxTime and connEffectiveMaxRxTime definitions
-     */
-
-    if (usecs < header_tx_time) {
-        return 27;
-    }
-
-    usecs -= header_tx_time;
-
-    if (phy_mode == BLE_PHY_MODE_1M) {
-        /* 8 usecs per byte */
-        octets = usecs >> 3;
-    } else if (phy_mode == BLE_PHY_MODE_2M) {
-        /* 4 usecs per byte */
-        octets = usecs >> 2;
-    } else if (phy_mode == BLE_PHY_MODE_CODED_125KBPS) {
-        /* S=8 => 8 * 8 = 64 usecs per byte */
-        octets = usecs >> 6;
-    } else if (phy_mode == BLE_PHY_MODE_CODED_500KBPS) {
-        /* S=2 => 2 * 8 = 16 usecs per byte */
-        octets = usecs >> 4;
-    } else {
-        BLE_LL_ASSERT(0);
-    }
-
-    /* see comment at the beginning */
-    return MAX(27, octets);
+	uint32_t header_tx_time;
+	uint16_t octets = 0;
+
+	BLE_LL_ASSERT(phy_mode < BLE_PHY_NUM_MODE);
+
+	header_tx_time = ble_ll_pdu_us(0, phy_mode);
+
+	/*
+	 * Current conn max tx time can be too short to even send a packet header
+	 * and this can happen if we changed connection form uncoded to coded phy.
+	 * However, the lower bound for conn max tx time (all of them) depends on
+	 * current phy (uncoded/coded) but it always allows to send at least 27
+	 * bytes of payload thus we always return at least 27 from here.
+	 *
+	 * Reference:
+	 * Core v5.0, Vol 6, Part B, section 4.5.10
+	 * see connEffectiveMaxTxTime and connEffectiveMaxRxTime definitions
+	 */
+
+	if (usecs < header_tx_time) {
+		return 27;
+	}
+
+	usecs -= header_tx_time;
+
+	if (phy_mode == BLE_PHY_MODE_1M) {
+		/* 8 usecs per byte */
+		octets = usecs >> 3;
+	}
+	else if (phy_mode == BLE_PHY_MODE_2M) {
+		/* 4 usecs per byte */
+		octets = usecs >> 2;
+	}
+	else if (phy_mode == BLE_PHY_MODE_CODED_125KBPS) {
+		/* S=8 => 8 * 8 = 64 usecs per byte */
+		octets = usecs >> 6;
+	}
+	else if (phy_mode == BLE_PHY_MODE_CODED_500KBPS) {
+		/* S=2 => 2 * 8 = 16 usecs per byte */
+		octets = usecs >> 4;
+	}
+	else {
+		BLE_LL_ASSERT(0);
+	}
+
+	/* see comment at the beginning */
+	return MAX(27, octets);
 }
 
-static inline bool
-ble_ll_is_addr_empty(const uint8_t *addr)
+static inline bool ble_ll_is_addr_empty(const uint8_t *addr)
 {
-    return memcmp(addr, BLE_ADDR_ANY, BLE_DEV_ADDR_LEN) == 0;
+	return memcmp(addr, BLE_ADDR_ANY, BLE_DEV_ADDR_LEN) == 0;
 }
 
 #if MYNEWT_VAL(BLE_LL_HCI_VS_EVENT_ON_ASSERT)
-void
-ble_ll_assert(const char *file, unsigned line)
+void ble_ll_assert(const char *file, unsigned line)
 {
-    ble_ll_hci_ev_send_vs_assert(file, line);
+	ble_ll_hci_ev_send_vs_assert(file, line);
 
-    if (hal_debugger_connected()) {
-        __BKPT(0);
-    }
+	if (hal_debugger_connected()) {
+		__BKPT(0);
+	}
 
-    while (1);
+	while (1)
+		;
 }
 #endif
 
@@ -1764,333 +1698,322 @@ ble_ll_assert(const char *file, unsigned line)
  *
  * @return int
  */
-void
-ble_ll_init(void)
+void ble_ll_init(void)
 {
-    int rc;
-    uint64_t features;
+	int rc;
+	uint64_t features;
 #if MYNEWT_VAL(BLE_LL_PUBLIC_DEV_ADDR)
-    uint64_t pub_dev_addr;
-    int i;
+	uint64_t pub_dev_addr;
+	int i;
 #endif
-    ble_addr_t addr;
-    struct ble_ll_obj *lldata;
+	ble_addr_t addr;
+	struct ble_ll_obj *lldata;
 
-    /* Ensure this function only gets called by sysinit. */
-    SYSINIT_ASSERT_ACTIVE();
+	/* Ensure this function only gets called by sysinit. */
+	SYSINIT_ASSERT_ACTIVE();
 
-    ble_ll_trace_init();
-    ble_phy_trace_init();
+	ble_ll_trace_init();
+	ble_phy_trace_init();
 
-    /* Set public device address if not already set */
-    if (ble_ll_is_addr_empty(g_dev_addr)) {
+	/* Set public device address if not already set */
+	if (ble_ll_is_addr_empty(g_dev_addr)) {
 #if MYNEWT_VAL(BLE_LL_PUBLIC_DEV_ADDR)
-        pub_dev_addr = MYNEWT_VAL(BLE_LL_PUBLIC_DEV_ADDR);
+		pub_dev_addr = MYNEWT_VAL(BLE_LL_PUBLIC_DEV_ADDR);
 
-        for (i = 0; i < BLE_DEV_ADDR_LEN; i++) {
-            g_dev_addr[i] = pub_dev_addr & 0xff;
-            pub_dev_addr >>= 8;
-        }
+		for (i = 0; i < BLE_DEV_ADDR_LEN; i++) {
+			g_dev_addr[i] = pub_dev_addr & 0xff;
+			pub_dev_addr >>= 8;
+		}
 #else
-        memcpy(g_dev_addr, MYNEWT_VAL(BLE_PUBLIC_DEV_ADDR), BLE_DEV_ADDR_LEN);
+		memcpy(g_dev_addr, MYNEWT_VAL(BLE_PUBLIC_DEV_ADDR), BLE_DEV_ADDR_LEN);
 #endif
-        if (ble_ll_is_addr_empty(g_dev_addr)) {
-            rc = ble_hw_get_public_addr(&addr);
-            if (!rc) {
-                memcpy(g_dev_addr, &addr.val[0], BLE_DEV_ADDR_LEN);
-            }
-        }
-    }
+		if (ble_ll_is_addr_empty(g_dev_addr)) {
+			rc = ble_hw_get_public_addr(&addr);
+			if (!rc) {
+				memcpy(g_dev_addr, &addr.val[0], BLE_DEV_ADDR_LEN);
+			}
+		}
+	}
 
-    ble_ll_rfmgmt_init();
+	ble_ll_rfmgmt_init();
 
-    /* Get pointer to global data object */
-    lldata = &g_ble_ll_data;
+	/* Get pointer to global data object */
+	lldata = &g_ble_ll_data;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    /* Set acl pkt size and number */
-    lldata->ll_num_acl_pkts = MYNEWT_VAL(BLE_TRANSPORT_ACL_FROM_HS_COUNT);
-    lldata->ll_acl_pkt_size = MYNEWT_VAL(BLE_TRANSPORT_ACL_SIZE);
+	/* Set acl pkt size and number */
+	lldata->ll_num_acl_pkts = MYNEWT_VAL(BLE_TRANSPORT_ACL_FROM_HS_COUNT);
+	lldata->ll_acl_pkt_size = MYNEWT_VAL(BLE_TRANSPORT_ACL_SIZE);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ISO)
-    lldata->ll_num_iso_pkts = MYNEWT_VAL(BLE_TRANSPORT_ISO_FROM_HS_COUNT);
-    lldata->ll_iso_pkt_size = MYNEWT_VAL(BLE_TRANSPORT_ISO_SIZE);
+	lldata->ll_num_iso_pkts = MYNEWT_VAL(BLE_TRANSPORT_ISO_FROM_HS_COUNT);
+	lldata->ll_iso_pkt_size = MYNEWT_VAL(BLE_TRANSPORT_ISO_SIZE);
 #endif
 
-    /* Initialize eventq */
-    ble_npl_eventq_init(&lldata->ll_evq);
+	/* Initialize eventq */
+	ble_npl_eventq_init(&lldata->ll_evq);
 
-    /* Initialize the transmit (from host) and receive (from phy) queues */
-    STAILQ_INIT(&lldata->ll_tx_pkt_q);
-    STAILQ_INIT(&lldata->ll_rx_pkt_q);
+	/* Initialize the transmit (from host) and receive (from phy) queues */
+	STAILQ_INIT(&lldata->ll_tx_pkt_q);
+	STAILQ_INIT(&lldata->ll_rx_pkt_q);
 
-    /* Initialize transmit (from host) and receive packet (from phy) event */
-    ble_npl_event_init(&lldata->ll_rx_pkt_ev, ble_ll_event_rx_pkt, NULL);
+	/* Initialize transmit (from host) and receive packet (from phy) event */
+	ble_npl_event_init(&lldata->ll_rx_pkt_ev, ble_ll_event_rx_pkt, NULL);
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    ble_npl_event_init(&lldata->ll_tx_pkt_ev, ble_ll_event_tx_pkt, NULL);
+	ble_npl_event_init(&lldata->ll_tx_pkt_ev, ble_ll_event_tx_pkt, NULL);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    /* Initialize data buffer overflow event and completed packets */
-    ble_npl_event_init(&lldata->ll_dbuf_overflow_ev, ble_ll_event_dbuf_overflow, NULL);
-    ble_npl_event_init(&lldata->ll_comp_pkt_ev, ble_ll_event_comp_pkts, NULL);
+	/* Initialize data buffer overflow event and completed packets */
+	ble_npl_event_init(&lldata->ll_dbuf_overflow_ev, ble_ll_event_dbuf_overflow, NULL);
+	ble_npl_event_init(&lldata->ll_comp_pkt_ev, ble_ll_event_comp_pkts, NULL);
 #endif
 
-    /* Initialize the HW error timer */
-    ble_npl_callout_init(&g_ble_ll_data.ll_hw_err_timer,
-                         &g_ble_ll_data.ll_evq,
-                         ble_ll_hw_err_timer_cb,
-                         NULL);
+	/* Initialize the HW error timer */
+	ble_npl_callout_init(&g_ble_ll_data.ll_hw_err_timer, &g_ble_ll_data.ll_evq,
+	                     ble_ll_hw_err_timer_cb, NULL);
 
-    /* Initialize LL HCI */
-    ble_ll_hci_init();
+	/* Initialize LL HCI */
+	ble_ll_hci_init();
 
-    /* Init the scheduler */
-    ble_ll_sched_init();
+	/* Init the scheduler */
+	ble_ll_sched_init();
 
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-    /* Initialize advertiser */
-    ble_ll_adv_init();
+	/* Initialize advertiser */
+	ble_ll_adv_init();
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    /* Initialize a scanner */
-    ble_ll_scan_init();
+	/* Initialize a scanner */
+	ble_ll_scan_init();
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    /* Initialize the connection module */
-    ble_ll_conn_module_init();
+	/* Initialize the connection module */
+	ble_ll_conn_module_init();
 #endif
 
-    /* Set the supported features. NOTE: we always support extended reject. */
-    features = BLE_LL_FEAT_EXTENDED_REJ;
+	/* Set the supported features. NOTE: we always support extended reject. */
+	features = BLE_LL_FEAT_EXTENDED_REJ;
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_DATA_LEN_EXT)
-    features |= BLE_LL_FEAT_DATA_LEN_EXT;
+	features |= BLE_LL_FEAT_DATA_LEN_EXT;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_CONN_PARAM_REQ)
-    features |= BLE_LL_FEAT_CONN_PARM_REQ;
+	features |= BLE_LL_FEAT_CONN_PARM_REQ;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_PERIPH_INIT_FEAT_XCHG)
-    features |= BLE_LL_FEAT_PERIPH_INIT;
+	features |= BLE_LL_FEAT_PERIPH_INIT;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    features |= BLE_LL_FEAT_LE_ENCRYPTION;
+	features |= BLE_LL_FEAT_LE_ENCRYPTION;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PRIVACY)
-    features |= (BLE_LL_FEAT_LL_PRIVACY | BLE_LL_FEAT_EXT_SCAN_FILT);
-    ble_ll_resolv_init();
+	features |= (BLE_LL_FEAT_LL_PRIVACY | BLE_LL_FEAT_EXT_SCAN_FILT);
+	ble_ll_resolv_init();
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
-    features |= BLE_LL_FEAT_LE_PING;
+	features |= BLE_LL_FEAT_LE_PING;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-    features |= BLE_LL_FEAT_EXT_ADV;
+	features |= BLE_LL_FEAT_EXT_ADV;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CSA2)
-    /* CSA2 */
-    features |= BLE_LL_FEAT_CSA2;
+	/* CSA2 */
+	features |= BLE_LL_FEAT_CSA2;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_2M_PHY)
-    features |= BLE_LL_FEAT_LE_2M_PHY;
+	features |= BLE_LL_FEAT_LE_2M_PHY;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-    features |= BLE_LL_FEAT_LE_CODED_PHY;
+	features |= BLE_LL_FEAT_LE_CODED_PHY;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV)
-    features |= BLE_LL_FEAT_PERIODIC_ADV;
+	features |= BLE_LL_FEAT_PERIODIC_ADV;
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    ble_ll_sync_init();
+	ble_ll_sync_init();
 #endif
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
-    features |= BLE_LL_FEAT_SYNC_TRANS_RECV;
-    features |= BLE_LL_FEAT_SYNC_TRANS_SEND;
+	features |= BLE_LL_FEAT_SYNC_TRANS_RECV;
+	features |= BLE_LL_FEAT_SYNC_TRANS_SEND;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-    features |= BLE_LL_FEAT_SCA_UPDATE;
+	features |= BLE_LL_FEAT_SCA_UPDATE;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ISO_BROADCASTER)
-    features |= BLE_LL_FEAT_ISO_BROADCASTER;
+	features |= BLE_LL_FEAT_ISO_BROADCASTER;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    features |= BLE_LL_FEAT_CONN_SUBRATING;
+	features |= BLE_LL_FEAT_CONN_SUBRATING;
 #endif
 
-    lldata->ll_supp_features = features;
+	lldata->ll_supp_features = features;
 
-    /* Initialize random number generation */
-    ble_ll_rand_init();
-    /* Start the random number generator */
-    ble_ll_rand_start();
+	/* Initialize random number generation */
+	ble_ll_rand_init();
+	/* Start the random number generator */
+	ble_ll_rand_start();
 
-    rc = stats_init_and_reg(STATS_HDR(ble_ll_stats),
-                            STATS_SIZE_INIT_PARMS(ble_ll_stats, STATS_SIZE_32),
-                            STATS_NAME_INIT_PARMS(ble_ll_stats),
-                            "ble_ll");
-    SYSINIT_PANIC_ASSERT(rc == 0);
+	rc = stats_init_and_reg(STATS_HDR(ble_ll_stats),
+	                        STATS_SIZE_INIT_PARMS(ble_ll_stats, STATS_SIZE_32),
+	                        STATS_NAME_INIT_PARMS(ble_ll_stats), "ble_ll");
+	SYSINIT_PANIC_ASSERT(rc == 0);
 
 #if MYNEWT_VAL(BLE_LL_DTM)
-    ble_ll_dtm_init();
+	ble_ll_dtm_init();
 #endif
 
 #if MYNEWT_VAL(BLE_LL_HCI_VS)
-    ble_ll_hci_vs_init();
+	ble_ll_hci_vs_init();
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ISO)
-    ble_ll_isoal_init();
+	ble_ll_isoal_init();
 #endif
 #if MYNEWT_VAL(BLE_LL_ISO_BROADCASTER)
-    ble_ll_iso_big_init();
+	ble_ll_iso_big_init();
 #endif
 
 #if MYNEWT_VAL(BLE_LL_EXT)
-    ble_ll_ext_init();
+	ble_ll_ext_init();
 #endif
 
 #ifdef MYNEWT
-    /* Initialize the LL task */
-    os_task_init(&g_ble_ll_task, "ble_ll", ble_ll_task, NULL,
-                 MYNEWT_VAL(BLE_LL_PRIO), OS_WAIT_FOREVER, g_ble_ll_stack,
-                 MYNEWT_VAL(BLE_LL_STACK_SIZE));
+	/* Initialize the LL task */
+	os_task_init(&g_ble_ll_task, "ble_ll", ble_ll_task, NULL, MYNEWT_VAL(BLE_LL_PRIO),
+	             OS_WAIT_FOREVER, g_ble_ll_stack, MYNEWT_VAL(BLE_LL_STACK_SIZE));
 #else
 
-/*
- * For non-Mynewt OS it is required that OS creates task for LL and run LL
- * routine which is wrapped by nimble_port_ll_task_func().
- */
+	/*
+	 * For non-Mynewt OS it is required that OS creates task for LL and run LL
+	 * routine which is wrapped by nimble_port_ll_task_func().
+	 */
 
 #endif
 }
 
 /* Transport APIs for LL side */
 
-int
-ble_transport_to_ll_cmd_impl(void *buf)
+int ble_transport_to_ll_cmd_impl(void *buf)
 {
-    return ble_ll_hci_cmd_rx(buf);
+	return ble_ll_hci_cmd_rx(buf);
 }
 
-int
-ble_transport_to_ll_acl_impl(struct os_mbuf *om)
+int ble_transport_to_ll_acl_impl(struct os_mbuf *om)
 {
-    return ble_ll_hci_acl_rx(om);
+	return ble_ll_hci_acl_rx(om);
 }
 
-int
-ble_transport_to_ll_iso_impl(struct os_mbuf *om)
+int ble_transport_to_ll_iso_impl(struct os_mbuf *om)
 {
-    return ble_ll_hci_iso_rx(om);
+	return ble_ll_hci_iso_rx(om);
 }
 
-void
-ble_transport_ll_init(void)
+void ble_transport_ll_init(void)
 {
-    /* Tell the host that we are ready to receive packets */
-    ble_ll_hci_send_noop();
+	/* Tell the host that we are ready to receive packets */
+	ble_ll_hci_send_noop();
 }
 
-int
-ble_ll_tx_power_round(int tx_power)
+int ble_ll_tx_power_round(int tx_power)
 {
 #if MYNEWT_VAL(BLE_FEM_PA)
 #if MYNEWT_VAL(BLE_FEM_PA_GAIN_TUNABLE)
-    tx_power = ble_fem_pa_tx_power_round(tx_power);
+	tx_power = ble_fem_pa_tx_power_round(tx_power);
 #else
-    tx_power = ble_phy_tx_power_round(tx_power);
-    tx_power += MYNEWT_VAL(BLE_FEM_PA_GAIN);
+	tx_power = ble_phy_tx_power_round(tx_power);
+	tx_power += MYNEWT_VAL(BLE_FEM_PA_GAIN);
 #endif
 #else
-    tx_power = ble_phy_tx_power_round(tx_power);
+	tx_power = ble_phy_tx_power_round(tx_power);
 #endif
 
-    return tx_power;
+	return tx_power;
 }
 
-void
-ble_ll_tx_power_set(int tx_power)
+void ble_ll_tx_power_set(int tx_power)
 {
 #if MYNEWT_VAL(BLE_FEM_PA)
 #if MYNEWT_VAL(BLE_FEM_PA_GAIN_TUNABLE)
-    /* TODO should rounding be in assert only? or just skip it and assume
-     * power is already rounded?
-     */
-    tx_power = ble_fem_pa_tx_power_round(tx_power);
-    tx_power = ble_fem_pa_tx_power_set(tx_power);
+	/* TODO should rounding be in assert only? or just skip it and assume
+	 * power is already rounded?
+	 */
+	tx_power = ble_fem_pa_tx_power_round(tx_power);
+	tx_power = ble_fem_pa_tx_power_set(tx_power);
 #else
-    tx_power -= MYNEWT_VAL(BLE_FEM_PA_GAIN);
+	tx_power -= MYNEWT_VAL(BLE_FEM_PA_GAIN);
 #endif
 #endif
 
-    /* If current TX power configuration matches requested one we don't need
-     * to update PHY tx power.
-     */
-    if (g_ble_ll_tx_power_phy_current == tx_power) {
-        return;
-    }
+	/* If current TX power configuration matches requested one we don't need
+	 * to update PHY tx power.
+	 */
+	if (g_ble_ll_tx_power_phy_current == tx_power) {
+		return;
+	}
 
-    g_ble_ll_tx_power_phy_current = tx_power;
-    ble_phy_tx_power_set(tx_power);
+	g_ble_ll_tx_power_phy_current = tx_power;
+	ble_phy_tx_power_set(tx_power);
 }
 
-int
-ble_ll_is_busy(unsigned int flags)
+int ble_ll_is_busy(unsigned int flags)
 {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    struct ble_ll_conn_sm *cur;
-    int i = 0;
+	struct ble_ll_conn_sm *cur;
+	int i = 0;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV) && MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    if (ble_ll_sync_enabled()) {
-        return 1;
-    }
+	if (ble_ll_sync_enabled()) {
+		return 1;
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-    if (ble_ll_adv_enabled()) {
-        return 1;
-    }
+	if (ble_ll_adv_enabled()) {
+		return 1;
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    if (ble_ll_scan_enabled()) {
-        return 1;
-    }
+	if (ble_ll_scan_enabled()) {
+		return 1;
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (g_ble_ll_conn_create_sm.connsm) {
-        return 1;
-    }
+	if (g_ble_ll_conn_create_sm.connsm) {
+		return 1;
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    if (!(flags & BLE_LL_BUSY_EXCLUDE_CONNECTIONS)) {
-        STAILQ_FOREACH(cur, &g_ble_ll_conn_free_list, free_stqe) {
-            i++;
-        }
+	if (!(flags & BLE_LL_BUSY_EXCLUDE_CONNECTIONS)) {
+		STAILQ_FOREACH(cur, &g_ble_ll_conn_free_list, free_stqe)
+		{
+			i++;
+		}
 
-        /* check if all connection objects are free */
-        if (i < MYNEWT_VAL(BLE_MAX_CONNECTIONS)) {
-            return 1;
-        }
-    }
+		/* check if all connection objects are free */
+		if (i < MYNEWT_VAL(BLE_MAX_CONNECTIONS)) {
+			return 1;
+		}
+	}
 #endif
 
-    return 0;
+	return 0;
 }
diff --git a/nimble/controller/src/ble_ll_ctrl.c b/nimble/controller/src/ble_ll_ctrl.c
index 6eb883c8..e63e76ea 100644
--- a/nimble/controller/src/ble_ll_ctrl.c
+++ b/nimble/controller/src/ble_ll_ctrl.c
@@ -84,8 +84,7 @@
  * control PDU, so total data channel payload length for the control pdu is
  * one greater.
  */
-const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] =
-{
+const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] = {
     BLE_LL_CTRL_CONN_UPD_REQ_LEN,
     BLE_LL_CTRL_CHAN_MAP_LEN,
     BLE_LL_CTRL_TERMINATE_IND_LEN,
@@ -130,6 +129,27 @@ const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] =
     BLE_LL_CTRL_CHAN_STATUS_IND_LEN,
 };
 
+// #if MYNEWT_VAL(REJECT_ENC_REQ)
+// #if MYNEWT_VAL(VICTIM_IS_APPLE_DEVICE)
+// static int force_reject = 2;
+// #else
+// static int force_reject = 1;
+// #endif
+// #endif
+
+static int force_reject = 0;
+static int fr_times = 1;
+
+void ble_ll_ctrl_set_repairing_flag(int val)
+{
+  printf("ble_ll_ctrl_set_repairing_flag: %d\n", val);
+  fr_times = val;
+  if (fr_times != 0)
+  {
+    force_reject = 1;
+  }
+}
+
 /**
  * Called to determine if a LL control procedure with an instant has
  * been initiated.
@@ -143,31 +163,36 @@ const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] =
  *
  * @return uint8_t
  */
-uint8_t
-ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm *connsm,
-                                        uint8_t req_ctrl_proc)
+uint8_t ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm *connsm,
+                                                uint8_t req_ctrl_proc)
 {
-    uint8_t err;
+  uint8_t err;
 
-    switch (connsm->cur_ctrl_proc) {
-    case BLE_LL_CTRL_PROC_PHY_UPDATE:
-    case BLE_LL_CTRL_PROC_CONN_UPDATE:
-    case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
-    case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
-        if (req_ctrl_proc == connsm->cur_ctrl_proc) {
-            err = BLE_ERR_LMP_COLLISION;
-        } else if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_UPDATE) &&
-                   (req_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
-            err = BLE_ERR_LMP_COLLISION;
-        } else {
-            err = BLE_ERR_DIFF_TRANS_COLL;
-        }
-        break;
-    default:
-        err = 0;
+  switch (connsm->cur_ctrl_proc)
+  {
+  case BLE_LL_CTRL_PROC_PHY_UPDATE:
+  case BLE_LL_CTRL_PROC_CONN_UPDATE:
+  case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
+  case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
+    if (req_ctrl_proc == connsm->cur_ctrl_proc)
+    {
+      err = BLE_ERR_LMP_COLLISION;
+    }
+    else if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_UPDATE) &&
+             (req_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ))
+    {
+      err = BLE_ERR_LMP_COLLISION;
+    }
+    else
+    {
+      err = BLE_ERR_DIFF_TRANS_COLL;
     }
+    break;
+  default:
+    err = 0;
+  }
 
-    return err;
+  return err;
 }
 
 /**
@@ -177,11 +202,10 @@ ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm *connsm,
  * @param err: error response
  * @param ctrdata: Pointer to where CtrData starts in pdu
  */
-void
-ble_ll_ctrl_rej_ext_ind_make(uint8_t rej_opcode, uint8_t err, uint8_t *ctrdata)
+void ble_ll_ctrl_rej_ext_ind_make(uint8_t rej_opcode, uint8_t err, uint8_t *ctrdata)
 {
-    ctrdata[0] = rej_opcode;
-    ctrdata[1] = err;
+  ctrdata[0] = rej_opcode;
+  ctrdata[1] = err;
 }
 
 #if MYNEWT_VAL(BLE_LL_PHY)
@@ -191,53 +215,55 @@ ble_ll_ctrl_rej_ext_ind_make(uint8_t rej_opcode, uint8_t err, uint8_t *ctrdata)
  * @param connsm
  * @param ble_err
  */
-void
-ble_ll_ctrl_phy_update_cancel(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
-{
-    /* cancel any pending phy update procedures */
-    CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
-
-    /* Check if the host wants an event */
-    if (connsm->flags.phy_update_host_initiated) {
-        ble_ll_hci_ev_phy_update(connsm, ble_err);
-        connsm->flags.phy_update_host_initiated = 0;
-    }
-
-    /* Clear any bits for phy updates that might be in progress */
-    connsm->flags.phy_update_self_initiated = 0;
-}
-#endif
-
-static int
-ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
-{
-    int rc;
-    struct ble_ll_len_req ctrl_req;
-
-    /* Extract parameters and check if valid */
-    ctrl_req.max_rx_bytes = get_le16(dptr);
-    ctrl_req.max_rx_time = get_le16(dptr + 2);
-    ctrl_req.max_tx_bytes = get_le16(dptr + 4);
-    ctrl_req.max_tx_time = get_le16(dptr + 6);
-
-    if ((ctrl_req.max_rx_bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
-        (ctrl_req.max_rx_time < BLE_LL_CONN_SUPP_TIME_MIN) ||
-        (ctrl_req.max_tx_bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
-        (ctrl_req.max_tx_time < BLE_LL_CONN_SUPP_TIME_MIN)) {
-        rc = 1;
-    } else {
-        /* Update parameters */
-        connsm->rem_max_rx_time = ctrl_req.max_rx_time;
-        connsm->rem_max_tx_time = ctrl_req.max_tx_time;
-        connsm->rem_max_rx_octets = ctrl_req.max_rx_bytes;
-        connsm->rem_max_tx_octets = ctrl_req.max_tx_bytes;
-
-        /* Recalculate effective connection parameters */
-        ble_ll_conn_update_eff_data_len(connsm);
-        rc = 0;
-    }
+void ble_ll_ctrl_phy_update_cancel(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
+{
+  /* cancel any pending phy update procedures */
+  CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+
+  /* Check if the host wants an event */
+  if (connsm->flags.phy_update_host_initiated)
+  {
+    ble_ll_hci_ev_phy_update(connsm, ble_err);
+    connsm->flags.phy_update_host_initiated = 0;
+  }
+
+  /* Clear any bits for phy updates that might be in progress */
+  connsm->flags.phy_update_self_initiated = 0;
+}
+#endif
+
+static int ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+{
+  int rc;
+  struct ble_ll_len_req ctrl_req;
+
+  /* Extract parameters and check if valid */
+  ctrl_req.max_rx_bytes = get_le16(dptr);
+  ctrl_req.max_rx_time = get_le16(dptr + 2);
+  ctrl_req.max_tx_bytes = get_le16(dptr + 4);
+  ctrl_req.max_tx_time = get_le16(dptr + 6);
+
+  if ((ctrl_req.max_rx_bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
+      (ctrl_req.max_rx_time < BLE_LL_CONN_SUPP_TIME_MIN) ||
+      (ctrl_req.max_tx_bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
+      (ctrl_req.max_tx_time < BLE_LL_CONN_SUPP_TIME_MIN))
+  {
+    rc = 1;
+  }
+  else
+  {
+    /* Update parameters */
+    connsm->rem_max_rx_time = ctrl_req.max_rx_time;
+    connsm->rem_max_tx_time = ctrl_req.max_tx_time;
+    connsm->rem_max_rx_octets = ctrl_req.max_rx_bytes;
+    connsm->rem_max_tx_octets = ctrl_req.max_tx_bytes;
+
+    /* Recalculate effective connection parameters */
+    ble_ll_conn_update_eff_data_len(connsm);
+    rc = 0;
+  }
 
-    return rc;
+  return rc;
 }
 
 /**
@@ -248,11 +274,10 @@ ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  *
  * @param connsm
  */
-static void
-ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm *connsm)
+static void ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm *connsm)
 {
-    /* Stop the control procedure */
-    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_LE_PING);
+  /* Stop the control procedure */
+  ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_LE_PING);
 }
 
 /**
@@ -265,236 +290,254 @@ ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm *connsm)
  *
  * @return int
  */
-static int
-ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                                uint8_t *rspbuf, uint8_t opcode)
-{
-    int rc;
-    int indicate;
-    uint8_t rsp_opcode;
-    uint8_t ble_err;
-    struct ble_ll_conn_params *req;
-    struct hci_conn_update *hcu;
-
-    /* Extract parameters and check if valid */
-    req = &connsm->conn_cp;
-    req->interval_min = get_le16(dptr);
-    req->interval_max = get_le16(dptr + 2);
-    req->latency = get_le16(dptr + 4);
-    req->timeout = get_le16(dptr + 6);
-    req->pref_periodicity = dptr[8];
-    req->ref_conn_event_cnt  = get_le16(dptr + 9);
-    req->offset0 = get_le16(dptr + 11);
-    req->offset1 = get_le16(dptr + 13);
-    req->offset2 = get_le16(dptr + 15);
-    req->offset3 = get_le16(dptr + 17);
-    req->offset4 = get_le16(dptr + 19);
-    req->offset5 = get_le16(dptr + 21);
-
-    /* Check if parameters are valid */
-    ble_err = BLE_ERR_SUCCESS;
-    rc = ble_ll_conn_hci_chk_conn_params(req->interval_min,
-                                         req->interval_max,
-                                         req->latency,
-                                         req->timeout);
-    if (rc) {
-        ble_err = BLE_ERR_INV_LMP_LL_PARM;
-        goto conn_param_pdu_exit;
-    }
-
+static int ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                           uint8_t *rspbuf, uint8_t opcode)
+{
+  int rc;
+  int indicate;
+  uint8_t rsp_opcode;
+  uint8_t ble_err;
+  struct ble_ll_conn_params *req;
+  struct hci_conn_update *hcu;
+
+  /* Extract parameters and check if valid */
+  req = &connsm->conn_cp;
+  req->interval_min = get_le16(dptr);
+  req->interval_max = get_le16(dptr + 2);
+  req->latency = get_le16(dptr + 4);
+  req->timeout = get_le16(dptr + 6);
+  req->pref_periodicity = dptr[8];
+  req->ref_conn_event_cnt = get_le16(dptr + 9);
+  req->offset0 = get_le16(dptr + 11);
+  req->offset1 = get_le16(dptr + 13);
+  req->offset2 = get_le16(dptr + 15);
+  req->offset3 = get_le16(dptr + 17);
+  req->offset4 = get_le16(dptr + 19);
+  req->offset5 = get_le16(dptr + 21);
+
+  /* Check if parameters are valid */
+  ble_err = BLE_ERR_SUCCESS;
+  rc = ble_ll_conn_hci_chk_conn_params(req->interval_min, req->interval_max,
+                                       req->latency, req->timeout);
+  if (rc)
+  {
+    ble_err = BLE_ERR_INV_LMP_LL_PARM;
+    goto conn_param_pdu_exit;
+  }
+
+  /*
+   * Check if there is a requested change to either the interval, timeout
+   * or latency. If not, this may just be an anchor point change and we do
+   * not have to notify the host.
+   *  XXX: what if we dont like the parameters? When do we check that out?
+   */
+  indicate = 1;
+  if (opcode == BLE_LL_CTRL_CONN_PARM_REQ)
+  {
+    if ((connsm->conn_itvl >= req->interval_min) &&
+        (connsm->conn_itvl <= req->interval_max) &&
+        (connsm->supervision_tmo == req->timeout) &&
+        (connsm->periph_latency == req->latency))
+    {
+      indicate = 0;
+      goto conn_parm_req_do_indicate;
+    }
+  }
+
+  /*
+   * A change has been requested. Is it within the values specified by
+   * the host? Note that for a central we will not be processing a
+   * connect param request from a peripheral if we are currently trying to
+   * update the connection parameters. This means that the previous
+   * check is all we need for a central (when receiving a request).
+   */
+  if (CONN_IS_PERIPHERAL(connsm) || (opcode == BLE_LL_CTRL_CONN_PARM_RSP))
+  {
     /*
-     * Check if there is a requested change to either the interval, timeout
-     * or latency. If not, this may just be an anchor point change and we do
-     * not have to notify the host.
-     *  XXX: what if we dont like the parameters? When do we check that out?
+     * Not sure what to do about the peripheral. It is possible that the
+     * current connection parameters are not the same ones as the local host
+     * has provided? Not sure what to do here. Do we need to remember what
+     * host sent us? For now, I will assume that we need to remember what
+     * the host sent us and check it out.
      */
-    indicate = 1;
-    if (opcode == BLE_LL_CTRL_CONN_PARM_REQ) {
-        if ((connsm->conn_itvl >= req->interval_min) &&
-            (connsm->conn_itvl <= req->interval_max) &&
-            (connsm->supervision_tmo == req->timeout) &&
-            (connsm->periph_latency == req->latency)) {
-            indicate = 0;
-            goto conn_parm_req_do_indicate;
-        }
-    }
+    hcu = &connsm->conn_param_req;
+    if (hcu->handle != 0)
+    {
+      if (!((req->interval_min < hcu->conn_itvl_min) ||
+            (req->interval_min > hcu->conn_itvl_max) ||
+            (req->interval_max < hcu->conn_itvl_min) ||
+            (req->interval_max > hcu->conn_itvl_max) ||
+            (req->latency != hcu->conn_latency) ||
+            (req->timeout != hcu->supervision_timeout)))
+      {
+        indicate = 0;
+      }
+    }
+  }
 
-    /*
-     * A change has been requested. Is it within the values specified by
-     * the host? Note that for a central we will not be processing a
-     * connect param request from a peripheral if we are currently trying to
-     * update the connection parameters. This means that the previous
-     * check is all we need for a central (when receiving a request).
+conn_parm_req_do_indicate:
+  /*
+   * XXX: are the connection update parameters acceptable? If not, we will
+   * need to know before we indicate to the host that they are acceptable.
+   */
+  if (indicate)
+  {
+    /* If Host masked out Remote Connection Parameter Request Event, we need to
+     * send Reject back to the remote device
      */
-    if (CONN_IS_PERIPHERAL(connsm) || (opcode == BLE_LL_CTRL_CONN_PARM_RSP)) {
-        /*
-         * Not sure what to do about the peripheral. It is possible that the
-         * current connection parameters are not the same ones as the local host
-         * has provided? Not sure what to do here. Do we need to remember what
-         * host sent us? For now, I will assume that we need to remember what
-         * the host sent us and check it out.
-         */
-        hcu = &connsm->conn_param_req;
-        if (hcu->handle != 0) {
-            if (!((req->interval_min < hcu->conn_itvl_min) ||
-                  (req->interval_min > hcu->conn_itvl_max) ||
-                  (req->interval_max < hcu->conn_itvl_min) ||
-                  (req->interval_max > hcu->conn_itvl_max) ||
-                  (req->latency != hcu->conn_latency) ||
-                  (req->timeout != hcu->supervision_timeout))) {
-                indicate = 0;
-            }
-        }
+    if (!ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ))
+    {
+      ble_err = BLE_ERR_UNSUPP_REM_FEATURE;
+      goto conn_param_pdu_exit;
     }
 
-conn_parm_req_do_indicate:
     /*
-     * XXX: are the connection update parameters acceptable? If not, we will
-     * need to know before we indicate to the host that they are acceptable.
+     * Send event to host. At this point we leave and wait to get
+     * an answer.
      */
-    if (indicate) {
-        /* If Host masked out Remote Connection Parameter Request Event, we need to
-         * send Reject back to the remote device
-         */
-        if (!ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ)){
-            ble_err = BLE_ERR_UNSUPP_REM_FEATURE;
-            goto conn_param_pdu_exit;
-        }
-
-        /*
-         * Send event to host. At this point we leave and wait to get
-         * an answer.
-         */
-        ble_ll_hci_ev_rem_conn_parm_req(connsm, req);
-        connsm->host_reply_opcode = opcode;
-        connsm->flags.conn_update_host_w4reply = 1;
-        rsp_opcode = 255;
-    } else {
-        /* Create reply to connection request */
-        rsp_opcode = ble_ll_ctrl_conn_param_reply(connsm, rspbuf, req);
-    }
+    ble_ll_hci_ev_rem_conn_parm_req(connsm, req);
+    connsm->host_reply_opcode = opcode;
+    connsm->flags.conn_update_host_w4reply = 1;
+    rsp_opcode = 255;
+  }
+  else
+  {
+    /* Create reply to connection request */
+    rsp_opcode = ble_ll_ctrl_conn_param_reply(connsm, rspbuf, req);
+  }
 
 conn_param_pdu_exit:
-    if (ble_err) {
-        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        rspbuf[1] = opcode;
-        rspbuf[2] = ble_err;
-    }
-    return rsp_opcode;
-}
-
-static void
-ble_ll_ctrl_conn_update_init_proc(struct ble_ll_conn_sm *connsm,
-                                  struct ble_ll_conn_params *cp)
-{
-    /* This only stores conn params, if any. The caller will enqueue LL Control
-     * PDU and we will calculate its contents when dequeued so we know that
-     * instant is in the future.
-     */
-
-    connsm->flags.conn_update_sched = 0;
-    connsm->flags.conn_update_use_cp = (cp != NULL);
-
-    if (cp) {
-        connsm->conn_cp = *cp;
-    }
-}
-
-static void
-ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
-                                     uint8_t *ctrdata)
-{
-    struct ble_ll_conn_params *cp = NULL;
-    struct ble_ll_conn_params offset_cp = { };
-    uint16_t instant;
-    uint32_t dt;
-    uint32_t num_old_ce;
-    uint32_t new_itvl_usecs;
-    uint32_t old_itvl_usecs;
-    struct hci_conn_update *hcu;
-    struct ble_ll_conn_upd_req *req;
-
-    if (connsm->flags.conn_update_use_cp) {
-        cp = &connsm->conn_cp;
-    }
-
-    /*
-     * Set instant. We set the instant to the current event counter plus
-     * the amount of peripheral latency as the peripheral may not be listening
-     * at every connection interval and we are not sure when the connect
-     * request will actually get sent. We add one more event plus the
-     * minimum as per the spec of 6 connection events.
-     */
+  if (ble_err)
+  {
+    rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+    rspbuf[1] = opcode;
+    rspbuf[2] = ble_err;
+  }
+  return rsp_opcode;
+}
+
+static void ble_ll_ctrl_conn_update_init_proc(struct ble_ll_conn_sm *connsm,
+                                              struct ble_ll_conn_params *cp)
+{
+  /* This only stores conn params, if any. The caller will enqueue LL Control
+   * PDU and we will calculate its contents when dequeued so we know that
+   * instant is in the future.
+   */
+
+  connsm->flags.conn_update_sched = 0;
+  connsm->flags.conn_update_use_cp = (cp != NULL);
+
+  if (cp)
+  {
+    connsm->conn_cp = *cp;
+  }
+}
+
+static void ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
+                                                 uint8_t *ctrdata)
+{
+  struct ble_ll_conn_params *cp = NULL;
+  struct ble_ll_conn_params offset_cp = {};
+  uint16_t instant;
+  uint32_t dt;
+  uint32_t num_old_ce;
+  uint32_t new_itvl_usecs;
+  uint32_t old_itvl_usecs;
+  struct hci_conn_update *hcu;
+  struct ble_ll_conn_upd_req *req;
+
+  if (connsm->flags.conn_update_use_cp)
+  {
+    cp = &connsm->conn_cp;
+  }
+
+  /*
+   * Set instant. We set the instant to the current event counter plus
+   * the amount of peripheral latency as the peripheral may not be listening
+   * at every connection interval and we are not sure when the connect
+   * request will actually get sent. We add one more event plus the
+   * minimum as per the spec of 6 connection events.
+   */
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    instant = connsm->subrate_base_event + 6 * connsm->subrate_factor *
-                                           (connsm->periph_latency + 1);
+  instant = connsm->subrate_base_event +
+            6 * connsm->subrate_factor * (connsm->periph_latency + 1);
 #else
-    instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
-#endif
-
-    /* Check if this is a move anchor request and configure proper connection
-     * parameters */
-    if (connsm->conn_update_anchor_offset_req) {
-        offset_cp.interval_min = connsm->conn_itvl;
-        offset_cp.interval_max = connsm->conn_itvl;
-        offset_cp.latency = connsm->periph_latency;
-        offset_cp.timeout = connsm->supervision_tmo;
-        offset_cp.offset0 = connsm->conn_update_anchor_offset_req;
-        connsm->conn_update_anchor_offset_req = 0;
-        cp = &offset_cp;
-    }
-
-    /*
-     * XXX: This should change in the future, but for now we will just
-     * start the new instant at the same anchor using win offset 0.
-     */
-    /* Copy parameters in connection update structure */
-    hcu = &connsm->conn_param_req;
-    req = &connsm->conn_update_req;
-    if (cp) {
-        /* XXX: so we need to make the new anchor point some time away
-         * from txwinoffset by some amount of msecs. Not sure how to do
-           that here. We dont need to, but we should. */
-        /* Calculate offset from requested offsets (if any) */
-        if (cp->offset0 != 0xFFFF) {
-            new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
-            old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
-            if ((int16_t)(cp->ref_conn_event_cnt - instant) >= 0) {
-                num_old_ce = cp->ref_conn_event_cnt - instant;
-                dt = old_itvl_usecs * num_old_ce;
-                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
-                dt = dt % new_itvl_usecs;
-            } else {
-                num_old_ce = instant - cp->ref_conn_event_cnt;
-                dt = old_itvl_usecs * num_old_ce;
-                dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
-                dt = dt % new_itvl_usecs;
-                dt = new_itvl_usecs - dt;
-            }
-            req->winoffset = dt / BLE_LL_CONN_TX_WIN_USECS;
-        } else {
-            req->winoffset = 0;
-        }
-        req->interval = cp->interval_max;
-        req->timeout = cp->timeout;
-        req->latency = cp->latency;
-        req->winsize = 1;
-    } else {
-        req->interval = hcu->conn_itvl_max;
-        req->timeout = hcu->supervision_timeout;
-        req->latency = hcu->conn_latency;
-        req->winoffset = 0;
-        req->winsize = connsm->tx_win_size;
-    }
-    req->instant = instant;
-
-    /* XXX: make sure this works for the connection parameter request proc. */
-    ctrdata[0] = req->winsize;
-    put_le16(ctrdata + 1, req->winoffset);
-    put_le16(ctrdata + 3, req->interval);
-    put_le16(ctrdata + 5, req->latency);
-    put_le16(ctrdata + 7, req->timeout);
-    put_le16(ctrdata + 9, instant);
+  instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
+#endif
+
+  /* Check if this is a move anchor request and configure proper connection
+   * parameters */
+  if (connsm->conn_update_anchor_offset_req)
+  {
+    offset_cp.interval_min = connsm->conn_itvl;
+    offset_cp.interval_max = connsm->conn_itvl;
+    offset_cp.latency = connsm->periph_latency;
+    offset_cp.timeout = connsm->supervision_tmo;
+    offset_cp.offset0 = connsm->conn_update_anchor_offset_req;
+    connsm->conn_update_anchor_offset_req = 0;
+    cp = &offset_cp;
+  }
+
+  /*
+   * XXX: This should change in the future, but for now we will just
+   * start the new instant at the same anchor using win offset 0.
+   */
+  /* Copy parameters in connection update structure */
+  hcu = &connsm->conn_param_req;
+  req = &connsm->conn_update_req;
+  if (cp)
+  {
+    /* XXX: so we need to make the new anchor point some time away
+     * from txwinoffset by some amount of msecs. Not sure how to do
+       that here. We dont need to, but we should. */
+    /* Calculate offset from requested offsets (if any) */
+    if (cp->offset0 != 0xFFFF)
+    {
+      new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
+      old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
+      if ((int16_t)(cp->ref_conn_event_cnt - instant) >= 0)
+      {
+        num_old_ce = cp->ref_conn_event_cnt - instant;
+        dt = old_itvl_usecs * num_old_ce;
+        dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
+        dt = dt % new_itvl_usecs;
+      }
+      else
+      {
+        num_old_ce = instant - cp->ref_conn_event_cnt;
+        dt = old_itvl_usecs * num_old_ce;
+        dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
+        dt = dt % new_itvl_usecs;
+        dt = new_itvl_usecs - dt;
+      }
+      req->winoffset = dt / BLE_LL_CONN_TX_WIN_USECS;
+    }
+    else
+    {
+      req->winoffset = 0;
+    }
+    req->interval = cp->interval_max;
+    req->timeout = cp->timeout;
+    req->latency = cp->latency;
+    req->winsize = 1;
+  }
+  else
+  {
+    req->interval = hcu->conn_itvl_max;
+    req->timeout = hcu->supervision_timeout;
+    req->latency = hcu->conn_latency;
+    req->winoffset = 0;
+    req->winsize = connsm->tx_win_size;
+  }
+  req->instant = instant;
+
+  /* XXX: make sure this works for the connection parameter request proc. */
+  ctrdata[0] = req->winsize;
+  put_le16(ctrdata + 1, req->winoffset);
+  put_le16(ctrdata + 3, req->interval);
+  put_le16(ctrdata + 5, req->latency);
+  put_le16(ctrdata + 7, req->timeout);
+  put_le16(ctrdata + 9, instant);
 }
 
 /**
@@ -504,81 +547,87 @@ ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
  *
  * @param dptr
  */
-static int
-ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr, uint8_t *rspdata)
-{
-    uint8_t ctrl_proc;
-    uint8_t opcode;
-
-    /* Get opcode of unknown LL control frame */
-    opcode = dptr[0];
-
-    /* Convert opcode to control procedure id */
-    switch (opcode) {
-    case BLE_LL_CTRL_LENGTH_REQ:
-        ctrl_proc = BLE_LL_CTRL_PROC_DATA_LEN_UPD;
-        BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_DATA_LEN_EXT);
-        break;
-    case BLE_LL_CTRL_CONN_UPDATE_IND:
-        ctrl_proc = BLE_LL_CTRL_PROC_CONN_UPDATE;
-        break;
-    case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
-        ctrl_proc = BLE_LL_CTRL_PROC_FEATURE_XCHG;
-        BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_PERIPH_INIT);
-        break;
-    case BLE_LL_CTRL_CONN_PARM_REQ:
-        BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_CONN_PARM_REQ);
+static int ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                    uint8_t *rspdata)
+{
+  uint8_t ctrl_proc;
+  uint8_t opcode;
+
+  /* Get opcode of unknown LL control frame */
+  opcode = dptr[0];
+
+  /* Convert opcode to control procedure id */
+  switch (opcode)
+  {
+  case BLE_LL_CTRL_LENGTH_REQ:
+    ctrl_proc = BLE_LL_CTRL_PROC_DATA_LEN_UPD;
+    BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_DATA_LEN_EXT);
+    break;
+  case BLE_LL_CTRL_CONN_UPDATE_IND:
+    ctrl_proc = BLE_LL_CTRL_PROC_CONN_UPDATE;
+    break;
+  case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
+    ctrl_proc = BLE_LL_CTRL_PROC_FEATURE_XCHG;
+    BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_PERIPH_INIT);
+    break;
+  case BLE_LL_CTRL_CONN_PARM_REQ:
+    BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_CONN_PARM_REQ);
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-        if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-            ble_ll_ctrl_conn_update_init_proc(connsm, NULL);
-            connsm->reject_reason = BLE_ERR_SUCCESS;
-            return BLE_LL_CTRL_CONN_UPDATE_IND;
-        }
-#endif
-        /* note: fall-through intentional */
-    case BLE_LL_CTRL_CONN_PARM_RSP:
-        ctrl_proc = BLE_LL_CTRL_PROC_CONN_PARAM_REQ;
-        break;
-    case BLE_LL_CTRL_PING_REQ:
-        /* LL can authenticate remote device even if remote device does not
-         * support LE Ping feature.
-         */
-        ctrl_proc = BLE_LL_CTRL_PROC_LE_PING;
-        BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_LE_PING);
-        break;
+    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL)
+    {
+      ble_ll_ctrl_conn_update_init_proc(connsm, NULL);
+      connsm->reject_reason = BLE_ERR_SUCCESS;
+      return BLE_LL_CTRL_CONN_UPDATE_IND;
+    }
+#endif
+    /* note: fall-through intentional */
+  case BLE_LL_CTRL_CONN_PARM_RSP:
+    ctrl_proc = BLE_LL_CTRL_PROC_CONN_PARAM_REQ;
+    break;
+  case BLE_LL_CTRL_PING_REQ:
+    /* LL can authenticate remote device even if remote device does not
+     * support LE Ping feature.
+     */
+    ctrl_proc = BLE_LL_CTRL_PROC_LE_PING;
+    BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_LE_PING);
+    break;
 #if MYNEWT_VAL(BLE_LL_PHY)
-    case BLE_LL_CTRL_PHY_REQ:
-        ble_ll_ctrl_phy_update_cancel(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
-        ctrl_proc = BLE_LL_CTRL_PROC_PHY_UPDATE;
-        break;
+  case BLE_LL_CTRL_PHY_REQ:
+    ble_ll_ctrl_phy_update_cancel(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
+    ctrl_proc = BLE_LL_CTRL_PROC_PHY_UPDATE;
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-    case BLE_LL_CTRL_CLOCK_ACCURACY_REQ:
-        ble_ll_hci_ev_sca_update(connsm, BLE_ERR_UNSUPPORTED, 0);
-        ctrl_proc = BLE_LL_CTRL_PROC_SCA_UPDATE;
-        break;
-#endif
-    default:
-        ctrl_proc = BLE_LL_CTRL_PROC_NUM;
-        break;
+  case BLE_LL_CTRL_CLOCK_ACCURACY_REQ:
+    ble_ll_hci_ev_sca_update(connsm, BLE_ERR_UNSUPPORTED, 0);
+    ctrl_proc = BLE_LL_CTRL_PROC_SCA_UPDATE;
+    break;
+#endif
+  default:
+    ctrl_proc = BLE_LL_CTRL_PROC_NUM;
+    break;
+  }
+
+  /* If we are running this one currently, stop it */
+  if (connsm->cur_ctrl_proc == ctrl_proc)
+  {
+    /* Stop the control procedure */
+    ble_ll_ctrl_proc_stop(connsm, ctrl_proc);
+    if (ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ)
+    {
+      ble_ll_hci_ev_conn_update(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
     }
-
-    /* If we are running this one currently, stop it */
-    if (connsm->cur_ctrl_proc == ctrl_proc) {
-        /* Stop the control procedure */
-        ble_ll_ctrl_proc_stop(connsm, ctrl_proc);
-        if (ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ) {
-            ble_ll_hci_ev_conn_update(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
-        } else if (ctrl_proc == BLE_LL_CTRL_PROC_FEATURE_XCHG) {
-            if (connsm->flags.features_host_req) {
-                ble_ll_hci_ev_rd_rem_used_feat(connsm,
-                                                   BLE_ERR_UNSUPP_REM_FEATURE);
-            }
-            connsm->flags.features_host_req = 0;
-        }
+    else if (ctrl_proc == BLE_LL_CTRL_PROC_FEATURE_XCHG)
+    {
+      if (connsm->flags.features_host_req)
+      {
+        ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
+      }
+      connsm->flags.features_host_req = 0;
     }
+  }
 
-    return BLE_ERR_MAX;
+  return BLE_ERR_MAX;
 }
 
 /**
@@ -590,20 +639,18 @@ ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr, uint8_t *
  *
  * @param arg Pointer to connection state machine.
  */
-static void
-ble_ll_ctrl_proc_rsp_timer_cb(struct ble_npl_event *ev)
+static void ble_ll_ctrl_proc_rsp_timer_cb(struct ble_npl_event *ev)
 {
-    /* Control procedure has timed out. Kill the connection */
-    ble_ll_conn_timeout((struct ble_ll_conn_sm *)ble_npl_event_get_arg(ev),
-                        BLE_ERR_LMP_LL_RSP_TMO);
+  /* Control procedure has timed out. Kill the connection */
+  ble_ll_conn_timeout((struct ble_ll_conn_sm *)ble_npl_event_get_arg(ev),
+                      BLE_ERR_LMP_LL_RSP_TMO);
 }
 
-static void
-ble_ll_ctrl_start_rsp_timer(struct ble_ll_conn_sm *connsm)
+static void ble_ll_ctrl_start_rsp_timer(struct ble_ll_conn_sm *connsm)
 {
-    /* Re-start timer. Control procedure timeout is 40 seconds */
-    ble_npl_callout_reset(&connsm->ctrl_proc_rsp_timer,
-                     ble_npl_time_ms_to_ticks32(BLE_LL_CTRL_PROC_TIMEOUT_MS));
+  /* Re-start timer. Control procedure timeout is 40 seconds */
+  ble_npl_callout_reset(&connsm->ctrl_proc_rsp_timer,
+                        ble_npl_time_ms_to_ticks32(BLE_LL_CTRL_PROC_TIMEOUT_MS));
 }
 
 /**
@@ -620,100 +667,122 @@ ble_ll_ctrl_start_rsp_timer(struct ble_ll_conn_sm *connsm)
  * BLE_HCI_LE_PHY_2M                    (2)
  * BLE_HCI_LE_PHY_CODED                 (3)
  */
-uint8_t
-ble_ll_ctrl_phy_from_phy_mask(uint8_t phy_mask)
+uint8_t ble_ll_ctrl_phy_from_phy_mask(uint8_t phy_mask)
 {
-    uint8_t phy;
+  uint8_t phy;
 
-    /*
-     * NOTE: wipe out unsupported PHYs. There should not be an unsupported
-     * in this mask if the other side is working correctly.
-     */
+  /*
+   * NOTE: wipe out unsupported PHYs. There should not be an unsupported
+   * in this mask if the other side is working correctly.
+   */
 #if !MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_2M_PHY)
-    phy_mask &= ~BLE_HCI_LE_PHY_2M_PREF_MASK;
+  phy_mask &= ~BLE_HCI_LE_PHY_2M_PREF_MASK;
 #endif
 #if !MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-    phy_mask &= ~BLE_HCI_LE_PHY_CODED_PREF_MASK;
-#endif
-
-    if (phy_mask & BLE_PHY_MASK_1M) {
-        phy = BLE_PHY_1M;
-        phy_mask &= ~BLE_PHY_MASK_1M;
-    } else if (phy_mask & BLE_PHY_MASK_2M) {
-        phy = BLE_PHY_2M;
-        phy_mask &= ~BLE_PHY_MASK_2M;
-    } else if (phy_mask & BLE_PHY_MASK_CODED) {
-        phy = BLE_PHY_CODED;
-        phy_mask &= ~BLE_PHY_MASK_CODED;
-    } else {
-        phy = 0;
-    }
-
-    if (phy_mask != 0) {
-        phy = 0;
-    }
-
-    return phy;
+  phy_mask &= ~BLE_HCI_LE_PHY_CODED_PREF_MASK;
+#endif
+
+  if (phy_mask & BLE_PHY_MASK_1M)
+  {
+    phy = BLE_PHY_1M;
+    phy_mask &= ~BLE_PHY_MASK_1M;
+  }
+  else if (phy_mask & BLE_PHY_MASK_2M)
+  {
+    phy = BLE_PHY_2M;
+    phy_mask &= ~BLE_PHY_MASK_2M;
+  }
+  else if (phy_mask & BLE_PHY_MASK_CODED)
+  {
+    phy = BLE_PHY_CODED;
+    phy_mask &= ~BLE_PHY_MASK_CODED;
+  }
+  else
+  {
+    phy = 0;
+  }
+
+  if (phy_mask != 0)
+  {
+    phy = 0;
+  }
+
+  return phy;
 }
 
 #if MYNEWT_VAL(BLE_LL_PHY)
-uint8_t
-ble_ll_ctrl_phy_tx_transition_get(uint8_t phy_mask)
-{
-    /*
-     * Evaluate PHYs in transition starting from the one with longest TX time
-     * so we select the one that allows shortest payload to be sent. This is
-     * to make sure we do not violate timing restriction on new PHY.
-     */
-    if (phy_mask & BLE_PHY_MASK_CODED) {
-        return BLE_PHY_CODED;
-    } else if (phy_mask & BLE_PHY_MASK_1M) {
-        return BLE_PHY_1M;
-    } else if (phy_mask & BLE_PHY_MASK_2M) {
-        return BLE_PHY_2M;
-    }
-
-    return 0;
-}
-
-void
-ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm)
-{
-    int chk_proc_stop;
-    int chk_host_phy;
-
-    chk_proc_stop = 1;
-    chk_host_phy = 1;
-
-    connsm->phy_tx_transition = 0;
-
-    if (connsm->flags.phy_update_peer_initiated) {
-        connsm->flags.phy_update_peer_initiated = 0;
-    } else if (connsm->flags.phy_update_self_initiated) {
-        connsm->flags.phy_update_self_initiated = 0;
-    } else {
-        /* Must be a host-initiated update */
+uint8_t ble_ll_ctrl_phy_tx_transition_get(uint8_t phy_mask)
+{
+  /*
+   * Evaluate PHYs in transition starting from the one with longest TX time
+   * so we select the one that allows shortest payload to be sent. This is
+   * to make sure we do not violate timing restriction on new PHY.
+   */
+  if (phy_mask & BLE_PHY_MASK_CODED)
+  {
+    return BLE_PHY_CODED;
+  }
+  else if (phy_mask & BLE_PHY_MASK_1M)
+  {
+    return BLE_PHY_1M;
+  }
+  else if (phy_mask & BLE_PHY_MASK_2M)
+  {
+    return BLE_PHY_2M;
+  }
+
+  return 0;
+}
+
+void ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm)
+{
+  int chk_proc_stop;
+  int chk_host_phy;
+
+  chk_proc_stop = 1;
+  chk_host_phy = 1;
+
+  connsm->phy_tx_transition = 0;
+
+  if (connsm->flags.phy_update_peer_initiated)
+  {
+    connsm->flags.phy_update_peer_initiated = 0;
+  }
+  else if (connsm->flags.phy_update_self_initiated)
+  {
+    connsm->flags.phy_update_self_initiated = 0;
+  }
+  else
+  {
+    /* Must be a host-initiated update */
+    connsm->flags.phy_update_host_initiated = 0;
+    chk_host_phy = 0;
+    if (connsm->flags.phy_update_host_w4event == 0)
+    {
+      ble_ll_hci_ev_phy_update(connsm, BLE_ERR_SUCCESS);
+    }
+  }
+
+  /* Must check if we need to start host procedure */
+  if (chk_host_phy)
+  {
+    if (connsm->flags.phy_update_host_initiated)
+    {
+      if (ble_ll_conn_phy_update_if_needed(connsm))
+      {
         connsm->flags.phy_update_host_initiated = 0;
-        chk_host_phy = 0;
-        if (connsm->flags.phy_update_host_w4event == 0) {
-            ble_ll_hci_ev_phy_update(connsm, BLE_ERR_SUCCESS);
-        }
-    }
-
-    /* Must check if we need to start host procedure */
-    if (chk_host_phy) {
-        if (connsm->flags.phy_update_host_initiated) {
-            if (ble_ll_conn_phy_update_if_needed(connsm)) {
-                connsm->flags.phy_update_host_initiated = 0;
-            } else {
-                chk_proc_stop = 0;
-            }
-        }
+      }
+      else
+      {
+        chk_proc_stop = 0;
+      }
     }
+  }
 
-    if (chk_proc_stop) {
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
-    }
+  if (chk_proc_stop)
+  {
+    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+  }
 }
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
@@ -729,23 +798,28 @@ ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm)
  * @param prefs The mask of preferred phys
  * @return uint8_t The phy to use (not a mask)
  */
-static uint8_t
-ble_ll_ctrl_find_new_phy(uint8_t phy_mask_prefs)
-{
-    uint8_t new_phy;
-
-    new_phy = phy_mask_prefs;
-    if (new_phy) {
-        if (new_phy & BLE_PHY_MASK_2M) {
-            new_phy = BLE_PHY_2M;
-        } else if (new_phy & BLE_PHY_MASK_1M) {
-            new_phy = BLE_PHY_1M;
-        } else {
-            new_phy = BLE_PHY_CODED;
-        }
+static uint8_t ble_ll_ctrl_find_new_phy(uint8_t phy_mask_prefs)
+{
+  uint8_t new_phy;
+
+  new_phy = phy_mask_prefs;
+  if (new_phy)
+  {
+    if (new_phy & BLE_PHY_MASK_2M)
+    {
+      new_phy = BLE_PHY_2M;
+    }
+    else if (new_phy & BLE_PHY_MASK_1M)
+    {
+      new_phy = BLE_PHY_1M;
     }
+    else
+    {
+      new_phy = BLE_PHY_CODED;
+    }
+  }
 
-    return new_phy;
+  return new_phy;
 }
 
 /**
@@ -757,129 +831,151 @@ ble_ll_ctrl_find_new_phy(uint8_t phy_mask_prefs)
  * @param periph_req flag denoting if peripheral requested this. 0: no 1:yes
  */
 
-static void
-ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                                uint8_t *ctrdata, int periph_req)
+static void ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                            uint8_t *ctrdata, int periph_req)
 {
-    uint8_t m_to_s;
-    uint8_t s_to_m;
-    uint8_t tx_phys;
-    uint8_t rx_phys;
-    uint8_t is_periph_sym = 0;
+  uint8_t m_to_s;
+  uint8_t s_to_m;
+  uint8_t tx_phys;
+  uint8_t rx_phys;
+  uint8_t is_periph_sym = 0;
 
-    /* Get preferences from PDU */
-    tx_phys = dptr[0];
-    rx_phys = dptr[1];
+  /* Get preferences from PDU */
+  tx_phys = dptr[0];
+  rx_phys = dptr[1];
 
-    /* If we are central, check if peripheral requested symmetric PHY */
+  /* If we are central, check if peripheral requested symmetric PHY */
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        is_periph_sym = tx_phys == rx_phys;
-        is_periph_sym &= __builtin_popcount(tx_phys) == 1;
-    }
-#endif
-
-    /* Get m_to_s and s_to_m masks */
-    if (periph_req) {
-        m_to_s = connsm->phy_data.pref_mask_tx & rx_phys;
-        s_to_m = connsm->phy_data.pref_mask_rx & tx_phys;
-    } else {
-        m_to_s = connsm->phy_data.pref_mask_tx_req & rx_phys;
-        s_to_m = connsm->phy_data.pref_mask_rx_req & tx_phys;
-    }
-
-    if (is_periph_sym) {
-        /*
-         * If either s_to_m or m_to_s is 0, it means for at least one direction
-         * requested PHY is not our preferred one so make sure we keep current
-         * PHY in both directions
-         *
-         * Core 5.2, Vol 6, PartB, 5.1.10
-         *     If the peripheral specified a single PHY in both the TX_PHYS and
-         *     RX_PHYS fields and both fields are the same, the central shall
-         *     either select the PHY specified by the peripheral for both directions
-         *     or shall leave both directions unchanged.
-         */
-        if ((s_to_m == 0) || (m_to_s == 0)) {
-            s_to_m = 0;
-            m_to_s = 0;
-        } else {
-            BLE_LL_ASSERT(s_to_m == m_to_s);
-        }
-    }
-
-    /* Calculate new PHYs to use */
-    m_to_s = ble_ll_ctrl_find_new_phy(m_to_s);
-    s_to_m = ble_ll_ctrl_find_new_phy(s_to_m);
-
-    /* Make sure we do not indicate PHY change if the same as current one */
-    if (m_to_s == connsm->phy_data.cur_tx_phy) {
-        m_to_s = 0;
-    }
-    if (s_to_m == connsm->phy_data.cur_rx_phy) {
-        s_to_m = 0;
-    }
-
-    /* At this point, m_to_s and s_to_m are not masks; they are numeric */
-
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL)
+  {
+    is_periph_sym = tx_phys == rx_phys;
+    is_periph_sym &= __builtin_popcount(tx_phys) == 1;
+  }
+#endif
+
+  /* Get m_to_s and s_to_m masks */
+  if (periph_req)
+  {
+    m_to_s = connsm->phy_data.pref_mask_tx & rx_phys;
+    s_to_m = connsm->phy_data.pref_mask_rx & tx_phys;
+  }
+  else
+  {
+    m_to_s = connsm->phy_data.pref_mask_tx_req & rx_phys;
+    s_to_m = connsm->phy_data.pref_mask_rx_req & tx_phys;
+  }
+
+  if (is_periph_sym)
+  {
     /*
-     * If not changing we still send update ind. Check if hosts expects
-     * the event and if so send it. Stop control procedure if it is the
-     * one running.
+     * If either s_to_m or m_to_s is 0, it means for at least one direction
+     * requested PHY is not our preferred one so make sure we keep current
+     * PHY in both directions
+     *
+     * Core 5.2, Vol 6, PartB, 5.1.10
+     *     If the peripheral specified a single PHY in both the TX_PHYS and
+     *     RX_PHYS fields and both fields are the same, the central shall
+     *     either select the PHY specified by the peripheral for both directions
+     *     or shall leave both directions unchanged.
      */
-    if ((m_to_s == 0) && (s_to_m == 0)) {
-        if (connsm->flags.phy_update_peer_initiated) {
-            connsm->flags.phy_update_peer_initiated = 0;
-        } else if (connsm->flags.phy_update_self_initiated) {
-            connsm->flags.phy_update_self_initiated = 0;
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
-        } else {
-            ble_ll_hci_ev_phy_update(connsm, BLE_ERR_SUCCESS);
-            connsm->flags.phy_update_host_initiated = 0;
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
-        }
-    } else {
-        /* Set new phys to use when instant occurs */
-        connsm->phy_data.new_tx_phy = m_to_s;
-        connsm->phy_data.new_rx_phy = s_to_m;
-
-        /* Convert m_to_s and s_to_m to masks */
-        if (m_to_s) {
-            m_to_s = 1 << (m_to_s - 1);
-        }
-
-        if (s_to_m) {
-            s_to_m = 1 << (s_to_m - 1);
-        }
-    }
-
-    ctrdata[0] = m_to_s;
-    ctrdata[1] = s_to_m;
-}
-
-static bool
-ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
-{
-    uint16_t instant;
-    uint8_t m_to_s;
-    uint8_t s_to_m;
-    bool schedule = false;
-
-    m_to_s = ctrdata[0];
-    s_to_m = ctrdata[1];
-
-    if ((m_to_s == 0) && (s_to_m == 0)) {
-        instant = 0;
-    } else {
-        /* Determine instant we will use. 6 more is minimum */
-        instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
-        connsm->phy_instant = instant;
-        schedule = true;
-    }
+    if ((s_to_m == 0) || (m_to_s == 0))
+    {
+      s_to_m = 0;
+      m_to_s = 0;
+    }
+    else
+    {
+      BLE_LL_ASSERT(s_to_m == m_to_s);
+    }
+  }
+
+  /* Calculate new PHYs to use */
+  m_to_s = ble_ll_ctrl_find_new_phy(m_to_s);
+  s_to_m = ble_ll_ctrl_find_new_phy(s_to_m);
+
+  /* Make sure we do not indicate PHY change if the same as current one */
+  if (m_to_s == connsm->phy_data.cur_tx_phy)
+  {
+    m_to_s = 0;
+  }
+  if (s_to_m == connsm->phy_data.cur_rx_phy)
+  {
+    s_to_m = 0;
+  }
+
+  /* At this point, m_to_s and s_to_m are not masks; they are numeric */
+
+  /*
+   * If not changing we still send update ind. Check if hosts expects
+   * the event and if so send it. Stop control procedure if it is the
+   * one running.
+   */
+  if ((m_to_s == 0) && (s_to_m == 0))
+  {
+    if (connsm->flags.phy_update_peer_initiated)
+    {
+      connsm->flags.phy_update_peer_initiated = 0;
+    }
+    else if (connsm->flags.phy_update_self_initiated)
+    {
+      connsm->flags.phy_update_self_initiated = 0;
+      ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+    }
+    else
+    {
+      ble_ll_hci_ev_phy_update(connsm, BLE_ERR_SUCCESS);
+      connsm->flags.phy_update_host_initiated = 0;
+      ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+    }
+  }
+  else
+  {
+    /* Set new phys to use when instant occurs */
+    connsm->phy_data.new_tx_phy = m_to_s;
+    connsm->phy_data.new_rx_phy = s_to_m;
+
+    /* Convert m_to_s and s_to_m to masks */
+    if (m_to_s)
+    {
+      m_to_s = 1 << (m_to_s - 1);
+    }
+
+    if (s_to_m)
+    {
+      s_to_m = 1 << (s_to_m - 1);
+    }
+  }
+
+  ctrdata[0] = m_to_s;
+  ctrdata[1] = s_to_m;
+}
+
+static bool ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm *connsm,
+                                               uint8_t *ctrdata)
+{
+  uint16_t instant;
+  uint8_t m_to_s;
+  uint8_t s_to_m;
+  bool schedule = false;
+
+  m_to_s = ctrdata[0];
+  s_to_m = ctrdata[1];
+
+  if ((m_to_s == 0) && (s_to_m == 0))
+  {
+    instant = 0;
+  }
+  else
+  {
+    /* Determine instant we will use. 6 more is minimum */
+    instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
+    connsm->phy_instant = instant;
+    schedule = true;
+  }
 
-    put_le16(ctrdata + 2, instant);
+  put_le16(ctrdata + 2, instant);
 
-    return schedule;
+  return schedule;
 }
 #endif
 
@@ -889,11 +985,10 @@ ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm *connsm, uint8_t *ctrda
  * @param connsm Pointer to connection state machine
  * @param ctrdata: Pointer to where CtrData starts in pdu
  */
-static void
-ble_ll_ctrl_phy_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
+static void ble_ll_ctrl_phy_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
 {
-    ctrdata[0] = connsm->phy_data.pref_mask_tx;
-    ctrdata[1] = connsm->phy_data.pref_mask_rx;
+  ctrdata[0] = connsm->phy_data.pref_mask_tx;
+  ctrdata[1] = connsm->phy_data.pref_mask_rx;
 }
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
@@ -903,84 +998,87 @@ ble_ll_ctrl_phy_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
  * @param connsm Pointer to connection state machine
  * @param ctrdata: Pointer to where CtrData starts in pdu
  */
-static void
-ble_ll_ctrl_sca_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
+static void ble_ll_ctrl_sca_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
 {
-    ctrdata[0] = BLE_LL_SCA_ENUM;
+  ctrdata[0] = BLE_LL_SCA_ENUM;
 }
 #endif
 
-static uint8_t
-ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
-                       uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
+                                      uint8_t *rsp)
 {
-    uint8_t rsp_opcode;
-    uint8_t err;
+  uint8_t rsp_opcode;
+  uint8_t err;
 
-    /*
-     * XXX: TODO if we have an instant in progress we should end connection.
-     * At least it seems that is the case. Need to figure out more from
-     * the spec here.
-     */
+  /*
+   * XXX: TODO if we have an instant in progress we should end connection.
+   * At least it seems that is the case. Need to figure out more from
+   * the spec here.
+   */
 
-    /* Check if we have already initiated a procedure with an instant */
-    err = ble_ll_ctrl_proc_with_instant_initiated(connsm,
-                                                  BLE_LL_CTRL_PROC_PHY_UPDATE);
+  /* Check if we have already initiated a procedure with an instant */
+  err = ble_ll_ctrl_proc_with_instant_initiated(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
 
-    switch (connsm->conn_role) {
+  switch (connsm->conn_role)
+  {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        if (err) {
-            ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_PHY_REQ, err, rsp);
-            rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        } else {
-            /*
-             * NOTE: do not change order of these two lines as the call to
-             * make the LL_PHY_UPDATE_IND pdu might clear the flag.
-             */
-            connsm->flags.phy_update_peer_initiated = 1;
-            ble_ll_ctrl_phy_update_ind_make(connsm, req, rsp, 1);
-            rsp_opcode = BLE_LL_CTRL_PHY_UPDATE_IND;
-        }
-        break;
+  case BLE_LL_CONN_ROLE_CENTRAL:
+    if (err)
+    {
+      ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_PHY_REQ, err, rsp);
+      rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+    }
+    else
+    {
+      /*
+       * NOTE: do not change order of these two lines as the call to
+       * make the LL_PHY_UPDATE_IND pdu might clear the flag.
+       */
+      connsm->flags.phy_update_peer_initiated = 1;
+      ble_ll_ctrl_phy_update_ind_make(connsm, req, rsp, 1);
+      rsp_opcode = BLE_LL_CTRL_PHY_UPDATE_IND;
+    }
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        /* XXX: deal with other control procedures that we need to stop */
-        if (err) {
-            if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE) {
-                ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
-                connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
-            }
-
-            /* If there is a PHY update procedure pending cancel it */
-            ble_ll_ctrl_phy_update_cancel(connsm, err);
-
-            /* XXX: ? Should not be any phy update events */
-            connsm->flags.phy_update_host_w4event = 0;
-        }
+  case BLE_LL_CONN_ROLE_PERIPHERAL:
+    /* XXX: deal with other control procedures that we need to stop */
+    if (err)
+    {
+      if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE)
+      {
+        ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
+        connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
+      }
 
-        /* XXX: TODO: if we started another procedure with an instant
-         * why are we doing this? Need to look into this.*/
+      /* If there is a PHY update procedure pending cancel it */
+      ble_ll_ctrl_phy_update_cancel(connsm, err);
 
-        /* Respond to central's phy update procedure */
-        connsm->flags.phy_update_peer_initiated = 1;
-        ble_ll_ctrl_phy_req_rsp_make(connsm, rsp);
-        rsp_opcode = BLE_LL_CTRL_PHY_RSP;
+      /* XXX: ? Should not be any phy update events */
+      connsm->flags.phy_update_host_w4event = 0;
+    }
 
-        connsm->phy_tx_transition = ble_ll_ctrl_phy_tx_transition_get(req[1] | rsp[0]);
+    /* XXX: TODO: if we started another procedure with an instant
+     * why are we doing this? Need to look into this.*/
 
-        /* Start response timer */
-        connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_PHY_UPDATE;
-        ble_ll_ctrl_start_rsp_timer(connsm);
-        break;
+    /* Respond to central's phy update procedure */
+    connsm->flags.phy_update_peer_initiated = 1;
+    ble_ll_ctrl_phy_req_rsp_make(connsm, rsp);
+    rsp_opcode = BLE_LL_CTRL_PHY_RSP;
+
+    connsm->phy_tx_transition = ble_ll_ctrl_phy_tx_transition_get(req[1] | rsp[0]);
+
+    /* Start response timer */
+    connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_PHY_UPDATE;
+    ble_ll_ctrl_start_rsp_timer(connsm);
+    break;
 #endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
+  default:
+    BLE_LL_ASSERT(0);
+    break;
+  }
 
-    return rsp_opcode;
+  return rsp_opcode;
 }
 
 /**
@@ -992,44 +1090,45 @@ ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_phy_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                       uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_phy_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                      uint8_t *rsp)
 {
-    uint8_t rsp_opcode;
+  uint8_t rsp_opcode;
 
-    rsp_opcode = BLE_ERR_MAX;
+  rsp_opcode = BLE_ERR_MAX;
 
-    switch (connsm->conn_role) {
+  switch (connsm->conn_role)
+  {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE) {
-            ble_ll_ctrl_phy_update_ind_make(connsm, dptr, rsp, 0);
-            ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
-            rsp_opcode = BLE_LL_CTRL_PHY_UPDATE_IND;
-        }
+  case BLE_LL_CONN_ROLE_CENTRAL:
+    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE)
+    {
+      ble_ll_ctrl_phy_update_ind_make(connsm, dptr, rsp, 0);
+      ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
+      rsp_opcode = BLE_LL_CTRL_PHY_UPDATE_IND;
+    }
 
-        /*
-         * If not in the process of doing this control procedure something
-         * is wrong. End connection? Assert?
-         *
-         * XXX: TODO count some stat?
-         */
-        break;
+    /*
+     * If not in the process of doing this control procedure something
+     * is wrong. End connection? Assert?
+     *
+     * XXX: TODO count some stat?
+     */
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-        break;
+  case BLE_LL_CONN_ROLE_PERIPHERAL:
+    rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
+    break;
 #endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
+  default:
+    BLE_LL_ASSERT(0);
+    break;
+  }
 
-    /* NOTE: peripheral should never receive one of these */
+  /* NOTE: peripheral should never receive one of these */
 
-    return rsp_opcode;
+  return rsp_opcode;
 }
 
 /**
@@ -1042,82 +1141,92 @@ ble_ll_ctrl_rx_phy_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static uint8_t ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    int no_change;
-    uint8_t new_m_to_s_mask;
-    uint8_t new_s_to_m_mask;
-    uint8_t new_tx_phy;
-    uint8_t new_rx_phy;
-    uint16_t instant;
-    uint16_t delta;
+  int no_change;
+  uint8_t new_m_to_s_mask;
+  uint8_t new_s_to_m_mask;
+  uint8_t new_tx_phy;
+  uint8_t new_rx_phy;
+  uint16_t instant;
+  uint16_t delta;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
-#endif
-
-    /*
-     * Reception stops the procedure response timer but does not
-     * complete the procedure
-     */
-    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE) {
-        ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
-    }
-
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL)
+  {
+    return BLE_LL_CTRL_UNKNOWN_RSP;
+  }
+#endif
+
+  /*
+   * Reception stops the procedure response timer but does not
+   * complete the procedure
+   */
+  if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE)
+  {
+    ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
+  }
+
+  /*
+   * XXX: Should we check to see if we are expecting to receive one
+   * of these, and if not, kill connection? Meaning we better be
+   * doing either a PEER, CTRLR, or HOST phy update.
+   */
+  /* get the new phy masks and see if we need to change */
+  new_m_to_s_mask = dptr[0];
+  new_s_to_m_mask = dptr[1];
+  instant = get_le16(dptr + 2);
+
+  if ((new_m_to_s_mask == 0) && (new_s_to_m_mask == 0))
+  {
+    /* No change in phy */
+    no_change = 1;
+  }
+  else
+  {
+    no_change = 0;
     /*
-     * XXX: Should we check to see if we are expecting to receive one
-     * of these, and if not, kill connection? Meaning we better be
-     * doing either a PEER, CTRLR, or HOST phy update.
+     * NOTE: from the peripherals perspective, the m to s phy is the one
+     * that the peripheral will receive on; s to m is the one it will
+     * transmit on
      */
-    /* get the new phy masks and see if we need to change */
-    new_m_to_s_mask = dptr[0];
-    new_s_to_m_mask = dptr[1];
-    instant = get_le16(dptr + 2);
-
-    if ((new_m_to_s_mask == 0) && (new_s_to_m_mask == 0)) {
-        /* No change in phy */
-        no_change = 1;
-    } else {
-        no_change = 0;
-        /*
-         * NOTE: from the peripherals perspective, the m to s phy is the one
-         * that the peripheral will receive on; s to m is the one it will
-         * transmit on
-         */
-        new_rx_phy = ble_ll_ctrl_phy_from_phy_mask(new_m_to_s_mask);
-        new_tx_phy = ble_ll_ctrl_phy_from_phy_mask(new_s_to_m_mask);
+    new_rx_phy = ble_ll_ctrl_phy_from_phy_mask(new_m_to_s_mask);
+    new_tx_phy = ble_ll_ctrl_phy_from_phy_mask(new_s_to_m_mask);
 
-        if ((new_tx_phy == 0) && (new_rx_phy == 0)) {
-            /* XXX: this is an error! What to do??? */
-            no_change = 1;
-        }
+    if ((new_tx_phy == 0) && (new_rx_phy == 0))
+    {
+      /* XXX: this is an error! What to do??? */
+      no_change = 1;
+    }
 
-        if ((new_tx_phy == connsm->phy_data.cur_tx_phy) &&
-            (new_rx_phy == connsm->phy_data.cur_rx_phy)) {
-            no_change = 1;
-        }
+    if ((new_tx_phy == connsm->phy_data.cur_tx_phy) &&
+        (new_rx_phy == connsm->phy_data.cur_rx_phy))
+    {
+      no_change = 1;
     }
+  }
 
-    if (!no_change) {
-        /* If instant is in the past, we have to end the connection */
-        delta = (instant - connsm->event_cntr) & 0xFFFF;
-        if (delta >= 32767) {
-            ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
-        } else {
-            connsm->phy_data.new_tx_phy = new_tx_phy;
-            connsm->phy_data.new_rx_phy = new_rx_phy;
-            connsm->phy_instant = instant;
-            connsm->flags.phy_update_sched = 1;
-        }
-        return BLE_ERR_MAX;
+  if (!no_change)
+  {
+    /* If instant is in the past, we have to end the connection */
+    delta = (instant - connsm->event_cntr) & 0xFFFF;
+    if (delta >= 32767)
+    {
+      ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
+    }
+    else
+    {
+      connsm->phy_data.new_tx_phy = new_tx_phy;
+      connsm->phy_data.new_rx_phy = new_rx_phy;
+      connsm->phy_instant = instant;
+      connsm->flags.phy_update_sched = 1;
     }
+    return BLE_ERR_MAX;
+  }
 
-    ble_ll_ctrl_phy_update_proc_complete(connsm);
+  ble_ll_ctrl_phy_update_proc_complete(connsm);
 
-    return BLE_ERR_MAX;
+  return BLE_ERR_MAX;
 }
 #endif
 
@@ -1130,15 +1239,16 @@ ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_periodic_sync_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static uint8_t ble_ll_ctrl_rx_periodic_sync_ind(struct ble_ll_conn_sm *connsm,
+                                                uint8_t *dptr)
 {
-    if (connsm->sync_transfer_mode) {
-        ble_ll_sync_periodic_ind(connsm, dptr, connsm->sync_transfer_mode == 1,
-                                 connsm->sync_transfer_skip,
-                                 connsm->sync_transfer_sync_timeout);
-    }
-    return BLE_ERR_MAX;
+  if (connsm->sync_transfer_mode)
+  {
+    ble_ll_sync_periodic_ind(connsm, dptr, connsm->sync_transfer_mode == 1,
+                             connsm->sync_transfer_skip,
+                             connsm->sync_transfer_sync_timeout);
+  }
+  return BLE_ERR_MAX;
 }
 #endif
 
@@ -1152,17 +1262,17 @@ ble_ll_ctrl_rx_periodic_sync_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_sca_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                       uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_sca_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                      uint8_t *rsp)
 {
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-        connsm->central_sca = dptr[0];
-    }
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL)
+  {
+    connsm->central_sca = dptr[0];
+  }
 
-    ble_ll_ctrl_sca_req_rsp_make(connsm, rsp);
+  ble_ll_ctrl_sca_req_rsp_make(connsm, rsp);
 
-    return BLE_LL_CTRL_CLOCK_ACCURACY_RSP;
+  return BLE_LL_CTRL_CLOCK_ACCURACY_RSP;
 }
 
 /**
@@ -1173,143 +1283,151 @@ ble_ll_ctrl_rx_sca_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_sca_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static uint8_t ble_ll_ctrl_rx_sca_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    if (connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_SCA_UPDATE) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+  if (connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_SCA_UPDATE)
+  {
+    return BLE_LL_CTRL_UNKNOWN_RSP;
+  }
 
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-        connsm->central_sca = dptr[0];
-    }
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL)
+  {
+    connsm->central_sca = dptr[0];
+  }
 
-    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SCA_UPDATE);
-    ble_ll_hci_ev_sca_update(connsm, BLE_ERR_SUCCESS, dptr[0]);
+  ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SCA_UPDATE);
+  ble_ll_hci_ev_sca_update(connsm, BLE_ERR_SUCCESS, dptr[0]);
 
-    return BLE_ERR_MAX;
+  return BLE_ERR_MAX;
 }
 
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-static void
-ble_ll_ctrl_subrate_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
-                             struct ble_ll_conn_subrate_req_params *srp)
+static void ble_ll_ctrl_subrate_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
+                                         struct ble_ll_conn_subrate_req_params *srp)
 {
-    put_le16(pyld + 0, srp->subrate_min);
-    put_le16(pyld + 2, srp->subrate_max);
-    put_le16(pyld + 4, srp->max_latency);
-    put_le16(pyld + 6, srp->cont_num);
-    put_le16(pyld + 8, srp->supervision_tmo);
+  put_le16(pyld + 0, srp->subrate_min);
+  put_le16(pyld + 2, srp->subrate_max);
+  put_le16(pyld + 4, srp->max_latency);
+  put_le16(pyld + 6, srp->cont_num);
+  put_le16(pyld + 8, srp->supervision_tmo);
 }
 
-static void
-ble_ll_ctrl_subrate_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
-                             struct ble_ll_conn_subrate_params *sp)
+static void ble_ll_ctrl_subrate_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
+                                         struct ble_ll_conn_subrate_params *sp)
 {
-    put_le16(pyld + 0, sp->subrate_factor);
-    put_le16(pyld + 2, sp->subrate_base_event);
-    put_le16(pyld + 4, sp->periph_latency);
-    put_le16(pyld + 6, sp->cont_num);
-    put_le16(pyld + 8, sp->supervision_tmo);
+  put_le16(pyld + 0, sp->subrate_factor);
+  put_le16(pyld + 2, sp->subrate_base_event);
+  put_le16(pyld + 4, sp->periph_latency);
+  put_le16(pyld + 6, sp->cont_num);
+  put_le16(pyld + 8, sp->supervision_tmo);
 }
 
-static uint8_t
-ble_ll_ctrl_rx_subrate_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
-                           uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_subrate_req(struct ble_ll_conn_sm *connsm,
+                                          uint8_t *req, uint8_t *rsp)
 {
-    struct ble_ll_conn_subrate_req_params params;
-    struct ble_ll_conn_subrate_req_params *srp = &params;
-    uint8_t err;
-    int rc;
+  struct ble_ll_conn_subrate_req_params params;
+  struct ble_ll_conn_subrate_req_params *srp = &params;
+  uint8_t err;
+  int rc;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL)
+  {
+    return BLE_LL_CTRL_UNKNOWN_RSP;
+  }
 #endif
 
-    if ((ble_ll_read_supp_features() & BLE_LL_FEAT_CONN_SUBRATING_HOST) == 0) {
-        ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_SUBRATE_REQ,
-                                     BLE_ERR_UNSUPP_REM_FEATURE, rsp);
-        return BLE_LL_CTRL_REJECT_IND_EXT;
-    }
+  if ((ble_ll_read_supp_features() & BLE_LL_FEAT_CONN_SUBRATING_HOST) == 0)
+  {
+    ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_SUBRATE_REQ, BLE_ERR_UNSUPP_REM_FEATURE,
+                                 rsp);
+    return BLE_LL_CTRL_REJECT_IND_EXT;
+  }
 
-    srp->subrate_min = get_le16(req + 0);
-    srp->subrate_max = get_le16(req + 2);
-    srp->max_latency = get_le16(req + 4);
-    srp->cont_num = get_le16(req + 6);
-    srp->supervision_tmo = get_le16(req + 8);
+  srp->subrate_min = get_le16(req + 0);
+  srp->subrate_max = get_le16(req + 2);
+  srp->max_latency = get_le16(req + 4);
+  srp->cont_num = get_le16(req + 6);
+  srp->supervision_tmo = get_le16(req + 8);
 
-    rc = ble_ll_conn_subrate_req_llcp(connsm, srp);
-    if (rc < 0) {
-        if (rc == -EINVAL) {
-            err = BLE_ERR_INV_LMP_LL_PARM;
-        } else if (rc == -ENOTSUP) {
-            err = BLE_ERR_UNSUPP_REM_FEATURE;
-        } else if (rc == -EBUSY) {
-            err = BLE_ERR_DIFF_TRANS_COLL;
-        } else {
-            err = BLE_ERR_UNSPECIFIED;
-        }
+  rc = ble_ll_conn_subrate_req_llcp(connsm, srp);
+  if (rc < 0)
+  {
+    if (rc == -EINVAL)
+    {
+      err = BLE_ERR_INV_LMP_LL_PARM;
+    }
+    else if (rc == -ENOTSUP)
+    {
+      err = BLE_ERR_UNSUPP_REM_FEATURE;
+    }
+    else if (rc == -EBUSY)
+    {
+      err = BLE_ERR_DIFF_TRANS_COLL;
+    }
+    else
+    {
+      err = BLE_ERR_UNSPECIFIED;
+    }
 
-        ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_SUBRATE_REQ, err, rsp);
+    ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_SUBRATE_REQ, err, rsp);
 
-        return BLE_LL_CTRL_REJECT_IND_EXT;
-    }
+    return BLE_LL_CTRL_REJECT_IND_EXT;
+  }
 
-    return BLE_ERR_MAX;
+  return BLE_ERR_MAX;
 }
 
-static uint8_t
-ble_ll_ctrl_rx_subrate_ind(struct ble_ll_conn_sm *connsm, uint8_t *req,
-                           uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_subrate_ind(struct ble_ll_conn_sm *connsm,
+                                          uint8_t *req, uint8_t *rsp)
 {
-    struct ble_ll_conn_subrate_params params;
-    struct ble_ll_conn_subrate_params *sp = &params;
-    uint32_t t1, t2;
+  struct ble_ll_conn_subrate_params params;
+  struct ble_ll_conn_subrate_params *sp = &params;
+  uint32_t t1, t2;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
-#endif
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL)
+  {
+    return BLE_LL_CTRL_UNKNOWN_RSP;
+  }
+#endif
+
+  sp->subrate_factor = get_le16(req + 0);
+  sp->subrate_base_event = get_le16(req + 2);
+  sp->periph_latency = get_le16(req + 4);
+  sp->cont_num = get_le16(req + 6);
+  sp->supervision_tmo = get_le16(req + 8);
+
+  /* This is probably not really useful since we shall apply new parameters
+   * immediately after receiving LL_SUBRATE_IND and central shall apply those
+   * parameters after receiving ack which it already did, so it's too late
+   * here to do anything useful. Let's just send LL_REJECT_EXT_IND anyway just
+   * for debugging purposes and reset to subrate factor of 1 and no latency,
+   * perhaps we can find some connection event from central and send our PDU.
+   */
+  t1 = connsm->conn_itvl * sp->subrate_factor * (sp->periph_latency + 1) *
+       BLE_LL_CONN_ITVL_USECS;
+  t2 = sp->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000 / 2;
+  if ((sp->subrate_factor < 1) || (sp->subrate_factor > 500) ||
+      (sp->cont_num > sp->subrate_factor - 1) ||
+      (sp->subrate_factor * (sp->periph_latency + 1) > 500) || (t1 >= t2))
+  {
+    sp->subrate_factor = 1;
+    sp->subrate_base_event = connsm->event_cntr;
+    sp->periph_latency = 0;
+    sp->cont_num = 0;
+    sp->supervision_tmo = connsm->supervision_tmo;
 
-    sp->subrate_factor = get_le16(req + 0);
-    sp->subrate_base_event = get_le16(req + 2);
-    sp->periph_latency = get_le16(req + 4);
-    sp->cont_num = get_le16(req + 6);
-    sp->supervision_tmo = get_le16(req + 8);
-
-    /* This is probably not really useful since we shall apply new parameters
-     * immediately after receiving LL_SUBRATE_IND and central shall apply those
-     * parameters after receiving ack which it already did, so it's too late
-     * here to do anything useful. Let's just send LL_REJECT_EXT_IND anyway just
-     * for debugging purposes and reset to subrate factor of 1 and no latency,
-     * perhaps we can find some connection event from central and send our PDU.
-     */
-    t1 = connsm->conn_itvl * sp->subrate_factor * (sp->periph_latency + 1) *
-         BLE_LL_CONN_ITVL_USECS;
-    t2 = sp->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000 / 2;
-    if ((sp->subrate_factor < 1) || (sp->subrate_factor > 500) ||
-        (sp->cont_num > sp->subrate_factor - 1) ||
-        (sp->subrate_factor * (sp->periph_latency + 1) > 500) || (t1 >= t2)) {
-
-        sp->subrate_factor = 1;
-        sp->subrate_base_event = connsm->event_cntr;
-        sp->periph_latency = 0;
-        sp->cont_num = 0;
-        sp->supervision_tmo = connsm->supervision_tmo;
-
-        return BLE_ERR_MAX;
-    }
+    return BLE_ERR_MAX;
+  }
 
-    ble_ll_conn_subrate_set(connsm, sp);
-    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SUBRATE_REQ);
-    connsm->flags.subrate_host_req = 0;
+  ble_ll_conn_subrate_set(connsm, sp);
+  ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SUBRATE_REQ);
+  connsm->flags.subrate_host_req = 0;
 
-    return BLE_ERR_MAX;
+  return BLE_ERR_MAX;
 }
 #endif
 
@@ -1322,51 +1440,65 @@ ble_ll_ctrl_rx_subrate_ind(struct ble_ll_conn_sm *connsm, uint8_t *req,
  * @param connsm
  * @param dptr: Pointer to where control pdu payload starts
  */
-static void
-ble_ll_ctrl_datalen_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static void ble_ll_ctrl_datalen_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    put_le16(dptr + 1, connsm->max_rx_octets);
-    put_le16(dptr + 3, connsm->max_rx_time);
-    put_le16(dptr + 5, connsm->max_tx_octets);
-    put_le16(dptr + 7, connsm->max_tx_time);
+  put_le16(dptr + 1, connsm->max_rx_octets);
+  put_le16(dptr + 3, connsm->max_rx_time);
+  put_le16(dptr + 5, connsm->max_tx_octets);
+  put_le16(dptr + 7, connsm->max_tx_time);
 }
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-void
-ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm)
+void ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm)
 {
 #ifdef BLE_LL_ENCRYPT_DEBUG
-    int cnt;
+  int cnt;
 #endif
-
-    /* XXX: possibly have some way out of this if this locks up */
-    while (1) {
-        if (!ble_hw_encrypt_block(&connsm->enc_data.enc_block)) {
-            break;
-        }
+  int cnt;
+  /* XXX: possibly have some way out of this if this locks up */
+  while (1)
+  {
+    if (!ble_hw_encrypt_block(&connsm->enc_data.enc_block))
+    {
+      break;
     }
+  }
+  printf("\nLTK:");
 
-#ifdef BLE_LL_ENCRYPT_DEBUG
-    console_printf("Calculating Session Key for handle=%u",
-                   connsm->conn_handle);
+  for (cnt = 0; cnt < 16; ++cnt)
+  {
+    printf("%02x", connsm->enc_data.enc_block.key[cnt]);
+  }
 
-    console_printf("\nLTK:");
-    for (cnt = 0; cnt < 16; ++cnt) {
-        console_printf("%02x", connsm->enc_data.enc_block.key[cnt]);
-    }
-    console_printf("\nSKD:");
-    for (cnt = 0; cnt < 16; ++cnt) {
-        console_printf("%02x", connsm->enc_data.enc_block.plain_text[cnt]);
-    }
-    console_printf("\nSession Key:");
-    for (cnt = 0; cnt < 16; ++cnt) {
-        console_printf("%02x", connsm->enc_data.enc_block.cipher_text[cnt]);
-    }
-    console_printf("\nIV:");
-    for (cnt = 0; cnt < 8; ++ cnt) {
-        console_printf("%02x", connsm->enc_data.iv[cnt]);
-    }
-    console_printf("\n");
+  printf("\n");
+
+#ifdef BLE_LL_ENCRYPT_DEBUG
+  console_printf("Calculating Session Key for handle=%u",
+                 connsm->conn_handle);
+
+  console_printf("\nLTK:");
+  for (cnt = 0; cnt < 16; ++cnt)
+  {
+    console_printf("%02x", connsm->enc_data.enc_block.key[cnt]);
+  }
+  console_printf("\nSKD:");
+  for (cnt = 0; cnt < 16; ++cnt)
+  {
+    console_printf("%02x",
+                   connsm->enc_data.enc_block.plain_text[cnt]);
+  }
+  console_printf("\nSession Key:");
+  for (cnt = 0; cnt < 16; ++cnt)
+  {
+    console_printf("%02x",
+                   connsm->enc_data.enc_block.cipher_text[cnt]);
+  }
+  console_printf("\nIV:");
+  for (cnt = 0; cnt < 8; ++cnt)
+  {
+    console_printf("%02x", connsm->enc_data.iv[cnt]);
+  }
+  console_printf("\n");
 #endif
 }
 
@@ -1389,98 +1521,106 @@ ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm)
 static int
 ble_ll_ctrl_enc_allowed_pdu(uint8_t llid, uint8_t len, uint8_t opcode)
 {
-    int allowed;
-
-    allowed = 0;
-
-    switch (llid) {
-    case BLE_LL_LLID_CTRL:
-        switch (opcode) {
-        case BLE_LL_CTRL_REJECT_IND:
-        case BLE_LL_CTRL_REJECT_IND_EXT:
-        case BLE_LL_CTRL_START_ENC_RSP:
-        case BLE_LL_CTRL_START_ENC_REQ:
-        case BLE_LL_CTRL_ENC_REQ:
-        case BLE_LL_CTRL_ENC_RSP:
-        case BLE_LL_CTRL_PAUSE_ENC_REQ:
-        case BLE_LL_CTRL_PAUSE_ENC_RSP:
-        case BLE_LL_CTRL_TERMINATE_IND:
-            allowed = 1;
-            break;
-        }
-        break;
-    case BLE_LL_LLID_DATA_FRAG:
-        if (len == 0) {
-            /* Empty PDUs are allowed */
-            allowed = 1;
-        }
-        break;
+  int allowed;
+
+  allowed = 0;
+
+  switch (llid)
+  {
+  case BLE_LL_LLID_CTRL:
+    switch (opcode)
+    {
+    case BLE_LL_CTRL_REJECT_IND:
+    case BLE_LL_CTRL_REJECT_IND_EXT:
+    case BLE_LL_CTRL_START_ENC_RSP:
+    case BLE_LL_CTRL_START_ENC_REQ:
+    case BLE_LL_CTRL_ENC_REQ:
+    case BLE_LL_CTRL_ENC_RSP:
+    case BLE_LL_CTRL_PAUSE_ENC_REQ:
+    case BLE_LL_CTRL_PAUSE_ENC_RSP:
+    case BLE_LL_CTRL_TERMINATE_IND:
+      allowed = 1;
+      break;
+    }
+    break;
+  case BLE_LL_LLID_DATA_FRAG:
+    if (len == 0)
+    {
+      /* Empty PDUs are allowed */
+      allowed = 1;
     }
+    break;
+  }
 
-    return allowed;
+  return allowed;
 }
 
-int
-ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf *rxpdu)
+int ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf *rxpdu)
 {
-    uint8_t llid;
-    uint8_t len;
-    uint8_t opcode;
+  uint8_t llid;
+  uint8_t len;
+  uint8_t opcode;
 
-    llid = rxpdu->om_data[0] & BLE_LL_DATA_HDR_LLID_MASK;
-    len = rxpdu->om_data[1];
-    if (llid == BLE_LL_LLID_CTRL) {
-        opcode = rxpdu->om_data[2];
-    } else {
-        opcode = 0;
-    }
+  llid = rxpdu->om_data[0] & BLE_LL_DATA_HDR_LLID_MASK;
+  len = rxpdu->om_data[1];
+  if (llid == BLE_LL_LLID_CTRL)
+  {
+    opcode = rxpdu->om_data[2];
+  }
+  else
+  {
+    opcode = 0;
+  }
 
-    return ble_ll_ctrl_enc_allowed_pdu(llid, len, opcode);
+  return ble_ll_ctrl_enc_allowed_pdu(llid, len, opcode);
 }
 
-int
-ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr *pkthdr)
+int ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr *pkthdr)
 {
-    struct os_mbuf *m;
-    struct ble_mbuf_hdr *ble_hdr;
-    uint8_t llid;
-    uint8_t len;
-    uint8_t opcode;
+  struct os_mbuf *m;
+  struct ble_mbuf_hdr *ble_hdr;
+  uint8_t llid;
+  uint8_t len;
+  uint8_t opcode;
 
-    m = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
-    ble_hdr = BLE_MBUF_HDR_PTR(m);
+  m = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
+  ble_hdr = BLE_MBUF_HDR_PTR(m);
 
-    llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
-    len = ble_hdr->txinfo.pyld_len;
-    if (llid == BLE_LL_LLID_CTRL) {
-        opcode = m->om_data[0];
-    } else {
-        opcode = 0;
-    }
+  llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
+  len = ble_hdr->txinfo.pyld_len;
+  if (llid == BLE_LL_LLID_CTRL)
+  {
+    opcode = m->om_data[0];
+  }
+  else
+  {
+    opcode = 0;
+  }
 
-    return ble_ll_ctrl_enc_allowed_pdu(llid, len, opcode);
+  return ble_ll_ctrl_enc_allowed_pdu(llid, len, opcode);
 }
 
-int
-ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf *txpdu)
+int ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf *txpdu)
 {
-    int is_start_enc_rsp;
-    uint8_t opcode;
-    uint8_t llid;
-    struct ble_mbuf_hdr *ble_hdr;
+  int is_start_enc_rsp;
+  uint8_t opcode;
+  uint8_t llid;
+  struct ble_mbuf_hdr *ble_hdr;
 
-    is_start_enc_rsp = 0;
-    ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
+  is_start_enc_rsp = 0;
+  ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
 
-    llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
-    if (llid == BLE_LL_LLID_CTRL) {
-        opcode = txpdu->om_data[0];
-        if (opcode == BLE_LL_CTRL_START_ENC_RSP) {
-            is_start_enc_rsp = 1;
-        }
+  llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
+  if (llid == BLE_LL_LLID_CTRL)
+  {
+    opcode = txpdu->om_data[0];
+    if (opcode == BLE_LL_CTRL_START_ENC_RSP)
+    {
+      is_start_enc_rsp = 1;
     }
+  }
 
-    return is_start_enc_rsp;
+  return is_start_enc_rsp;
 }
 
 /**
@@ -1491,31 +1631,34 @@ ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf *txpdu)
  *
  * @return int
  */
-int
-ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm)
+int ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm)
 {
-    int rc;
-    struct os_mbuf *om;
+  int rc;
+  struct os_mbuf *om;
 
-    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
-                            sizeof(struct ble_mbuf_hdr));
-    if (om) {
-        om->om_data[0] = BLE_LL_CTRL_START_ENC_REQ;
-        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, 1);
+  om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
+                          sizeof(struct ble_mbuf_hdr));
+  if (om)
+  {
+    om->om_data[0] = BLE_LL_CTRL_START_ENC_REQ;
+    ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, 1);
 
-        /* Wait for LL_START_ENC_RSP. If there is already procedure in progress,
-         * LL response timer is already running.
-         */
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) {
-            connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_ENCRYPT;
-            ble_ll_ctrl_start_rsp_timer(connsm);
-        }
-
-        rc = 0;
-    } else {
-        rc = -1;
+    /* Wait for LL_START_ENC_RSP. If there is already procedure in progress,
+     * LL response timer is already running.
+     */
+    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE)
+    {
+      connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_ENCRYPT;
+      ble_ll_ctrl_start_rsp_timer(connsm);
     }
-    return rc;
+
+    rc = 0;
+  }
+  else
+  {
+    rc = -1;
+  }
+  return rc;
 }
 
 /**
@@ -1539,22 +1682,22 @@ ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm)
 static void
 ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    put_le64(dptr, connsm->enc_data.host_rand_num);
-    put_le16(dptr + 8, connsm->enc_data.enc_div);
+  put_le64(dptr, connsm->enc_data.host_rand_num);
+  put_le16(dptr + 8, connsm->enc_data.enc_div);
 
 #ifdef BLE_LL_ENCRYPT_USE_TEST_DATA
-    /* IV stored LSB to MSB, IVm is LSB, IVs is MSB */
-    put_le64(dptr + 10, g_bletest_SKDm);
-    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
-    put_le32(dptr + 18, g_bletest_IVm);
-    memcpy(connsm->enc_data.iv, dptr + 18, 4);
-    return;
+  /* IV stored LSB to MSB, IVm is LSB, IVs is MSB */
+  put_le64(dptr + 10, g_bletest_SKDm);
+  swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
+  put_le32(dptr + 18, g_bletest_IVm);
+  memcpy(connsm->enc_data.iv, dptr + 18, 4);
+  return;
 #endif
 
-    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text + 8, 8);
-    swap_buf(dptr + 10, connsm->enc_data.enc_block.plain_text + 8, 8);
-    ble_ll_rand_data_get(connsm->enc_data.iv, 4);
-    memcpy(dptr + 18, connsm->enc_data.iv, 4);
+  ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text + 8, 8);
+  swap_buf(dptr + 10, connsm->enc_data.enc_block.plain_text + 8, 8);
+  ble_ll_rand_data_get(connsm->enc_data.iv, 4);
+  memcpy(dptr + 18, connsm->enc_data.iv, 4);
 }
 
 /**
@@ -1576,18 +1719,19 @@ ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 static void
 ble_ll_ctrl_rx_enc_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    /* Calculate session key now that we have received the ENC_RSP */
-    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
-        /* In case we were already encrypted we need to reset packet counters */
-        connsm->enc_data.rx_pkt_cntr = 0;
-        connsm->enc_data.tx_pkt_cntr = 0;
-        connsm->enc_data.tx_encrypted = 0;
+  /* Calculate session key now that we have received the ENC_RSP */
+  if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT)
+  {
+    /* In case we were already encrypted we need to reset packet counters */
+    connsm->enc_data.rx_pkt_cntr = 0;
+    connsm->enc_data.tx_pkt_cntr = 0;
+    connsm->enc_data.tx_encrypted = 0;
 
-        swap_buf(connsm->enc_data.enc_block.plain_text, dptr, 8);
-        memcpy(connsm->enc_data.iv + 4, dptr + 8, 4);
-        ble_ll_calc_session_key(connsm);
-        connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_REQ_WAIT;
-    }
+    swap_buf(connsm->enc_data.enc_block.plain_text, dptr, 8);
+    memcpy(connsm->enc_data.iv + 4, dptr + 8, 4);
+    ble_ll_calc_session_key(connsm);
+    connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_REQ_WAIT;
+  }
 }
 
 /**
@@ -1616,95 +1760,100 @@ ble_ll_ctrl_rx_enc_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                        uint8_t *rspdata)
 {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL)
+  {
+    return BLE_LL_CTRL_UNKNOWN_RSP;
+  }
 #endif
 
-    connsm->enc_data.enc_state = CONN_ENC_S_ENC_RSP_TO_BE_SENT;
+  connsm->enc_data.enc_state = CONN_ENC_S_ENC_RSP_TO_BE_SENT;
 
-    /* In case we were already encrypted we need to reset packet counters */
-    connsm->enc_data.rx_pkt_cntr = 0;
-    connsm->enc_data.tx_pkt_cntr = 0;
-    connsm->enc_data.tx_encrypted = 0;
+  /* In case we were already encrypted we need to reset packet counters */
+  connsm->enc_data.rx_pkt_cntr = 0;
+  connsm->enc_data.tx_pkt_cntr = 0;
+  connsm->enc_data.tx_encrypted = 0;
 
-    /* Extract information from request */
-    connsm->enc_data.host_rand_num = get_le64(dptr);
-    connsm->enc_data.enc_div = get_le16(dptr + 8);
+  /* Extract information from request */
+  connsm->enc_data.host_rand_num = get_le64(dptr);
+  connsm->enc_data.enc_div = get_le16(dptr + 8);
 
 #if BLE_LL_ENCRYPT_USE_TEST_DATA
-    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
-    memcpy(connsm->enc_data.iv, dptr + 18, 4);
+  swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
+  memcpy(connsm->enc_data.iv, dptr + 18, 4);
 
-    put_le64(rspdata, g_bletest_SKDs);
-    swap_buf(connsm->enc_data.enc_block.plain_text, rspdata, 8);
-    put_le32(rspdata + 8, g_bletest_IVs);
-    memcpy(connsm->enc_data.iv + 4, rspdata + 8, 4);
-    return BLE_LL_CTRL_ENC_RSP;
+  put_le64(rspdata, g_bletest_SKDs);
+  swap_buf(connsm->enc_data.enc_block.plain_text, rspdata, 8);
+  put_le32(rspdata + 8, g_bletest_IVs);
+  memcpy(connsm->enc_data.iv + 4, rspdata + 8, 4);
+  return BLE_LL_CTRL_ENC_RSP;
 #endif
 
-    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
-    memcpy(connsm->enc_data.iv, dptr + 18, 4);
+  swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
+  memcpy(connsm->enc_data.iv, dptr + 18, 4);
 
-    /* Create the ENC_RSP. Concatenate our SKD and IV */
-    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text, 8);
-    swap_buf(rspdata, connsm->enc_data.enc_block.plain_text, 8);
-    ble_ll_rand_data_get(connsm->enc_data.iv + 4, 4);
-    memcpy(rspdata + 8, connsm->enc_data.iv + 4, 4);
+  /* Create the ENC_RSP. Concatenate our SKD and IV */
+  ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text, 8);
+  swap_buf(rspdata, connsm->enc_data.enc_block.plain_text, 8);
+  ble_ll_rand_data_get(connsm->enc_data.iv + 4, 4);
+  memcpy(rspdata + 8, connsm->enc_data.iv + 4, 4);
 
-    return BLE_LL_CTRL_ENC_RSP;
+  return BLE_LL_CTRL_ENC_RSP;
 }
 
 static uint8_t
 ble_ll_ctrl_rx_start_enc_req(struct ble_ll_conn_sm *connsm)
 {
-    int rc;
+  int rc;
 
-    /* Only central should receive start enc request */
-    rc = BLE_ERR_MAX;
+  /* Only central should receive start enc request */
+  rc = BLE_ERR_MAX;
 
-    switch (connsm->conn_role) {
+  switch (connsm->conn_role)
+  {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        /* We only want to send a START_ENC_RSP if we havent yet */
-        if (connsm->enc_data.enc_state == CONN_ENC_S_START_ENC_REQ_WAIT) {
-            connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_RSP_WAIT;
-            rc = BLE_LL_CTRL_START_ENC_RSP;
-        }
-        break;
+  case BLE_LL_CONN_ROLE_CENTRAL:
+    /* We only want to send a START_ENC_RSP if we havent yet */
+    if (connsm->enc_data.enc_state == CONN_ENC_S_START_ENC_REQ_WAIT)
+    {
+      connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_RSP_WAIT;
+      rc = BLE_LL_CTRL_START_ENC_RSP;
+    }
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        rc = BLE_LL_CTRL_UNKNOWN_RSP;
-        break;
+  case BLE_LL_CONN_ROLE_PERIPHERAL:
+    rc = BLE_LL_CTRL_UNKNOWN_RSP;
+    break;
 #endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
+  default:
+    BLE_LL_ASSERT(0);
+    break;
+  }
 
-    return rc;
+  return rc;
 }
 
 static uint8_t
 ble_ll_ctrl_rx_pause_enc_req(struct ble_ll_conn_sm *connsm)
 {
-    int rc;
+  int rc;
 
-    /*
-     * The spec does not say what to do here, but if we receive a pause
-     * encryption request and we are not encrypted, what do we do? We
-     * ignore it...
-     */
-    rc = BLE_ERR_MAX;
-    if (CONN_IS_PERIPHERAL(connsm) &&
-        (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED)) {
-        rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
-    } else {
-        rc = BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+  /*
+   * The spec does not say what to do here, but if we receive a pause
+   * encryption request and we are not encrypted, what do we do? We
+   * ignore it...
+   */
+  rc = BLE_ERR_MAX;
+  if (CONN_IS_PERIPHERAL(connsm) && (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED))
+  {
+    rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
+  }
+  else
+  {
+    rc = BLE_LL_CTRL_UNKNOWN_RSP;
+  }
 
-    return rc;
+  return rc;
 }
 
 /**
@@ -1718,33 +1867,37 @@ ble_ll_ctrl_rx_pause_enc_req(struct ble_ll_conn_sm *connsm)
 static uint8_t
 ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
 {
-    int rc = 0;
+  int rc = 0;
 
-    switch (connsm->conn_role) {
+  switch (connsm->conn_role)
+  {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
-        break;
+  case BLE_LL_CONN_ROLE_CENTRAL:
+    rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        if (connsm->enc_data.enc_state == CONN_ENC_S_PAUSE_ENC_RSP_WAIT) {
-                /* Master sends back unencrypted LL_PAUSE_ENC_RSP.
-                 * From this moment encryption is paused.
-                 */
-                rc = BLE_ERR_MAX;
-                connsm->enc_data.enc_state = CONN_ENC_S_PAUSED;
-            } else {
-                rc = BLE_LL_CTRL_UNKNOWN_RSP;
-            }
-        break;
-#endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
+  case BLE_LL_CONN_ROLE_PERIPHERAL:
+    if (connsm->enc_data.enc_state == CONN_ENC_S_PAUSE_ENC_RSP_WAIT)
+    {
+      /* Master sends back unencrypted LL_PAUSE_ENC_RSP.
+       * From this moment encryption is paused.
+       */
+      rc = BLE_ERR_MAX;
+      connsm->enc_data.enc_state = CONN_ENC_S_PAUSED;
+    }
+    else
+    {
+      rc = BLE_LL_CTRL_UNKNOWN_RSP;
     }
+    break;
+#endif
+  default:
+    BLE_LL_ASSERT(0);
+    break;
+  }
 
-    return rc;
+  return rc;
 }
 
 /**
@@ -1759,50 +1912,53 @@ ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
 static uint8_t
 ble_ll_ctrl_rx_start_enc_rsp(struct ble_ll_conn_sm *connsm)
 {
-    int rc = 0;
+  int rc = 0;
 
-    /* Not in proper state. Discard */
-    if (connsm->enc_data.enc_state != CONN_ENC_S_START_ENC_RSP_WAIT) {
-        return BLE_ERR_MAX;
-    }
+  /* Not in proper state. Discard */
+  if (connsm->enc_data.enc_state != CONN_ENC_S_START_ENC_RSP_WAIT)
+  {
+    return BLE_ERR_MAX;
+  }
 
-    switch (connsm->conn_role) {
+  switch (connsm->conn_role)
+  {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
+  case BLE_LL_CONN_ROLE_CENTRAL:
+    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
 
-        /* We are encrypted */
-        connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
+    /* We are encrypted */
+    connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
-        ble_ll_conn_auth_pyld_timer_start(connsm);
+    ble_ll_conn_auth_pyld_timer_start(connsm);
 #endif
-        rc = BLE_ERR_MAX;
-        break;
+    rc = BLE_ERR_MAX;
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        /* Procedure has completed but peripheral needs to send START_ENC_RSP */
-        rc = BLE_LL_CTRL_START_ENC_RSP;
+  case BLE_LL_CONN_ROLE_PERIPHERAL:
+    /* Procedure has completed but peripheral needs to send START_ENC_RSP */
+    rc = BLE_LL_CTRL_START_ENC_RSP;
 
-        /* Stop timer if it was started when sending START_ENC_REQ */
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
-        }
-        break;
-#endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
+    /* Stop timer if it was started when sending START_ENC_REQ */
+    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT)
+    {
+      ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
     }
+    break;
+#endif
+  default:
+    BLE_LL_ASSERT(0);
+    break;
+  }
 
-    /*
-     * XXX: for now, a Slave sends this event when it receivest the
-     * START_ENC_RSP from the central. It might be technically incorrect
-     * to send it before we transmit our own START_ENC_RSP.
-     */
-    ble_ll_hci_ev_encrypt_chg(connsm, BLE_ERR_SUCCESS);
+  /*
+   * XXX: for now, a Slave sends this event when it receivest the
+   * START_ENC_RSP from the central. It might be technically incorrect
+   * to send it before we transmit our own START_ENC_RSP.
+   */
+  ble_ll_hci_ev_encrypt_chg(connsm, BLE_ERR_SUCCESS);
 
-    return rc;
+  return rc;
 }
 
 #endif
@@ -1818,56 +1974,59 @@ static void
 ble_ll_ctrl_conn_param_pdu_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                                 struct ble_ll_conn_params *req)
 {
-    uint16_t offset;
-    struct hci_conn_update *hcu;
-
-    /* If we were passed in a request, we use the parameters from the request */
-    if (req) {
-        put_le16(dptr, req->interval_min);
-        put_le16(dptr + 2, req->interval_max);
-        put_le16(dptr + 4, req->latency);
-        put_le16(dptr + 6, req->timeout);
-    } else {
-        hcu = &connsm->conn_param_req;
-        /* The host should have provided the parameters! */
-        BLE_LL_ASSERT(hcu->handle != 0);
-        put_le16(dptr, hcu->conn_itvl_min);
-        put_le16(dptr + 2, hcu->conn_itvl_max);
-        put_le16(dptr + 4, hcu->conn_latency);
-        put_le16(dptr + 6, hcu->supervision_timeout);
-    }
-
-    /* XXX: NOTE: if interval min and interval max are != to each
-     * other this value should be set to non-zero. I think this
-     * applies only when an offset field is set. See section 5.1.7.1 pg 103
-     * Vol 6 Part B.
-     */
-    /* XXX: for now, set periodicity to 0 */
-    dptr[8] = 0;
-
-    /* XXX: deal with reference event count. what to put here? */
-    put_le16(dptr + 9, connsm->event_cntr);
-
-    /* XXX: For now, dont use offsets */
-    offset = 0xFFFF;
-    put_le16(dptr + 11, offset);
-    put_le16(dptr + 13, offset);
-    put_le16(dptr + 15, offset);
-    put_le16(dptr + 17, offset);
-    put_le16(dptr + 19, offset);
-    put_le16(dptr + 21, offset);
+  uint16_t offset;
+  struct hci_conn_update *hcu;
+
+  /* If we were passed in a request, we use the parameters from the request */
+  if (req)
+  {
+    put_le16(dptr, req->interval_min);
+    put_le16(dptr + 2, req->interval_max);
+    put_le16(dptr + 4, req->latency);
+    put_le16(dptr + 6, req->timeout);
+  }
+  else
+  {
+    hcu = &connsm->conn_param_req;
+    /* The host should have provided the parameters! */
+    BLE_LL_ASSERT(hcu->handle != 0);
+    put_le16(dptr, hcu->conn_itvl_min);
+    put_le16(dptr + 2, hcu->conn_itvl_max);
+    put_le16(dptr + 4, hcu->conn_latency);
+    put_le16(dptr + 6, hcu->supervision_timeout);
+  }
+
+  /* XXX: NOTE: if interval min and interval max are != to each
+   * other this value should be set to non-zero. I think this
+   * applies only when an offset field is set. See section 5.1.7.1 pg 103
+   * Vol 6 Part B.
+   */
+  /* XXX: for now, set periodicity to 0 */
+  dptr[8] = 0;
+
+  /* XXX: deal with reference event count. what to put here? */
+  put_le16(dptr + 9, connsm->event_cntr);
+
+  /* XXX: For now, dont use offsets */
+  offset = 0xFFFF;
+  put_le16(dptr + 11, offset);
+  put_le16(dptr + 13, offset);
+  put_le16(dptr + 15, offset);
+  put_le16(dptr + 17, offset);
+  put_le16(dptr + 19, offset);
+  put_le16(dptr + 21, offset);
 }
 
 static void
 ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
 {
-    /* Set flag to denote we have sent/received this */
-    connsm->flags.version_ind_txd = 1;
+  /* Set flag to denote we have sent/received this */
+  connsm->flags.version_ind_txd = 1;
 
-    /* Fill out response */
-    pyld[0] = BLE_HCI_VER_BCS;
-    put_le16(pyld + 1, MYNEWT_VAL(BLE_LL_MANUFACTURER_ID));
-    put_le16(pyld + 3, BLE_LL_SUB_VERS_NR);
+  /* Fill out response */
+  pyld[0] = BLE_HCI_VER_BCS;
+  put_le16(pyld + 1, MYNEWT_VAL(BLE_LL_MANUFACTURER_ID));
+  put_le16(pyld + 3, BLE_LL_SUB_VERS_NR);
 }
 
 /**
@@ -1879,19 +2038,19 @@ ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
 static void
 ble_ll_ctrl_chanmap_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
 {
-    /* Copy channel map that host desires into request */
-    memcpy(pyld, g_ble_ll_data.chan_map, BLE_LL_CHAN_MAP_LEN);
-    memcpy(connsm->req_chanmap, pyld, BLE_LL_CHAN_MAP_LEN);
+  /* Copy channel map that host desires into request */
+  memcpy(pyld, g_ble_ll_data.chan_map, BLE_LL_CHAN_MAP_LEN);
+  memcpy(connsm->req_chanmap, pyld, BLE_LL_CHAN_MAP_LEN);
 
-    /* Instant is placed in ble_ll_ctrl_chanmap_req_instant()*/
+  /* Instant is placed in ble_ll_ctrl_chanmap_req_instant()*/
 }
 
 static void
 ble_ll_ctrl_chanmap_req_instant(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
 {
-    /* Place instant into request */
-    connsm->chanmap_instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
-    put_le16(pyld + BLE_LL_CHAN_MAP_LEN, connsm->chanmap_instant);
+  /* Place instant into request */
+  connsm->chanmap_instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
+  put_le16(pyld + BLE_LL_CHAN_MAP_LEN, connsm->chanmap_instant);
 }
 
 /**
@@ -1908,28 +2067,29 @@ uint8_t
 ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm, uint8_t *rsp,
                              struct ble_ll_conn_params *req)
 {
-    uint8_t rsp_opcode = 0;
+  uint8_t rsp_opcode = 0;
 
-    switch (connsm->conn_role) {
+  switch (connsm->conn_role)
+  {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        ble_ll_ctrl_conn_update_init_proc(connsm, req);
-        rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
-        break;
+  case BLE_LL_CONN_ROLE_CENTRAL:
+    ble_ll_ctrl_conn_update_init_proc(connsm, req);
+    rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        /* Create a connection parameter response */
-        ble_ll_ctrl_conn_param_pdu_make(connsm, rsp + 1, req);
-        rsp_opcode = BLE_LL_CTRL_CONN_PARM_RSP;
-        break;
+  case BLE_LL_CONN_ROLE_PERIPHERAL:
+    /* Create a connection parameter response */
+    ble_ll_ctrl_conn_param_pdu_make(connsm, rsp + 1, req);
+    rsp_opcode = BLE_LL_CTRL_CONN_PARM_RSP;
+    break;
 #endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
+  default:
+    BLE_LL_ASSERT(0);
+    break;
+  }
 
-    return rsp_opcode;
+  return rsp_opcode;
 }
 
 /**
@@ -1944,83 +2104,90 @@ static int
 ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                           uint8_t opcode, uint8_t *rspdata)
 {
-    uint8_t ble_error;
-    uint8_t rsp_opcode = BLE_ERR_MAX;
-
-    /* Get error out of received PDU */
-    if (opcode == BLE_LL_CTRL_REJECT_IND) {
-        ble_error = dptr[0];
-    } else {
-        ble_error = dptr[1];
-    }
-
-    /* Suppress unused-but-set if not used by following code (due to syscfg) */
-    (void)ble_error;
-
-    /* XXX: should I check to make sure the rejected opcode is sane
-       if we receive ind ext? */
-    switch (connsm->cur_ctrl_proc) {
-    case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
-        if (opcode == BLE_LL_CTRL_REJECT_IND_EXT) {
-            switch (connsm->conn_role) {
-        #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-            case BLE_LL_CONN_ROLE_CENTRAL:
-                /* As a central we should send connection update indication in this point */
-                rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
-                ble_ll_ctrl_conn_update_init_proc(connsm, NULL);
-                connsm->reject_reason = BLE_ERR_SUCCESS;
-                break;
-        #endif
-        #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-            case BLE_LL_CONN_ROLE_PERIPHERAL:
-                ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
-                ble_ll_hci_ev_conn_update(connsm, ble_error);
-                break;
-        #endif
-            default:
-                BLE_LL_ASSERT(0);
-                break;
-            }
-        }
-        break;
-#if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    case BLE_LL_CTRL_PROC_ENCRYPT:
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
-        ble_ll_hci_ev_encrypt_chg(connsm, ble_error);
-        connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
+  uint8_t ble_error;
+  uint8_t rsp_opcode = BLE_ERR_MAX;
+
+  /* Get error out of received PDU */
+  if (opcode == BLE_LL_CTRL_REJECT_IND)
+  {
+    ble_error = dptr[0];
+  }
+  else
+  {
+    ble_error = dptr[1];
+  }
+
+  /* Suppress unused-but-set if not used by following code (due to syscfg) */
+  (void)ble_error;
+
+  /* XXX: should I check to make sure the rejected opcode is sane
+     if we receive ind ext? */
+  switch (connsm->cur_ctrl_proc)
+  {
+  case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
+    if (opcode == BLE_LL_CTRL_REJECT_IND_EXT)
+    {
+      switch (connsm->conn_role)
+      {
+#if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
+      case BLE_LL_CONN_ROLE_CENTRAL:
+        /* As a central we should send connection update indication in
+         * this point */
+        rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
+        ble_ll_ctrl_conn_update_init_proc(connsm, NULL);
+        connsm->reject_reason = BLE_ERR_SUCCESS;
         break;
 #endif
-#if MYNEWT_VAL(BLE_LL_PHY)
-    case BLE_LL_CTRL_PROC_PHY_UPDATE:
-        ble_ll_ctrl_phy_update_cancel(connsm, ble_error);
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+#if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
+      case BLE_LL_CONN_ROLE_PERIPHERAL:
+        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
+        ble_ll_hci_ev_conn_update(connsm, ble_error);
         break;
 #endif
-    case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
-        /* That should not happen according to Bluetooth 5.0 Vol6 Part B, 5.1.9
-         * However we need this workaround as there are devices on the market
-         * which do send LL_REJECT on LL_LENGTH_REQ when collision happens
-         */
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
+      default:
+        BLE_LL_ASSERT(0);
         break;
+      }
+    }
+    break;
+#if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
+  case BLE_LL_CTRL_PROC_ENCRYPT:
+    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
+    ble_ll_hci_ev_encrypt_chg(connsm, ble_error);
+    connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
+    break;
+#endif
+#if MYNEWT_VAL(BLE_LL_PHY)
+  case BLE_LL_CTRL_PROC_PHY_UPDATE:
+    ble_ll_ctrl_phy_update_cancel(connsm, ble_error);
+    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+    break;
+#endif
+  case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
+    /* That should not happen according to Bluetooth 5.0 Vol6 Part B, 5.1.9
+     * However we need this workaround as there are devices on the market
+     * which do send LL_REJECT on LL_LENGTH_REQ when collision happens
+     */
+    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
+    break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-    case BLE_LL_CTRL_PROC_SCA_UPDATE:
-        ble_ll_hci_ev_sca_update(connsm, ble_error, 0);
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SCA_UPDATE);
-        break;
+  case BLE_LL_CTRL_PROC_SCA_UPDATE:
+    ble_ll_hci_ev_sca_update(connsm, ble_error, 0);
+    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SCA_UPDATE);
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    case BLE_LL_CTRL_PROC_SUBRATE_REQ:
-        ble_ll_hci_ev_subrate_change(connsm, ble_error);
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SUBRATE_UPDATE);
-        break;
+  case BLE_LL_CTRL_PROC_SUBRATE_REQ:
+    ble_ll_hci_ev_subrate_change(connsm, ble_error);
+    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SUBRATE_UPDATE);
+    break;
 #endif
 
-    default:
-        break;
-    }
+  default:
+    break;
+  }
 
-    return rsp_opcode;
+  return rsp_opcode;
 }
 
 /**
@@ -2034,118 +2201,128 @@ ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
 static int
 ble_ll_ctrl_rx_conn_update(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    uint8_t rsp_opcode;
-    uint16_t conn_events;
-    struct ble_ll_conn_upd_req *reqdata;
+  uint8_t rsp_opcode;
+  uint16_t conn_events;
+  struct ble_ll_conn_upd_req *reqdata;
 
-    /* Only a peripheral should receive this */
+  /* Only a peripheral should receive this */
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
-#endif
-
-    /* Retrieve parameters */
-    reqdata = &connsm->conn_update_req;
-    reqdata->winsize = dptr[0];
-    reqdata->winoffset = get_le16(dptr + 1);
-    reqdata->interval = get_le16(dptr + 3);
-    reqdata->latency = get_le16(dptr + 5);
-    reqdata->timeout = get_le16(dptr + 7);
-    reqdata->instant = get_le16(dptr + 9);
-
-    /* XXX: validate them at some point. If they dont check out, we
-       return the unknown response */
-    rsp_opcode = BLE_ERR_MAX;
-
-    /* If instant is in the past, we have to end the connection */
-    conn_events = (reqdata->instant - connsm->event_cntr) & 0xFFFF;
-    if (conn_events >= 32767) {
-        ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
-    } else {
-        connsm->flags.conn_update_sched = 1;
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL)
+  {
+    return BLE_LL_CTRL_UNKNOWN_RSP;
+  }
+#endif
+
+  /* Retrieve parameters */
+  reqdata = &connsm->conn_update_req;
+  reqdata->winsize = dptr[0];
+  reqdata->winoffset = get_le16(dptr + 1);
+  reqdata->interval = get_le16(dptr + 3);
+  reqdata->latency = get_le16(dptr + 5);
+  reqdata->timeout = get_le16(dptr + 7);
+  reqdata->instant = get_le16(dptr + 9);
+
+  /* XXX: validate them at some point. If they dont check out, we
+     return the unknown response */
+  rsp_opcode = BLE_ERR_MAX;
+
+  /* If instant is in the past, we have to end the connection */
+  conn_events = (reqdata->instant - connsm->event_cntr) & 0xFFFF;
+  if (conn_events >= 32767)
+  {
+    ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
+  }
+  else
+  {
+    connsm->flags.conn_update_sched = 1;
 
-        /*
-         * Errata says that receiving a connection update when the event
-         * counter is equal to the instant means wesimply ignore the window
-         * offset and window size. Anchor point has already been set based on
-         * first packet received in connection event. Given that we increment
-         * the event counter BEFORE checking to see if the instant is equal to
-         * the event counter what we do here is increment the instant and set
-         * the window offset and size to 0.
-         */
-        if (conn_events == 0) {
-            reqdata->winoffset = 0;
-            reqdata->winsize = 0;
-            reqdata->instant += 1;
-        }
+    /*
+     * Errata says that receiving a connection update when the event
+     * counter is equal to the instant means wesimply ignore the window
+     * offset and window size. Anchor point has already been set based on
+     * first packet received in connection event. Given that we increment
+     * the event counter BEFORE checking to see if the instant is equal to
+     * the event counter what we do here is increment the instant and set
+     * the window offset and size to 0.
+     */
+    if (conn_events == 0)
+    {
+      reqdata->winoffset = 0;
+      reqdata->winsize = 0;
+      reqdata->instant += 1;
     }
+  }
 
-    return rsp_opcode;
+  return rsp_opcode;
 }
 
-void
-ble_ll_ctrl_initiate_dle(struct ble_ll_conn_sm *connsm, bool initial)
+void ble_ll_ctrl_initiate_dle(struct ble_ll_conn_sm *connsm, bool initial)
 {
-    if (!(connsm->conn_features & BLE_LL_FEAT_DATA_LEN_EXT)) {
-        return;
-    }
+  if (!(connsm->conn_features & BLE_LL_FEAT_DATA_LEN_EXT))
+  {
+    return;
+  }
 
-    /*
-     * Section 4.5.10 Vol 6 PART B. If the max tx/rx time or octets
-     * exceeds the minimum, data length procedure needs to occur
-     * "at the earliest practical opportunity".
-     */
-    if (initial) {
-        if ((connsm->max_tx_octets <= BLE_LL_CONN_SUPP_BYTES_MIN) &&
-            (connsm->max_rx_octets <= BLE_LL_CONN_SUPP_BYTES_MIN) &&
-            (connsm->max_tx_time <= BLE_LL_CONN_SUPP_TIME_MIN) &&
-            (connsm->max_rx_time <= BLE_LL_CONN_SUPP_TIME_MIN)) {
-            return;
-        }
+  /*
+   * Section 4.5.10 Vol 6 PART B. If the max tx/rx time or octets
+   * exceeds the minimum, data length procedure needs to occur
+   * "at the earliest practical opportunity".
+   */
+  if (initial)
+  {
+    if ((connsm->max_tx_octets <= BLE_LL_CONN_SUPP_BYTES_MIN) && (connsm->max_rx_octets <= BLE_LL_CONN_SUPP_BYTES_MIN) && (connsm->max_tx_time <= BLE_LL_CONN_SUPP_TIME_MIN) && (connsm->max_rx_time <= BLE_LL_CONN_SUPP_TIME_MIN))
+    {
+      return;
     }
+  }
 
-    ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD, NULL);
+  ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD, NULL);
 }
 
 static void
 ble_ll_ctrl_update_features(struct ble_ll_conn_sm *connsm, uint8_t *feat)
 {
-    connsm->conn_features = feat[0];
-    memcpy(connsm->remote_features, feat + 1, 7);
+  connsm->conn_features = feat[0];
+  memcpy(connsm->remote_features, feat + 1, 7);
 
-    /* If we received peer's features for the 1st time, we should try DLE */
-    if (!connsm->flags.features_rxd) {
+  /* If we received peer's features for the 1st time, we should try DLE */
+  if (!connsm->flags.features_rxd)
+  {
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-        /*
-         * If connection was established on uncoded PHY, by default we use
-         * MaxTxTime and MaxRxTime applicable for that PHY since we are not
-         * allowed to indicate longer supported time if peer does not support
-         * LE Coded PHY. However, once we know that peer does support it we can
-         * update those values to ones applicable for coded PHY.
-         */
-        if (ble_ll_conn_rem_feature_check(connsm, BLE_LL_FEAT_LE_CODED_PHY)) {
-            if (connsm->host_req_max_tx_time) {
-                connsm->max_tx_time = MAX(connsm->max_tx_time,
-                                          connsm->host_req_max_tx_time);
-            } else {
-                connsm->max_tx_time = g_ble_ll_conn_params.conn_init_max_tx_time_coded;
-            }
-            if (connsm->host_req_max_rx_time) {
-                connsm->max_rx_time = MAX(connsm->max_rx_time,
-                                          connsm->host_req_max_rx_time);
-            } else {
-                connsm->max_rx_time = BLE_LL_CONN_SUPP_TIME_MAX_CODED;
-            }
-        }
+    /*
+     * If connection was established on uncoded PHY, by default we use
+     * MaxTxTime and MaxRxTime applicable for that PHY since we are not
+     * allowed to indicate longer supported time if peer does not support
+     * LE Coded PHY. However, once we know that peer does support it we can
+     * update those values to ones applicable for coded PHY.
+     */
+    if (ble_ll_conn_rem_feature_check(connsm, BLE_LL_FEAT_LE_CODED_PHY))
+    {
+      if (connsm->host_req_max_tx_time)
+      {
+        connsm->max_tx_time = MAX(connsm->max_tx_time, connsm->host_req_max_tx_time);
+      }
+      else
+      {
+        connsm->max_tx_time = g_ble_ll_conn_params.conn_init_max_tx_time_coded;
+      }
+      if (connsm->host_req_max_rx_time)
+      {
+        connsm->max_rx_time = MAX(connsm->max_rx_time, connsm->host_req_max_rx_time);
+      }
+      else
+      {
+        connsm->max_rx_time = BLE_LL_CONN_SUPP_TIME_MAX_CODED;
+      }
+    }
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CONN_INIT_AUTO_DLE)
-        connsm->flags.pending_initiate_dle = 1;
+    connsm->flags.pending_initiate_dle = 1;
 #endif
 
-        connsm->flags.features_rxd = 1;
-    }
+    connsm->flags.features_rxd = 1;
+  }
 }
 
 /**
@@ -2165,44 +2342,49 @@ static int
 ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                            uint8_t *rspbuf, uint8_t opcode)
 {
-    uint8_t rsp_opcode;
-    uint64_t our_feat;
+  uint8_t rsp_opcode;
+  uint64_t our_feat;
 
-    /*
-     * Only accept peripheral feature requests if we are a central and feature
-     * requests if we are a peripheral.
-     */
-    if (opcode == BLE_LL_CTRL_PERIPH_FEATURE_REQ) {
-        if (!CONN_IS_CENTRAL(connsm)) {
-            return BLE_LL_CTRL_UNKNOWN_RSP;
-        }
-    } else {
-        /* XXX: not sure this is correct but do it anyway */
-        if (!CONN_IS_PERIPHERAL(connsm)) {
-            return BLE_LL_CTRL_UNKNOWN_RSP;
-        }
+  /*
+   * Only accept peripheral feature requests if we are a central and feature
+   * requests if we are a peripheral.
+   */
+  if (opcode == BLE_LL_CTRL_PERIPH_FEATURE_REQ)
+  {
+    if (!CONN_IS_CENTRAL(connsm))
+    {
+      return BLE_LL_CTRL_UNKNOWN_RSP;
+    }
+  }
+  else
+  {
+    /* XXX: not sure this is correct but do it anyway */
+    if (!CONN_IS_PERIPHERAL(connsm))
+    {
+      return BLE_LL_CTRL_UNKNOWN_RSP;
     }
+  }
 
-    our_feat = ble_ll_read_supp_features();
+  our_feat = ble_ll_read_supp_features();
 
-    rsp_opcode = BLE_LL_CTRL_FEATURE_RSP;
+  rsp_opcode = BLE_LL_CTRL_FEATURE_RSP;
 
-    ble_ll_ctrl_update_features(connsm, dptr);
+  ble_ll_ctrl_update_features(connsm, dptr);
 
-    /*
-     * 1st octet of features should be common features of local and remote
-     * controller - we call this 'connection features'
-     * remaining octets are features of controller which sends PDU, in this case
-     * it's our controller
-     *
-     * See: Vol 6, Part B, section 2.4.2.10
-     */
-    connsm->conn_features &= our_feat;
+  /*
+   * 1st octet of features should be common features of local and remote
+   * controller - we call this 'connection features'
+   * remaining octets are features of controller which sends PDU, in this case
+   * it's our controller
+   *
+   * See: Vol 6, Part B, section 2.4.2.10
+   */
+  connsm->conn_features &= our_feat;
 
-    put_le64(rspbuf + 1, our_feat);
-    rspbuf[1] = connsm->conn_features;
+  put_le64(rspbuf + 1, our_feat);
+  rspbuf[1] = connsm->conn_features;
 
-    return rsp_opcode;
+  return rsp_opcode;
 }
 
 /**
@@ -2216,18 +2398,20 @@ ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
 static void
 ble_ll_ctrl_rx_feature_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    ble_ll_ctrl_update_features(connsm, dptr);
+  ble_ll_ctrl_update_features(connsm, dptr);
 
-    /* Stop the control procedure */
-    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG)) {
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG);
-    }
+  /* Stop the control procedure */
+  if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG))
+  {
+    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG);
+  }
 
-    /* Send event to host if pending features read */
-    if (connsm->flags.features_host_req) {
-        ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_SUCCESS);
-        connsm->flags.features_host_req = 0;
-    }
+  /* Send event to host if pending features read */
+  if (connsm->flags.features_host_req)
+  {
+    ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_SUCCESS);
+    connsm->flags.features_host_req = 0;
+  }
 }
 
 /**
@@ -2245,123 +2429,129 @@ static int
 ble_ll_ctrl_rx_conn_param_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                               uint8_t *rspbuf)
 {
-    uint8_t rsp_opcode;
-
-    /*
-     * This is not in the specification per se but it simplifies the
-     * implementation. If we get a connection parameter request and we
-     * are awaiting a reply from the host, simply ignore the request. This
-     * might not be a good idea if the parameters are different, but oh
-     * well. This is not expected to happen anyway. A return of BLE_ERR_MAX
-     * means that we will simply discard the connection parameter request
-     */
-    if (connsm->flags.conn_update_host_w4reply) {
-        return BLE_ERR_MAX;
-    }
+  uint8_t rsp_opcode;
+
+  /*
+   * This is not in the specification per se but it simplifies the
+   * implementation. If we get a connection parameter request and we
+   * are awaiting a reply from the host, simply ignore the request. This
+   * might not be a good idea if the parameters are different, but oh
+   * well. This is not expected to happen anyway. A return of BLE_ERR_MAX
+   * means that we will simply discard the connection parameter request
+   */
+  if (connsm->flags.conn_update_host_w4reply)
+  {
+    return BLE_ERR_MAX;
+  }
 
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
-    /* Reject any attempts to change connection parameters by peripheral */
-    if (ble_ll_sched_css_is_enabled() &&
-        connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
-        rspbuf[2] = BLE_ERR_UNSUPPORTED;
-        return rsp_opcode;
-    }
-#endif
-
-    /* XXX: remember to deal with this on the central: if the peripheral has
-     * initiated a procedure we may have received its connection parameter
-     * update request and have signaled the host with an event. If that
-     * is the case, we will need to drop the host command when we get it
-       and also clear any applicable states. */
-
-    /* XXX: Read 5.3 again. There are multiple control procedures that might
-     * be pending (a connection update) that will cause collisions and the
-       behavior below. */
-    /*
-     * Check for procedure collision (Vol 6 PartB 5.3). If we are a peripheral
-     * and we receive a request we "consider the peripheral initiated
-     * procedure as complete". This means send a connection update complete
-     * event (with error).
-     *
-     * If a central, we send reject with a
-     * transaction collision error code.
-     */
-    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
-        switch (connsm->conn_role) {
+  /* Reject any attempts to change connection parameters by peripheral */
+  if (ble_ll_sched_css_is_enabled() && connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL)
+  {
+    rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+    rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
+    rspbuf[2] = BLE_ERR_UNSUPPORTED;
+    return rsp_opcode;
+  }
+#endif
+
+  /* XXX: remember to deal with this on the central: if the peripheral has
+   * initiated a procedure we may have received its connection parameter
+   * update request and have signaled the host with an event. If that
+   * is the case, we will need to drop the host command when we get it
+     and also clear any applicable states. */
+
+  /* XXX: Read 5.3 again. There are multiple control procedures that might
+   * be pending (a connection update) that will cause collisions and the
+     behavior below. */
+  /*
+   * Check for procedure collision (Vol 6 PartB 5.3). If we are a peripheral
+   * and we receive a request we "consider the peripheral initiated
+   * procedure as complete". This means send a connection update complete
+   * event (with error).
+   *
+   * If a central, we send reject with a
+   * transaction collision error code.
+   */
+  if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ))
+  {
+    switch (connsm->conn_role)
+    {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-        case BLE_LL_CONN_ROLE_CENTRAL:
-            /* The central sends reject ind ext w/error code 0x23 */
-            rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-            rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
-            rspbuf[2] = BLE_ERR_LMP_COLLISION;
-            return rsp_opcode;
+    case BLE_LL_CONN_ROLE_CENTRAL:
+      /* The central sends reject ind ext w/error code 0x23 */
+      rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+      rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
+      rspbuf[2] = BLE_ERR_LMP_COLLISION;
+      return rsp_opcode;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-        case BLE_LL_CONN_ROLE_PERIPHERAL:
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
-            ble_ll_hci_ev_conn_update(connsm, BLE_ERR_LMP_COLLISION);
-            break;
-#endif
-        default:
-            BLE_LL_ASSERT(0);
-            break;
-        }
+    case BLE_LL_CONN_ROLE_PERIPHERAL:
+      ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
+      ble_ll_hci_ev_conn_update(connsm, BLE_ERR_LMP_COLLISION);
+      break;
+#endif
+    default:
+      BLE_LL_ASSERT(0);
+      break;
     }
+  }
 
-    /*
-     * If we are a central and we currently performing a channel map
-     * update procedure we need to return an error
-     */
+  /*
+   * If we are a central and we currently performing a channel map
+   * update procedure we need to return an error
+   */
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if ((connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) &&
-        (connsm->flags.chanmap_update_sched)) {
-        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
-        rspbuf[2] = BLE_ERR_DIFF_TRANS_COLL;
-        return rsp_opcode;
-    }
+  if ((connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) && (connsm->flags.chanmap_update_sched))
+  {
+    rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+    rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
+    rspbuf[2] = BLE_ERR_DIFF_TRANS_COLL;
+    return rsp_opcode;
+  }
 #endif
 
-    /* Process the received connection parameter request */
-    rsp_opcode = ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf,
-                                                 BLE_LL_CTRL_CONN_PARM_REQ);
-    return rsp_opcode;
+  /* Process the received connection parameter request */
+  rsp_opcode = ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf,
+                                               BLE_LL_CTRL_CONN_PARM_REQ);
+  return rsp_opcode;
 }
 
 static int
 ble_ll_ctrl_rx_conn_param_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                               uint8_t *rspbuf)
 {
-    uint8_t rsp_opcode;
+  uint8_t rsp_opcode;
 
-    /* A peripheral should never receive this response */
+  /* A peripheral should never receive this response */
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
-#endif
-
-    /*
-     * This case should never happen! It means that the peripheral initiated a
-     * procedure and the central initiated one as well. If we do get in this
-     * state just clear the awaiting reply. The peripheral will hopefully stop its
-     * procedure when we reply.
-     */
-    if (connsm->flags.conn_update_host_w4reply) {
-        connsm->flags.conn_update_host_w4reply = 0;
-    }
-
-    /* If we receive a response and no procedure is pending, just leave */
-    if (!IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
-        return BLE_ERR_MAX;
-    }
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL)
+  {
+    return BLE_LL_CTRL_UNKNOWN_RSP;
+  }
+#endif
+
+  /*
+   * This case should never happen! It means that the peripheral initiated a
+   * procedure and the central initiated one as well. If we do get in this
+   * state just clear the awaiting reply. The peripheral will hopefully stop
+   * its procedure when we reply.
+   */
+  if (connsm->flags.conn_update_host_w4reply)
+  {
+    connsm->flags.conn_update_host_w4reply = 0;
+  }
+
+  /* If we receive a response and no procedure is pending, just leave */
+  if (!IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ))
+  {
+    return BLE_ERR_MAX;
+  }
 
-    /* Process the received connection parameter response */
-    rsp_opcode = ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf,
-                                                 BLE_LL_CTRL_CONN_PARM_RSP);
-    return rsp_opcode;
+  /* Process the received connection parameter response */
+  rsp_opcode = ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf,
+                                               BLE_LL_CTRL_CONN_PARM_RSP);
+  return rsp_opcode;
 }
 
 /**
@@ -2379,26 +2569,28 @@ static int
 ble_ll_ctrl_rx_version_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
                            uint8_t *rspbuf)
 {
-    uint8_t rsp_opcode;
+  uint8_t rsp_opcode;
 
-    /* Process the packet */
-    connsm->vers_nr = dptr[0];
-    connsm->comp_id = get_le16(dptr + 1);
-    connsm->sub_vers_nr = get_le16(dptr + 3);
-    connsm->flags.version_ind_rxd = 1;
+  /* Process the packet */
+  connsm->vers_nr = dptr[0];
+  connsm->comp_id = get_le16(dptr + 1);
+  connsm->sub_vers_nr = get_le16(dptr + 3);
+  connsm->flags.version_ind_rxd = 1;
 
-    rsp_opcode = BLE_ERR_MAX;
-    if (!connsm->flags.version_ind_txd) {
-        rsp_opcode = BLE_LL_CTRL_VERSION_IND;
-        ble_ll_ctrl_version_ind_make(connsm, rspbuf);
-    }
+  rsp_opcode = BLE_ERR_MAX;
+  if (!connsm->flags.version_ind_txd)
+  {
+    rsp_opcode = BLE_LL_CTRL_VERSION_IND;
+    ble_ll_ctrl_version_ind_make(connsm, rspbuf);
+  }
 
-    /* Stop the control procedure */
-    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG)) {
-        ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG);
-    }
-    return rsp_opcode;
+  /* Stop the control procedure */
+  if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG))
+  {
+    ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
+    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG);
+  }
+  return rsp_opcode;
 }
 
 /**
@@ -2412,27 +2604,31 @@ ble_ll_ctrl_rx_version_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
 static int
 ble_ll_ctrl_rx_chanmap_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    uint16_t instant;
-    uint16_t conn_events;
+  uint16_t instant;
+  uint16_t conn_events;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+  if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL)
+  {
+    return BLE_LL_CTRL_UNKNOWN_RSP;
+  }
 #endif
 
-    /* If instant is in the past, we have to end the connection */
-    instant = get_le16(dptr + BLE_LL_CHAN_MAP_LEN);
-    conn_events = (instant - connsm->event_cntr) & 0xFFFF;
-    if (conn_events >= 32767) {
-        ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
-    } else {
-        connsm->chanmap_instant = instant;
-        memcpy(connsm->req_chanmap, dptr, BLE_LL_CHAN_MAP_LEN);
-        connsm->flags.chanmap_update_sched = 1;
-    }
+  /* If instant is in the past, we have to end the connection */
+  instant = get_le16(dptr + BLE_LL_CHAN_MAP_LEN);
+  conn_events = (instant - connsm->event_cntr) & 0xFFFF;
+  if (conn_events >= 32767)
+  {
+    ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
+  }
+  else
+  {
+    connsm->chanmap_instant = instant;
+    memcpy(connsm->req_chanmap, dptr, BLE_LL_CHAN_MAP_LEN);
+    connsm->flags.chanmap_update_sched = 1;
+  }
 
-    return BLE_ERR_MAX;
+  return BLE_ERR_MAX;
 }
 
 /**
@@ -2448,121 +2644,129 @@ ble_ll_ctrl_rx_chanmap_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @param ctrl_proc
  */
 static struct os_mbuf *
-ble_ll_ctrl_proc_init(struct ble_ll_conn_sm *connsm, int ctrl_proc, void *data)
-{
-    uint8_t len;
-    uint8_t opcode = 0;
-    uint8_t *dptr;
-    uint8_t *ctrdata;
-    struct os_mbuf *om;
-
-    /* Get an mbuf for the control pdu */
-    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN, sizeof(struct ble_mbuf_hdr));
-
-    if (om) {
-        /* The control data starts after the opcode (1 byte) */
-        dptr = om->om_data;
-        ctrdata = dptr + 1;
-
-        switch (ctrl_proc) {
-        case BLE_LL_CTRL_PROC_CONN_UPDATE:
-            opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
-            ble_ll_ctrl_conn_update_init_proc(connsm, data);
-            break;
-        case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
-            opcode = BLE_LL_CTRL_CHANNEL_MAP_REQ;
-            ble_ll_ctrl_chanmap_req_make(connsm, ctrdata);
-            break;
-        case BLE_LL_CTRL_PROC_FEATURE_XCHG:
-            switch (connsm->conn_role) {
+ble_ll_ctrl_proc_init(struct ble_ll_conn_sm *connsm, int ctrl_proc,
+                      void *data)
+{
+  uint8_t len;
+  uint8_t opcode = 0;
+  uint8_t *dptr;
+  uint8_t *ctrdata;
+  struct os_mbuf *om;
+
+  /* Get an mbuf for the control pdu */
+  om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
+                          sizeof(struct ble_mbuf_hdr));
+
+  if (om)
+  {
+    /* The control data starts after the opcode (1 byte) */
+    dptr = om->om_data;
+    ctrdata = dptr + 1;
+
+    switch (ctrl_proc)
+    {
+    case BLE_LL_CTRL_PROC_CONN_UPDATE:
+      opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
+      ble_ll_ctrl_conn_update_init_proc(connsm, data);
+      break;
+    case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
+      opcode = BLE_LL_CTRL_CHANNEL_MAP_REQ;
+      ble_ll_ctrl_chanmap_req_make(connsm, ctrdata);
+      break;
+    case BLE_LL_CTRL_PROC_FEATURE_XCHG:
+      switch (connsm->conn_role)
+      {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-            case BLE_LL_CONN_ROLE_CENTRAL:
-                opcode = BLE_LL_CTRL_FEATURE_REQ;
-                break;
+      case BLE_LL_CONN_ROLE_CENTRAL:
+        opcode = BLE_LL_CTRL_FEATURE_REQ;
+        break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-            case BLE_LL_CONN_ROLE_PERIPHERAL:
-                opcode = BLE_LL_CTRL_PERIPH_FEATURE_REQ;
-                break;
-#endif
-            default:
-                BLE_LL_ASSERT(0);
-                break;
-            }
-            put_le64(ctrdata, ble_ll_read_supp_features());
-            break;
-        case BLE_LL_CTRL_PROC_VERSION_XCHG:
-            opcode = BLE_LL_CTRL_VERSION_IND;
-            ble_ll_ctrl_version_ind_make(connsm, ctrdata);
-            break;
-        case BLE_LL_CTRL_PROC_TERMINATE:
-            opcode = BLE_LL_CTRL_TERMINATE_IND;
-            ctrdata[0] = connsm->disconnect_reason;
-            break;
-        case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
-            opcode = BLE_LL_CTRL_CONN_PARM_REQ;
-            ble_ll_ctrl_conn_param_pdu_make(connsm, ctrdata, NULL);
-            break;
-        case BLE_LL_CTRL_PROC_LE_PING:
-            opcode = BLE_LL_CTRL_PING_REQ;
-            break;
-        case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
-            opcode = BLE_LL_CTRL_LENGTH_REQ;
-            ble_ll_ctrl_datalen_upd_make(connsm, dptr);
-            break;
+      case BLE_LL_CONN_ROLE_PERIPHERAL:
+        opcode = BLE_LL_CTRL_PERIPH_FEATURE_REQ;
+        break;
+#endif
+      default:
+        BLE_LL_ASSERT(0);
+        break;
+      }
+      put_le64(ctrdata, ble_ll_read_supp_features());
+      break;
+    case BLE_LL_CTRL_PROC_VERSION_XCHG:
+      opcode = BLE_LL_CTRL_VERSION_IND;
+      ble_ll_ctrl_version_ind_make(connsm, ctrdata);
+      break;
+    case BLE_LL_CTRL_PROC_TERMINATE:
+      opcode = BLE_LL_CTRL_TERMINATE_IND;
+      ctrdata[0] = connsm->disconnect_reason;
+      break;
+    case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
+      opcode = BLE_LL_CTRL_CONN_PARM_REQ;
+      ble_ll_ctrl_conn_param_pdu_make(connsm, ctrdata, NULL);
+      break;
+    case BLE_LL_CTRL_PROC_LE_PING:
+      opcode = BLE_LL_CTRL_PING_REQ;
+      break;
+    case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
+      opcode = BLE_LL_CTRL_LENGTH_REQ;
+      ble_ll_ctrl_datalen_upd_make(connsm, dptr);
+      break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-        /* XXX: deal with already encrypted connection.*/
-        case BLE_LL_CTRL_PROC_ENCRYPT:
-            /* If we are already encrypted we do pause procedure */
-            if (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED) {
-                opcode = BLE_LL_CTRL_PAUSE_ENC_REQ;
-            } else {
-                opcode = BLE_LL_CTRL_ENC_REQ;
-                ble_ll_ctrl_enc_req_make(connsm, ctrdata);
-            }
-            break;
+    /* XXX: deal with already encrypted connection.*/
+    case BLE_LL_CTRL_PROC_ENCRYPT:
+      /* If we are already encrypted we do pause procedure */
+      if (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED)
+      {
+        opcode = BLE_LL_CTRL_PAUSE_ENC_REQ;
+      }
+      else
+      {
+        opcode = BLE_LL_CTRL_ENC_REQ;
+        ble_ll_ctrl_enc_req_make(connsm, ctrdata);
+      }
+      break;
 #endif
 #if MYNEWT_VAL(BLE_LL_PHY)
-        case BLE_LL_CTRL_PROC_PHY_UPDATE:
-            opcode = BLE_LL_CTRL_PHY_REQ;
-            ble_ll_ctrl_phy_req_rsp_make(connsm, ctrdata);
-            break;
+    case BLE_LL_CTRL_PROC_PHY_UPDATE:
+      opcode = BLE_LL_CTRL_PHY_REQ;
+      ble_ll_ctrl_phy_req_rsp_make(connsm, ctrdata);
+      break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-        case BLE_LL_CTRL_PROC_SCA_UPDATE:
-            opcode = BLE_LL_CTRL_CLOCK_ACCURACY_REQ;
-            ble_ll_ctrl_sca_req_rsp_make(connsm, ctrdata);
-            break;
+    case BLE_LL_CTRL_PROC_SCA_UPDATE:
+      opcode = BLE_LL_CTRL_CLOCK_ACCURACY_REQ;
+      ble_ll_ctrl_sca_req_rsp_make(connsm, ctrdata);
+      break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-        case BLE_LL_CTRL_PROC_SUBRATE_REQ:
-            opcode = BLE_LL_CTRL_SUBRATE_REQ;
-            ble_ll_ctrl_subrate_req_make(connsm, ctrdata, &connsm->subrate_req);
-            break;
+    case BLE_LL_CTRL_PROC_SUBRATE_REQ:
+      opcode = BLE_LL_CTRL_SUBRATE_REQ;
+      ble_ll_ctrl_subrate_req_make(connsm, ctrdata, &connsm->subrate_req);
+      break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-        case BLE_LL_CTRL_PROC_SUBRATE_UPDATE:
-            opcode = BLE_LL_CTRL_SUBRATE_IND;
-            ble_ll_ctrl_subrate_ind_make(connsm, ctrdata,
-                                         &connsm->subrate_trans);
-            break;
+    case BLE_LL_CTRL_PROC_SUBRATE_UPDATE:
+      opcode = BLE_LL_CTRL_SUBRATE_IND;
+      ble_ll_ctrl_subrate_ind_make(connsm, ctrdata,
+                                   &connsm->subrate_trans);
+      break;
 #endif
 #endif
-        default:
-            BLE_LL_ASSERT(0);
-            break;
-        }
+    default:
+      BLE_LL_ASSERT(0);
+      break;
+    }
 
-        /* Set llid, length and opcode */
-        dptr[0] = opcode;
-        len = g_ble_ll_ctrl_pkt_lengths[opcode] + 1;
+    /* Set llid, length and opcode */
+    dptr[0] = opcode;
+    len = g_ble_ll_ctrl_pkt_lengths[opcode] + 1;
 
-        /* Add packet to transmit queue of connection */
-        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
-    }
+    /* Add packet to transmit queue of connection */
+    ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
+  }
 
-    return om;
+  return om;
 }
 
 /**
@@ -2573,18 +2777,19 @@ ble_ll_ctrl_proc_init(struct ble_ll_conn_sm *connsm, int ctrl_proc, void *data)
  *
  * @return int
  */
-int
-ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode)
+int ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode)
 {
-    int rc;
+  int rc;
 
-    rc = 0;
-    if ((hdr & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
-        if (opcode == BLE_LL_CTRL_TERMINATE_IND) {
-            rc = 1;
-        }
+  rc = 0;
+  if ((hdr & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL)
+  {
+    if (opcode == BLE_LL_CTRL_TERMINATE_IND)
+    {
+      rc = 1;
     }
-    return rc;
+  }
+  return rc;
 }
 
 /**
@@ -2595,17 +2800,17 @@ ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode)
  * @param connsm
  * @param ctrl_proc
  */
-void
-ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
+void ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
 {
-    if (connsm->cur_ctrl_proc == ctrl_proc) {
-        ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
-        connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
-    }
-    CLR_PENDING_CTRL_PROC(connsm, ctrl_proc);
+  if (connsm->cur_ctrl_proc == ctrl_proc)
+  {
+    ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
+    connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
+  }
+  CLR_PENDING_CTRL_PROC(connsm, ctrl_proc);
 
-    /* If there are others, start them */
-    ble_ll_ctrl_chk_proc_start(connsm);
+  /* If there are others, start them */
+  ble_ll_ctrl_chk_proc_start(connsm);
 }
 
 /**
@@ -2615,60 +2820,62 @@ ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
  *
  * @param connsm
  */
-void
-ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm)
+void ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm)
 {
-    int ctrl_proc;
-    uint32_t usecs;
-    struct os_mbuf *om;
+  int ctrl_proc;
+  uint32_t usecs;
+  struct os_mbuf *om;
 
-    BLE_LL_ASSERT(connsm->disconnect_reason != 0);
+  BLE_LL_ASSERT(connsm->disconnect_reason != 0);
 
-    ctrl_proc = BLE_LL_CTRL_PROC_TERMINATE;
-    om = ble_ll_ctrl_proc_init(connsm, ctrl_proc, NULL);
-    if (om) {
-        connsm->flags.terminate_started = 1;
+  ctrl_proc = BLE_LL_CTRL_PROC_TERMINATE;
+  om = ble_ll_ctrl_proc_init(connsm, ctrl_proc, NULL);
+  if (om)
+  {
+    connsm->flags.terminate_started = 1;
 
-        /* Set terminate "timeout" */
-        usecs = connsm->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000;
-        connsm->terminate_timeout = ble_ll_tmr_get() + ble_ll_tmr_u2t(usecs);
-    }
+    /* Set terminate "timeout" */
+    usecs = connsm->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000;
+    connsm->terminate_timeout = ble_ll_tmr_get() + ble_ll_tmr_u2t(usecs);
+  }
 }
 
 /**
- * Called to start a LL control procedure except for the terminate procedure. We
- * always set the control procedure pending bit even if the control procedure
- * has been initiated.
+ * Called to start a LL control procedure except for the terminate procedure.
+ * We always set the control procedure pending bit even if the control
+ * procedure has been initiated.
  *
  * Context: Link Layer task.
  *
  * @param connsm Pointer to connection state machine.
  */
-void
-ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc,
-                       void *data)
-{
-    struct os_mbuf *om;
-
-    BLE_LL_ASSERT(ctrl_proc != BLE_LL_CTRL_PROC_TERMINATE);
-
-    om = NULL;
-    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) {
-        /* Initiate the control procedure. */
-        om = ble_ll_ctrl_proc_init(connsm, ctrl_proc, data);
-        if (om) {
-            /* Set the current control procedure */
-            connsm->cur_ctrl_proc = ctrl_proc;
-
-            /* Initialize the procedure response timeout */
-            if (ctrl_proc != BLE_LL_CTRL_PROC_CHAN_MAP_UPD) {
-                ble_ll_ctrl_start_rsp_timer(connsm);
-            }
-        }
+void ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc,
+                            void *data)
+{
+  struct os_mbuf *om;
+
+  BLE_LL_ASSERT(ctrl_proc != BLE_LL_CTRL_PROC_TERMINATE);
+
+  om = NULL;
+  if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE)
+  {
+    /* Initiate the control procedure. */
+    om = ble_ll_ctrl_proc_init(connsm, ctrl_proc, data);
+    if (om)
+    {
+      /* Set the current control procedure */
+      connsm->cur_ctrl_proc = ctrl_proc;
+
+      /* Initialize the procedure response timeout */
+      if (ctrl_proc != BLE_LL_CTRL_PROC_CHAN_MAP_UPD)
+      {
+        ble_ll_ctrl_start_rsp_timer(connsm);
+      }
     }
+  }
 
-    /* Set bitmask denoting control procedure is pending */
-    connsm->pending_ctrl_procs |= (1 << ctrl_proc);
+  /* Set bitmask denoting control procedure is pending */
+  connsm->pending_ctrl_procs |= (1 << ctrl_proc);
 }
 
 /**
@@ -2679,55 +2886,60 @@ ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc,
  *
  * @param connsm Pointer to connection state machine.
  */
-void
-ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
-{
-    int i;
-
-    /* XXX: TODO new rules! Cannot start certain control procedures if other
-     * ones are peer initiated. We need to wait. Deal with this.
-     */
+void ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
+{
+  int i;
+
+  /* XXX: TODO new rules! Cannot start certain control procedures if other
+   * ones are peer initiated. We need to wait. Deal with this.
+   */
+
+  /*
+   * If we are terminating, dont start any new procedures but start
+   * terminate if needed
+   */
+  if (connsm->disconnect_reason)
+  {
+    if (!connsm->flags.terminate_started)
+    {
+      /*
+       * If the terminate procedure has not started it means we were not
+       * able to start it right away (no control pdu was available).
+       * Start it now. No need to start any other procedures.
+       */
+      ble_ll_ctrl_terminate_start(connsm);
+    }
+    return;
+  }
 
+  /* If there is a running procedure or no pending, do nothing */
+  if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) && (connsm->pending_ctrl_procs != 0))
+  {
     /*
-     * If we are terminating, dont start any new procedures but start
-     * terminate if needed
+     * The specification says there is no priority to control procedures
+     * so just start from the first one for now.
      */
-    if (connsm->disconnect_reason) {
-        if (!connsm->flags.terminate_started) {
-            /*
-             * If the terminate procedure has not started it means we were not
-             * able to start it right away (no control pdu was available).
-             * Start it now. No need to start any other procedures.
-             */
-            ble_ll_ctrl_terminate_start(connsm);
-        }
-        return;
-    }
-
-    /* If there is a running procedure or no pending, do nothing */
-    if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) &&
-        (connsm->pending_ctrl_procs != 0)) {
+    for (i = 0; i < BLE_LL_CTRL_PROC_NUM; ++i)
+    {
+      if (IS_PENDING_CTRL_PROC(connsm, i))
+      {
         /*
-         * The specification says there is no priority to control procedures
-         * so just start from the first one for now.
+         * The version exchange is a special case. If we have already
+         * received the information dont start it.
          */
-        for (i = 0; i < BLE_LL_CTRL_PROC_NUM; ++i) {
-            if (IS_PENDING_CTRL_PROC(connsm, i)) {
-                /*
-                 * The version exchange is a special case. If we have already
-                 * received the information dont start it.
-                 */
-                if ((i == BLE_LL_CTRL_PROC_VERSION_XCHG) &&
-                    (connsm->flags.version_ind_rxd)) {
-                    ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
-                    CLR_PENDING_CTRL_PROC(connsm, i);
-                } else {
-                    ble_ll_ctrl_proc_start(connsm, i, NULL);
-                    break;
-                }
-            }
+        if ((i == BLE_LL_CTRL_PROC_VERSION_XCHG) && (connsm->flags.version_ind_rxd))
+        {
+          ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
+          CLR_PENDING_CTRL_PROC(connsm, i);
         }
+        else
+        {
+          ble_ll_ctrl_proc_start(connsm, i, NULL);
+          break;
+        }
+      }
     }
+  }
 }
 
 /**
@@ -2743,310 +2955,350 @@ ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
  * @param om
  * @param connsm
  */
-int
-ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
-{
-    uint64_t features;
-    uint64_t feature;
-    uint8_t len;
-    uint8_t opcode;
-    uint8_t *dptr;
-    uint8_t *rspbuf;
-    uint8_t *rspdata;
+int ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
+{
+  uint64_t features;
+  uint64_t feature;
+  uint8_t len;
+  uint8_t opcode;
+  uint8_t *dptr;
+  uint8_t *rspbuf;
+  uint8_t *rspdata;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    int restart_encryption;
+  int restart_encryption;
 #endif
-    int rc = 0;
-    uint8_t rsp_opcode = 0;
+  int rc = 0;
+  uint8_t rsp_opcode = 0;
 
-    /* XXX: where do we validate length received and packet header length?
-     * do this in LL task when received. Someplace!!! What I mean
-     * is we should validate the over the air length with the mbuf length.
-       Should the PHY do that???? */
+  /* XXX: where do we validate length received and packet header length?
+   * do this in LL task when received. Someplace!!! What I mean
+   * is we should validate the over the air length with the mbuf length.
+     Should the PHY do that???? */
 
-    /*
-     * dptr points to om_data pointer. The first byte of om_data is the
-     * first byte of the Data Channel PDU header. Get length from header and
-     * opcode from LL control PDU.
-     */
-    dptr = om->om_data;
-    len = dptr[1];
-    opcode = dptr[2];
+  /*
+   * dptr points to om_data pointer. The first byte of om_data is the
+   * first byte of the Data Channel PDU header. Get length from header and
+   * opcode from LL control PDU.
+   */
+  dptr = om->om_data;
+  len = dptr[1];
+  opcode = dptr[2];
 
 #if MYNEWT_VAL(BLE_LL_HCI_LLCP_TRACE)
-    ble_ll_hci_ev_send_vs_llcp_trace(0x03, connsm->conn_handle,
-                                     connsm->event_cntr,
-                                     &dptr[2], len);
+  ble_ll_hci_ev_send_vs_llcp_trace(0x03, connsm->conn_handle,
+                                   connsm->event_cntr, &dptr[2], len);
 #endif
 
-    /*
-     * rspbuf points to first byte of response. The response buffer does not
-     * contain the Data Channel PDU. Thus, the first byte of rspbuf is the
-     * LL control PDU payload (the opcode of the control PDU). rspdata
-     * points to CtrData in the control PDU.
-     */
-    rspbuf = dptr;
-    rspdata = rspbuf + 1;
+  /*
+   * rspbuf points to first byte of response. The response buffer does not
+   * contain the Data Channel PDU. Thus, the first byte of rspbuf is the
+   * LL control PDU payload (the opcode of the control PDU). rspdata
+   * points to CtrData in the control PDU.
+   */
+  rspbuf = dptr;
+  rspdata = rspbuf + 1;
 
-    /* Move data pointer to start of control data (2 byte PDU hdr + opcode) */
-    dptr += (BLE_LL_PDU_HDR_LEN + 1);
+  /* Move data pointer to start of control data (2 byte PDU hdr + opcode) */
+  dptr += (BLE_LL_PDU_HDR_LEN + 1);
 
-    /*
-     * Subtract the opcode from the length. Note that if the length was zero,
-     * which would be an error, we will fail the check against the length
-     * of the control packet.
-     */
-    --len;
+  /*
+   * Subtract the opcode from the length. Note that if the length was zero,
+   * which would be an error, we will fail the check against the length
+   * of the control packet.
+   */
+  --len;
 
-    ble_ll_trace_u32x2(BLE_LL_TRACE_ID_CTRL_RX, opcode, len);
+  ble_ll_trace_u32x2(BLE_LL_TRACE_ID_CTRL_RX, opcode, len);
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    restart_encryption = 0;
-#endif
+  restart_encryption = 0;
+#endif
+
+  /* If opcode comes from reserved value or CtrlData fields is invalid
+   * we shall respond with LL_UNKNOWN_RSP
+   */
+  if ((opcode >= BLE_LL_CTRL_OPCODES) || (len != g_ble_ll_ctrl_pkt_lengths[opcode]))
+  {
+    rc = -1;
+    rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
+    goto ll_ctrl_send_rsp;
+  }
+
+  /* Check if the feature is supported. */
+  switch (opcode)
+  {
+  case BLE_LL_CTRL_LENGTH_REQ:
+    feature = BLE_LL_FEAT_DATA_LEN_EXT;
+    break;
+  case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
+    feature = BLE_LL_FEAT_PERIPH_INIT;
+    break;
+  case BLE_LL_CTRL_CONN_PARM_REQ:
+  case BLE_LL_CTRL_CONN_PARM_RSP:
+    feature = BLE_LL_FEAT_CONN_PARM_REQ;
+    break;
+  case BLE_LL_CTRL_ENC_REQ:
+    // Reject only if peripheral, otherwise no need
+    if (fr_times && force_reject && connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL)
+    {
+      if (connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ)
+      {
+        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+        rspbuf[1] = opcode;
+        rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;
+      }
+      else
+      {
+        rsp_opcode = BLE_LL_CTRL_REJECT_IND;
+        rspbuf[1] = BLE_ERR_UNSUPP_REM_FEATURE;
+      }
+      fr_times--;
+      goto ll_ctrl_send_rsp;
+    }
+  case BLE_LL_CTRL_START_ENC_REQ:
+  case BLE_LL_CTRL_PAUSE_ENC_REQ:
+    feature = BLE_LL_FEAT_LE_ENCRYPTION;
+    break;
+  case BLE_LL_CTRL_PING_REQ:
+    feature = BLE_LL_FEAT_LE_PING;
+    break;
+  case BLE_LL_CTRL_PHY_REQ:
+    feature = BLE_LL_FEAT_LE_2M_PHY | BLE_LL_FEAT_LE_CODED_PHY;
+    break;
+  case BLE_LL_CTRL_MIN_USED_CHAN_IND:
+    feature = BLE_LL_FEAT_MIN_USED_CHAN;
+    break;
+  case BLE_LL_CTRL_PERIODIC_SYNC_IND:
+    feature = BLE_LL_FEAT_SYNC_TRANS_RECV;
+    break;
+  case BLE_LL_CTRL_SUBRATE_REQ:
+  case BLE_LL_CTRL_SUBRATE_IND:
+    feature = BLE_LL_FEAT_CONN_SUBRATING;
+    break;
+  default:
+    feature = 0;
+    break;
+  }
+
+  if (feature)
+  {
+    features = ble_ll_read_supp_features();
+    if ((features & feature) == 0)
+    {
+      if (opcode == BLE_LL_CTRL_ENC_REQ)
+      {
+        if (connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ)
+        {
+          rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+          rspbuf[1] = opcode;
+          rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;
+        }
+        else
+        {
+          rsp_opcode = BLE_LL_CTRL_REJECT_IND;
+          rspbuf[1] = BLE_ERR_UNSUPP_REM_FEATURE;
+        }
+      }
+      else
+      {
+        /* Construct unknown rsp pdu */
+        rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
+      }
+      goto ll_ctrl_send_rsp;
+    }
+  }
+
+  /* Process opcode */
+  rsp_opcode = BLE_ERR_MAX;
+  switch (opcode)
+  {
+  case BLE_LL_CTRL_CONN_UPDATE_IND:
+    rsp_opcode = ble_ll_ctrl_rx_conn_update(connsm, dptr);
+    break;
+  case BLE_LL_CTRL_CHANNEL_MAP_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_chanmap_req(connsm, dptr);
+    break;
+  case BLE_LL_CTRL_LENGTH_REQ:
+    /* Extract parameters and check if valid */
+    if (ble_ll_ctrl_len_proc(connsm, dptr))
+    {
+      rc = -1;
+      rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
+      goto ll_ctrl_send_rsp;
+    }
 
-    /* If opcode comes from reserved value or CtrlData fields is invalid
-     * we shall respond with LL_UNKNOWN_RSP
+    /*
+     * If we have not started this procedure ourselves and it is
+     * pending, no need to perform it.
      */
-    if ((opcode >= BLE_LL_CTRL_OPCODES) ||
-        (len != g_ble_ll_ctrl_pkt_lengths[opcode])) {
+    if ((connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_DATA_LEN_UPD) && IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD))
+    {
+      CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
+    }
+
+    /* Send a response */
+    rsp_opcode = BLE_LL_CTRL_LENGTH_RSP;
+    ble_ll_ctrl_datalen_upd_make(connsm, rspbuf);
+    break;
+  case BLE_LL_CTRL_LENGTH_RSP:
+    /* According to specification, process this only if we asked for it. */
+    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_DATA_LEN_UPD)
+    {
+      /*
+       * Process the received data. If received data is invalid, we'll
+       * reply with LL_UNKNOWN_RSP as per spec, but we still need to stop
+       * control procedure to avoid timeout.
+       */
+      if (ble_ll_ctrl_len_proc(connsm, dptr))
+      {
         rc = -1;
         rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-        goto ll_ctrl_send_rsp;
-    }
-
-    /* Check if the feature is supported. */
-    switch (opcode) {
-    case BLE_LL_CTRL_LENGTH_REQ:
-        feature = BLE_LL_FEAT_DATA_LEN_EXT;
-        break;
-    case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
-        feature = BLE_LL_FEAT_PERIPH_INIT;
-        break;
-    case BLE_LL_CTRL_CONN_PARM_REQ:
-    case BLE_LL_CTRL_CONN_PARM_RSP:
-        feature = BLE_LL_FEAT_CONN_PARM_REQ;
-        break;
-    case BLE_LL_CTRL_ENC_REQ:
-    case BLE_LL_CTRL_START_ENC_REQ:
-    case BLE_LL_CTRL_PAUSE_ENC_REQ:
-        feature = BLE_LL_FEAT_LE_ENCRYPTION;
-        break;
-    case BLE_LL_CTRL_PING_REQ:
-        feature = BLE_LL_FEAT_LE_PING;
-        break;
-    case BLE_LL_CTRL_PHY_REQ:
-        feature = BLE_LL_FEAT_LE_2M_PHY | BLE_LL_FEAT_LE_CODED_PHY;
-        break;
-    case BLE_LL_CTRL_MIN_USED_CHAN_IND:
-        feature = BLE_LL_FEAT_MIN_USED_CHAN;
-        break;
-    case BLE_LL_CTRL_PERIODIC_SYNC_IND:
-        feature = BLE_LL_FEAT_SYNC_TRANS_RECV;
-        break;
-    case BLE_LL_CTRL_SUBRATE_REQ:
-    case BLE_LL_CTRL_SUBRATE_IND:
-        feature = BLE_LL_FEAT_CONN_SUBRATING;
-        break;
-    default:
-        feature = 0;
-        break;
-    }
-
-    if (feature) {
-        features = ble_ll_read_supp_features();
-        if ((features & feature) == 0) {
-            if (opcode == BLE_LL_CTRL_ENC_REQ) {
-                if (connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ) {
-                    rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-                    rspbuf[1] = opcode;
-                    rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;
-
-                } else {
-                    rsp_opcode = BLE_LL_CTRL_REJECT_IND;
-                    rspbuf[1] = BLE_ERR_UNSUPP_REM_FEATURE;
-                }
-            } else {
-                /* Construct unknown rsp pdu */
-                rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-            }
-            goto ll_ctrl_send_rsp;
-        }
-    }
-
-    /* Process opcode */
-    rsp_opcode = BLE_ERR_MAX;
-    switch (opcode) {
-    case BLE_LL_CTRL_CONN_UPDATE_IND:
-        rsp_opcode = ble_ll_ctrl_rx_conn_update(connsm, dptr);
-        break;
-    case BLE_LL_CTRL_CHANNEL_MAP_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_chanmap_req(connsm, dptr);
-        break;
-    case BLE_LL_CTRL_LENGTH_REQ:
-        /* Extract parameters and check if valid */
-        if (ble_ll_ctrl_len_proc(connsm, dptr)) {
-            rc  = -1;
-            rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-            goto ll_ctrl_send_rsp;
-        }
-
-        /*
-         * If we have not started this procedure ourselves and it is
-         * pending, no need to perform it.
-         */
-        if ((connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_DATA_LEN_UPD) &&
-            IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD)) {
-            CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
-        }
-
-        /* Send a response */
-        rsp_opcode = BLE_LL_CTRL_LENGTH_RSP;
-        ble_ll_ctrl_datalen_upd_make(connsm, rspbuf);
-        break;
-    case BLE_LL_CTRL_LENGTH_RSP:
-        /* According to specification, process this only if we asked for it. */
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_DATA_LEN_UPD) {
-            /*
-             * Process the received data. If received data is invalid, we'll
-             * reply with LL_UNKNOWN_RSP as per spec, but we still need to stop
-             * control procedure to avoid timeout.
-             */
-            if (ble_ll_ctrl_len_proc(connsm, dptr)) {
-                rc = -1;
-                rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-            }
-
-            /* Stop the control procedure */
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
-        }
-        break;
-    case BLE_LL_CTRL_UNKNOWN_RSP:
-        rsp_opcode = ble_ll_ctrl_proc_unk_rsp(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_FEATURE_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
-        break;
-    /* XXX: check to see if ctrl procedure was running? Do we care? */
-    case BLE_LL_CTRL_FEATURE_RSP:
-        ble_ll_ctrl_rx_feature_rsp(connsm, dptr);
-        break;
-    case BLE_LL_CTRL_VERSION_IND:
-        rsp_opcode = ble_ll_ctrl_rx_version_ind(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
-        break;
+      }
+
+      /* Stop the control procedure */
+      ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
+    }
+    break;
+  case BLE_LL_CTRL_UNKNOWN_RSP:
+    rsp_opcode = ble_ll_ctrl_proc_unk_rsp(connsm, dptr, rspdata);
+    break;
+  case BLE_LL_CTRL_FEATURE_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
+    break;
+  /* XXX: check to see if ctrl procedure was running? Do we care? */
+  case BLE_LL_CTRL_FEATURE_RSP:
+    ble_ll_ctrl_rx_feature_rsp(connsm, dptr);
+    break;
+  case BLE_LL_CTRL_VERSION_IND:
+    rsp_opcode = ble_ll_ctrl_rx_version_ind(connsm, dptr, rspdata);
+    break;
+  case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
+    break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    case BLE_LL_CTRL_ENC_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_enc_req(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_ENC_RSP:
-        ble_ll_ctrl_rx_enc_rsp(connsm, dptr);
-        break;
-    case BLE_LL_CTRL_START_ENC_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_start_enc_req(connsm);
-        break;
-    case BLE_LL_CTRL_START_ENC_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_start_enc_rsp(connsm);
-        break;
-    case BLE_LL_CTRL_PAUSE_ENC_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_pause_enc_req(connsm);
-        break;
-    case BLE_LL_CTRL_PAUSE_ENC_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_pause_enc_rsp(connsm);
-        if (rsp_opcode == BLE_LL_CTRL_PAUSE_ENC_RSP) {
-            restart_encryption = 1;
-        }
-        break;
-#endif
-    case BLE_LL_CTRL_PING_REQ:
-        rsp_opcode = BLE_LL_CTRL_PING_RSP;
-        break;
-    case BLE_LL_CTRL_PING_RSP:
-        ble_ll_ctrl_rx_ping_rsp(connsm);
-        break;
-    case BLE_LL_CTRL_CONN_PARM_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_conn_param_req(connsm, dptr, rspbuf);
-        break;
-    case BLE_LL_CTRL_CONN_PARM_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_conn_param_rsp(connsm, dptr, rspbuf);
-        break;
-    /* Fall-through intentional... */
-    case BLE_LL_CTRL_REJECT_IND:
-    case BLE_LL_CTRL_REJECT_IND_EXT:
-        /* Sometimes reject triggers sending other LL CTRL msg */
-        rsp_opcode = ble_ll_ctrl_rx_reject_ind(connsm, dptr, opcode, rspdata);
-        break;
+  case BLE_LL_CTRL_ENC_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_enc_req(connsm, dptr, rspdata);
+    break;
+  case BLE_LL_CTRL_ENC_RSP:
+    ble_ll_ctrl_rx_enc_rsp(connsm, dptr);
+    break;
+  case BLE_LL_CTRL_START_ENC_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_start_enc_req(connsm);
+    break;
+  case BLE_LL_CTRL_START_ENC_RSP:
+    rsp_opcode = ble_ll_ctrl_rx_start_enc_rsp(connsm);
+    break;
+  case BLE_LL_CTRL_PAUSE_ENC_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_pause_enc_req(connsm);
+    break;
+  case BLE_LL_CTRL_PAUSE_ENC_RSP:
+    rsp_opcode = ble_ll_ctrl_rx_pause_enc_rsp(connsm);
+    if (rsp_opcode == BLE_LL_CTRL_PAUSE_ENC_RSP)
+    {
+      restart_encryption = 1;
+    }
+    break;
+#endif
+  case BLE_LL_CTRL_PING_REQ:
+    rsp_opcode = BLE_LL_CTRL_PING_RSP;
+    break;
+  case BLE_LL_CTRL_PING_RSP:
+    ble_ll_ctrl_rx_ping_rsp(connsm);
+    break;
+  case BLE_LL_CTRL_CONN_PARM_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_conn_param_req(connsm, dptr, rspbuf);
+    break;
+  case BLE_LL_CTRL_CONN_PARM_RSP:
+    rsp_opcode = ble_ll_ctrl_rx_conn_param_rsp(connsm, dptr, rspbuf);
+    break;
+  /* Fall-through intentional... */
+  case BLE_LL_CTRL_REJECT_IND:
+  case BLE_LL_CTRL_REJECT_IND_EXT:
+    /* Sometimes reject triggers sending other LL CTRL msg */
+    rsp_opcode = ble_ll_ctrl_rx_reject_ind(connsm, dptr, opcode, rspdata);
+    break;
 #if MYNEWT_VAL(BLE_LL_PHY)
-    case BLE_LL_CTRL_PHY_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_phy_req(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_PHY_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_phy_rsp(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_PHY_UPDATE_IND:
-        rsp_opcode = ble_ll_ctrl_rx_phy_update_ind(connsm, dptr);
-        break;
+  case BLE_LL_CTRL_PHY_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_phy_req(connsm, dptr, rspdata);
+    break;
+  case BLE_LL_CTRL_PHY_RSP:
+    rsp_opcode = ble_ll_ctrl_rx_phy_rsp(connsm, dptr, rspdata);
+    break;
+  case BLE_LL_CTRL_PHY_UPDATE_IND:
+    rsp_opcode = ble_ll_ctrl_rx_phy_update_ind(connsm, dptr);
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-    case BLE_LL_CTRL_CLOCK_ACCURACY_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_sca_req(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_CLOCK_ACCURACY_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_sca_rsp(connsm, dptr);
-        break;
+  case BLE_LL_CTRL_CLOCK_ACCURACY_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_sca_req(connsm, dptr, rspdata);
+    break;
+  case BLE_LL_CTRL_CLOCK_ACCURACY_RSP:
+    rsp_opcode = ble_ll_ctrl_rx_sca_rsp(connsm, dptr);
+    break;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
-    case BLE_LL_CTRL_PERIODIC_SYNC_IND:
-        rsp_opcode = ble_ll_ctrl_rx_periodic_sync_ind(connsm, dptr);
-        break;
+  case BLE_LL_CTRL_PERIODIC_SYNC_IND:
+    rsp_opcode = ble_ll_ctrl_rx_periodic_sync_ind(connsm, dptr);
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    case BLE_LL_CTRL_SUBRATE_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_subrate_req(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_SUBRATE_IND:
-        rsp_opcode = ble_ll_ctrl_rx_subrate_ind(connsm, dptr, rspdata);
-        break;
-#endif
-    default:
-        /* Nothing to do here */
-        break;
-    }
-
-    /* Free mbuf or send response */
+  case BLE_LL_CTRL_SUBRATE_REQ:
+    rsp_opcode = ble_ll_ctrl_rx_subrate_req(connsm, dptr, rspdata);
+    break;
+  case BLE_LL_CTRL_SUBRATE_IND:
+    rsp_opcode = ble_ll_ctrl_rx_subrate_ind(connsm, dptr, rspdata);
+    break;
+#endif
+  default:
+    /* Nothing to do here */
+    break;
+  }
+
+  /* Free mbuf or send response */
 ll_ctrl_send_rsp:
-    if (rsp_opcode == BLE_ERR_MAX) {
-        os_mbuf_free_chain(om);
-    } else {
-        /*
-         * Write the response opcode into the buffer. If this is an unknown
-         * response, put opcode of unknown pdu into buffer.
-         */
-        rspbuf[0] = rsp_opcode;
-        if (rsp_opcode == BLE_LL_CTRL_UNKNOWN_RSP) {
-            rspbuf[1] = opcode;
-        }
-        len = g_ble_ll_ctrl_pkt_lengths[rsp_opcode] + 1;
-        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
+  if (rsp_opcode == BLE_ERR_MAX)
+  {
+    os_mbuf_free_chain(om);
+  }
+  else
+  {
+    /*
+     * Write the response opcode into the buffer. If this is an unknown
+     * response, put opcode of unknown pdu into buffer.
+     */
+    rspbuf[0] = rsp_opcode;
+    if (rsp_opcode == BLE_LL_CTRL_UNKNOWN_RSP)
+    {
+      rspbuf[1] = opcode;
+    }
+    len = g_ble_ll_ctrl_pkt_lengths[rsp_opcode] + 1;
+    ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-        if (restart_encryption) {
-            /* XXX: what happens if this fails? Meaning we cant allocate
-               mbuf? */
-            ble_ll_ctrl_proc_init(connsm, BLE_LL_CTRL_PROC_ENCRYPT, NULL);
-        }
-#endif
+    if (restart_encryption)
+    {
+      /* XXX: what happens if this fails? Meaning we cant allocate
+         mbuf? */
+      ble_ll_ctrl_proc_init(connsm, BLE_LL_CTRL_PROC_ENCRYPT, NULL);
     }
+#endif
+  }
 
 #if MYNEWT_VAL(BLE_LL_CONN_INIT_AUTO_DLE)
-    if (connsm->flags.pending_initiate_dle) {
-        connsm->flags.pending_initiate_dle = 0;
-        ble_ll_ctrl_initiate_dle(connsm, true);
-    }
+  if (connsm->flags.pending_initiate_dle)
+  {
+    connsm->flags.pending_initiate_dle = 0;
+    ble_ll_ctrl_initiate_dle(connsm, true);
+  }
 #endif
 
-    return rc;
+  if (force_reject == 1 && fr_times == 0 && opcode == BLE_LL_CTRL_ENC_REQ && connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL)
+  {
+    force_reject = 0;
+    ble_ll_hci_ev_conn_update(connsm, BLE_ERR_MAX);
+  }
+
+  return rc;
 }
 
 /**
@@ -3058,76 +3310,83 @@ ll_ctrl_send_rsp:
  *
  * @return int
  */
-int
-ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm, uint8_t rej_opcode,
-                            uint8_t err)
-{
-    int rc;
-    uint8_t len;
-    uint8_t opcode;
-    uint8_t *rspbuf;
-    struct os_mbuf *om;
-
-    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
-                            sizeof(struct ble_mbuf_hdr));
-    if (om) {
-        rspbuf = om->om_data;
-        opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        if (rej_opcode == BLE_LL_CTRL_ENC_REQ) {
-            if ((connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ) == 0) {
-                opcode = BLE_LL_CTRL_REJECT_IND;
-            }
-        }
-        rspbuf[0] = opcode;
-        if (opcode == BLE_LL_CTRL_REJECT_IND) {
-            rspbuf[1] = err;
-            len = BLE_LL_CTRL_REJ_IND_LEN + 1;
-        } else {
-            rspbuf[1] = rej_opcode;
-            rspbuf[2] = err;
-            len = BLE_LL_CTRL_REJECT_IND_EXT_LEN + 1;
-        }
-        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
-        rc = 0;
-    } else {
-        rc = 1;
-    }
-    return rc;
-}
-
-int
-ble_ll_ctrl_tx_start(struct ble_ll_conn_sm *connsm, struct os_mbuf *txpdu)
-{
-    uint8_t opcode;
-    uint8_t *ctrdata;
-
-    opcode = txpdu->om_data[0];
-    ctrdata = &txpdu->om_data[1];
-
-    switch (opcode) {
-    case BLE_LL_CTRL_CONN_UPDATE_IND:
-        ble_ll_ctrl_conn_update_make_ind_pdu(connsm, ctrdata);
-        connsm->flags.conn_update_sched = 1;
-        break;
-    case BLE_LL_CTRL_CHANNEL_MAP_REQ:
-        ble_ll_ctrl_chanmap_req_instant(connsm, ctrdata);
-        connsm->flags.chanmap_update_sched = 1;
-        break;
+int ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm, uint8_t rej_opcode,
+                                uint8_t err)
+{
+  int rc;
+  uint8_t len;
+  uint8_t opcode;
+  uint8_t *rspbuf;
+  struct os_mbuf *om;
+
+  om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN, sizeof(struct ble_mbuf_hdr));
+  if (om)
+  {
+    rspbuf = om->om_data;
+    opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+    if (rej_opcode == BLE_LL_CTRL_ENC_REQ)
+    {
+      if ((connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ) == 0)
+      {
+        opcode = BLE_LL_CTRL_REJECT_IND;
+      }
+    }
+    rspbuf[0] = opcode;
+    if (opcode == BLE_LL_CTRL_REJECT_IND)
+    {
+      rspbuf[1] = err;
+      len = BLE_LL_CTRL_REJ_IND_LEN + 1;
+    }
+    else
+    {
+      rspbuf[1] = rej_opcode;
+      rspbuf[2] = err;
+      len = BLE_LL_CTRL_REJECT_IND_EXT_LEN + 1;
+    }
+    ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
+    rc = 0;
+  }
+  else
+  {
+    rc = 1;
+  }
+  return rc;
+}
+
+int ble_ll_ctrl_tx_start(struct ble_ll_conn_sm *connsm, struct os_mbuf *txpdu)
+{
+  uint8_t opcode;
+  uint8_t *ctrdata;
+
+  opcode = txpdu->om_data[0];
+  ctrdata = &txpdu->om_data[1];
+
+  switch (opcode)
+  {
+  case BLE_LL_CTRL_CONN_UPDATE_IND:
+    ble_ll_ctrl_conn_update_make_ind_pdu(connsm, ctrdata);
+    connsm->flags.conn_update_sched = 1;
+    break;
+  case BLE_LL_CTRL_CHANNEL_MAP_REQ:
+    ble_ll_ctrl_chanmap_req_instant(connsm, ctrdata);
+    connsm->flags.chanmap_update_sched = 1;
+    break;
 #if MYNEWT_VAL(BLE_LL_PHY)
-    case BLE_LL_CTRL_PHY_UPDATE_IND:
-        if (ble_ll_ctrl_phy_update_ind_instant(connsm, ctrdata)) {
-            connsm->flags.phy_update_sched = 1;
-        }
-        break;
+  case BLE_LL_CTRL_PHY_UPDATE_IND:
+    if (ble_ll_ctrl_phy_update_ind_instant(connsm, ctrdata))
+    {
+      connsm->flags.phy_update_sched = 1;
+    }
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    case BLE_LL_CTRL_SUBRATE_IND:
-        connsm->flags.subrate_trans = 1;
-        break;
+  case BLE_LL_CTRL_SUBRATE_IND:
+    connsm->flags.subrate_trans = 1;
+    break;
 #endif
-    }
+  }
 
-    return 0;
+  return 0;
 }
 
 /**
@@ -3140,114 +3399,118 @@ ble_ll_ctrl_tx_start(struct ble_ll_conn_sm *connsm, struct os_mbuf *txpdu)
  *
  * @return int
  */
-int
-ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
+int ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
 {
-    int rc;
-    uint8_t opcode;
+  int rc;
+  uint8_t opcode;
 
 #if MYNEWT_VAL(BLE_LL_HCI_LLCP_TRACE)
-    ble_ll_hci_ev_send_vs_llcp_trace(0x04, connsm->conn_handle,
-                                     connsm->event_cntr,
-                                     txpdu->om_data, txpdu->om_len);
-#endif
-
-    rc = 0;
-    opcode = txpdu->om_data[0];
-    switch (opcode) {
-    case BLE_LL_CTRL_TERMINATE_IND:
-        connsm->flags.terminate_ind_txd = 1;
-        rc = -1;
-        break;
-    case BLE_LL_CTRL_REJECT_IND_EXT:
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ) {
-            /* If rejecting opcode is BLE_LL_CTRL_PROC_CONN_PARAM_REQ and
-             * reason is LMP collision that means we are central on the link and
-             * peer wanted to start procedure which we already started.
-             * Let's wait for response and do not close procedure. */
-            if (txpdu->om_data[1] == BLE_LL_CTRL_CONN_PARM_REQ &&
-                            txpdu->om_data[2] != BLE_ERR_LMP_COLLISION) {
-                connsm->reject_reason = txpdu->om_data[2];
-                connsm->flags.conn_update_host_w4event = 1;
-            }
-        }
+  ble_ll_hci_ev_send_vs_llcp_trace(0x04, connsm->conn_handle, connsm->event_cntr,
+                                   txpdu->om_data, txpdu->om_len);
+#endif
+
+  rc = 0;
+  opcode = txpdu->om_data[0];
+  switch (opcode)
+  {
+  case BLE_LL_CTRL_TERMINATE_IND:
+    connsm->flags.terminate_ind_txd = 1;
+    rc = -1;
+    break;
+  case BLE_LL_CTRL_REJECT_IND_EXT:
+    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ)
+    {
+      /* If rejecting opcode is BLE_LL_CTRL_PROC_CONN_PARAM_REQ and
+       * reason is LMP collision that means we are central on the link and
+       * peer wanted to start procedure which we already started.
+       * Let's wait for response and do not close procedure. */
+      if (txpdu->om_data[1] == BLE_LL_CTRL_CONN_PARM_REQ &&
+          txpdu->om_data[2] != BLE_ERR_LMP_COLLISION)
+      {
+        connsm->reject_reason = txpdu->om_data[2];
+        connsm->flags.conn_update_host_w4event = 1;
+      }
+    }
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-        if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
-            connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
-        }
+    if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED)
+    {
+      connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
+    }
 #endif
-        break;
-    case BLE_LL_CTRL_REJECT_IND:
+    break;
+  case BLE_LL_CTRL_REJECT_IND:
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-        connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
+    connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
 #endif
-        break;
+    break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    case BLE_LL_CTRL_PAUSE_ENC_REQ:
-        /* note: fall-through intentional */
-    case BLE_LL_CTRL_ENC_REQ:
-        connsm->enc_data.enc_state = CONN_ENC_S_ENC_RSP_WAIT;
-        break;
-    case BLE_LL_CTRL_ENC_RSP:
-        connsm->enc_data.enc_state = CONN_ENC_S_LTK_REQ_WAIT;
-        connsm->flags.encrypt_ltk_req = 1;
-        break;
+  case BLE_LL_CTRL_PAUSE_ENC_REQ:
+    /* note: fall-through intentional */
+  case BLE_LL_CTRL_ENC_REQ:
+    connsm->enc_data.enc_state = CONN_ENC_S_ENC_RSP_WAIT;
+    break;
+  case BLE_LL_CTRL_ENC_RSP:
+    // Here we should request the LTK from the host
+    connsm->enc_data.enc_state = CONN_ENC_S_LTK_REQ_WAIT;
+    connsm->flags.encrypt_ltk_req = 1;
+    break;
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CTRL_START_ENC_RSP:
-        if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-            connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
-            if (connsm->flags.le_ping_supp) {
-                ble_ll_conn_auth_pyld_timer_start(connsm);
-            }
-        }
-        break;
-    case BLE_LL_CTRL_PAUSE_ENC_RSP:
-        if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-            connsm->enc_data.enc_state = CONN_ENC_S_PAUSE_ENC_RSP_WAIT;
-        }
-        break;
+  case BLE_LL_CTRL_START_ENC_RSP:
+    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL)
+    {
+      connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
+      if (connsm->flags.le_ping_supp)
+      {
+        ble_ll_conn_auth_pyld_timer_start(connsm);
+      }
+    }
+    break;
+  case BLE_LL_CTRL_PAUSE_ENC_RSP:
+    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL)
+    {
+      connsm->enc_data.enc_state = CONN_ENC_S_PAUSE_ENC_RSP_WAIT;
+    }
+    break;
 #endif
 #endif
 #if MYNEWT_VAL(BLE_LL_PHY)
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CTRL_PHY_REQ:
-        if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-            connsm->phy_tx_transition =
-                    ble_ll_ctrl_phy_tx_transition_get(
-                            connsm->phy_data.pref_mask_tx_req);
-        }
-        break;
+  case BLE_LL_CTRL_PHY_REQ:
+    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL)
+    {
+      connsm->phy_tx_transition =
+          ble_ll_ctrl_phy_tx_transition_get(connsm->phy_data.pref_mask_tx_req);
+    }
+    break;
 #endif
-    case BLE_LL_CTRL_PHY_UPDATE_IND:
-        connsm->phy_tx_transition =
-                    ble_ll_ctrl_phy_tx_transition_get(txpdu->om_data[2]);
-        break;
+  case BLE_LL_CTRL_PHY_UPDATE_IND:
+    connsm->phy_tx_transition = ble_ll_ctrl_phy_tx_transition_get(txpdu->om_data[2]);
+    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CTRL_SUBRATE_IND:
-        connsm->flags.subrate_trans = 0;
-        connsm->flags.subrate_ind_txd = 1;
-        break;
+  case BLE_LL_CTRL_SUBRATE_IND:
+    connsm->flags.subrate_trans = 0;
+    connsm->flags.subrate_ind_txd = 1;
+    break;
 #endif /* BLE_LL_CTRL_SUBRATE_IND */
 #endif /* BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE */
-    default:
-        break;
-    }
+  default:
+    break;
+  }
 
-    os_mbuf_free_chain(txpdu);
-    return rc;
+  os_mbuf_free_chain(txpdu);
+  return rc;
 }
 
-void
-ble_ll_ctrl_init_conn_sm(struct ble_ll_conn_sm *connsm)
+void ble_ll_ctrl_init_conn_sm(struct ble_ll_conn_sm *connsm)
 {
-    ble_npl_callout_init(&connsm->ctrl_proc_rsp_timer, &g_ble_ll_data.ll_evq,
-                         ble_ll_ctrl_proc_rsp_timer_cb, connsm);
+  ble_npl_callout_init(&connsm->ctrl_proc_rsp_timer, &g_ble_ll_data.ll_evq,
+                       ble_ll_ctrl_proc_rsp_timer_cb, connsm);
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
-    ble_npl_callout_init(&connsm->auth_pyld_timer, &g_ble_ll_data.ll_evq,
-                         ble_ll_conn_auth_pyld_timer_cb, connsm);
+  ble_npl_callout_init(&connsm->auth_pyld_timer, &g_ble_ll_data.ll_evq,
+                       ble_ll_conn_auth_pyld_timer_cb, connsm);
 #endif
 }
 #endif
diff --git a/nimble/controller/src/ble_ll_hci.c b/nimble/controller/src/ble_ll_hci.c
index 6e5f4689..edfca955 100644
--- a/nimble/controller/src/ble_ll_hci.c
+++ b/nimble/controller/src/ble_ll_hci.c
@@ -63,20 +63,19 @@ static void *hci_cmd_post_cb_user_data = NULL;
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
 static enum {
-    ADV_MODE_ANY,
-    ADV_MODE_LEGACY,
-    ADV_MODE_EXT,
+	ADV_MODE_ANY,
+	ADV_MODE_LEGACY,
+	ADV_MODE_EXT,
 } hci_adv_mode;
 
 bool ble_ll_hci_adv_mode_ext(void)
 {
-    return hci_adv_mode == ADV_MODE_EXT;
+	return hci_adv_mode == ADV_MODE_EXT;
 }
 #else
-bool
-ble_ll_hci_adv_mode_ext(void)
+bool ble_ll_hci_adv_mode_ext(void)
 {
-    return false;
+	return false;
 }
 #endif
 
@@ -88,10 +87,9 @@ ble_ll_hci_adv_mode_ext(void)
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_hci_get_num_cmd_pkts(void)
+static uint8_t ble_ll_hci_get_num_cmd_pkts(void)
 {
-    return BLE_LL_CFG_NUM_HCI_CMD_PKTS;
+	return BLE_LL_CFG_NUM_HCI_CMD_PKTS;
 }
 
 /**
@@ -101,49 +99,47 @@ ble_ll_hci_get_num_cmd_pkts(void)
  *
  * @return int 0: success; -1 otherwise.
  */
-int
-ble_ll_hci_event_send(struct ble_hci_ev *hci_ev)
+int ble_ll_hci_event_send(struct ble_hci_ev *hci_ev)
 {
-    int rc;
+	int rc;
 
-    BLE_LL_DEBUG_GPIO(HCI_EV, 1);
+	BLE_LL_DEBUG_GPIO(HCI_EV, 1);
 
-    BLE_LL_ASSERT(sizeof(*hci_ev) + hci_ev->length <= BLE_LL_MAX_EVT_LEN);
+	BLE_LL_ASSERT(sizeof(*hci_ev) + hci_ev->length <= BLE_LL_MAX_EVT_LEN);
 
-    /* Count number of events sent */
-    STATS_INC(ble_ll_stats, hci_events_sent);
+	/* Count number of events sent */
+	STATS_INC(ble_ll_stats, hci_events_sent);
 
-    /* Send the event to the host */
-    rc = ble_transport_to_hs_evt(hci_ev);
+	/* Send the event to the host */
+	rc = ble_transport_to_hs_evt(hci_ev);
 
-    BLE_LL_DEBUG_GPIO(HCI_EV, 0);
+	BLE_LL_DEBUG_GPIO(HCI_EV, 0);
 
-    return rc;
+	return rc;
 }
 
 /**
  * Created and sends a command complete event with the no-op opcode to the
  * host.
  */
-void
-ble_ll_hci_send_noop(void)
+void ble_ll_hci_send_noop(void)
 {
-    struct ble_hci_ev_command_complete_nop *ev;
-    struct ble_hci_ev *hci_ev;
+	struct ble_hci_ev_command_complete_nop *ev;
+	struct ble_hci_ev *hci_ev;
 
-    hci_ev = ble_transport_alloc_evt(0);
-    if (hci_ev) {
-        /* Create a command complete event with a NO-OP opcode */
-        hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_COMPLETE;
+	hci_ev = ble_transport_alloc_evt(0);
+	if (hci_ev) {
+		/* Create a command complete event with a NO-OP opcode */
+		hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_COMPLETE;
 
-        hci_ev->length = sizeof(*ev);
-        ev = (void *)hci_ev->data;
+		hci_ev->length = sizeof(*ev);
+		ev = (void *) hci_ev->data;
 
-        ev->num_packets = ble_ll_hci_get_num_cmd_pkts();
-        ev->opcode = BLE_HCI_OPCODE_NOP;
+		ev->num_packets = ble_ll_hci_get_num_cmd_pkts();
+		ev->opcode = BLE_HCI_OPCODE_NOP;
 
-        ble_ll_hci_event_send(hci_ev);
-    }
+		ble_ll_hci_event_send(hci_ev);
+	}
 }
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
@@ -156,28 +152,28 @@ ble_ll_hci_send_noop(void)
  *
  * @return int
  */
-static int
-ble_ll_hci_le_encrypt(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf,
-                      uint8_t *rsplen)
+static int ble_ll_hci_le_encrypt(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf,
+                                 uint8_t *rsplen)
 {
-    const struct ble_hci_le_encrypt_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_le_encrypt_rp *rsp = (void *)rspbuf;
-    struct ble_encryption_block ecb;
-    int rc;
-
-    /* Call the link layer to encrypt the data */
-    swap_buf(ecb.key, cmd->key, BLE_ENC_BLOCK_SIZE);
-    swap_buf(ecb.plain_text, cmd->data, BLE_ENC_BLOCK_SIZE);
-    rc = ble_hw_encrypt_block(&ecb);
-    if (!rc) {
-        swap_buf(rsp->data, ecb.cipher_text, BLE_ENC_BLOCK_SIZE);
-        *rsplen = sizeof(*rsp);
-        rc = BLE_ERR_SUCCESS;
-    } else {
-        rc = BLE_ERR_CTLR_BUSY;
-    }
-
-    return rc;
+	const struct ble_hci_le_encrypt_cp *cmd = (const void *) cmdbuf;
+	struct ble_hci_le_encrypt_rp *rsp = (void *) rspbuf;
+	struct ble_encryption_block ecb;
+	int rc;
+
+	/* Call the link layer to encrypt the data */
+	swap_buf(ecb.key, cmd->key, BLE_ENC_BLOCK_SIZE);
+	swap_buf(ecb.plain_text, cmd->data, BLE_ENC_BLOCK_SIZE);
+	rc = ble_hw_encrypt_block(&ecb);
+	if (!rc) {
+		swap_buf(rsp->data, ecb.cipher_text, BLE_ENC_BLOCK_SIZE);
+		*rsplen = sizeof(*rsp);
+		rc = BLE_ERR_SUCCESS;
+	}
+	else {
+		rc = BLE_ERR_CTLR_BUSY;
+	}
+
+	return rc;
 }
 #endif
 
@@ -190,16 +186,14 @@ ble_ll_hci_le_encrypt(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf,
  *
  * @return int
  */
-static int
-ble_ll_hci_le_rand(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_le_rand(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rand_rp *rsp = (void *) rspbuf;
+	struct ble_hci_le_rand_rp *rsp = (void *) rspbuf;
 
-    ble_ll_rand_data_get((uint8_t *)&rsp->random_number,
-                         sizeof(rsp->random_number));
+	ble_ll_rand_data_get((uint8_t *) &rsp->random_number, sizeof(rsp->random_number));
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -210,19 +204,18 @@ ble_ll_hci_le_rand(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int
  */
-static int
-ble_ll_hci_rd_local_version(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_rd_local_version(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_ip_rd_local_ver_rp *rsp = (void *) rspbuf;
+	struct ble_hci_ip_rd_local_ver_rp *rsp = (void *) rspbuf;
 
-    rsp->hci_ver = BLE_HCI_VER_BCS;
-    rsp->hci_rev = 0;
-    rsp->lmp_ver = BLE_LMP_VER_BCS;
-    rsp->manufacturer = htole16(MYNEWT_VAL(BLE_LL_MANUFACTURER_ID));
-    rsp->lmp_subver = 0;
+	rsp->hci_ver = BLE_HCI_VER_BCS;
+	rsp->hci_rev = 0;
+	rsp->lmp_ver = BLE_LMP_VER_BCS;
+	rsp->manufacturer = htole16(MYNEWT_VAL(BLE_LL_MANUFACTURER_ID));
+	rsp->lmp_subver = 0;
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -233,20 +226,19 @@ ble_ll_hci_rd_local_version(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int
  */
-static int
-ble_ll_hci_rd_local_supp_feat(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_rd_local_supp_feat(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_ip_rd_loc_supp_feat_rp *rsp = (void *) rspbuf;
+	struct ble_hci_ip_rd_loc_supp_feat_rp *rsp = (void *) rspbuf;
 
-    /*
-     * The only two bits we set here currently are (5th byte):
-     *      BR/EDR not supported        (bit 5)
-     *      LE supported (controller)   (bit 6)
-     */
-    rsp->features = htole64(0x0000006000000000);
+	/*
+	 * The only two bits we set here currently are (5th byte):
+	 *      BR/EDR not supported        (bit 5)
+	 *      LE supported (controller)   (bit 6)
+	 */
+	rsp->features = htole64(0x0000006000000000);
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -257,15 +249,14 @@ ble_ll_hci_rd_local_supp_feat(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int
  */
-static int
-ble_ll_hci_rd_local_supp_cmd(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_rd_local_supp_cmd(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_ip_rd_loc_supp_cmd_rp *rsp = (void *) rspbuf;
+	struct ble_hci_ip_rd_loc_supp_cmd_rp *rsp = (void *) rspbuf;
 
-    ble_ll_hci_supp_cmd_get(rsp->commands);
+	ble_ll_hci_supp_cmd_get(rsp->commands);
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -277,15 +268,14 @@ ble_ll_hci_rd_local_supp_cmd(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int
  */
-static int
-ble_ll_hci_rd_bd_addr(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_rd_bd_addr(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_ip_rd_bd_addr_rp *rsp = (void *) rspbuf;
+	struct ble_hci_ip_rd_bd_addr_rp *rsp = (void *) rspbuf;
 
-    memcpy(rsp->addr, g_dev_addr, BLE_DEV_ADDR_LEN);
+	memcpy(rsp->addr, g_dev_addr, BLE_DEV_ADDR_LEN);
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -299,18 +289,17 @@ ble_ll_hci_rd_bd_addr(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int BLE_ERR_SUCCESS. Does not return any errors.
  */
-static int
-ble_ll_hci_set_le_event_mask(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_hci_set_le_event_mask(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_set_event_mask_cp *cmd = (const void *) cmdbuf;
+	const struct ble_hci_le_set_event_mask_cp *cmd = (const void *) cmdbuf;
 
-    if (len != sizeof(*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    g_ble_ll_hci_le_event_mask = le64toh(cmd->event_mask);
+	g_ble_ll_hci_le_event_mask = le64toh(cmd->event_mask);
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -322,22 +311,21 @@ ble_ll_hci_set_le_event_mask(const uint8_t *cmdbuf, uint8_t len)
  *
  * @return int BLE error code
  */
-static int
-ble_ll_hci_le_read_bufsize(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_le_read_bufsize(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_buf_size_rp *rp = (void *) rspbuf;
+	struct ble_hci_le_rd_buf_size_rp *rp = (void *) rspbuf;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    rp->data_len = htole16(g_ble_ll_data.ll_acl_pkt_size);
-    rp->data_packets = g_ble_ll_data.ll_num_acl_pkts;
+	rp->data_len = htole16(g_ble_ll_data.ll_acl_pkt_size);
+	rp->data_packets = g_ble_ll_data.ll_num_acl_pkts;
 #else
-    /* TODO check if can just not support this command */
-    rp->data_len = 0;
-    rp->data_packets = 0;
+	/* TODO check if can just not support this command */
+	rp->data_len = 0;
+	rp->data_packets = 0;
 #endif
 
-    *rsplen = sizeof(*rp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rp);
+	return BLE_ERR_SUCCESS;
 }
 
 #if MYNEWT_VAL(BLE_LL_ISO)
@@ -350,24 +338,23 @@ ble_ll_hci_le_read_bufsize(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int BLE error code
  */
-static int
-ble_ll_hci_le_read_bufsize_v2(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_le_read_bufsize_v2(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_buf_size_v2_rp *rp = (void *) rspbuf;
+	struct ble_hci_le_rd_buf_size_v2_rp *rp = (void *) rspbuf;
 
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    rp->data_len = htole16(g_ble_ll_data.ll_acl_pkt_size);
-    rp->data_packets = g_ble_ll_data.ll_num_acl_pkts;
+	rp->data_len = htole16(g_ble_ll_data.ll_acl_pkt_size);
+	rp->data_packets = g_ble_ll_data.ll_num_acl_pkts;
 #else
-    rp->data_len = 0;
-    rp->data_packets = 0;
+	rp->data_len = 0;
+	rp->data_packets = 0;
 #endif
-    rp->iso_data_len = htole16(g_ble_ll_data.ll_iso_pkt_size);
-    rp->iso_data_packets = g_ble_ll_data.ll_num_iso_pkts;
+	rp->iso_data_len = htole16(g_ble_ll_data.ll_iso_pkt_size);
+	rp->iso_data_packets = g_ble_ll_data.ll_num_iso_pkts;
 
-    *rsplen = sizeof(*rp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rp);
+	return BLE_ERR_SUCCESS;
 }
 #endif
 
@@ -378,46 +365,45 @@ ble_ll_hci_le_read_bufsize_v2(uint8_t *rspbuf, uint8_t *rsplen)
 
  * @return int BLE_ERR_SUCCESS or BLE_ERR_INV_HCI_CMD_PARMS or BLE_ERR_UNSUPPORTED
  */
-int
-ble_ll_hci_chk_phy_masks(uint8_t all_phys, uint8_t tx_phys, uint8_t rx_phys,
-                         uint8_t *txphy, uint8_t *rxphy)
+int ble_ll_hci_chk_phy_masks(uint8_t all_phys, uint8_t tx_phys, uint8_t rx_phys,
+                             uint8_t *txphy, uint8_t *rxphy)
 {
-    /* Check for RFU */
-    if ((tx_phys & ~BLE_HCI_LE_PHY_PREF_MASK_ALL) ||
-                    (rx_phys & ~BLE_HCI_LE_PHY_PREF_MASK_ALL)) {
-        return BLE_ERR_UNSUPPORTED;
-    }
-
-    if ((!(all_phys & BLE_HCI_LE_PHY_NO_TX_PREF_MASK) && (tx_phys == 0)) ||
-        (!(all_phys & BLE_HCI_LE_PHY_NO_RX_PREF_MASK) && (rx_phys == 0))) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    /* If phy not supported, return error */
+	/* Check for RFU */
+	if ((tx_phys & ~BLE_HCI_LE_PHY_PREF_MASK_ALL) ||
+	    (rx_phys & ~BLE_HCI_LE_PHY_PREF_MASK_ALL)) {
+		return BLE_ERR_UNSUPPORTED;
+	}
+
+	if ((!(all_phys & BLE_HCI_LE_PHY_NO_TX_PREF_MASK) && (tx_phys == 0)) ||
+	    (!(all_phys & BLE_HCI_LE_PHY_NO_RX_PREF_MASK) && (rx_phys == 0))) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	/* If phy not supported, return error */
 #if !MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_2M_PHY)
-    if((tx_phys & BLE_HCI_LE_PHY_2M_PREF_MASK) ||
-                    (rx_phys & BLE_HCI_LE_PHY_2M_PREF_MASK)) {
-        return BLE_ERR_UNSUPPORTED;
-    }
+	if ((tx_phys & BLE_HCI_LE_PHY_2M_PREF_MASK) ||
+	    (rx_phys & BLE_HCI_LE_PHY_2M_PREF_MASK)) {
+		return BLE_ERR_UNSUPPORTED;
+	}
 #endif
 #if !MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-    if ((tx_phys & BLE_HCI_LE_PHY_CODED_PREF_MASK) ||
-                    (rx_phys & BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
-        return BLE_ERR_UNSUPPORTED;
-    }
-#endif
-    /* Set the default PHY preferences */
-    if (all_phys & BLE_HCI_LE_PHY_NO_TX_PREF_MASK) {
-        tx_phys = BLE_HCI_LE_PHY_PREF_MASK_ALL;
-    }
-    *txphy = tx_phys;
-
-    if (all_phys & BLE_HCI_LE_PHY_NO_RX_PREF_MASK) {
-        rx_phys = BLE_HCI_LE_PHY_PREF_MASK_ALL;
-    }
-    *rxphy = rx_phys;
-
-    return BLE_ERR_SUCCESS;
+	if ((tx_phys & BLE_HCI_LE_PHY_CODED_PREF_MASK) ||
+	    (rx_phys & BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+		return BLE_ERR_UNSUPPORTED;
+	}
+#endif
+	/* Set the default PHY preferences */
+	if (all_phys & BLE_HCI_LE_PHY_NO_TX_PREF_MASK) {
+		tx_phys = BLE_HCI_LE_PHY_PREF_MASK_ALL;
+	}
+	*txphy = tx_phys;
+
+	if (all_phys & BLE_HCI_LE_PHY_NO_RX_PREF_MASK) {
+		rx_phys = BLE_HCI_LE_PHY_PREF_MASK_ALL;
+	}
+	*rxphy = rx_phys;
+
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -428,32 +414,30 @@ ble_ll_hci_chk_phy_masks(uint8_t all_phys, uint8_t tx_phys, uint8_t rx_phys,
  * @return int
  */
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-static int
-ble_ll_hci_le_set_def_phy(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_hci_le_set_def_phy(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_set_default_phy_cp *cmd = (const void *) cmdbuf;
-    int rc;
+	const struct ble_hci_le_set_default_phy_cp *cmd = (const void *) cmdbuf;
+	int rc;
 
-    if (len != sizeof(*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    rc = ble_ll_hci_chk_phy_masks(cmd->all_phys, cmd->tx_phys, cmd->rx_phys,
-                                  &g_ble_ll_data.ll_pref_tx_phys,
-                                  &g_ble_ll_data.ll_pref_rx_phys);
-    return rc;
+	rc = ble_ll_hci_chk_phy_masks(cmd->all_phys, cmd->tx_phys, cmd->rx_phys,
+	                              &g_ble_ll_data.ll_pref_tx_phys,
+	                              &g_ble_ll_data.ll_pref_rx_phys);
+	return rc;
 }
 #endif
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_DATA_LEN_EXT)
-int
-ble_ll_hci_check_dle(uint16_t max_octets, uint16_t max_time)
+int ble_ll_hci_check_dle(uint16_t max_octets, uint16_t max_time)
 {
-    return (max_octets >= BLE_LL_CONN_SUPP_BYTES_MIN) &&
-           (max_octets <= BLE_LL_CONN_SUPP_BYTES_MAX) &&
-           (max_time >= BLE_LL_CONN_SUPP_TIME_MIN) &&
-           (max_time <= BLE_LL_CONN_SUPP_TIME_MAX);
+	return (max_octets >= BLE_LL_CONN_SUPP_BYTES_MIN) &&
+	       (max_octets <= BLE_LL_CONN_SUPP_BYTES_MAX) &&
+	       (max_time >= BLE_LL_CONN_SUPP_TIME_MIN) &&
+	       (max_time <= BLE_LL_CONN_SUPP_TIME_MAX);
 }
 
 /**
@@ -471,50 +455,48 @@ ble_ll_hci_check_dle(uint16_t max_octets, uint16_t max_time)
  *
  * @return int BLE error code
  */
-static int
-ble_ll_hci_le_wr_sugg_data_len(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_hci_le_wr_sugg_data_len(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_wr_sugg_def_data_len_cp *cmd = (const void *)cmdbuf;
-    uint16_t tx_octets;
-    uint16_t tx_time;
-
-    if (len != sizeof(*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    /* Get suggested octets and time */
-    tx_octets = le16toh(cmd->max_tx_octets);
-    tx_time = le16toh(cmd->max_tx_time);
-
-    if (!ble_ll_hci_check_dle(tx_octets, tx_time)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    g_ble_ll_conn_params.sugg_tx_octets = tx_octets;
-    g_ble_ll_conn_params.sugg_tx_time = tx_time;
-
-    /*
-     * We can disregard host suggestion, but we are a nice controller so
-     * let's use host suggestion, unless they exceed max supported values
-     * in which case we just use our max.
-     */
-    g_ble_ll_conn_params.conn_init_max_tx_octets =
-        MIN(tx_octets, g_ble_ll_conn_params.supp_max_tx_octets);
-    g_ble_ll_conn_params.conn_init_max_tx_time =
-        MIN(tx_time, g_ble_ll_conn_params.supp_max_tx_time);
-
-    /*
-     * Use the same for coded and uncoded defaults. These are used when PHY
-     * parameters are initialized and we want to use values overridden by
-     * host. Make sure we do not exceed max supported time on uncoded.
-     */
-    g_ble_ll_conn_params.conn_init_max_tx_time_uncoded =
-        MIN(BLE_LL_CONN_SUPP_TIME_MAX_UNCODED,
-            g_ble_ll_conn_params.conn_init_max_tx_time);
-    g_ble_ll_conn_params.conn_init_max_tx_time_coded =
-        g_ble_ll_conn_params.conn_init_max_tx_time;
-
-    return 0;
+	const struct ble_hci_le_wr_sugg_def_data_len_cp *cmd = (const void *) cmdbuf;
+	uint16_t tx_octets;
+	uint16_t tx_time;
+
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	/* Get suggested octets and time */
+	tx_octets = le16toh(cmd->max_tx_octets);
+	tx_time = le16toh(cmd->max_tx_time);
+
+	if (!ble_ll_hci_check_dle(tx_octets, tx_time)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	g_ble_ll_conn_params.sugg_tx_octets = tx_octets;
+	g_ble_ll_conn_params.sugg_tx_time = tx_time;
+
+	/*
+	 * We can disregard host suggestion, but we are a nice controller so
+	 * let's use host suggestion, unless they exceed max supported values
+	 * in which case we just use our max.
+	 */
+	g_ble_ll_conn_params.conn_init_max_tx_octets =
+		MIN(tx_octets, g_ble_ll_conn_params.supp_max_tx_octets);
+	g_ble_ll_conn_params.conn_init_max_tx_time =
+		MIN(tx_time, g_ble_ll_conn_params.supp_max_tx_time);
+
+	/*
+	 * Use the same for coded and uncoded defaults. These are used when PHY
+	 * parameters are initialized and we want to use values overridden by
+	 * host. Make sure we do not exceed max supported time on uncoded.
+	 */
+	g_ble_ll_conn_params.conn_init_max_tx_time_uncoded =
+		MIN(BLE_LL_CONN_SUPP_TIME_MAX_UNCODED, g_ble_ll_conn_params.conn_init_max_tx_time);
+	g_ble_ll_conn_params.conn_init_max_tx_time_coded =
+		g_ble_ll_conn_params.conn_init_max_tx_time;
+
+	return 0;
 }
 
 /**
@@ -526,17 +508,16 @@ ble_ll_hci_le_wr_sugg_data_len(const uint8_t *cmdbuf, uint8_t len)
  *
  * @return int BLE error code
  */
-static int
-ble_ll_hci_le_rd_sugg_data_len(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_le_rd_sugg_data_len(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_sugg_def_data_len_rp *rsp = (void *) rspbuf;
+	struct ble_hci_le_rd_sugg_def_data_len_rp *rsp = (void *) rspbuf;
 
-    /* Place the data packet length and number of packets in the buffer */
-    rsp->max_tx_octets = htole16(g_ble_ll_conn_params.sugg_tx_octets);
-    rsp->max_tx_time = htole16(g_ble_ll_conn_params.sugg_tx_time);
+	/* Place the data packet length and number of packets in the buffer */
+	rsp->max_tx_octets = htole16(g_ble_ll_conn_params.sugg_tx_octets);
+	rsp->max_tx_time = htole16(g_ble_ll_conn_params.sugg_tx_time);
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -548,19 +529,18 @@ ble_ll_hci_le_rd_sugg_data_len(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int BLE error code
  */
-static int
-ble_ll_hci_le_rd_max_data_len(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_le_rd_max_data_len(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_max_data_len_rp *rsp = (void *)rspbuf;
+	struct ble_hci_le_rd_max_data_len_rp *rsp = (void *) rspbuf;
 
-    /* Place the data packet length and number of packets in the buffer */
-    rsp->max_tx_octests = htole16(g_ble_ll_conn_params.supp_max_tx_octets);
-    rsp->max_tx_time = htole16(g_ble_ll_conn_params.supp_max_tx_time);
-    rsp->max_rx_octests = htole16(g_ble_ll_conn_params.supp_max_rx_octets);
-    rsp->max_rx_time = htole16(g_ble_ll_conn_params.supp_max_rx_time);
+	/* Place the data packet length and number of packets in the buffer */
+	rsp->max_tx_octests = htole16(g_ble_ll_conn_params.supp_max_tx_octets);
+	rsp->max_tx_time = htole16(g_ble_ll_conn_params.supp_max_tx_time);
+	rsp->max_rx_octests = htole16(g_ble_ll_conn_params.supp_max_rx_octets);
+	rsp->max_rx_time = htole16(g_ble_ll_conn_params.supp_max_rx_time);
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 #endif
 
@@ -573,15 +553,14 @@ ble_ll_hci_le_rd_max_data_len(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int BLE error code
  */
-static int
-ble_ll_hci_le_read_local_features(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_le_read_local_features(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_loc_supp_feat_rp *rsp = (void *) rspbuf;
+	struct ble_hci_le_rd_loc_supp_feat_rp *rsp = (void *) rspbuf;
 
-    rsp->features = htole64(ble_ll_read_supp_features());
+	rsp->features = htole64(ble_ll_read_supp_features());
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -593,16 +572,15 @@ ble_ll_hci_le_read_local_features(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int BLE error code
  */
-static int
-ble_ll_hci_le_read_supp_states(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_le_read_supp_states(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_supp_states_rp *rsp = (void *) rspbuf;
+	struct ble_hci_le_rd_supp_states_rp *rsp = (void *) rspbuf;
 
-    /* Add list of supported states. */
-    rsp->states = htole64(ble_ll_read_supp_states());
+	/* Add list of supported states. */
+	rsp->states = htole64(ble_ll_read_supp_states());
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
 
@@ -614,15 +592,14 @@ ble_ll_hci_le_read_supp_states(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return uint8_t 0: event is not enabled; otherwise event is enabled.
  */
-bool
-ble_ll_hci_is_le_event_enabled(unsigned int subev)
+bool ble_ll_hci_is_le_event_enabled(unsigned int subev)
 {
-    /* The LE meta event must be enabled for any LE event to be enabled */
-    if (g_ble_ll_hci_event_mask & (1ull << (BLE_HCI_EVCODE_LE_META - 1))) {
-        return g_ble_ll_hci_le_event_mask & (1ull << (subev - 1));
-    }
+	/* The LE meta event must be enabled for any LE event to be enabled */
+	if (g_ble_ll_hci_event_mask & (1ull << (BLE_HCI_EVCODE_LE_META - 1))) {
+		return g_ble_ll_hci_le_event_mask & (1ull << (subev - 1));
+	}
 
-    return false;
+	return false;
 }
 
 /**
@@ -636,14 +613,13 @@ ble_ll_hci_is_le_event_enabled(unsigned int subev)
  *
  * @return uint8_t 0: event is not enabled; otherwise event is enabled.
  */
-bool
-ble_ll_hci_is_event_enabled(unsigned int evcode)
+bool ble_ll_hci_is_event_enabled(unsigned int evcode)
 {
-    if (evcode >= 64) {
-        return g_ble_ll_hci_event_mask2 & (1ull << (evcode - 64));
-    }
+	if (evcode >= 64) {
+		return g_ble_ll_hci_event_mask2 & (1ull << (evcode - 64));
+	}
 
-    return g_ble_ll_hci_event_mask & (1ull << (evcode - 1));
+	return g_ble_ll_hci_event_mask & (1ull << (evcode - 1));
 }
 
 /**
@@ -654,58 +630,56 @@ ble_ll_hci_is_event_enabled(unsigned int evcode)
  *
  * @return int 0: return command complete; 1: return command status event
  */
-static int
-ble_ll_hci_le_cmd_send_cmd_status(uint16_t ocf)
+static int ble_ll_hci_le_cmd_send_cmd_status(uint16_t ocf)
 {
-    int rc;
-
-    switch (ocf) {
-    case BLE_HCI_OCF_LE_RD_REM_FEAT:
-    case BLE_HCI_OCF_LE_CREATE_CONN:
-    case BLE_HCI_OCF_LE_EXT_CREATE_CONN:
-    case BLE_HCI_OCF_LE_CONN_UPDATE:
-    case BLE_HCI_OCF_LE_START_ENCRYPT:
-    case BLE_HCI_OCF_LE_RD_P256_PUBKEY:
-    case BLE_HCI_OCF_LE_GEN_DHKEY:
-    case BLE_HCI_OCF_LE_SET_PHY:
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC:
+	int rc;
+
+	switch (ocf) {
+	case BLE_HCI_OCF_LE_RD_REM_FEAT:
+	case BLE_HCI_OCF_LE_CREATE_CONN:
+	case BLE_HCI_OCF_LE_EXT_CREATE_CONN:
+	case BLE_HCI_OCF_LE_CONN_UPDATE:
+	case BLE_HCI_OCF_LE_START_ENCRYPT:
+	case BLE_HCI_OCF_LE_RD_P256_PUBKEY:
+	case BLE_HCI_OCF_LE_GEN_DHKEY:
+	case BLE_HCI_OCF_LE_SET_PHY:
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC:
 #if MYNEWT_VAL(BLE_LL_ISO_BROADCASTER)
-    case BLE_HCI_OCF_LE_CREATE_BIG:
-    case BLE_HCI_OCF_LE_CREATE_BIG_TEST:
-    case BLE_HCI_OCF_LE_TERMINATE_BIG:
+	case BLE_HCI_OCF_LE_CREATE_BIG:
+	case BLE_HCI_OCF_LE_CREATE_BIG_TEST:
+	case BLE_HCI_OCF_LE_TERMINATE_BIG:
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-    case BLE_HCI_OCF_LE_REQ_PEER_SCA:
-#endif
-    case BLE_HCI_OCF_LE_SUBRATE_REQ:
-        rc = 1;
-        break;
-    default:
-        rc = 0;
-        break;
-    }
-    return rc;
+	case BLE_HCI_OCF_LE_REQ_PEER_SCA:
+#endif
+	case BLE_HCI_OCF_LE_SUBRATE_REQ:
+		rc = 1;
+		break;
+	default:
+		rc = 0;
+		break;
+	}
+	return rc;
 }
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
 /** HCI LE read maximum advertising data length command. Returns the controllers
-* max supported advertising data length;
-*
-* @param rspbuf Pointer to response buffer
-* @param rsplen Length of response buffer
-*
-* @return int BLE error code
-*/
-static int
-ble_ll_adv_rd_max_adv_data_len(uint8_t *rspbuf, uint8_t *rsplen)
+ * max supported advertising data length;
+ *
+ * @param rspbuf Pointer to response buffer
+ * @param rsplen Length of response buffer
+ *
+ * @return int BLE error code
+ */
+static int ble_ll_adv_rd_max_adv_data_len(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_max_adv_data_len_rp *rsp = (void *) rspbuf;
+	struct ble_hci_le_rd_max_adv_data_len_rp *rsp = (void *) rspbuf;
 
-    rsp->max_adv_data_len = htole16(BLE_ADV_DATA_MAX_LEN);
+	rsp->max_adv_data_len = htole16(BLE_ADV_DATA_MAX_LEN);
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -716,170 +690,164 @@ ble_ll_adv_rd_max_adv_data_len(uint8_t *rspbuf, uint8_t *rsplen)
  *
  * @return int BLE error code
  */
-static int
-ble_ll_adv_rd_sup_adv_sets(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_adv_rd_sup_adv_sets(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_num_of_adv_sets_rp *rsp = (void *)rspbuf;
+	struct ble_hci_le_rd_num_of_adv_sets_rp *rsp = (void *) rspbuf;
 
-    rsp->num_sets = BLE_ADV_INSTANCES;
+	rsp->num_sets = BLE_ADV_INSTANCES;
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 #endif
 
-static bool
-ble_ll_is_valid_adv_mode(uint8_t ocf)
+static bool ble_ll_is_valid_adv_mode(uint8_t ocf)
 {
-    /*
-     * If, since the last power-on or reset, the Host has ever issued a legacy
-     * advertising command and then issues an extended advertising command, or
-     * has ever issued an extended advertising command and then issues a legacy
-     * advertising command, the Controller shall return the error code Command
-     * Disallowed (0x0C).
-    */
-
-    switch(ocf) {
-    case BLE_HCI_OCF_LE_CREATE_CONN:
-    case BLE_HCI_OCF_LE_SET_ADV_PARAMS:
-    case BLE_HCI_OCF_LE_SET_ADV_ENABLE:
-    case BLE_HCI_OCF_LE_SET_ADV_DATA:
-    case BLE_HCI_OCF_LE_SET_SCAN_PARAMS:
-    case BLE_HCI_OCF_LE_SET_SCAN_ENABLE:
-    case BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA:
-    case BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR:
-        if (hci_adv_mode == ADV_MODE_EXT) {
-            return false;
-        }
-
-        hci_adv_mode = ADV_MODE_LEGACY;
-        break;
-    case BLE_HCI_OCF_LE_EXT_CREATE_CONN:
-    case BLE_HCI_OCF_LE_SET_EXT_ADV_DATA:
-    case BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE:
-    case BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM:
-    case BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE:
-    case BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM:
-    case BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA:
-    case BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN:
-    case BLE_HCI_OCF_LE_RD_NUM_OF_ADV_SETS:
-    case BLE_HCI_OCF_LE_REMOVE_ADV_SET:
-    case BLE_HCI_OCF_LE_CLEAR_ADV_SETS:
-    case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS:
-    case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA:
-    case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE:
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC:
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL:
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC:
-    case BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST:
-    case BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST:
-    case BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST:
-    case BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE:
+	/*
+	 * If, since the last power-on or reset, the Host has ever issued a legacy
+	 * advertising command and then issues an extended advertising command, or
+	 * has ever issued an extended advertising command and then issues a legacy
+	 * advertising command, the Controller shall return the error code Command
+	 * Disallowed (0x0C).
+	 */
+
+	switch (ocf) {
+	case BLE_HCI_OCF_LE_CREATE_CONN:
+	case BLE_HCI_OCF_LE_SET_ADV_PARAMS:
+	case BLE_HCI_OCF_LE_SET_ADV_ENABLE:
+	case BLE_HCI_OCF_LE_SET_ADV_DATA:
+	case BLE_HCI_OCF_LE_SET_SCAN_PARAMS:
+	case BLE_HCI_OCF_LE_SET_SCAN_ENABLE:
+	case BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA:
+	case BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR:
+		if (hci_adv_mode == ADV_MODE_EXT) {
+			return false;
+		}
+
+		hci_adv_mode = ADV_MODE_LEGACY;
+		break;
+	case BLE_HCI_OCF_LE_EXT_CREATE_CONN:
+	case BLE_HCI_OCF_LE_SET_EXT_ADV_DATA:
+	case BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE:
+	case BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM:
+	case BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE:
+	case BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM:
+	case BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA:
+	case BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN:
+	case BLE_HCI_OCF_LE_RD_NUM_OF_ADV_SETS:
+	case BLE_HCI_OCF_LE_REMOVE_ADV_SET:
+	case BLE_HCI_OCF_LE_CLEAR_ADV_SETS:
+	case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS:
+	case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA:
+	case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE:
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC:
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL:
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC:
+	case BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST:
+	case BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST:
+	case BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST:
+	case BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE:
 #if MYNEWT_VAL(BLE_VERSION) >= 51
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE:
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE:
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER:
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER:
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS:
-    case BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS:
-#endif
-        if (hci_adv_mode == ADV_MODE_LEGACY) {
-            return false;
-        }
-
-        hci_adv_mode = ADV_MODE_EXT;
-        break;
-    default:
-        break;
-    }
-
-    return true;
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER:
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER:
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS:
+	case BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS:
+#endif
+		if (hci_adv_mode == ADV_MODE_LEGACY) {
+			return false;
+		}
+
+		hci_adv_mode = ADV_MODE_EXT;
+		break;
+	default:
+		break;
+	}
+
+	return true;
 }
 #endif
 
-static int
-ble_ll_read_tx_power(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_read_tx_power(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_transmit_power_rp *rsp = (void *) rspbuf;
+	struct ble_hci_le_rd_transmit_power_rp *rsp = (void *) rspbuf;
 
-    rsp->min_tx_power = ble_ll_tx_power_round(-127);
-    rsp->max_tx_power = ble_ll_tx_power_round(126);
+	rsp->min_tx_power = ble_ll_tx_power_round(-127);
+	rsp->max_tx_power = ble_ll_tx_power_round(126);
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
-static int
-ble_ll_read_rf_path_compensation(uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_read_rf_path_compensation(uint8_t *rspbuf, uint8_t *rsplen)
 {
-    struct ble_hci_le_rd_rf_path_compensation_rp *rsp = (void *) rspbuf;
+	struct ble_hci_le_rd_rf_path_compensation_rp *rsp = (void *) rspbuf;
 
-    rsp->rx_path_compensation = htole16(rx_path_pwr_compensation);
-    rsp->tx_path_compensation = htole16(tx_path_pwr_compensation);
+	rsp->rx_path_compensation = htole16(rx_path_pwr_compensation);
+	rsp->tx_path_compensation = htole16(tx_path_pwr_compensation);
 
-    *rsplen = sizeof(*rsp);
-    return BLE_ERR_SUCCESS;
+	*rsplen = sizeof(*rsp);
+	return BLE_ERR_SUCCESS;
 }
 
-static int
-ble_ll_write_rf_path_compensation(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_write_rf_path_compensation(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_wr_rf_path_compensation_cp *cmd = (const void *)cmdbuf;
-    int16_t rx;
-    int16_t tx;
+	const struct ble_hci_le_wr_rf_path_compensation_cp *cmd = (const void *) cmdbuf;
+	int16_t rx;
+	int16_t tx;
 
-    if (len != sizeof(*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    tx = le16toh(cmd->tx_path_compensation);
-    rx = le16toh(cmd->rx_path_compensation);
+	tx = le16toh(cmd->tx_path_compensation);
+	rx = le16toh(cmd->rx_path_compensation);
 
-    if ((tx < -1280) || (tx > 1280) || (rx < -1280) || (rx > 1280)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if ((tx < -1280) || (tx > 1280) || (rx < -1280) || (rx > 1280)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    tx_path_pwr_compensation = tx;
-    rx_path_pwr_compensation = rx;
+	tx_path_pwr_compensation = tx;
+	rx_path_pwr_compensation = rx;
 
-    g_ble_ll_tx_power_compensation = tx / 10;
-    g_ble_ll_rx_power_compensation = rx / 10;
+	g_ble_ll_tx_power_compensation = tx / 10;
+	g_ble_ll_rx_power_compensation = rx / 10;
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 
-static int
-ble_ll_hci_le_set_host_chan_class(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_hci_le_set_host_chan_class(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_set_host_chan_class_cp *cmd = (const void *)cmdbuf;
-    uint8_t chan_map_used;
+	const struct ble_hci_le_set_host_chan_class_cp *cmd = (const void *) cmdbuf;
+	uint8_t chan_map_used;
 
-    if (len != sizeof(*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    /* HCI command allows only single channel to be enabled, but LL needs at
-     * least 2 channels to work so let's reject in such case.
-     */
-    chan_map_used = ble_ll_utils_chan_map_used_get(cmd->chan_map);
-    if ((chan_map_used < 2) || (cmd->chan_map[4] & 0xe0)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	/* HCI command allows only single channel to be enabled, but LL needs at
+	 * least 2 channels to work so let's reject in such case.
+	 */
+	chan_map_used = ble_ll_utils_chan_map_used_get(cmd->chan_map);
+	if ((chan_map_used < 2) || (cmd->chan_map[4] & 0xe0)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    if (!memcmp(g_ble_ll_data.chan_map, cmd->chan_map, BLE_LL_CHAN_MAP_LEN)) {
-        return BLE_ERR_SUCCESS;
-    }
+	if (!memcmp(g_ble_ll_data.chan_map, cmd->chan_map, BLE_LL_CHAN_MAP_LEN)) {
+		return BLE_ERR_SUCCESS;
+	}
 
-    memcpy(g_ble_ll_data.chan_map, cmd->chan_map, BLE_LL_CHAN_MAP_LEN);
-    g_ble_ll_data.chan_map_used = chan_map_used;
+	memcpy(g_ble_ll_data.chan_map, cmd->chan_map, BLE_LL_CHAN_MAP_LEN);
+	g_ble_ll_data.chan_map_used = chan_map_used;
 
-    ble_ll_conn_chan_map_update();
+	ble_ll_conn_chan_map_update();
 #if MYNEWT_VAL(BLE_LL_ISO_BROADCASTER)
-    ble_ll_iso_big_chan_map_update();
+	ble_ll_iso_big_chan_map_update();
 #endif
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 
 /**
@@ -896,456 +864,465 @@ ble_ll_hci_le_set_host_chan_class(const uint8_t *cmdbuf, uint8_t len)
  *              event should be returned as opposed to command complete,
  *              256 gets added to the return value.
  */
-static int
-ble_ll_hci_le_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
-                       uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_le_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
+                                  uint8_t *rspbuf, uint8_t *rsplen)
 {
-    int rc;
+	int rc;
 
-    /* Assume error; if all pass rc gets set to 0 */
-    rc = BLE_ERR_INV_HCI_CMD_PARMS;
+	/* Assume error; if all pass rc gets set to 0 */
+	rc = BLE_ERR_INV_HCI_CMD_PARMS;
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-    if (!ble_ll_is_valid_adv_mode(ocf)) {
-        rc = BLE_ERR_CMD_DISALLOWED;
-
-        /*
-         * This code is here because we add 256 to the return code to denote
-         * that the reply to this command should be command status (as opposed to
-         * command complete).
-         *
-         * For unknown HCI command let us return always command status as per
-         * specification Bluetooth 5, Vol. 2, Chapter 4.4
-         */
-        if (ble_ll_hci_le_cmd_send_cmd_status(ocf)) {
-            rc += (BLE_ERR_MAX + 1);
-        }
-
-        return rc;
-    }
-#endif
-
-    switch (ocf) {
-    case BLE_HCI_OCF_LE_SET_EVENT_MASK:
-        rc = ble_ll_hci_set_le_event_mask(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_RD_BUF_SIZE:
-        if (len == 0) {
-            rc = ble_ll_hci_le_read_bufsize(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_RD_LOC_SUPP_FEAT:
-        if (len == 0) {
-            rc = ble_ll_hci_le_read_local_features(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_SET_RAND_ADDR:
+	if (!ble_ll_is_valid_adv_mode(ocf)) {
+		rc = BLE_ERR_CMD_DISALLOWED;
+
+		/*
+		 * This code is here because we add 256 to the return code to denote
+		 * that the reply to this command should be command status (as opposed to
+		 * command complete).
+		 *
+		 * For unknown HCI command let us return always command status as per
+		 * specification Bluetooth 5, Vol. 2, Chapter 4.4
+		 */
+		if (ble_ll_hci_le_cmd_send_cmd_status(ocf)) {
+			rc += (BLE_ERR_MAX + 1);
+		}
+
+		return rc;
+	}
+#endif
+
+	switch (ocf) {
+	case BLE_HCI_OCF_LE_SET_EVENT_MASK:
+		rc = ble_ll_hci_set_le_event_mask(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_RD_BUF_SIZE:
+		if (len == 0) {
+			rc = ble_ll_hci_le_read_bufsize(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_RD_LOC_SUPP_FEAT:
+		if (len == 0) {
+			rc = ble_ll_hci_le_read_local_features(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_SET_PUB_ADDR:
+		const struct ble_hci_le_set_pub_addr_cp *cmd = (const void *) cmdbuf;
+		// TODO: Should probably check that no scanning / adv in progress. For now let
+		// leave it like this see ble_ll_set_random_addr implementation
+		memcpy(g_dev_addr, cmd->addr, BLE_DEV_ADDR_LEN);
+		rc = BLE_ERR_SUCCESS;
+		break;
+	case BLE_HCI_OCF_LE_SET_RAND_ADDR:
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-        rc = ble_ll_set_random_addr(cmdbuf, len, hci_adv_mode == ADV_MODE_EXT);
+		rc = ble_ll_set_random_addr(cmdbuf, len, hci_adv_mode == ADV_MODE_EXT);
 #else
-        rc = ble_ll_set_random_addr(cmdbuf, len, false);
+		rc = ble_ll_set_random_addr(cmdbuf, len, false);
 #endif
-        break;
+		break;
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-    case BLE_HCI_OCF_LE_SET_ADV_PARAMS:
-        rc = ble_ll_adv_set_adv_params(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR:
-        if (len == 0) {
-            rc = ble_ll_adv_read_txpwr(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_SET_ADV_DATA:
-        rc = ble_ll_hci_set_adv_data(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA:
-        rc = ble_ll_hci_set_scan_rsp_data(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_ADV_ENABLE:
-        rc = ble_ll_hci_adv_set_enable(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_SET_ADV_PARAMS:
+		rc = ble_ll_adv_set_adv_params(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR:
+		if (len == 0) {
+			rc = ble_ll_adv_read_txpwr(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_SET_ADV_DATA:
+		rc = ble_ll_hci_set_adv_data(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA:
+		rc = ble_ll_hci_set_scan_rsp_data(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_ADV_ENABLE:
+		rc = ble_ll_hci_adv_set_enable(cmdbuf, len);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    case BLE_HCI_OCF_LE_SET_SCAN_PARAMS:
-        rc = ble_ll_scan_hci_set_params(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_SCAN_ENABLE:
-        rc = ble_ll_scan_hci_set_enable(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_SET_SCAN_PARAMS:
+		rc = ble_ll_scan_hci_set_params(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_SCAN_ENABLE:
+		rc = ble_ll_scan_hci_set_enable(cmdbuf, len);
+		break;
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_HCI_OCF_LE_CREATE_CONN:
-        rc = ble_ll_conn_hci_create(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_CREATE_CONN_CANCEL:
-        if (len == 0) {
-            rc = ble_ll_conn_create_cancel();
-        }
-        break;
-#endif
-#endif
-    case BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE:
-        if (len == 0) {
-            rc = ble_ll_whitelist_read_size(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_CLEAR_WHITE_LIST:
-        if (len == 0) {
-            rc = ble_ll_whitelist_clear();
-        }
-        break;
-    case BLE_HCI_OCF_LE_ADD_WHITE_LIST:
-        rc = ble_ll_whitelist_add(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_RMV_WHITE_LIST:
-        rc = ble_ll_whitelist_rmv(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_CREATE_CONN:
+		rc = ble_ll_conn_hci_create(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_CREATE_CONN_CANCEL:
+		if (len == 0) {
+			rc = ble_ll_conn_create_cancel();
+		}
+		break;
+#endif
+#endif
+	case BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE:
+		if (len == 0) {
+			rc = ble_ll_whitelist_read_size(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_CLEAR_WHITE_LIST:
+		if (len == 0) {
+			rc = ble_ll_whitelist_clear();
+		}
+		break;
+	case BLE_HCI_OCF_LE_ADD_WHITE_LIST:
+		rc = ble_ll_whitelist_add(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_RMV_WHITE_LIST:
+		rc = ble_ll_whitelist_rmv(cmdbuf, len);
+		break;
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_HCI_OCF_LE_CONN_UPDATE:
-        rc = ble_ll_conn_hci_update(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_CONN_UPDATE:
+		rc = ble_ll_conn_hci_update(cmdbuf, len);
+		break;
 #endif
-    case BLE_HCI_OCF_LE_SET_HOST_CHAN_CLASS:
-        rc = ble_ll_hci_le_set_host_chan_class(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_SET_HOST_CHAN_CLASS:
+		rc = ble_ll_hci_le_set_host_chan_class(cmdbuf, len);
+		break;
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_HCI_OCF_LE_RD_CHAN_MAP:
-        rc = ble_ll_conn_hci_rd_chan_map(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_RD_REM_FEAT:
-        rc = ble_ll_conn_hci_read_rem_features(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_RD_CHAN_MAP:
+		rc = ble_ll_conn_hci_rd_chan_map(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_RD_REM_FEAT:
+		rc = ble_ll_conn_hci_read_rem_features(cmdbuf, len);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    case BLE_HCI_OCF_LE_ENCRYPT:
-        rc = ble_ll_hci_le_encrypt(cmdbuf, len, rspbuf, rsplen);
-        break;
-#endif
-    case BLE_HCI_OCF_LE_RAND:
-        if (len == 0) {
-            rc = ble_ll_hci_le_rand(rspbuf, rsplen);
-        }
-        break;
+	case BLE_HCI_OCF_LE_ENCRYPT:
+		rc = ble_ll_hci_le_encrypt(cmdbuf, len, rspbuf, rsplen);
+		break;
+#endif
+	case BLE_HCI_OCF_LE_RAND:
+		if (len == 0) {
+			rc = ble_ll_hci_le_rand(rspbuf, rsplen);
+		}
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_HCI_OCF_LE_START_ENCRYPT:
-        rc = ble_ll_conn_hci_le_start_encrypt(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_START_ENCRYPT:
+		rc = ble_ll_conn_hci_le_start_encrypt(cmdbuf, len);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY:
-        rc = ble_ll_conn_hci_le_ltk_reply(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY:
-        rc = ble_ll_conn_hci_le_ltk_neg_reply(cmdbuf, len, rspbuf, rsplen);
-        break;
-#endif
-#endif
-    case BLE_HCI_OCF_LE_RD_SUPP_STATES :
-        if (len == 0) {
-            rc = ble_ll_hci_le_read_supp_states(rspbuf, rsplen);
-        }
-        break;
+	case BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY:
+		rc = ble_ll_conn_hci_le_ltk_reply(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY:
+		rc = ble_ll_conn_hci_le_ltk_neg_reply(cmdbuf, len, rspbuf, rsplen);
+		break;
+#endif
+#endif
+	case BLE_HCI_OCF_LE_RD_SUPP_STATES:
+		if (len == 0) {
+			rc = ble_ll_hci_le_read_supp_states(rspbuf, rsplen);
+		}
+		break;
 #if MYNEWT_VAL(BLE_LL_DTM)
-    case BLE_HCI_OCF_LE_TX_TEST:
-        rc = ble_ll_hci_dtm_tx_test(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_RX_TEST:
-        rc = ble_ll_hci_dtm_rx_test(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_TEST_END:
-        if (len == 0) {
-            rc = ble_ll_dtm_end_test(rspbuf, rsplen);
-        }
-        break;
+	case BLE_HCI_OCF_LE_TX_TEST:
+		rc = ble_ll_hci_dtm_tx_test(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_RX_TEST:
+		rc = ble_ll_hci_dtm_rx_test(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_TEST_END:
+		if (len == 0) {
+			rc = ble_ll_dtm_end_test(rspbuf, rsplen);
+		}
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_HCI_OCF_LE_REM_CONN_PARAM_RR:
-        rc = ble_ll_conn_hci_param_rr(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR:
-        rc = ble_ll_conn_hci_param_nrr(cmdbuf, len, rspbuf, rsplen);
-        break;
+	case BLE_HCI_OCF_LE_REM_CONN_PARAM_RR:
+		rc = ble_ll_conn_hci_param_rr(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR:
+		rc = ble_ll_conn_hci_param_nrr(cmdbuf, len, rspbuf, rsplen);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_DATA_LEN_EXT)
-    case BLE_HCI_OCF_LE_SET_DATA_LEN:
-        rc = ble_ll_conn_hci_set_data_len(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_RD_SUGG_DEF_DATA_LEN:
-        if (len == 0) {
-            rc = ble_ll_hci_le_rd_sugg_data_len(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_WR_SUGG_DEF_DATA_LEN:
-        rc = ble_ll_hci_le_wr_sugg_data_len(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_SET_DATA_LEN:
+		rc = ble_ll_conn_hci_set_data_len(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_RD_SUGG_DEF_DATA_LEN:
+		if (len == 0) {
+			rc = ble_ll_hci_le_rd_sugg_data_len(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_WR_SUGG_DEF_DATA_LEN:
+		rc = ble_ll_hci_le_wr_sugg_data_len(cmdbuf, len);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PRIVACY)
-    case BLE_HCI_OCF_LE_ADD_RESOLV_LIST:
-        rc = ble_ll_resolv_list_add(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_RMV_RESOLV_LIST:
-        rc = ble_ll_resolv_list_rmv(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_CLR_RESOLV_LIST:
-        if (len == 0) {
-            rc = ble_ll_resolv_list_clr();
-        }
-        break;
-    case BLE_HCI_OCF_LE_RD_RESOLV_LIST_SIZE:
-        if (len == 0) {
-            rc = ble_ll_resolv_list_read_size(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_RD_PEER_RESOLV_ADDR:
-        rc = ble_ll_resolv_peer_addr_rd(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_RD_LOCAL_RESOLV_ADDR:
-        rc = ble_ll_resolv_local_addr_rd(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_SET_ADDR_RES_EN:
-        rc = ble_ll_resolv_enable_cmd(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_RPA_TMO:
-        rc = ble_ll_resolv_set_rpa_tmo(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_ADD_RESOLV_LIST:
+		rc = ble_ll_resolv_list_add(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_RMV_RESOLV_LIST:
+		rc = ble_ll_resolv_list_rmv(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_CLR_RESOLV_LIST:
+		if (len == 0) {
+			rc = ble_ll_resolv_list_clr();
+		}
+		break;
+	case BLE_HCI_OCF_LE_RD_RESOLV_LIST_SIZE:
+		if (len == 0) {
+			rc = ble_ll_resolv_list_read_size(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_RD_PEER_RESOLV_ADDR:
+		rc = ble_ll_resolv_peer_addr_rd(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_RD_LOCAL_RESOLV_ADDR:
+		rc = ble_ll_resolv_local_addr_rd(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_SET_ADDR_RES_EN:
+		rc = ble_ll_resolv_enable_cmd(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_RPA_TMO:
+		rc = ble_ll_resolv_set_rpa_tmo(cmdbuf, len);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_DATA_LEN_EXT)
-    case BLE_HCI_OCF_LE_RD_MAX_DATA_LEN:
-        if (len == 0) {
-            rc = ble_ll_hci_le_rd_max_data_len(rspbuf, rsplen);
-        }
-        break;
+	case BLE_HCI_OCF_LE_RD_MAX_DATA_LEN:
+		if (len == 0) {
+			rc = ble_ll_hci_le_rd_max_data_len(rspbuf, rsplen);
+		}
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_PHY)
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_HCI_OCF_LE_RD_PHY:
-        rc = ble_ll_conn_hci_le_rd_phy(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_SET_DEFAULT_PHY:
-        rc = ble_ll_hci_le_set_def_phy(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_PHY:
-        rc = ble_ll_conn_hci_le_set_phy(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_RD_PHY:
+		rc = ble_ll_conn_hci_le_rd_phy(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_SET_DEFAULT_PHY:
+		rc = ble_ll_hci_le_set_def_phy(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_PHY:
+		rc = ble_ll_conn_hci_le_set_phy(cmdbuf, len);
+		break;
 #endif
 #endif
 #if MYNEWT_VAL(BLE_LL_DTM)
-    case BLE_HCI_OCF_LE_RX_TEST_V2:
-        rc = ble_ll_hci_dtm_rx_test_v2(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_TX_TEST_V2:
-        rc = ble_ll_hci_dtm_tx_test_v2(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_RX_TEST_V2:
+		rc = ble_ll_hci_dtm_rx_test_v2(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_TX_TEST_V2:
+		rc = ble_ll_hci_dtm_tx_test_v2(cmdbuf, len);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-    case BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR:
-        rc = ble_ll_adv_hci_set_random_addr(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM:
-        rc = ble_ll_adv_ext_set_param(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_SET_EXT_ADV_DATA:
-        rc = ble_ll_adv_ext_set_adv_data(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA:
-        rc = ble_ll_adv_ext_set_scan_rsp(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE:
-        rc =  ble_ll_adv_ext_set_enable(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN:
-        if (len == 0) {
-            rc = ble_ll_adv_rd_max_adv_data_len(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_RD_NUM_OF_ADV_SETS:
-        if (len == 0) {
-            rc = ble_ll_adv_rd_sup_adv_sets(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_REMOVE_ADV_SET:
-        rc =  ble_ll_adv_remove(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_CLEAR_ADV_SETS:
-        if (len == 0) {
-            rc =  ble_ll_adv_clear_all();
-        }
-        break;
+	case BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR:
+		rc = ble_ll_adv_hci_set_random_addr(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM:
+		rc = ble_ll_adv_ext_set_param(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_SET_EXT_ADV_DATA:
+		rc = ble_ll_adv_ext_set_adv_data(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA:
+		rc = ble_ll_adv_ext_set_scan_rsp(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE:
+		rc = ble_ll_adv_ext_set_enable(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN:
+		if (len == 0) {
+			rc = ble_ll_adv_rd_max_adv_data_len(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_RD_NUM_OF_ADV_SETS:
+		if (len == 0) {
+			rc = ble_ll_adv_rd_sup_adv_sets(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_REMOVE_ADV_SET:
+		rc = ble_ll_adv_remove(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_CLEAR_ADV_SETS:
+		if (len == 0) {
+			rc = ble_ll_adv_clear_all();
+		}
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV)
-    case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS:
-        rc = ble_ll_adv_periodic_set_param(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA:
-        rc = ble_ll_adv_periodic_set_data(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE:
-        rc = ble_ll_adv_periodic_enable(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS:
+		rc = ble_ll_adv_periodic_set_param(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA:
+		rc = ble_ll_adv_periodic_set_data(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE:
+		rc = ble_ll_adv_periodic_enable(cmdbuf, len);
+		break;
 #endif
 #endif
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-    case BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM:
-        rc = ble_ll_scan_hci_set_ext_params(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE:
-        rc = ble_ll_scan_hci_set_ext_enable(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM:
+		rc = ble_ll_scan_hci_set_ext_params(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE:
+		rc = ble_ll_scan_hci_set_ext_enable(cmdbuf, len);
+		break;
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_HCI_OCF_LE_EXT_CREATE_CONN:
-        rc = ble_ll_conn_hci_ext_create(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_EXT_CREATE_CONN:
+		rc = ble_ll_conn_hci_ext_create(cmdbuf, len);
+		break;
 #endif
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV)
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC:
-        rc = ble_ll_sync_create(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL:
-        if (len == 0) {
-            rc = ble_ll_sync_cancel();
-        }
-        break;
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC:
-        rc = ble_ll_sync_terminate(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST:
-        rc = ble_ll_sync_list_add(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST:
-        rc = ble_ll_sync_list_remove(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST:
-        if (len == 0) {
-            rc = ble_ll_sync_list_clear();
-        }
-        break;
-    case BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE:
-        if (len == 0) {
-            rc = ble_ll_sync_list_size(rspbuf, rsplen);
-        }
-        break;
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC:
+		rc = ble_ll_sync_create(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL:
+		if (len == 0) {
+			rc = ble_ll_sync_cancel();
+		}
+		break;
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC:
+		rc = ble_ll_sync_terminate(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST:
+		rc = ble_ll_sync_list_add(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST:
+		rc = ble_ll_sync_list_remove(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST:
+		if (len == 0) {
+			rc = ble_ll_sync_list_clear();
+		}
+		break;
+	case BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE:
+		if (len == 0) {
+			rc = ble_ll_sync_list_size(rspbuf, rsplen);
+		}
+		break;
 #if MYNEWT_VAL(BLE_VERSION) >= 51
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE:
-        rc = ble_ll_sync_receive_enable(cmdbuf, len);
-        break;
-#endif
-#endif
-#endif
-    case BLE_HCI_OCF_LE_RD_TRANSMIT_POWER:
-        if (len == 0) {
-            rc = ble_ll_read_tx_power(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_RD_RF_PATH_COMPENSATION:
-        if (len == 0) {
-            rc = ble_ll_read_rf_path_compensation(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_LE_WR_RF_PATH_COMPENSATION:
-        rc = ble_ll_write_rf_path_compensation(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE:
+		rc = ble_ll_sync_receive_enable(cmdbuf, len);
+		break;
+#endif
+#endif
+#endif
+	case BLE_HCI_OCF_LE_RD_TRANSMIT_POWER:
+		if (len == 0) {
+			rc = ble_ll_read_tx_power(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_RD_RF_PATH_COMPENSATION:
+		if (len == 0) {
+			rc = ble_ll_read_rf_path_compensation(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_LE_WR_RF_PATH_COMPENSATION:
+		rc = ble_ll_write_rf_path_compensation(cmdbuf, len);
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PRIVACY)
-    case BLE_HCI_OCF_LE_SET_PRIVACY_MODE:
-        rc = ble_ll_resolve_set_priv_mode(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_SET_PRIVACY_MODE:
+		rc = ble_ll_resolve_set_priv_mode(cmdbuf, len);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
 #if MYNEWT_VAL(BLE_LL_ROLE_OBSERVER)
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER:
-        rc = ble_ll_sync_transfer(cmdbuf, len, rspbuf, rsplen);
-        break;
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER:
+		rc = ble_ll_sync_transfer(cmdbuf, len, rspbuf, rsplen);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_BROADCASTER)
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER:
-        rc = ble_ll_adv_periodic_set_info_transfer(cmdbuf, len, rspbuf, rsplen);
-        break;
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER:
+		rc = ble_ll_adv_periodic_set_info_transfer(cmdbuf, len, rspbuf, rsplen);
+		break;
 #endif
-    case BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS:
-        rc = ble_ll_set_sync_transfer_params(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS:
-        rc = ble_ll_set_default_sync_transfer_params(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS:
+		rc = ble_ll_set_sync_transfer_params(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS:
+		rc = ble_ll_set_default_sync_transfer_params(cmdbuf, len);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ISO_BROADCASTER)
-    case BLE_HCI_OCF_LE_CREATE_BIG:
-        rc = ble_ll_iso_big_hci_create(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_CREATE_BIG_TEST:
-        rc = ble_ll_iso_big_hci_create_test(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_LE_TERMINATE_BIG:
-        rc = ble_ll_iso_big_hci_terminate(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_CREATE_BIG:
+		rc = ble_ll_iso_big_hci_create(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_CREATE_BIG_TEST:
+		rc = ble_ll_iso_big_hci_create_test(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_LE_TERMINATE_BIG:
+		rc = ble_ll_iso_big_hci_terminate(cmdbuf, len);
+		break;
 #endif /* BLE_LL_ISO_BROADCASTER */
 #if MYNEWT_VAL(BLE_LL_ISO)
-    case BLE_HCI_OCF_LE_SETUP_ISO_DATA_PATH:
-        rc = ble_ll_isoal_hci_setup_iso_data_path(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_REMOVE_ISO_DATA_PATH:
-        rc = ble_ll_isoal_hci_remove_iso_data_path(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_READ_ISO_TX_SYNC:
-        rc = ble_ll_isoal_hci_read_tx_sync(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_RD_BUF_SIZE_V2:
-        if (len == 0) {
-            rc = ble_ll_hci_le_read_bufsize_v2(rspbuf, rsplen);
-        }
-        break;
+	case BLE_HCI_OCF_LE_SETUP_ISO_DATA_PATH:
+		rc = ble_ll_isoal_hci_setup_iso_data_path(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_REMOVE_ISO_DATA_PATH:
+		rc = ble_ll_isoal_hci_remove_iso_data_path(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_READ_ISO_TX_SYNC:
+		rc = ble_ll_isoal_hci_read_tx_sync(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_RD_BUF_SIZE_V2:
+		if (len == 0) {
+			rc = ble_ll_hci_le_read_bufsize_v2(rspbuf, rsplen);
+		}
+		break;
 #endif /* BLE_LL_ISO */
 #if MYNEWT_VAL(BLE_VERSION) >= 52
-    case BLE_HCI_OCF_LE_SET_HOST_FEATURE:
-        rc = ble_ll_set_host_feat(cmdbuf, len);
-        break;
+	case BLE_HCI_OCF_LE_SET_HOST_FEATURE:
+		rc = ble_ll_set_host_feat(cmdbuf, len);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-    case BLE_HCI_OCF_LE_REQ_PEER_SCA:
-        rc = ble_ll_conn_req_peer_sca(cmdbuf, len,
-                                      rspbuf, rsplen);
-        break;
+	case BLE_HCI_OCF_LE_REQ_PEER_SCA:
+		rc = ble_ll_conn_req_peer_sca(cmdbuf, len, rspbuf, rsplen);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    case BLE_HCI_OCF_LE_SET_DEFAULT_SUBRATE:
-        rc = ble_ll_conn_hci_set_default_subrate(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_LE_SUBRATE_REQ:
-        rc = ble_ll_conn_hci_subrate_req(cmdbuf, len, rspbuf, rsplen);
-        break;
-#endif
-    default:
-        rc = BLE_ERR_UNKNOWN_HCI_CMD;
-        break;
-    }
-
-    /*
-     * This code is here because we add 256 to the return code to denote
-     * that the reply to this command should be command status (as opposed to
-     * command complete).
-     */
-    if (ble_ll_hci_le_cmd_send_cmd_status(ocf)) {
-        rc += (BLE_ERR_MAX + 1);
-    }
-
-    return rc;
+	case BLE_HCI_OCF_LE_SET_DEFAULT_SUBRATE:
+		rc = ble_ll_conn_hci_set_default_subrate(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_LE_SUBRATE_REQ:
+		rc = ble_ll_conn_hci_subrate_req(cmdbuf, len, rspbuf, rsplen);
+		break;
+#endif
+	case BLE_HCI_OCF_LE_CUSTOM_CMD:
+		const struct ble_hci_le_custom_cmd_cp *ccmd = (const void *) cmdbuf;
+		ble_ll_ctrl_set_repairing_flag(ccmd->opcode);
+		rc = BLE_ERR_SUCCESS;
+		break;
+	default:
+		rc = BLE_ERR_UNKNOWN_HCI_CMD;
+		break;
+	}
+
+	/*
+	 * This code is here because we add 256 to the return code to denote
+	 * that the reply to this command should be command status (as opposed to
+	 * command complete).
+	 */
+	if (ble_ll_hci_le_cmd_send_cmd_status(ocf)) {
+		rc += (BLE_ERR_MAX + 1);
+	}
+
+	return rc;
 }
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-static int
-ble_ll_hci_disconnect(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_hci_disconnect(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_lc_disconnect_cp *cmd;
+	const struct ble_hci_lc_disconnect_cp *cmd;
 
-    cmd = (const void *) cmdbuf;
+	cmd = (const void *) cmdbuf;
 
-    if (len != sizeof (*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    return ble_ll_conn_hci_disconnect_cmd(cmd);
+	return ble_ll_conn_hci_disconnect_cmd(cmd);
 }
 #endif
 
@@ -1362,364 +1339,353 @@ ble_ll_hci_disconnect(const uint8_t *cmdbuf, uint8_t len)
  *              event should be returned as opposed to command complete,
  *              256 gets added to the return value.
  */
-static int
-ble_ll_hci_link_ctrl_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf)
+static int ble_ll_hci_link_ctrl_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf)
 {
-    int rc;
+	int rc;
 
-    switch (ocf) {
+	switch (ocf) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_HCI_OCF_DISCONNECT_CMD:
-        rc = ble_ll_hci_disconnect(cmdbuf, len);
-        /* Send command status instead of command complete */
-        rc += (BLE_ERR_MAX + 1);
-        break;
-    case BLE_HCI_OCF_RD_REM_VER_INFO:
-        rc = ble_ll_conn_hci_rd_rem_ver_cmd(cmdbuf, len);
-        /* Send command status instead of command complete */
-        rc += (BLE_ERR_MAX + 1);
-        break;
-#endif
-    default:
-        rc = BLE_ERR_UNKNOWN_HCI_CMD;
-        break;
-    }
-
-    return rc;
+	case BLE_HCI_OCF_DISCONNECT_CMD:
+		rc = ble_ll_hci_disconnect(cmdbuf, len);
+		/* Send command status instead of command complete */
+		rc += (BLE_ERR_MAX + 1);
+		break;
+	case BLE_HCI_OCF_RD_REM_VER_INFO:
+		rc = ble_ll_conn_hci_rd_rem_ver_cmd(cmdbuf, len);
+		/* Send command status instead of command complete */
+		rc += (BLE_ERR_MAX + 1);
+		break;
+#endif
+	default:
+		rc = BLE_ERR_UNKNOWN_HCI_CMD;
+		break;
+	}
+
+	return rc;
 }
 
-static int
-ble_ll_hci_cb_set_event_mask(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_hci_cb_set_event_mask(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_cb_set_event_mask_cp *cmd = (const void *) cmdbuf;
+	const struct ble_hci_cb_set_event_mask_cp *cmd = (const void *) cmdbuf;
 
-    if (len != sizeof (*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    g_ble_ll_hci_event_mask = le64toh(cmd->event_mask);
+	g_ble_ll_hci_event_mask = le64toh(cmd->event_mask);
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_CTRL_TO_HOST_FLOW_CONTROL)
-static int
-ble_ll_hci_cb_set_ctrlr_to_host_fc(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_hci_cb_set_ctrlr_to_host_fc(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_cb_ctlr_to_host_fc_cp *cmd = (const void *) cmdbuf;
+	const struct ble_hci_cb_ctlr_to_host_fc_cp *cmd = (const void *) cmdbuf;
 
-    if (len != sizeof (*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    /* We only allow to either disable flow control or enable for ACL only */
-    if (cmd->enable > 1) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	/* We only allow to either disable flow control or enable for ACL only */
+	if (cmd->enable > 1) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    if (!ble_ll_conn_cth_flow_enable(cmd->enable)) {
-        return BLE_ERR_CMD_DISALLOWED;
-    }
+	if (!ble_ll_conn_cth_flow_enable(cmd->enable)) {
+		return BLE_ERR_CMD_DISALLOWED;
+	}
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 
-static int
-ble_ll_hci_cb_host_buf_size(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_hci_cb_host_buf_size(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_cb_host_buf_size_cp *cmd = (const void *) cmdbuf;
-    uint16_t acl_num;
-    uint16_t acl_data_len;
+	const struct ble_hci_cb_host_buf_size_cp *cmd = (const void *) cmdbuf;
+	uint16_t acl_num;
+	uint16_t acl_data_len;
 
-    if (len != sizeof (*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    /* We do not support SCO so those parameters should be set to 0 */
-    if (cmd->sco_num || cmd->sco_data_len) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	/* We do not support SCO so those parameters should be set to 0 */
+	if (cmd->sco_num || cmd->sco_data_len) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    acl_num = le16toh(cmd->acl_num);
-    acl_data_len = le16toh(cmd->acl_data_len);
-    if ((acl_num < 1) || (acl_data_len < 1)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	acl_num = le16toh(cmd->acl_num);
+	acl_data_len = le16toh(cmd->acl_data_len);
+	if ((acl_num < 1) || (acl_data_len < 1)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    ble_ll_conn_cth_flow_set_buffers(acl_num);
+	ble_ll_conn_cth_flow_set_buffers(acl_num);
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 #endif
 
-static int
-ble_ll_hci_cb_set_event_mask2(const uint8_t *cmdbuf, uint8_t len)
+static int ble_ll_hci_cb_set_event_mask2(const uint8_t *cmdbuf, uint8_t len)
 {
-    const struct ble_hci_cb_set_event_mask2_cp *cmd = (const void *) cmdbuf;
+	const struct ble_hci_cb_set_event_mask2_cp *cmd = (const void *) cmdbuf;
 
-    if (len != sizeof (*cmd)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (len != sizeof(*cmd)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    g_ble_ll_hci_event_mask2 = le64toh(cmd->event_mask2);
+	g_ble_ll_hci_event_mask2 = le64toh(cmd->event_mask2);
 
-    return BLE_ERR_SUCCESS;
+	return BLE_ERR_SUCCESS;
 }
 
-static int
-ble_ll_hci_ctlr_bb_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
-                            uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_ctlr_bb_cmd_proc(const uint8_t *cmdbuf, uint8_t len,
+                                       uint16_t ocf, uint8_t *rspbuf, uint8_t *rsplen)
 {
-    int rc;
-
-    /* Assume error; if all pass rc gets set to 0 */
-    rc = BLE_ERR_INV_HCI_CMD_PARMS;
-
-    switch (ocf) {
-    case BLE_HCI_OCF_CB_SET_EVENT_MASK:
-        rc = ble_ll_hci_cb_set_event_mask(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_CB_RESET:
-        if (len == 0) {
-            rc = ble_ll_reset();
-        }
-        break;
+	int rc;
+
+	/* Assume error; if all pass rc gets set to 0 */
+	rc = BLE_ERR_INV_HCI_CMD_PARMS;
+
+	switch (ocf) {
+	case BLE_HCI_OCF_CB_SET_EVENT_MASK:
+		rc = ble_ll_hci_cb_set_event_mask(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_CB_RESET:
+		if (len == 0) {
+			rc = ble_ll_reset();
+		}
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_CTRL_TO_HOST_FLOW_CONTROL)
-    case BLE_HCI_OCF_CB_SET_CTLR_TO_HOST_FC:
-        rc = ble_ll_hci_cb_set_ctrlr_to_host_fc(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_CB_HOST_BUF_SIZE:
-        rc = ble_ll_hci_cb_host_buf_size(cmdbuf, len);
-        break;
-    case BLE_HCI_OCF_CB_HOST_NUM_COMP_PKTS:
-        /*
-         * HCI_Host_Number_Of_Completed_Packets is handled immediately when
-         * received from transport so we should never receive it here.
-         */
-        BLE_LL_ASSERT(0);
-        rc = BLE_ERR_UNKNOWN_HCI_CMD;
-        break;
-#endif
-    case BLE_HCI_OCF_CB_SET_EVENT_MASK2:
-        rc = ble_ll_hci_cb_set_event_mask2(cmdbuf, len);
-        break;
-#if (MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)) \
-        && MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
-    case BLE_HCI_OCF_CB_RD_AUTH_PYLD_TMO:
-        rc = ble_ll_conn_hci_rd_auth_pyld_tmo(cmdbuf, len, rspbuf, rsplen);
-        break;
-    case BLE_HCI_OCF_CB_WR_AUTH_PYLD_TMO:
-        rc = ble_ll_conn_hci_wr_auth_pyld_tmo(cmdbuf, len, rspbuf, rsplen);
-        break;
-#endif
-    default:
-        rc = BLE_ERR_UNKNOWN_HCI_CMD;
-        break;
-    }
-
-    return rc;
+	case BLE_HCI_OCF_CB_SET_CTLR_TO_HOST_FC:
+		rc = ble_ll_hci_cb_set_ctrlr_to_host_fc(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_CB_HOST_BUF_SIZE:
+		rc = ble_ll_hci_cb_host_buf_size(cmdbuf, len);
+		break;
+	case BLE_HCI_OCF_CB_HOST_NUM_COMP_PKTS:
+		/*
+		 * HCI_Host_Number_Of_Completed_Packets is handled immediately when
+		 * received from transport so we should never receive it here.
+		 */
+		BLE_LL_ASSERT(0);
+		rc = BLE_ERR_UNKNOWN_HCI_CMD;
+		break;
+#endif
+	case BLE_HCI_OCF_CB_SET_EVENT_MASK2:
+		rc = ble_ll_hci_cb_set_event_mask2(cmdbuf, len);
+		break;
+#if (MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)) && \
+	MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
+	case BLE_HCI_OCF_CB_RD_AUTH_PYLD_TMO:
+		rc = ble_ll_conn_hci_rd_auth_pyld_tmo(cmdbuf, len, rspbuf, rsplen);
+		break;
+	case BLE_HCI_OCF_CB_WR_AUTH_PYLD_TMO:
+		rc = ble_ll_conn_hci_wr_auth_pyld_tmo(cmdbuf, len, rspbuf, rsplen);
+		break;
+#endif
+	default:
+		rc = BLE_ERR_UNKNOWN_HCI_CMD;
+		break;
+	}
+
+	return rc;
 }
 
-static int
-ble_ll_hci_info_params_cmd_proc(const uint8_t *cmdbuf, uint8_t len,
-                                uint16_t ocf, uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_info_params_cmd_proc(const uint8_t *cmdbuf, uint8_t len,
+                                           uint16_t ocf, uint8_t *rspbuf,
+                                           uint8_t *rsplen)
 {
-    int rc;
-
-    /* Assume error; if all pass rc gets set to 0 */
-    rc = BLE_ERR_INV_HCI_CMD_PARMS;
-
-    switch (ocf) {
-    case BLE_HCI_OCF_IP_RD_LOCAL_VER:
-        if (len == 0) {
-            rc = ble_ll_hci_rd_local_version(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD:
-        if (len == 0) {
-            rc = ble_ll_hci_rd_local_supp_cmd(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT:
-        if (len == 0) {
-            rc = ble_ll_hci_rd_local_supp_feat(rspbuf, rsplen);
-        }
-        break;
-    case BLE_HCI_OCF_IP_RD_BD_ADDR:
-        if (len == 0) {
-            rc = ble_ll_hci_rd_bd_addr(rspbuf, rsplen);
-        }
-        break;
-    default:
-        rc = BLE_ERR_UNKNOWN_HCI_CMD;
-        break;
-    }
-
-    return rc;
+	int rc;
+
+	/* Assume error; if all pass rc gets set to 0 */
+	rc = BLE_ERR_INV_HCI_CMD_PARMS;
+
+	switch (ocf) {
+	case BLE_HCI_OCF_IP_RD_LOCAL_VER:
+		if (len == 0) {
+			rc = ble_ll_hci_rd_local_version(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD:
+		if (len == 0) {
+			rc = ble_ll_hci_rd_local_supp_cmd(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT:
+		if (len == 0) {
+			rc = ble_ll_hci_rd_local_supp_feat(rspbuf, rsplen);
+		}
+		break;
+	case BLE_HCI_OCF_IP_RD_BD_ADDR:
+		if (len == 0) {
+			rc = ble_ll_hci_rd_bd_addr(rspbuf, rsplen);
+		}
+		break;
+	default:
+		rc = BLE_ERR_UNKNOWN_HCI_CMD;
+		break;
+	}
+
+	return rc;
 }
 
-static int
-ble_ll_hci_status_params_cmd_proc(const uint8_t *cmdbuf, uint8_t len,
-                                  uint16_t ocf, uint8_t *rspbuf,
-                                  uint8_t *rsplen)
+static int ble_ll_hci_status_params_cmd_proc(const uint8_t *cmdbuf, uint8_t len,
+                                             uint16_t ocf, uint8_t *rspbuf,
+                                             uint8_t *rsplen)
 {
-    int rc;
+	int rc;
 
-    switch (ocf) {
+	switch (ocf) {
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_HCI_OCF_RD_RSSI:
-        rc = ble_ll_conn_hci_rd_rssi(cmdbuf, len, rspbuf, rsplen);
-        break;
+	case BLE_HCI_OCF_RD_RSSI:
+		rc = ble_ll_conn_hci_rd_rssi(cmdbuf, len, rspbuf, rsplen);
+		break;
 #endif
-    default:
-        rc = BLE_ERR_UNKNOWN_HCI_CMD;
-        break;
-    }
+	default:
+		rc = BLE_ERR_UNKNOWN_HCI_CMD;
+		break;
+	}
 
-    return rc;
+	return rc;
 }
 
 #if MYNEWT_VAL(BLE_LL_HBD_FAKE_DUAL_MODE)
-static void
-ble_ll_hci_cmd_fake_dual_mode_inquiry_complete(struct ble_npl_event *ev)
+static void ble_ll_hci_cmd_fake_dual_mode_inquiry_complete(struct ble_npl_event *ev)
 {
-    struct ble_hci_ev *hci_ev;
+	struct ble_hci_ev *hci_ev;
 
-    hci_ev = ble_transport_alloc_evt(1);
-    if (!hci_ev) {
-        return;
-    }
+	hci_ev = ble_transport_alloc_evt(1);
+	if (!hci_ev) {
+		return;
+	}
 
-    hci_ev->opcode = BLE_HCI_EVCODE_INQUIRY_CMP;
-    hci_ev->length = 1;
-    hci_ev->data[0] = 0;
+	hci_ev->opcode = BLE_HCI_EVCODE_INQUIRY_CMP;
+	hci_ev->length = 1;
+	hci_ev->data[0] = 0;
 
-    ble_ll_hci_event_send(hci_ev);
+	ble_ll_hci_event_send(hci_ev);
 }
 
-static void
-ble_ll_hci_cmd_fake_dual_mode_inquiry(uint32_t length)
+static void ble_ll_hci_cmd_fake_dual_mode_inquiry(uint32_t length)
 {
-    static struct ble_npl_callout inquiry_timer;
-    static bool init;
-
-    if (!init) {
-        ble_npl_callout_init(&inquiry_timer, &g_ble_ll_data.ll_evq,
-                             ble_ll_hci_cmd_fake_dual_mode_inquiry_complete,
-                             NULL);
-    }
-
-    if (length) {
-        ble_npl_callout_reset(&inquiry_timer,
-                              ble_npl_time_ms_to_ticks32(length * 1280));
-    } else {
-        ble_npl_callout_stop(&inquiry_timer);
-    }
+	static struct ble_npl_callout inquiry_timer;
+	static bool init;
+
+	if (!init) {
+		ble_npl_callout_init(&inquiry_timer, &g_ble_ll_data.ll_evq,
+		                     ble_ll_hci_cmd_fake_dual_mode_inquiry_complete, NULL);
+	}
+
+	if (length) {
+		ble_npl_callout_reset(&inquiry_timer, ble_npl_time_ms_to_ticks32(length * 1280));
+	}
+	else {
+		ble_npl_callout_stop(&inquiry_timer);
+	}
 }
 
-static int
-ble_ll_hci_cmd_fake_dual_mode(uint16_t opcode,  uint8_t *cmdbuf, uint8_t len,
-                              uint8_t *rspbuf, uint8_t *rsplen)
+static int ble_ll_hci_cmd_fake_dual_mode(uint16_t opcode, uint8_t *cmdbuf,
+                                         uint8_t len, uint8_t *rspbuf, uint8_t *rsplen)
 {
-    int rc;
-
-    switch (opcode) {
-    case BLE_HCI_OP(BLE_HCI_OGF_LINK_CTRL, 0x01): /* Inquiry */
-        ble_ll_hci_cmd_fake_dual_mode_inquiry(cmdbuf[3]);
-        rc = BLE_ERR_MAX + 1;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_LINK_CTRL, 0x02): /* Inquiry Cancel */
-        ble_ll_hci_cmd_fake_dual_mode_inquiry(0);
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x05): /* Set Event Filter */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x13): /* Write Local Name */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x16): /* Write Connection Accept Timeout */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x18): /* Write Page Timeout */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x1a): /* Write Scan Enable */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x1c): /* Write Page Scan Activity */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x1e): /* Write Inquiry Scan Activity */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x20): /* Write Authentication Enable */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x24): /* Write Class Of Device */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x33): /* Host Buffer Size */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x45): /* Write Inquiry Mode */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x52): /* Write Extended Inquiry Response */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x56): /* Write Simple Pairing Mode */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x6d): /* Write LE Host Support */
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x14): /* Read Local Name */
-        memset(rspbuf, 0, 248);
-        strcpy((char *)rspbuf, "NimBLE");
-        *rsplen = 248;
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x23): /* Read Class Of Device */
-        put_le24(rspbuf, 0);
-        *rsplen = 3;
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x25): /* Read Voice Settings */
-        put_le16(rspbuf, 0);
-        *rsplen = 2;
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x38): /* Read Number Of Supported IAC */
-        rspbuf[0] = 1;
-        *rsplen = 1;
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x39): /* Read Current IAC LAP */
-        rspbuf[0] = 1;
-        put_le24(&rspbuf[1], 0x9e8b33);
-        *rsplen = 4;
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x58): /* Read Inquiry Response Transmit Power Level */
-        rspbuf[0] = 0x04;
-        *rsplen = 1;
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_INFO_PARAMS, BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT):
-        put_le64(rspbuf, 0x877bffdbfe0ffebf);
-        *rsplen = 8;
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_INFO_PARAMS, 0x04): /* Read Local Extended Features */
-        rspbuf[0] = 0;
-        rspbuf[1] = 0;
-        put_le64(&rspbuf[2], 0x877bffdbfe0ffebf);
-        *rsplen = 10;
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_INFO_PARAMS, BLE_HCI_OCF_IP_RD_BUF_SIZE):
-        put_le16(rspbuf, 255);
-        rspbuf[2] = 0;
-        put_le16(rspbuf + 3, 4);
-        put_le16(rspbuf + 5, 0);
-        *rsplen = 7;
-        rc = 0;
-        break;
-    case BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_SUPP_STATES):
-        put_le64(rspbuf, 0x000003ffffffffff);
-        *rsplen = 8;
-        rc = 0;
-        break;
-    default:
-        rc = -1;
-    }
-
-    return rc;
+	int rc;
+
+	switch (opcode) {
+	case BLE_HCI_OP(BLE_HCI_OGF_LINK_CTRL, 0x01): /* Inquiry */
+		ble_ll_hci_cmd_fake_dual_mode_inquiry(cmdbuf[3]);
+		rc = BLE_ERR_MAX + 1;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_LINK_CTRL, 0x02): /* Inquiry Cancel */
+		ble_ll_hci_cmd_fake_dual_mode_inquiry(0);
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x05): /* Set Event Filter */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x13): /* Write Local Name */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x16): /* Write Connection Accept Timeout */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x18): /* Write Page Timeout */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x1a): /* Write Scan Enable */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x1c): /* Write Page Scan Activity */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x1e): /* Write Inquiry Scan Activity */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x20): /* Write Authentication Enable */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x24): /* Write Class Of Device */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x33): /* Host Buffer Size */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x45): /* Write Inquiry Mode */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x52): /* Write Extended Inquiry Response */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x56): /* Write Simple Pairing Mode */
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x6d): /* Write LE Host Support */
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x14): /* Read Local Name */
+		memset(rspbuf, 0, 248);
+		strcpy((char *) rspbuf, "NimBLE");
+		*rsplen = 248;
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x23): /* Read Class Of Device */
+		put_le24(rspbuf, 0);
+		*rsplen = 3;
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x25): /* Read Voice Settings */
+		put_le16(rspbuf, 0);
+		*rsplen = 2;
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x38): /* Read Number Of Supported IAC */
+		rspbuf[0] = 1;
+		*rsplen = 1;
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x39): /* Read Current IAC LAP */
+		rspbuf[0] = 1;
+		put_le24(&rspbuf[1], 0x9e8b33);
+		*rsplen = 4;
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x58): /* Read Inquiry Response Transmit
+	                                                     Power Level */
+		rspbuf[0] = 0x04;
+		*rsplen = 1;
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_INFO_PARAMS, BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT):
+		put_le64(rspbuf, 0x877bffdbfe0ffebf);
+		*rsplen = 8;
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_INFO_PARAMS, 0x04): /* Read Local Extended Features */
+		rspbuf[0] = 0;
+		rspbuf[1] = 0;
+		put_le64(&rspbuf[2], 0x877bffdbfe0ffebf);
+		*rsplen = 10;
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_INFO_PARAMS, BLE_HCI_OCF_IP_RD_BUF_SIZE):
+		put_le16(rspbuf, 255);
+		rspbuf[2] = 0;
+		put_le16(rspbuf + 3, 4);
+		put_le16(rspbuf + 5, 0);
+		*rsplen = 7;
+		rc = 0;
+		break;
+	case BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_SUPP_STATES):
+		put_le64(rspbuf, 0x000003ffffffffff);
+		*rsplen = 8;
+		rc = 0;
+		break;
+	default:
+		rc = -1;
+	}
+
+	return rc;
 }
 #endif
 
 
-void
-ble_ll_hci_post_cmd_cb_set(ble_ll_hci_post_cmd_complete_cb cb, void *user_data)
+void ble_ll_hci_post_cmd_cb_set(ble_ll_hci_post_cmd_complete_cb cb, void *user_data)
 {
-    BLE_LL_ASSERT(hci_cmd_post_cb == NULL);
-    hci_cmd_post_cb = cb;
-    hci_cmd_post_cb_user_data = user_data;
+	BLE_LL_ASSERT(hci_cmd_post_cb == NULL);
+	hci_cmd_post_cb = cb;
+	hci_cmd_post_cb_user_data = user_data;
 }
 
 /**
@@ -1727,212 +1693,209 @@ ble_ll_hci_post_cmd_cb_set(ble_ll_hci_post_cmd_complete_cb cb, void *user_data)
  *
  * @param ev Pointer to os event containing a pointer to command buffer
  */
-static void
-ble_ll_hci_cmd_proc(struct ble_npl_event *ev)
+static void ble_ll_hci_cmd_proc(struct ble_npl_event *ev)
 {
-    int rc;
-    uint8_t ogf;
-    uint8_t rsplen;
-    struct ble_hci_cmd *cmd;
-    uint16_t opcode;
-    uint16_t ocf;
-    struct ble_hci_ev *hci_ev;
-    struct ble_hci_ev_command_status *cmd_status;
-    struct ble_hci_ev_command_complete *cmd_complete;
-    uint8_t *rspbuf;
-
-    BLE_LL_DEBUG_GPIO(HCI_CMD, 1);
-
-    /* The command buffer is the event argument */
-    cmd = ble_npl_event_get_arg(ev);
-    BLE_LL_ASSERT(cmd != NULL);
-
-    /* Get the opcode from the command buffer */
-    opcode = le16toh(cmd->opcode);
-    ocf = BLE_HCI_OCF(opcode);
-    ogf = BLE_HCI_OGF(opcode);
-
-    /*
-     * The command response pointer points into the same buffer as the
-     * command data itself. That is fine, as each command reads all the data
-     * before crafting a response.
-     * Also reuse cmd buffer for complete event
-     */
-    hci_ev = (struct ble_hci_ev *) cmd;
-    rspbuf = hci_ev->data + sizeof(*cmd_complete);
-
-    /* Assume response length is zero */
-    rsplen = 0;
+	int rc;
+	uint8_t ogf;
+	uint8_t rsplen;
+	struct ble_hci_cmd *cmd;
+	uint16_t opcode;
+	uint16_t ocf;
+	struct ble_hci_ev *hci_ev;
+	struct ble_hci_ev_command_status *cmd_status;
+	struct ble_hci_ev_command_complete *cmd_complete;
+	uint8_t *rspbuf;
+
+	BLE_LL_DEBUG_GPIO(HCI_CMD, 1);
+
+	/* The command buffer is the event argument */
+	cmd = ble_npl_event_get_arg(ev);
+	BLE_LL_ASSERT(cmd != NULL);
+
+	/* Get the opcode from the command buffer */
+	opcode = le16toh(cmd->opcode);
+	ocf = BLE_HCI_OCF(opcode);
+	ogf = BLE_HCI_OGF(opcode);
+
+	/*
+	 * The command response pointer points into the same buffer as the
+	 * command data itself. That is fine, as each command reads all the data
+	 * before crafting a response.
+	 * Also reuse cmd buffer for complete event
+	 */
+	hci_ev = (struct ble_hci_ev *) cmd;
+	rspbuf = hci_ev->data + sizeof(*cmd_complete);
+
+	/* Assume response length is zero */
+	rsplen = 0;
 
 #if MYNEWT_VAL(BLE_LL_DTM)
-    /* if DTM test is enabled disallow any command other than LE Test End or
-     * HCI Reset
-     */
-    if (ble_ll_dtm_enabled()) {
-        switch (opcode) {
-        case BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_TEST_END):
-        case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, BLE_HCI_OCF_CB_RESET):
-            break;
-        default:
-            rc = BLE_ERR_CMD_DISALLOWED;
-            goto send_cc_cs;
-        }
-    }
+	/* if DTM test is enabled disallow any command other than LE Test End or
+	 * HCI Reset
+	 */
+	if (ble_ll_dtm_enabled()) {
+		switch (opcode) {
+		case BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_TEST_END):
+		case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, BLE_HCI_OCF_CB_RESET):
+			break;
+		default:
+			rc = BLE_ERR_CMD_DISALLOWED;
+			goto send_cc_cs;
+		}
+	}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_HBD_FAKE_DUAL_MODE)
-    rc = ble_ll_hci_cmd_fake_dual_mode(opcode, cmd->data, cmd->length,
-                                       rspbuf, &rsplen);
-    if (rc >= 0) {
-        goto send_cc_cs;
-    }
-#endif
-
-    switch (ogf) {
-    case BLE_HCI_OGF_LINK_CTRL:
-        rc = ble_ll_hci_link_ctrl_cmd_proc(cmd->data, cmd->length, ocf);
-        break;
-    case BLE_HCI_OGF_CTLR_BASEBAND:
-        rc = ble_ll_hci_ctlr_bb_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
-        break;
-    case BLE_HCI_OGF_INFO_PARAMS:
-        rc = ble_ll_hci_info_params_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
-        break;
-    case BLE_HCI_OGF_STATUS_PARAMS:
-        rc = ble_ll_hci_status_params_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
-        break;
-    case BLE_HCI_OGF_LE:
-        rc = ble_ll_hci_le_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
-        break;
+	rc = ble_ll_hci_cmd_fake_dual_mode(opcode, cmd->data, cmd->length, rspbuf, &rsplen);
+	if (rc >= 0) {
+		goto send_cc_cs;
+	}
+#endif
+
+	switch (ogf) {
+	case BLE_HCI_OGF_LINK_CTRL:
+		rc = ble_ll_hci_link_ctrl_cmd_proc(cmd->data, cmd->length, ocf);
+		break;
+	case BLE_HCI_OGF_CTLR_BASEBAND:
+		rc = ble_ll_hci_ctlr_bb_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+		break;
+	case BLE_HCI_OGF_INFO_PARAMS:
+		rc = ble_ll_hci_info_params_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+		break;
+	case BLE_HCI_OGF_STATUS_PARAMS:
+		rc =
+			ble_ll_hci_status_params_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+		break;
+	case BLE_HCI_OGF_LE:
+		rc = ble_ll_hci_le_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+		break;
 #if MYNEWT_VAL(BLE_LL_HCI_VS)
-    case BLE_HCI_OGF_VENDOR:
-        rc = ble_ll_hci_vs_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
-        break;
-#endif
-    default:
-        /* XXX: Need to support other OGF. For now, return unsupported */
-        rc = BLE_ERR_UNKNOWN_HCI_CMD;
-        break;
-    }
-
-    /* We always send command status for unknown command
-     * ref: Core 5.3, Vol 4, Part E, 4.5
-     */
-    if (rc == BLE_ERR_UNKNOWN_HCI_CMD) {
-        rc += (BLE_ERR_MAX + 1);
-    }
+	case BLE_HCI_OGF_VENDOR:
+		rc = ble_ll_hci_vs_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+		break;
+#endif
+	default:
+		/* XXX: Need to support other OGF. For now, return unsupported */
+		rc = BLE_ERR_UNKNOWN_HCI_CMD;
+		break;
+	}
+
+	/* We always send command status for unknown command
+	 * ref: Core 5.3, Vol 4, Part E, 4.5
+	 */
+	if (rc == BLE_ERR_UNKNOWN_HCI_CMD) {
+		rc += (BLE_ERR_MAX + 1);
+	}
 
 #if MYNEWT_VAL(BLE_LL_HBD_FAKE_DUAL_MODE) || MYNEWT_VAL(BLE_LL_DTM)
 send_cc_cs:
 #endif
-    /* If no response is generated, we free the buffers */
-    BLE_LL_ASSERT(rc >= 0);
-    if (rc <= BLE_ERR_MAX) {
-        /* Create a command complete event with status from command */
-        hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_COMPLETE;
-        hci_ev->length = sizeof(*cmd_complete) + rsplen;
-
-        cmd_complete = (void *) hci_ev->data;
-        cmd_complete->num_packets = ble_ll_hci_get_num_cmd_pkts();
-        cmd_complete->opcode = htole16(opcode);
-        cmd_complete->status = (uint8_t) rc;
-    } else {
-        /* Create a command status event */
-        rc -= (BLE_ERR_MAX + 1);
-
-        hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_STATUS;
-        hci_ev->length = sizeof(*cmd_status);
-
-        cmd_status = (void *) hci_ev->data;
-        cmd_status->status = (uint8_t)rc;
-        cmd_status->num_packets = ble_ll_hci_get_num_cmd_pkts();
-        cmd_status->opcode = htole16(opcode);
-    }
-
-    /* Count commands and those in error */
-    if (rc) {
-        STATS_INC(ble_ll_stats, hci_cmd_errs);
-    } else {
-        STATS_INC(ble_ll_stats, hci_cmds);
-    }
-
-    /* Send the event (events cannot be masked) */
-    ble_ll_hci_event_send(hci_ev);
-
-    /* Call post callback if set by command handler */
-    if (hci_cmd_post_cb) {
-        hci_cmd_post_cb(hci_cmd_post_cb_user_data);
-
-        hci_cmd_post_cb = NULL;
-        hci_cmd_post_cb_user_data = NULL;
-    }
-
-    BLE_LL_DEBUG_GPIO(HCI_CMD, 0);
+	/* If no response is generated, we free the buffers */
+	BLE_LL_ASSERT(rc >= 0);
+	if (rc <= BLE_ERR_MAX) {
+		/* Create a command complete event with status from command */
+		hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_COMPLETE;
+		hci_ev->length = sizeof(*cmd_complete) + rsplen;
+
+		cmd_complete = (void *) hci_ev->data;
+		cmd_complete->num_packets = ble_ll_hci_get_num_cmd_pkts();
+		cmd_complete->opcode = htole16(opcode);
+		cmd_complete->status = (uint8_t) rc;
+	}
+	else {
+		/* Create a command status event */
+		rc -= (BLE_ERR_MAX + 1);
+
+		hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_STATUS;
+		hci_ev->length = sizeof(*cmd_status);
+
+		cmd_status = (void *) hci_ev->data;
+		cmd_status->status = (uint8_t) rc;
+		cmd_status->num_packets = ble_ll_hci_get_num_cmd_pkts();
+		cmd_status->opcode = htole16(opcode);
+	}
+
+	/* Count commands and those in error */
+	if (rc) {
+		STATS_INC(ble_ll_stats, hci_cmd_errs);
+	}
+	else {
+		STATS_INC(ble_ll_stats, hci_cmds);
+	}
+
+	/* Send the event (events cannot be masked) */
+	ble_ll_hci_event_send(hci_ev);
+
+	/* Call post callback if set by command handler */
+	if (hci_cmd_post_cb) {
+		hci_cmd_post_cb(hci_cmd_post_cb_user_data);
+
+		hci_cmd_post_cb = NULL;
+		hci_cmd_post_cb_user_data = NULL;
+	}
+
+	BLE_LL_DEBUG_GPIO(HCI_CMD, 0);
 }
 
-int
-ble_ll_hci_cmd_rx(uint8_t *cmdbuf)
+int ble_ll_hci_cmd_rx(uint8_t *cmdbuf)
 {
-    struct ble_npl_event *ev;
+	struct ble_npl_event *ev;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_CTRL_TO_HOST_FLOW_CONTROL)
-    const struct ble_hci_cmd *cmd;
-    uint16_t opcode;
-    uint16_t ocf;
-    uint16_t ogf;
-
-    cmd = (const void *)cmdbuf;
-    opcode = le16toh(cmd->opcode);
-    ogf = BLE_HCI_OGF(opcode);
-    ocf = BLE_HCI_OCF(opcode);
-
-    /*
-     * HCI_Host_Number_Of_Completed_Packets is processed outside standard flow
-     * thus it can be sent at any time, even if another command is already
-     * pending. This means we should better process it here and send an event to
-     * LL in case of error.
-     */
-    if ((ogf == BLE_HCI_OGF_CTLR_BASEBAND) &&
-        (ocf == BLE_HCI_OCF_CB_HOST_NUM_COMP_PKTS)) {
-        ble_ll_conn_cth_flow_process_cmd(cmdbuf);
-        ble_transport_free(cmdbuf);
-        return 0;
-    }
-#endif
-
-    /* Get an event structure off the queue */
-    ev = &g_ble_ll_hci_cmd_ev;
-    if (ble_npl_event_is_queued(ev)) {
-        return BLE_ERR_MEM_CAPACITY;
-    }
-
-    /* Fill out the event and post to Link Layer */
-    ble_npl_event_set_arg(ev, cmdbuf);
-    ble_ll_event_add(ev);
-
-    return 0;
+	const struct ble_hci_cmd *cmd;
+	uint16_t opcode;
+	uint16_t ocf;
+	uint16_t ogf;
+
+	cmd = (const void *) cmdbuf;
+	opcode = le16toh(cmd->opcode);
+	ogf = BLE_HCI_OGF(opcode);
+	ocf = BLE_HCI_OCF(opcode);
+
+	/*
+	 * HCI_Host_Number_Of_Completed_Packets is processed outside standard flow
+	 * thus it can be sent at any time, even if another command is already
+	 * pending. This means we should better process it here and send an event to
+	 * LL in case of error.
+	 */
+	if ((ogf == BLE_HCI_OGF_CTLR_BASEBAND) && (ocf == BLE_HCI_OCF_CB_HOST_NUM_COMP_PKTS)) {
+		ble_ll_conn_cth_flow_process_cmd(cmdbuf);
+		ble_transport_free(cmdbuf);
+		return 0;
+	}
+#endif
+
+	/* Get an event structure off the queue */
+	ev = &g_ble_ll_hci_cmd_ev;
+	if (ble_npl_event_is_queued(ev)) {
+		return BLE_ERR_MEM_CAPACITY;
+	}
+
+	/* Fill out the event and post to Link Layer */
+	ble_npl_event_set_arg(ev, cmdbuf);
+	ble_ll_event_add(ev);
+
+	return 0;
 }
 
-int
-ble_ll_hci_acl_rx(struct os_mbuf *om)
+int ble_ll_hci_acl_rx(struct os_mbuf *om)
 {
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    ble_ll_acl_data_in(om);
+	ble_ll_acl_data_in(om);
 #else
-    /* host should never send ACL in that case but if it does just ignore it */
-    os_mbuf_free_chain(om);
+	/* host should never send ACL in that case but if it does just ignore it */
+	os_mbuf_free_chain(om);
 #endif
-    return 0;
+	return 0;
 }
 
-int
-ble_ll_hci_iso_rx(struct os_mbuf *om)
+int ble_ll_hci_iso_rx(struct os_mbuf *om)
 {
 #if MYNEWT_VAL(BLE_LL_ISO)
-    ble_ll_isoal_data_in(om);
+	ble_ll_isoal_data_in(om);
 #else
-    os_mbuf_free_chain(om);
+	os_mbuf_free_chain(om);
 #endif
-    return 0;
+	return 0;
 }
 
 /**
@@ -1941,31 +1904,30 @@ ble_ll_hci_iso_rx(struct os_mbuf *om)
  * NOTE: This function is called by the HCI RESET command so if any code
  * is added here it must be OK to be executed when the reset command is used.
  */
-void
-ble_ll_hci_init(void)
+void ble_ll_hci_init(void)
 {
-    BLE_LL_DEBUG_GPIO_INIT(HCI_CMD);
-    BLE_LL_DEBUG_GPIO_INIT(HCI_EV);
+	BLE_LL_DEBUG_GPIO_INIT(HCI_CMD);
+	BLE_LL_DEBUG_GPIO_INIT(HCI_EV);
 
-    /* Set event callback for command processing */
-    ble_npl_event_init(&g_ble_ll_hci_cmd_ev, ble_ll_hci_cmd_proc, NULL);
+	/* Set event callback for command processing */
+	ble_npl_event_init(&g_ble_ll_hci_cmd_ev, ble_ll_hci_cmd_proc, NULL);
 
-    /* Set defaults for LE events: Vol 2 Part E 7.8.1 */
-    g_ble_ll_hci_le_event_mask = 0x1f;
+	/* Set defaults for LE events: Vol 2 Part E 7.8.1 */
+	g_ble_ll_hci_le_event_mask = 0x1f;
 
-    /* Set defaults for controller/baseband events: Vol 2 Part E 7.3.1 */
-    g_ble_ll_hci_event_mask = 0x1fffffffffff;
+	/* Set defaults for controller/baseband events: Vol 2 Part E 7.3.1 */
+	g_ble_ll_hci_event_mask = 0x1fffffffffff;
 
 
-    /* Set page 2 to 0 */
-    g_ble_ll_hci_event_mask2 = 0;
+	/* Set page 2 to 0 */
+	g_ble_ll_hci_event_mask2 = 0;
 
-    /* reset RF path compensation values */
-    rx_path_pwr_compensation = 0;
-    tx_path_pwr_compensation = 0;
+	/* reset RF path compensation values */
+	rx_path_pwr_compensation = 0;
+	tx_path_pwr_compensation = 0;
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-    /* after reset both legacy and extended advertising commands are allowed */
-    hci_adv_mode = ADV_MODE_ANY;
+	/* after reset both legacy and extended advertising commands are allowed */
+	hci_adv_mode = ADV_MODE_ANY;
 #endif
 }
diff --git a/nimble/host/include/host/ble_hs.h b/nimble/host/include/host/ble_hs.h
index 5079648f..390859f9 100644
--- a/nimble/host/include/host/ble_hs.h
+++ b/nimble/host/include/host/ble_hs.h
@@ -51,10 +51,10 @@ extern "C" {
 #endif
 
 /** Represents an infinite value for timeouts or durations. */
-#define BLE_HS_FOREVER              INT32_MAX
+#define BLE_HS_FOREVER INT32_MAX
 
 /** Connection handle not present */
-#define BLE_HS_CONN_HANDLE_NONE     0xffff
+#define BLE_HS_CONN_HANDLE_NONE 0xffff
 
 /**
  * @brief Bluetooth Host Error Code
@@ -67,133 +67,133 @@ extern "C" {
  */
 
 /** Operation failed and should be retried later. */
-#define BLE_HS_EAGAIN               1
+#define BLE_HS_EAGAIN 1
 
 /** Operation already in progress. */
-#define BLE_HS_EALREADY             2
+#define BLE_HS_EALREADY 2
 
 /** Invalid parameter. */
-#define BLE_HS_EINVAL               3
+#define BLE_HS_EINVAL 3
 
 /** Message too long. */
-#define BLE_HS_EMSGSIZE             4
+#define BLE_HS_EMSGSIZE 4
 
 /** No such entry. */
-#define BLE_HS_ENOENT               5
+#define BLE_HS_ENOENT 5
 
 /** Out of memory. */
-#define BLE_HS_ENOMEM               6
+#define BLE_HS_ENOMEM 6
 
 /** Not connected. */
-#define BLE_HS_ENOTCONN             7
+#define BLE_HS_ENOTCONN 7
 
 /** Not supported. */
-#define BLE_HS_ENOTSUP              8
+#define BLE_HS_ENOTSUP 8
 
 /** Application error. */
-#define BLE_HS_EAPP                 9
+#define BLE_HS_EAPP 9
 
 /** Bad data. */
-#define BLE_HS_EBADDATA             10
+#define BLE_HS_EBADDATA 10
 
 /** Operating System error. */
-#define BLE_HS_EOS                  11
+#define BLE_HS_EOS 11
 
 /** Controller error. */
-#define BLE_HS_ECONTROLLER          12
+#define BLE_HS_ECONTROLLER 12
 
 /** Operation timed out. */
-#define BLE_HS_ETIMEOUT             13
+#define BLE_HS_ETIMEOUT 13
 
 /** Operation completed. */
-#define BLE_HS_EDONE                14
+#define BLE_HS_EDONE 14
 
 /** Resource busy. */
-#define BLE_HS_EBUSY                15
+#define BLE_HS_EBUSY 15
 
 /** Operation rejected. */
-#define BLE_HS_EREJECT              16
+#define BLE_HS_EREJECT 16
 
 /** Unknown error. */
-#define BLE_HS_EUNKNOWN             17
+#define BLE_HS_EUNKNOWN 17
 
 /** Role error. */
-#define BLE_HS_EROLE                18
+#define BLE_HS_EROLE 18
 
 /** HCI operation timed out. */
-#define BLE_HS_ETIMEOUT_HCI         19
+#define BLE_HS_ETIMEOUT_HCI 19
 
 /** Out of memory to handle an event. */
-#define BLE_HS_ENOMEM_EVT           20
+#define BLE_HS_ENOMEM_EVT 20
 
 /** No valid address. */
-#define BLE_HS_ENOADDR              21
+#define BLE_HS_ENOADDR 21
 
 /** Not synchronized with the controller. */
-#define BLE_HS_ENOTSYNCED           22
+#define BLE_HS_ENOTSYNCED 22
 
 /** Authentication error. */
-#define BLE_HS_EAUTHEN              23
+#define BLE_HS_EAUTHEN 23
 
 /** Authorization error. */
-#define BLE_HS_EAUTHOR              24
+#define BLE_HS_EAUTHOR 24
 
 /** Encryption error. */
-#define BLE_HS_EENCRYPT             25
+#define BLE_HS_EENCRYPT 25
 
 /** Invalid encryption key size. */
-#define BLE_HS_EENCRYPT_KEY_SZ      26
+#define BLE_HS_EENCRYPT_KEY_SZ 26
 
 /** Storage capacity exceeded. */
-#define BLE_HS_ESTORE_CAP           27
+#define BLE_HS_ESTORE_CAP 27
 
 /** Storage operation failed. */
-#define BLE_HS_ESTORE_FAIL          28
+#define BLE_HS_ESTORE_FAIL 28
 
 /** Operation was preempted. */
-#define BLE_HS_EPREEMPTED           29
+#define BLE_HS_EPREEMPTED 29
 
 /** Operation disabled. */
-#define BLE_HS_EDISABLED            30
+#define BLE_HS_EDISABLED 30
 
 /** Operation stalled. */
-#define BLE_HS_ESTALLED             31
+#define BLE_HS_ESTALLED 31
 
 /** Error base for ATT errors */
-#define BLE_HS_ERR_ATT_BASE         0x100
+#define BLE_HS_ERR_ATT_BASE 0x100
 
 /** Converts error to ATT base */
-#define BLE_HS_ATT_ERR(x)           ((x) ? BLE_HS_ERR_ATT_BASE + (x) : 0)
+#define BLE_HS_ATT_ERR(x) ((x) ? BLE_HS_ERR_ATT_BASE + (x) : 0)
 
 /** Error base for HCI errors */
-#define BLE_HS_ERR_HCI_BASE         0x200
+#define BLE_HS_ERR_HCI_BASE 0x200
 
 /** Converts error to HCI base */
-#define BLE_HS_HCI_ERR(x)           ((x) ? BLE_HS_ERR_HCI_BASE + (x) : 0)
+#define BLE_HS_HCI_ERR(x) ((x) ? BLE_HS_ERR_HCI_BASE + (x) : 0)
 
 /** Error base for L2CAP errors */
-#define BLE_HS_ERR_L2C_BASE         0x300
+#define BLE_HS_ERR_L2C_BASE 0x300
 
 /** Converts error to L2CAP base */
-#define BLE_HS_L2C_ERR(x)           ((x) ? BLE_HS_ERR_L2C_BASE + (x) : 0)
+#define BLE_HS_L2C_ERR(x) ((x) ? BLE_HS_ERR_L2C_BASE + (x) : 0)
 
 /** Error base for local Security Manager errors */
-#define BLE_HS_ERR_SM_US_BASE       0x400
+#define BLE_HS_ERR_SM_US_BASE 0x400
 
 /** Converts error to local Security Manager base */
-#define BLE_HS_SM_US_ERR(x)         ((x) ? BLE_HS_ERR_SM_US_BASE + (x) : 0)
+#define BLE_HS_SM_US_ERR(x) ((x) ? BLE_HS_ERR_SM_US_BASE + (x) : 0)
 
 /** Error base for remote (peer) Security Manager errors */
-#define BLE_HS_ERR_SM_PEER_BASE     0x500
+#define BLE_HS_ERR_SM_PEER_BASE 0x500
 
 /** Converts error to remote (peer) Security Manager base */
-#define BLE_HS_SM_PEER_ERR(x)       ((x) ? BLE_HS_ERR_SM_PEER_BASE + (x) : 0)
+#define BLE_HS_SM_PEER_ERR(x) ((x) ? BLE_HS_ERR_SM_PEER_BASE + (x) : 0)
 
 /** Error base for hardware errors */
-#define BLE_HS_ERR_HW_BASE          0x600
+#define BLE_HS_ERR_HW_BASE 0x600
 
 /** Converts error to hardware error  base */
-#define BLE_HS_HW_ERR(x)            (BLE_HS_ERR_HW_BASE + (x))
+#define BLE_HS_HW_ERR(x) (BLE_HS_ERR_HW_BASE + (x))
 
 /**
  * @}
@@ -214,19 +214,19 @@ extern "C" {
  */
 
 /** DisplayOnly IO capability */
-#define BLE_HS_IO_DISPLAY_ONLY              0x00
+#define BLE_HS_IO_DISPLAY_ONLY 0x00
 
 /** DisplayYesNo IO capability */
-#define BLE_HS_IO_DISPLAY_YESNO             0x01
+#define BLE_HS_IO_DISPLAY_YESNO 0x01
 
 /** KeyboardOnly IO capability */
-#define BLE_HS_IO_KEYBOARD_ONLY             0x02
+#define BLE_HS_IO_KEYBOARD_ONLY 0x02
 
 /** NoInputNoOutput IO capability */
-#define BLE_HS_IO_NO_INPUT_OUTPUT           0x03
+#define BLE_HS_IO_NO_INPUT_OUTPUT 0x03
 
 /** KeyboardDisplay Only IO capability */
-#define BLE_HS_IO_KEYBOARD_DISPLAY          0x04
+#define BLE_HS_IO_KEYBOARD_DISPLAY 0x04
 
 /**
  * @}
@@ -240,10 +240,10 @@ extern "C" {
  */
 
 /** Distibute LTK */
-#define BLE_HS_KEY_DIST_ENC_KEY              0x01
+#define BLE_HS_KEY_DIST_ENC_KEY 0x01
 
 /** Distribute IRK */
-#define BLE_HS_KEY_DIST_ID_KEY               0x02
+#define BLE_HS_KEY_DIST_ID_KEY 0x02
 
 /** CSRK distibution and LinkKey are not supported */
 
@@ -270,107 +270,112 @@ typedef void ble_hs_sync_fn(void);
  * proper options in application's syscfg.
  */
 struct ble_hs_cfg {
-    /**
-     * An optional callback that gets executed upon registration of each GATT
-     * resource (service, characteristic, or descriptor).
-     */
-    ble_gatt_register_fn *gatts_register_cb;
-
-    /**
-     * An optional argument that gets passed to the GATT registration
-     * callback.
-     */
-    void *gatts_register_arg;
-
-    /** Security Manager Local Input Output Capabilities */
-    uint8_t sm_io_cap;
-
-    /** @brief Security Manager OOB flag
-     *
-     * If set proper flag in Pairing Request/Response will be set.
-     */
-    unsigned sm_oob_data_flag:1;
-
-    /** @brief Security Manager Bond flag
-     *
-     * If set proper flag in Pairing Request/Response will be set. This results
-     * in storing keys distributed during bonding.
-     */
-    unsigned sm_bonding:1;
-
-    /** @brief Security Manager MITM flag
-     *
-     * If set proper flag in Pairing Request/Response will be set. This results
-     * in requiring Man-In-The-Middle protection when pairing.
-     */
-    unsigned sm_mitm:1;
-
-    /** @brief Security Manager Secure Connections flag
-     *
-     * If set proper flag in Pairing Request/Response will be set. This results
-     * in using LE Secure Connections for pairing if also supported by remote
-     * device. Fallback to legacy pairing if not supported by remote.
-     */
-    unsigned sm_sc:1;
-
-    /** @brief Security Manager Key Press Notification flag
-     *
-     * Currently unsupported and should not be set.
-     */
-    unsigned sm_keypress:1;
-
-    /** @brief Security Manager Local Key Distribution Mask */
-    uint8_t sm_our_key_dist;
-
-    /** @brief Security Manager Remote Key Distribution Mask */
-    uint8_t sm_their_key_dist;
-
-    /** @brief Stack reset callback
-     *
-     * This callback is executed when the host resets itself and the controller
-     * due to fatal error.
-     */
-    ble_hs_reset_fn *reset_cb;
-
-    /** @brief Stack sync callback
-     *
-     * This callback is executed when the host and controller become synced.
-     * This happens at startup and after a reset.
-     */
-    ble_hs_sync_fn *sync_cb;
-
-    /** Callback to handle generation of security keys */
-    ble_store_gen_key_fn *store_gen_key_cb;
-
-    /* XXX: These need to go away. Instead, the nimble host package should
-     * require the host-store API (not yet implemented)..
-     */
-    /** Storage Read callback handles read of security material */
-    ble_store_read_fn *store_read_cb;
-
-    /** Storage Write callback handles write of security material */
-    ble_store_write_fn *store_write_cb;
-
-    /** Storage Delete callback handles deletion of security material */
-    ble_store_delete_fn *store_delete_cb;
-
-    /** @brief Storage Status callback.
-     *
-     * This callback gets executed when a persistence operation cannot be
-     * performed or a persistence failure is imminent. For example, if is
-     * insufficient storage capacity for a record to be persisted, this
-     * function gets called to give the application the opportunity to make
-     * room.
-     */
-    ble_store_status_fn *store_status_cb;
-
-    /** An optional argument that gets passed to the storage status callback. */
-    void *store_status_arg;
+	/**
+	 * An optional callback that gets executed upon registration of each GATT
+	 * resource (service, characteristic, or descriptor).
+	 */
+	ble_gatt_register_fn *gatts_register_cb;
+
+	/**
+	 * An optional argument that gets passed to the GATT registration
+	 * callback.
+	 */
+	void *gatts_register_arg;
+
+	/** Security Manager Local Input Output Capabilities */
+	uint8_t sm_io_cap;
+
+	/** @brief Security Manager OOB flag
+	 *
+	 * If set proper flag in Pairing Request/Response will be set.
+	 */
+	unsigned sm_oob_data_flag : 1;
+
+	/** @brief Security Manager Bond flag
+	 *
+	 * If set proper flag in Pairing Request/Response will be set. This results
+	 * in storing keys distributed during bonding.
+	 */
+	unsigned sm_bonding : 1;
+
+	/** @brief Security Manager MITM flag
+	 *
+	 * If set proper flag in Pairing Request/Response will be set. This results
+	 * in requiring Man-In-The-Middle protection when pairing.
+	 */
+	unsigned sm_mitm : 1;
+
+	/** @brief Security Manager Secure Connections flag
+	 *
+	 * If set proper flag in Pairing Request/Response will be set. This results
+	 * in using LE Secure Connections for pairing if also supported by remote
+	 * device. Fallback to legacy pairing if not supported by remote.
+	 */
+	unsigned sm_sc : 1;
+
+	/** @brief Security Manager Key Press Notification flag
+	 *
+	 * Currently unsupported and should not be set.
+	 */
+	unsigned sm_keypress : 1;
+
+	/** @brief Security Manager Local Key Distribution Mask */
+	uint8_t sm_our_key_dist;
+
+	/** @brief Security Manager Remote Key Distribution Mask */
+	uint8_t sm_their_key_dist;
+
+	/* Pairing Key Entropy */
+	uint8_t sm_max_enc_key_size;
+	/** @brief Stack reset callback
+	 *
+	 * This callback is executed when the host resets itself and the controller
+	 * due to fatal error.
+	 */
+	ble_hs_reset_fn *reset_cb;
+
+	/** @brief Stack sync callback
+	 *
+	 * This callback is executed when the host and controller become synced.
+	 * This happens at startup and after a reset.
+	 */
+	ble_hs_sync_fn *sync_cb;
+
+	/** Callback to handle generation of security keys */
+	ble_store_gen_key_fn *store_gen_key_cb;
+
+	/* XXX: These need to go away. Instead, the nimble host package should
+	 * require the host-store API (not yet implemented)..
+	 */
+	/** Storage Read callback handles read of security material */
+	ble_store_read_fn *store_read_cb;
+
+	/** Storage Write callback handles write of security material */
+	ble_store_write_fn *store_write_cb;
+
+	/** Storage Delete callback handles deletion of security material */
+	ble_store_delete_fn *store_delete_cb;
+
+	/** @brief Storage Status callback.
+	 *
+	 * This callback gets executed when a persistence operation cannot be
+	 * performed or a persistence failure is imminent. For example, if is
+	 * insufficient storage capacity for a record to be persisted, this
+	 * function gets called to give the application the opportunity to make
+	 * room.
+	 */
+	ble_store_status_fn *store_status_cb;
+
+	/** An optional argument that gets passed to the storage status callback. */
+	void *store_status_arg;
 };
 
 /** Configuration structure for the NimBLE Host stack. */
 extern struct ble_hs_cfg ble_hs_cfg;
 
+// to fake authreq at runtime
+extern struct ble_hs_cfg fake_sec_cfg;
+
 /**
  * @}
  */
@@ -457,7 +462,7 @@ void ble_hs_init(void);
  *                                  HAL_RESET_[...] codes or an
  *                                  implementation-defined value.
  *
- * @return                      SYSDOWN_IN_PROGRESS. 
+ * @return                      SYSDOWN_IN_PROGRESS.
  */
 int ble_hs_shutdown(int reason);
 
diff --git a/nimble/host/services/dis/include/services/dis/ble_svc_dis.h b/nimble/host/services/dis/include/services/dis/ble_svc_dis.h
index d095e959..d1b47d99 100644
--- a/nimble/host/services/dis/include/services/dis/ble_svc_dis.h
+++ b/nimble/host/services/dis/include/services/dis/ble_svc_dis.h
@@ -42,7 +42,7 @@
 #define BLE_SVC_DIS_CHR_UUID16_HARDWARE_REVISION 		0x2A27
 #define BLE_SVC_DIS_CHR_UUID16_SOFTWARE_REVISION 		0x2A28
 #define BLE_SVC_DIS_CHR_UUID16_MANUFACTURER_NAME		0x2A29
-
+#define BLE_SVC_DIS_CHR_UUID16_PNP_ID             0x2A50
 /**
  * Structure holding data for the main characteristics
  */
@@ -84,6 +84,16 @@ struct ble_svc_dis_data {
     const char *system_id;
 };
 
+struct ble_svc_dis_pnp_id {
+    uint16_t vendor_id;
+    uint16_t product_id;
+    uint16_t product_version;
+    uint8_t vendor_id_src;
+
+}__attribute__((packed));
+
+extern struct ble_svc_dis_pnp_id ble_svc_dis_pnp_id;
+
 /**
  * Variable holding data for the main characteristics.
  */
diff --git a/nimble/host/services/dis/src/ble_svc_dis.c b/nimble/host/services/dis/src/ble_svc_dis.c
index 0079a04c..53c9ed86 100644
--- a/nimble/host/services/dis/src/ble_svc_dis.c
+++ b/nimble/host/services/dis/src/ble_svc_dis.c
@@ -34,6 +34,15 @@ struct ble_svc_dis_data ble_svc_dis_data = {
     .system_id         = MYNEWT_VAL(BLE_SVC_DIS_SYSTEM_ID_DEFAULT),
 };
 
+
+struct ble_svc_dis_pnp_id pnp_id_struct = {
+    .vendor_id_src = 0x02,
+    .vendor_id = MYNEWT_VAL (BLE_LL_MANUFACTURER_ID),
+    .product_id = MYNEWT_VAL (BLE_LL_PRODUCT_ID),
+    .product_version = 0x0013,
+};
+
+
 /* Access function */
 #if (MYNEWT_VAL(BLE_SVC_DIS_MODEL_NUMBER_READ_PERM)      >= 0) ||	\
     (MYNEWT_VAL(BLE_SVC_DIS_SERIAL_NUMBER_READ_PERM)     >= 0) ||	\
@@ -52,6 +61,11 @@ static const struct ble_gatt_svc_def ble_svc_dis_defs[] = {
         .type = BLE_GATT_SVC_TYPE_PRIMARY,
         .uuid = BLE_UUID16_DECLARE(BLE_SVC_DIS_UUID16),
         .characteristics = (struct ble_gatt_chr_def[]) { {
+            /* Characteristic: PnP ID (mandatory in HOGP)*/
+            .uuid = BLE_UUID16_DECLARE(BLE_SVC_DIS_CHR_UUID16_PNP_ID),
+            .access_cb = ble_svc_dis_access,
+            .flags = BLE_GATT_CHR_F_READ | BLE_GATT_CHR_F_READ_ENC,
+        }, {
 #if (MYNEWT_VAL(BLE_SVC_DIS_MODEL_NUMBER_READ_PERM) >= 0)
 	    /*** Characteristic: Model Number String */
             .uuid = BLE_UUID16_DECLARE(BLE_SVC_DIS_CHR_UUID16_MODEL_NUMBER),
@@ -135,8 +149,23 @@ ble_svc_dis_access(uint16_t conn_handle, uint16_t attr_handle,
 {
     uint16_t uuid    = ble_uuid_u16(ctxt->chr->uuid);
     const char *info = NULL;
+    uint8_t pnp_id[sizeof(struct ble_svc_dis_pnp_id)];
+    size_t len = 0;
 
     switch(uuid) {
+    case BLE_SVC_DIS_CHR_UUID16_PNP_ID:
+        /* PnP ID is mandatory in HOGP */
+        pnp_id[0] = pnp_id_struct.vendor_id_src;
+        pnp_id[1] = pnp_id_struct.vendor_id & 0xff;
+        pnp_id[2] = (pnp_id_struct.vendor_id >> 8) & 0xff;
+        pnp_id[3] = pnp_id_struct.product_id & 0xff;
+        pnp_id[4] = (pnp_id_struct.product_id >> 8) & 0xff;
+        pnp_id[5] = pnp_id_struct.product_version & 0xff;
+        pnp_id[6] = (pnp_id_struct.product_version >> 8) & 0xff;
+
+        info = (const char*) pnp_id;
+        len = sizeof(pnp_id);
+        break;
 #if (MYNEWT_VAL(BLE_SVC_DIS_MODEL_NUMBER_READ_PERM) >= 0)
     case BLE_SVC_DIS_CHR_UUID16_MODEL_NUMBER:
         info = ble_svc_dis_data.model_number;
@@ -213,7 +242,10 @@ ble_svc_dis_access(uint16_t conn_handle, uint16_t attr_handle,
     }
 
     if (info != NULL) {
-       int rc = os_mbuf_append(ctxt->om, info, strlen(info));
+        if(len == 0) {
+            len = strlen(info);
+        }
+       int rc = os_mbuf_append(ctxt->om, info, len);
        return rc == 0 ? 0 : BLE_ATT_ERR_INSUFFICIENT_RES;
     }
 
diff --git a/nimble/host/services/gap/include/services/gap/ble_svc_gap.h b/nimble/host/services/gap/include/services/gap/ble_svc_gap.h
index 707a3bd0..da6552ea 100644
--- a/nimble/host/services/gap/include/services/gap/ble_svc_gap.h
+++ b/nimble/host/services/gap/include/services/gap/ble_svc_gap.h
@@ -23,30 +23,34 @@
 #include <inttypes.h>
 
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
-#define BLE_SVC_GAP_UUID16                                  0x1800
-#define BLE_SVC_GAP_CHR_UUID16_DEVICE_NAME                  0x2a00
-#define BLE_SVC_GAP_CHR_UUID16_APPEARANCE                   0x2a01
-#define BLE_SVC_GAP_CHR_UUID16_PERIPH_PREF_CONN_PARAMS      0x2a04
-#define BLE_SVC_GAP_CHR_UUID16_CENTRAL_ADDRESS_RESOLUTION   0x2aa6
+#define BLE_SVC_GAP_UUID16 0x1800
+#define BLE_SVC_GAP_CHR_UUID16_DEVICE_NAME 0x2a00
+#define BLE_SVC_GAP_CHR_UUID16_APPEARANCE 0x2a01
+#define BLE_SVC_GAP_CHR_UUID16_PERIPH_PREF_CONN_PARAMS 0x2a04
+#define BLE_SVC_GAP_CHR_UUID16_CENTRAL_ADDRESS_RESOLUTION 0x2aa6
 
-#define BLE_SVC_GAP_APPEARANCE_GEN_UNKNOWN                         0
-#define BLE_SVC_GAP_APPEARANCE_GEN_COMPUTER                        128
-#define BLE_SVC_GAP_APPEARANCE_GEN_HID                             960
-#define BLE_SVC_GAP_APPEARANCE_CYC_SPEED_AND_CADENCE_SENSOR        1157
+#define BLE_SVC_GAP_APPEARANCE_GEN_UNKNOWN 0
+#define BLE_SVC_GAP_APPEARANCE_GEN_COMPUTER 128
+#define BLE_SVC_GAP_APPEARANCE_GEN_HID 960
+#define BLE_SVC_GAP_APPEARANCE_KEYBOARD 961
+#define BLE_SVC_GAP_APPEARANCE_MOUSE 962
+#define BLE_SVC_GAP_APPEARANCE_CYC_SPEED_AND_CADENCE_SENSOR 1157
+    // #define BLE_SVC_GAP_APPEARANCE_RUNNING_SPEED_AND_CADENCE_SENSOR 0x1814
 
-typedef void (ble_svc_gap_chr_changed_fn) (uint16_t uuid);
+    typedef void(ble_svc_gap_chr_changed_fn)(uint16_t uuid);
 
-void ble_svc_gap_set_chr_changed_cb(ble_svc_gap_chr_changed_fn *cb);
+    void ble_svc_gap_set_chr_changed_cb(ble_svc_gap_chr_changed_fn *cb);
 
-const char *ble_svc_gap_device_name(void);
-int ble_svc_gap_device_name_set(const char *name);
-uint16_t ble_svc_gap_device_appearance(void);
-int ble_svc_gap_device_appearance_set(uint16_t appearance);
+    const char *ble_svc_gap_device_name(void);
+    int ble_svc_gap_device_name_set(const char *name);
+    uint16_t ble_svc_gap_device_appearance(void);
+    int ble_svc_gap_device_appearance_set(uint16_t appearance);
 
-void ble_svc_gap_init(void);
+    void ble_svc_gap_init(void);
 
 #ifdef __cplusplus
 }
diff --git a/nimble/host/src/ble_gap.c b/nimble/host/src/ble_gap.c
index b935efac..c16dfdb4 100644
--- a/nimble/host/src/ble_gap.c
+++ b/nimble/host/src/ble_gap.c
@@ -41,7 +41,7 @@
 #define bssnz_t
 #endif
 
-#define SET_BIT(t, n)  (t |= 1UL << (n))
+#define SET_BIT(t, n) (t |= 1UL << (n))
 
 /**
  * GAP - Generic Access Profile.
@@ -86,20 +86,20 @@
  */
 
 /** GAP procedure op codes. */
-#define BLE_GAP_OP_NULL             0
-#define BLE_GAP_OP_M_DISC           1
-#define BLE_GAP_OP_M_CONN           2
-#define BLE_GAP_OP_S_ADV            1
-#define BLE_GAP_OP_S_PERIODIC_ADV   2
-#define BLE_GAP_OP_SYNC             1
+#define BLE_GAP_OP_NULL 0
+#define BLE_GAP_OP_M_DISC 1
+#define BLE_GAP_OP_M_CONN 2
+#define BLE_GAP_OP_S_ADV 1
+#define BLE_GAP_OP_S_PERIODIC_ADV 2
+#define BLE_GAP_OP_SYNC 1
 
 /**
  * If an attempt to cancel an active procedure fails, the attempt is retried
  * at this rate (ms).
  */
-#define BLE_GAP_CANCEL_RETRY_TIMEOUT_MS         100 /* ms */
+#define BLE_GAP_CANCEL_RETRY_TIMEOUT_MS 100 /* ms */
 
-#define BLE_GAP_UPDATE_TIMEOUT_MS               40000 /* ms */
+#define BLE_GAP_UPDATE_TIMEOUT_MS 40000 /* ms */
 
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
 static const struct ble_gap_conn_params ble_gap_conn_params_dflt = {
@@ -118,14 +118,15 @@ static const struct ble_gap_conn_params ble_gap_conn_params_dflt = {
  * The state of the in-progress master connection.  If no master connection is
  * currently in progress, then the op field is set to BLE_GAP_OP_NULL.
  */
-struct ble_gap_master_state {
+struct ble_gap_master_state
+{
     uint8_t op;
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
     /* indicates if discovery was started with legacy API */
     uint8_t legacy_discovery;
 #endif
-    uint8_t exp_set:1;
+    uint8_t exp_set : 1;
     ble_npl_time_t exp_os_ticks;
 
     ble_gap_event_fn *cb;
@@ -137,15 +138,18 @@ struct ble_gap_master_state {
      */
     uint8_t preempted_op;
 
-    union {
-        struct {
-            uint8_t using_wl:1;
-            uint8_t our_addr_type:2;
-            uint8_t cancel:1;
+    union
+    {
+        struct
+        {
+            uint8_t using_wl : 1;
+            uint8_t our_addr_type : 2;
+            uint8_t cancel : 1;
         } conn;
 
-        struct {
-            uint8_t limited:1;
+        struct
+        {
+            uint8_t limited : 1;
         } disc;
     };
 };
@@ -156,7 +160,8 @@ static bssnz_t struct ble_gap_master_state ble_gap_master;
  * The state of the in-progress sync creation. If no sync creation connection is
  * currently in progress, then the op field is set to BLE_GAP_OP_NULL.
  */
-struct ble_gap_sync_state {
+struct ble_gap_sync_state
+{
     uint8_t op;
     struct ble_hs_periodic_sync *psync;
 
@@ -171,28 +176,29 @@ static bssnz_t struct ble_gap_sync_state ble_gap_sync;
  * The state of the in-progress slave connection.  If no slave connection is
  * currently in progress, then the op field is set to BLE_GAP_OP_NULL.
  */
-struct ble_gap_slave_state {
+struct ble_gap_slave_state
+{
     uint8_t op;
 
-    unsigned int our_addr_type:2;
-    unsigned int preempted:1;  /** Set to 1 if advertising was preempted. */
-    unsigned int connectable:1;
+    unsigned int our_addr_type : 2;
+    unsigned int preempted : 1; /** Set to 1 if advertising was preempted. */
+    unsigned int connectable : 1;
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    unsigned int configured:1; /** If instance is configured */
-    unsigned int scannable:1;
-    unsigned int directed:1;
-    unsigned int high_duty_directed:1;
-    unsigned int legacy_pdu:1;
-    unsigned int rnd_addr_set:1;
+    unsigned int configured : 1; /** If instance is configured */
+    unsigned int scannable : 1;
+    unsigned int directed : 1;
+    unsigned int high_duty_directed : 1;
+    unsigned int legacy_pdu : 1;
+    unsigned int rnd_addr_set : 1;
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-    unsigned int periodic_configured:1;
-    uint8_t      periodic_op;
+    unsigned int periodic_configured : 1;
+    uint8_t periodic_op;
 #endif
     uint8_t rnd_addr[6];
 #else
-/* timer is used only with legacy advertising */
-    unsigned int exp_set:1;
+    /* timer is used only with legacy advertising */
+    unsigned int exp_set : 1;
     ble_npl_time_t exp_os_ticks;
 #endif
 
@@ -202,24 +208,26 @@ struct ble_gap_slave_state {
 
 static bssnz_t struct ble_gap_slave_state ble_gap_slave[BLE_ADV_INSTANCES];
 
-struct ble_gap_update_entry {
-    SLIST_ENTRY(ble_gap_update_entry) next;
+struct ble_gap_update_entry
+{
+    SLIST_ENTRY(ble_gap_update_entry)
+    next;
     struct ble_gap_upd_params params;
     ble_npl_time_t exp_os_ticks;
     uint16_t conn_handle;
 };
 SLIST_HEAD(ble_gap_update_entry_list, ble_gap_update_entry);
 
-struct ble_gap_snapshot {
+struct ble_gap_snapshot
+{
     struct ble_gap_conn_desc *desc;
     ble_gap_event_fn *cb;
     void *cb_arg;
 };
 
 static SLIST_HEAD(ble_gap_hook_list, ble_gap_event_listener) ble_gap_event_listener_list;
-static os_membuf_t ble_gap_update_entry_mem[
-                        OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE),
-                                        sizeof (struct ble_gap_update_entry))];
+static os_membuf_t ble_gap_update_entry_mem[OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE),
+                                                            sizeof(struct ble_gap_update_entry))];
 static struct os_mempool ble_gap_update_entry_pool;
 static struct ble_gap_update_entry_list ble_gap_update_entries;
 
@@ -249,39 +257,40 @@ static int ble_gap_conn_cancel_tx(void);
 static int ble_gap_disc_enable_tx(int enable, int filter_duplicates);
 #endif
 
-STATS_SECT_DECL(ble_gap_stats) ble_gap_stats;
+STATS_SECT_DECL(ble_gap_stats)
+ble_gap_stats;
 STATS_NAME_START(ble_gap_stats)
-    STATS_NAME(ble_gap_stats, wl_set)
-    STATS_NAME(ble_gap_stats, wl_set_fail)
-    STATS_NAME(ble_gap_stats, adv_stop)
-    STATS_NAME(ble_gap_stats, adv_stop_fail)
-    STATS_NAME(ble_gap_stats, adv_start)
-    STATS_NAME(ble_gap_stats, adv_start_fail)
-    STATS_NAME(ble_gap_stats, adv_set_data)
-    STATS_NAME(ble_gap_stats, adv_set_data_fail)
-    STATS_NAME(ble_gap_stats, adv_rsp_set_data)
-    STATS_NAME(ble_gap_stats, adv_rsp_set_data_fail)
-    STATS_NAME(ble_gap_stats, discover)
-    STATS_NAME(ble_gap_stats, discover_fail)
-    STATS_NAME(ble_gap_stats, initiate)
-    STATS_NAME(ble_gap_stats, initiate_fail)
-    STATS_NAME(ble_gap_stats, terminate)
-    STATS_NAME(ble_gap_stats, terminate_fail)
-    STATS_NAME(ble_gap_stats, cancel)
-    STATS_NAME(ble_gap_stats, cancel_fail)
-    STATS_NAME(ble_gap_stats, update)
-    STATS_NAME(ble_gap_stats, update_fail)
-    STATS_NAME(ble_gap_stats, connect_mst)
-    STATS_NAME(ble_gap_stats, connect_slv)
-    STATS_NAME(ble_gap_stats, disconnect)
-    STATS_NAME(ble_gap_stats, rx_disconnect)
-    STATS_NAME(ble_gap_stats, rx_update_complete)
-    STATS_NAME(ble_gap_stats, rx_adv_report)
-    STATS_NAME(ble_gap_stats, rx_conn_complete)
-    STATS_NAME(ble_gap_stats, discover_cancel)
-    STATS_NAME(ble_gap_stats, discover_cancel_fail)
-    STATS_NAME(ble_gap_stats, security_initiate)
-    STATS_NAME(ble_gap_stats, security_initiate_fail)
+STATS_NAME(ble_gap_stats, wl_set)
+STATS_NAME(ble_gap_stats, wl_set_fail)
+STATS_NAME(ble_gap_stats, adv_stop)
+STATS_NAME(ble_gap_stats, adv_stop_fail)
+STATS_NAME(ble_gap_stats, adv_start)
+STATS_NAME(ble_gap_stats, adv_start_fail)
+STATS_NAME(ble_gap_stats, adv_set_data)
+STATS_NAME(ble_gap_stats, adv_set_data_fail)
+STATS_NAME(ble_gap_stats, adv_rsp_set_data)
+STATS_NAME(ble_gap_stats, adv_rsp_set_data_fail)
+STATS_NAME(ble_gap_stats, discover)
+STATS_NAME(ble_gap_stats, discover_fail)
+STATS_NAME(ble_gap_stats, initiate)
+STATS_NAME(ble_gap_stats, initiate_fail)
+STATS_NAME(ble_gap_stats, terminate)
+STATS_NAME(ble_gap_stats, terminate_fail)
+STATS_NAME(ble_gap_stats, cancel)
+STATS_NAME(ble_gap_stats, cancel_fail)
+STATS_NAME(ble_gap_stats, update)
+STATS_NAME(ble_gap_stats, update_fail)
+STATS_NAME(ble_gap_stats, connect_mst)
+STATS_NAME(ble_gap_stats, connect_slv)
+STATS_NAME(ble_gap_stats, disconnect)
+STATS_NAME(ble_gap_stats, rx_disconnect)
+STATS_NAME(ble_gap_stats, rx_update_complete)
+STATS_NAME(ble_gap_stats, rx_adv_report)
+STATS_NAME(ble_gap_stats, rx_conn_complete)
+STATS_NAME(ble_gap_stats, discover_cancel)
+STATS_NAME(ble_gap_stats, discover_cancel_fail)
+STATS_NAME(ble_gap_stats, security_initiate)
+STATS_NAME(ble_gap_stats, security_initiate_fail)
 STATS_NAME_END(ble_gap_stats)
 
 /*****************************************************************************
@@ -289,8 +298,7 @@ STATS_NAME_END(ble_gap_stats)
  *****************************************************************************/
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-int
-ble_gap_dbg_update_active(uint16_t conn_handle)
+int ble_gap_dbg_update_active(uint16_t conn_handle)
 {
     const struct ble_gap_update_entry *entry;
 
@@ -310,9 +318,12 @@ ble_gap_dbg_update_active(uint16_t conn_handle)
 static void
 ble_gap_log_duration(int32_t duration_ms)
 {
-    if (duration_ms == BLE_HS_FOREVER) {
+    if (duration_ms == BLE_HS_FOREVER)
+    {
         BLE_HS_LOG(INFO, "duration=forever");
-    } else {
+    }
+    else
+    {
         BLE_HS_LOG(INFO, "duration=%dms", duration_ms);
     }
 }
@@ -323,7 +334,8 @@ static void
 ble_gap_log_conn(uint8_t own_addr_type, const ble_addr_t *peer_addr,
                  const struct ble_gap_conn_params *params)
 {
-    if (peer_addr != NULL) {
+    if (peer_addr != NULL)
+    {
         BLE_HS_LOG(INFO, "peer_addr_type=%d peer_addr=", peer_addr->type);
         BLE_HS_LOG_ADDR(INFO, peer_addr->val);
     }
@@ -372,7 +384,8 @@ ble_gap_log_wl(const ble_addr_t *addr, uint8_t white_list_count)
 
     BLE_HS_LOG(INFO, "count=%d ", white_list_count);
 
-    for (i = 0; i < white_list_count; i++, addr++) {
+    for (i = 0; i < white_list_count; i++, addr++)
+    {
         BLE_HS_LOG(INFO, "entry-%d={addr_type=%d addr=", i, addr->type);
         BLE_HS_LOG_ADDR(INFO, addr->val);
         BLE_HS_LOG(INFO, "} ");
@@ -386,7 +399,8 @@ ble_gap_log_adv(uint8_t own_addr_type, const ble_addr_t *direct_addr,
                 const struct ble_gap_adv_params *adv_params)
 {
     BLE_HS_LOG(INFO, "disc_mode=%d", adv_params->disc_mode);
-    if (direct_addr) {
+    if (direct_addr)
+    {
         BLE_HS_LOG(INFO, " direct_addr_type=%d direct_addr=",
                    direct_addr->type);
         BLE_HS_LOG_ADDR(INFO, direct_addr->val);
@@ -426,9 +440,12 @@ ble_gap_fill_conn_desc(struct ble_hs_conn *conn,
     desc->master_clock_accuracy = conn->bhc_master_clock_accuracy;
     desc->sec_state = conn->bhc_sec_state;
 
-    if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
+    if (conn->bhc_flags & BLE_HS_CONN_F_MASTER)
+    {
         desc->role = BLE_GAP_ROLE_MASTER;
-    } else {
+    }
+    else
+    {
         desc->role = BLE_GAP_ROLE_SLAVE;
     }
 }
@@ -450,22 +467,25 @@ ble_gap_find_snapshot(uint16_t handle, struct ble_gap_snapshot *snap)
     ble_hs_lock();
 
     conn = ble_hs_conn_find(handle);
-    if (conn != NULL) {
+    if (conn != NULL)
+    {
         ble_gap_conn_to_snapshot(conn, snap);
     }
 
     ble_hs_unlock();
 
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         return BLE_HS_ENOTCONN;
-    } else {
+    }
+    else
+    {
         return 0;
     }
 }
 #endif
 
-int
-ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
+int ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hs_conn *conn;
@@ -473,15 +493,19 @@ ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
     ble_hs_lock();
 
     conn = ble_hs_conn_find(handle);
-    if (conn != NULL && out_desc != NULL) {
+    if (conn != NULL && out_desc != NULL)
+    {
         ble_gap_fill_conn_desc(conn, out_desc);
     }
 
     ble_hs_unlock();
 
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         return BLE_HS_ENOTCONN;
-    } else {
+    }
+    else
+    {
         return 0;
     }
 #else
@@ -489,27 +513,29 @@ ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
 #endif
 }
 
-int
-ble_gap_conn_find_by_addr(const ble_addr_t *addr,
-                          struct ble_gap_conn_desc *out_desc)
+int ble_gap_conn_find_by_addr(const ble_addr_t *addr,
+                              struct ble_gap_conn_desc *out_desc)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hs_conn *conn;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
     conn = ble_hs_conn_find_by_addr(addr);
-    if (conn != NULL && out_desc != NULL) {
+    if (conn != NULL && out_desc != NULL)
+    {
         ble_gap_fill_conn_desc(conn, out_desc);
     }
 
     ble_hs_unlock();
 
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         return BLE_HS_ENOTCONN;
     }
 
@@ -519,8 +545,7 @@ ble_gap_conn_find_by_addr(const ble_addr_t *addr,
 #endif
 }
 
-int
-ble_gap_conn_find_handle_by_addr(const ble_addr_t *addr, uint16_t *out_conn_handle)
+int ble_gap_conn_find_handle_by_addr(const ble_addr_t *addr, uint16_t *out_conn_handle)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hs_conn *conn;
@@ -528,15 +553,19 @@ ble_gap_conn_find_handle_by_addr(const ble_addr_t *addr, uint16_t *out_conn_hand
     ble_hs_lock();
 
     conn = ble_hs_conn_find_by_addr(addr);
-    if (conn != NULL) {
+    if (conn != NULL)
+    {
         *out_conn_handle = conn->bhc_handle;
-    } else {
+    }
+    else
+    {
         *out_conn_handle = BLE_HS_CONN_HANDLE_NONE;
     }
 
     ble_hs_unlock();
 
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         return BLE_HS_ENOTCONN;
     }
 
@@ -546,7 +575,8 @@ ble_gap_conn_find_handle_by_addr(const ble_addr_t *addr, uint16_t *out_conn_hand
 #endif
 }
 
-struct foreach_handle_cb_arg {
+struct foreach_handle_cb_arg
+{
     ble_gap_conn_foreach_handle_fn *cb;
     void *arg;
 };
@@ -559,8 +589,7 @@ ble_gap_conn_foreach_handle_callback(struct ble_hs_conn *conn, void *arg)
     return cb_arg->cb(conn->bhc_handle, cb_arg->arg);
 }
 
-void
-ble_gap_conn_foreach_handle(ble_gap_conn_foreach_handle_fn *cb, void *arg)
+void ble_gap_conn_foreach_handle(ble_gap_conn_foreach_handle_fn *cb, void *arg)
 {
     struct foreach_handle_cb_arg cb_arg = {
         .cb = cb,
@@ -582,29 +611,35 @@ ble_gap_extract_conn_cb(uint16_t conn_handle,
     ble_hs_lock();
 
     conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
+    if (conn != NULL)
+    {
         *out_cb = conn->bhc_cb;
         *out_cb_arg = conn->bhc_cb_arg;
-    } else {
+    }
+    else
+    {
         *out_cb = NULL;
         *out_cb_arg = NULL;
     }
 
     ble_hs_unlock();
 
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         return BLE_HS_ENOTCONN;
-    } else {
+    }
+    else
+    {
         return 0;
     }
 }
 #endif
 
-int
-ble_gap_set_priv_mode(const ble_addr_t *peer_addr, uint8_t priv_mode)
+int ble_gap_set_priv_mode(const ble_addr_t *peer_addr, uint8_t priv_mode)
 {
 #if NIMBLE_BLE_CONNECT
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -614,8 +649,7 @@ ble_gap_set_priv_mode(const ble_addr_t *peer_addr, uint8_t priv_mode)
 #endif
 }
 
-int
-ble_gap_read_le_phy(uint16_t conn_handle, uint8_t *tx_phy, uint8_t *rx_phy)
+int ble_gap_read_le_phy(uint16_t conn_handle, uint8_t *tx_phy, uint8_t *rx_phy)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hci_le_rd_phy_cp cmd;
@@ -623,7 +657,8 @@ ble_gap_read_le_phy(uint16_t conn_handle, uint8_t *tx_phy, uint8_t *rx_phy)
     struct ble_hs_conn *conn;
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -631,7 +666,8 @@ ble_gap_read_le_phy(uint16_t conn_handle, uint8_t *tx_phy, uint8_t *rx_phy)
     conn = ble_hs_conn_find(conn_handle);
     ble_hs_unlock();
 
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         return BLE_HS_ENOTCONN;
     }
 
@@ -639,12 +675,14 @@ ble_gap_read_le_phy(uint16_t conn_handle, uint8_t *tx_phy, uint8_t *rx_phy)
 
     rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_PHY),
                            &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
     /* sanity check for response */
-    if (le16toh(rsp.conn_handle) != conn_handle) {
+    if (le16toh(rsp.conn_handle) != conn_handle)
+    {
         return BLE_HS_ECONTROLLER;
     }
 
@@ -657,59 +695,67 @@ ble_gap_read_le_phy(uint16_t conn_handle, uint8_t *tx_phy, uint8_t *rx_phy)
 #endif
 }
 
-int
-ble_gap_set_prefered_default_le_phy(uint8_t tx_phys_mask, uint8_t rx_phys_mask)
+int ble_gap_set_prefered_default_le_phy(uint8_t tx_phys_mask, uint8_t rx_phys_mask)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hci_le_set_default_phy_cp cmd;
 
     if (tx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
                         BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+                        BLE_HCI_LE_PHY_CODED_PREF_MASK))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
     if (rx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
                         BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+                        BLE_HCI_LE_PHY_CODED_PREF_MASK))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     memset(&cmd, 0, sizeof(cmd));
 
-    if (tx_phys_mask == 0) {
+    if (tx_phys_mask == 0)
+    {
         cmd.all_phys |= BLE_HCI_LE_PHY_NO_TX_PREF_MASK;
-    } else {
+    }
+    else
+    {
         cmd.tx_phys = tx_phys_mask;
     }
 
-    if (rx_phys_mask == 0) {
+    if (rx_phys_mask == 0)
+    {
         cmd.all_phys |= BLE_HCI_LE_PHY_NO_RX_PREF_MASK;
-    } else {
+    }
+    else
+    {
         cmd.rx_phys = rx_phys_mask;
     }
 
     return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
                                         BLE_HCI_OCF_LE_SET_DEFAULT_PHY),
-                            &cmd, sizeof(cmd), NULL, 0);
+                             &cmd, sizeof(cmd), NULL, 0);
 #else
     return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
-                   uint8_t rx_phys_mask, uint16_t phy_opts)
+int ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
+                                uint8_t rx_phys_mask, uint16_t phy_opts)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hci_le_set_phy_cp cmd;
     struct ble_hs_conn *conn;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -717,38 +763,48 @@ ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
     conn = ble_hs_conn_find(conn_handle);
     ble_hs_unlock();
 
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         return BLE_HS_ENOTCONN;
     }
 
     if (tx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
                         BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+                        BLE_HCI_LE_PHY_CODED_PREF_MASK))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
     if (rx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
                         BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+                        BLE_HCI_LE_PHY_CODED_PREF_MASK))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    if (phy_opts > BLE_HCI_LE_PHY_CODED_S8_PREF) {
+    if (phy_opts > BLE_HCI_LE_PHY_CODED_S8_PREF)
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
     memset(&cmd, 0, sizeof(cmd));
     cmd.conn_handle = htole16(conn_handle);
 
-    if (tx_phys_mask == 0) {
+    if (tx_phys_mask == 0)
+    {
         cmd.all_phys |= BLE_HCI_LE_PHY_NO_TX_PREF_MASK;
-    } else {
+    }
+    else
+    {
         cmd.tx_phys = tx_phys_mask;
     }
 
-    if (rx_phys_mask == 0) {
+    if (rx_phys_mask == 0)
+    {
         cmd.all_phys |= BLE_HCI_LE_PHY_NO_RX_PREF_MASK;
-    } else {
+    }
+    else
+    {
         cmd.rx_phys = rx_phys_mask;
     }
 
@@ -776,10 +832,14 @@ ble_gap_call_event_cb(struct ble_gap_event *event,
 
     BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
 
-    if (cb != NULL) {
+    if (cb != NULL)
+    {
         rc = cb(event, cb_arg);
-    } else {
-        if (event->type == BLE_GAP_EVENT_CONN_UPDATE_REQ) {
+    }
+    else
+    {
+        if (event->type == BLE_GAP_EVENT_CONN_UPDATE_REQ)
+        {
             /* Just copy peer parameters back into the reply. */
             *event->conn_update_req.self_params =
                 *event->conn_update_req.peer_params;
@@ -799,12 +859,14 @@ ble_gap_call_conn_event_cb(struct ble_gap_event *event, uint16_t conn_handle)
     int rc;
 
     rc = ble_gap_extract_conn_cb(conn_handle, &cb, &cb_arg);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
     rc = ble_gap_call_event_cb(event, cb, cb_arg);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -821,13 +883,16 @@ ble_gap_is_preempted(void)
     BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
-    if (ble_gap_master.preempted_op != BLE_GAP_OP_NULL) {
+    if (ble_gap_master.preempted_op != BLE_GAP_OP_NULL)
+    {
         return true;
     }
 #endif
 #if NIMBLE_BLE_ADVERTISE
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (ble_gap_slave[i].preempted) {
+    for (i = 0; i < BLE_ADV_INSTANCES; i++)
+    {
+        if (ble_gap_slave[i].preempted)
+        {
             return true;
         }
     }
@@ -864,7 +929,8 @@ ble_gap_slave_reset_state(uint8_t instance)
 static bool
 ble_gap_has_client(struct ble_gap_master_state *out_state)
 {
-    if (!out_state) {
+    if (!out_state)
+    {
         return 0;
     }
 
@@ -881,7 +947,8 @@ ble_gap_master_extract_state(struct ble_gap_master_state *out_state,
 
     *out_state = ble_gap_master;
 
-    if (reset_state) {
+    if (reset_state)
+    {
         ble_gap_master_reset_state();
         ble_gap_master.preempted_op = BLE_GAP_OP_NULL;
     }
@@ -924,7 +991,8 @@ ble_gap_adv_finished(uint8_t instance, int reason, uint16_t conn_handle,
     ble_gap_event_listener_call(&event);
 
     ble_gap_slave_extract_cb(instance, &cb, &cb_arg);
-    if (cb != NULL) {
+    if (cb != NULL)
+    {
         cb(&event, cb_arg);
     }
 }
@@ -939,13 +1007,16 @@ ble_gap_master_connect_failure(int status)
     int rc;
 
     ble_gap_master_extract_state(&state, 1);
-    if (ble_gap_has_client(&state)) {
+    if (ble_gap_has_client(&state))
+    {
         memset(&event, 0, sizeof event);
         event.type = BLE_GAP_EVENT_CONNECT;
         event.connect.status = status;
 
         rc = state.cb(&event, state.cb_arg);
-    } else {
+    }
+    else
+    {
         rc = 0;
     }
 
@@ -959,14 +1030,18 @@ ble_gap_master_connect_cancelled(void)
     struct ble_gap_event event;
 
     ble_gap_master_extract_state(&state, 1);
-    if (state.cb != NULL) {
+    if (state.cb != NULL)
+    {
         memset(&event, 0, sizeof event);
         event.type = BLE_GAP_EVENT_CONNECT;
         event.connect.conn_handle = BLE_HS_CONN_HANDLE_NONE;
-        if (state.conn.cancel) {
+        if (state.conn.cancel)
+        {
             /* Connect procedure successfully cancelled. */
             event.connect.status = BLE_HS_EAPP;
-        } else {
+        }
+        else
+        {
             /* Connect procedure timed out. */
             event.connect.status = BLE_HS_ETIMEOUT;
         }
@@ -987,7 +1062,8 @@ ble_gap_disc_report(void *desc)
     event.disc = *((struct ble_gap_disc_desc *)desc);
 
     ble_gap_master_extract_state(&state, 0);
-    if (ble_gap_has_client(&state)) {
+    if (ble_gap_has_client(&state))
+    {
         state.cb(&event, state.cb_arg);
     }
 
@@ -1003,9 +1079,11 @@ ble_gap_ext_disc_report(void *desc)
     struct ble_gap_master_state state;
     struct ble_gap_event event;
 
-    if (ble_gap_master.legacy_discovery) {
+    if (ble_gap_master.legacy_discovery)
+    {
         /* ignore non-legacy events */
-        if (!(ext_desc->props & BLE_HCI_ADV_LEGACY_MASK)) {
+        if (!(ext_desc->props & BLE_HCI_ADV_LEGACY_MASK))
+        {
             return;
         }
 
@@ -1024,7 +1102,8 @@ ble_gap_ext_disc_report(void *desc)
     event.ext_disc = *((struct ble_gap_ext_disc_desc *)desc);
 
     ble_gap_master_extract_state(&state, 0);
-    if (ble_gap_has_client(&state)) {
+    if (ble_gap_has_client(&state))
+    {
         state.cb(&event, state.cb_arg);
     }
 
@@ -1043,7 +1122,8 @@ ble_gap_disc_complete(void)
     event.disc_complete.reason = 0;
 
     ble_gap_master_extract_state(&state, 1);
-    if (ble_gap_has_client(&state)) {
+    if (ble_gap_has_client(&state))
+    {
         ble_gap_call_event_cb(&event, state.cb, state.cb_arg);
     }
 
@@ -1066,7 +1146,8 @@ ble_gap_update_notify(uint16_t conn_handle, int status)
     ble_gap_call_conn_event_cb(&event, conn_handle);
 
     /* Terminate the connection on procedure timeout. */
-    if (status == BLE_HS_ETIMEOUT) {
+    if (status == BLE_HS_ETIMEOUT)
+    {
         ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);
     }
 }
@@ -1077,13 +1158,15 @@ ble_gap_master_ticks_until_exp(void)
 {
     ble_npl_stime_t ticks;
 
-    if (ble_gap_master.op == BLE_GAP_OP_NULL || !ble_gap_master.exp_set) {
+    if (ble_gap_master.op == BLE_GAP_OP_NULL || !ble_gap_master.exp_set)
+    {
         /* Timer not set; infinity ticks until next event. */
         return BLE_HS_FOREVER;
     }
 
     ticks = ble_gap_master.exp_os_ticks - ble_npl_time_get();
-    if (ticks > 0) {
+    if (ticks > 0)
+    {
         /* Timer not expired yet. */
         return ticks;
     }
@@ -1098,13 +1181,15 @@ ble_gap_slave_ticks_until_exp(void)
 {
     ble_npl_stime_t ticks;
 
-    if (ble_gap_slave[0].op == BLE_GAP_OP_NULL || !ble_gap_slave[0].exp_set) {
+    if (ble_gap_slave[0].op == BLE_GAP_OP_NULL || !ble_gap_slave[0].exp_set)
+    {
         /* Timer not set; infinity ticks until next event. */
         return BLE_HS_FOREVER;
     }
 
     ticks = ble_gap_slave[0].exp_os_ticks - ble_npl_time_get();
-    if (ticks > 0) {
+    if (ticks > 0)
+    {
         /* Timer not expired yet. */
         return ticks;
     }
@@ -1140,24 +1225,27 @@ ble_gap_update_next_exp(int32_t *out_ticks_from_now)
     best_ticks = BLE_HS_FOREVER;
     now = ble_npl_time_get();
 
-    SLIST_FOREACH(entry, &ble_gap_update_entries, next) {
+    SLIST_FOREACH(entry, &ble_gap_update_entries, next)
+    {
         ticks = entry->exp_os_ticks - now;
-        if (ticks <= 0) {
+        if (ticks <= 0)
+        {
             ticks = 0;
         }
 
-        if (ticks < best_ticks) {
+        if (ticks < best_ticks)
+        {
             conn_handle = entry->conn_handle;
             best_ticks = ticks;
         }
     }
 
-    if (out_ticks_from_now != NULL) {
+    if (out_ticks_from_now != NULL)
+    {
         *out_ticks_from_now = best_ticks;
     }
 
     return conn_handle;
-
 }
 
 #if NIMBLE_BLE_SCAN
@@ -1190,7 +1278,8 @@ ble_gap_slave_set_timer(uint32_t ticks_from_now)
 static void
 ble_gap_master_failed(int status)
 {
-    switch (ble_gap_master.op) {
+    switch (ble_gap_master.op)
+    {
 #if NIMBLE_BLE_CONNECT
     case BLE_GAP_OP_M_CONN:
         STATS_INC(ble_gap_stats, initiate_fail);
@@ -1244,7 +1333,8 @@ ble_gap_conn_broken(uint16_t conn_handle, int reason)
     snap.desc = &event.disconnect.conn;
 
     rc = ble_gap_find_snapshot(conn_handle, &snap);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         /* No longer connected. */
         return;
     }
@@ -1256,7 +1346,8 @@ ble_gap_conn_broken(uint16_t conn_handle, int reason)
     entry = ble_gap_update_entry_remove(conn_handle);
     ble_hs_unlock();
 
-    if (entry != NULL) {
+    if (entry != NULL)
+    {
         ble_gap_update_notify(conn_handle, reason);
         ble_gap_update_entry_free(entry);
     }
@@ -1269,7 +1360,8 @@ ble_gap_conn_broken(uint16_t conn_handle, int reason)
     ble_sm_connection_broken(conn_handle);
     ble_gatts_connection_broken(conn_handle);
     ble_gattc_connection_broken(conn_handle);
-    ble_hs_flow_connection_broken(conn_handle);;
+    ble_hs_flow_connection_broken(conn_handle);
+    ;
 
     ble_hs_atomic_conn_delete(conn_handle);
 
@@ -1295,8 +1387,7 @@ ble_gap_update_to_l2cap(const struct ble_gap_upd_params *params,
 }
 #endif
 
-void
-ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp *ev)
+void ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp *ev)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -1304,9 +1395,12 @@ ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp *ev)
 
     STATS_INC(ble_gap_stats, rx_disconnect);
 
-    if (ev->status == 0) {
+    if (ev->status == 0)
+    {
         ble_gap_conn_broken(handle, BLE_HS_HCI_ERR(ev->reason));
-    } else {
+    }
+    else
+    {
         memset(&event, 0, sizeof event);
         event.type = BLE_GAP_EVENT_TERM_FAILURE;
         event.term_failure.conn_handle = handle;
@@ -1318,8 +1412,7 @@ ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp *ev)
 #endif
 }
 
-void
-ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *ev)
+void ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *ev)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_update_entry *entry;
@@ -1341,8 +1434,10 @@ ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *e
     conn_handle = le16toh(ev->conn_handle);
 
     conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
-        switch (ev->status) {
+    if (conn != NULL)
+    {
+        switch (ev->status)
+        {
         case 0:
             /* Connection successfully updated. */
             conn->bhc_itvl = le16toh(ev->conn_itvl);
@@ -1357,41 +1452,52 @@ ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *e
              * update procedure.
              */
             entry = ble_gap_update_entry_find(conn_handle, NULL);
-            if (entry != NULL && !(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
+            if (entry != NULL && !(conn->bhc_flags & BLE_HS_CONN_F_MASTER))
+            {
                 ble_gap_update_to_l2cap(&entry->params, &l2cap_params);
                 entry->exp_os_ticks = ble_npl_time_get() +
                                       ble_npl_time_ms_to_ticks32(BLE_GAP_UPDATE_TIMEOUT_MS);
             }
             break;
-
+        case BLE_ERR_MAX:
+            ble_gap_enc_event(conn_handle, 66, 66, 0);
+            break;
         default:
             break;
         }
     }
 
     /* We aren't failing over to L2CAP, the update procedure is complete. */
-    if (l2cap_params.itvl_min == 0) {
+    if (l2cap_params.itvl_min == 0)
+    {
         entry = ble_gap_update_entry_remove(conn_handle);
         ble_gap_update_entry_free(entry);
     }
 
     ble_hs_unlock();
 
-    if (l2cap_params.itvl_min != 0) {
+    if (l2cap_params.itvl_min != 0)
+    {
         rc = ble_l2cap_sig_update(conn_handle, &l2cap_params,
                                   ble_gap_update_l2cap_cb, NULL);
-        if (rc == 0) {
+        if (rc == 0)
+        {
             call_cb = 0;
-        } else {
+        }
+        else
+        {
             call_cb = 1;
             cb_status = rc;
         }
-    } else {
+    }
+    else
+    {
         call_cb = 1;
         cb_status = BLE_HS_HCI_ERR(ev->status);
     }
 
-    if (call_cb) {
+    if (call_cb)
+    {
         ble_gap_update_notify(conn_handle, cb_status);
     }
 #endif
@@ -1400,8 +1506,7 @@ ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *e
 /**
  * Tells you if there is an active central GAP procedure (connect or discover).
  */
-int
-ble_gap_master_in_progress(void)
+int ble_gap_master_in_progress(void)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
     return ble_gap_master.op != BLE_GAP_OP_NULL;
@@ -1422,19 +1527,21 @@ ble_gap_adv_active_instance(uint8_t instance)
 #if MYNEWT_VAL(BLE_EXT_ADV)
 int ble_gap_ext_adv_active(uint8_t instance)
 {
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         return 0;
     }
     return ble_gap_adv_active_instance(instance);
 }
 
-int
-ble_gap_adv_get_free_instance(uint8_t *out_adv_instance)
+int ble_gap_adv_get_free_instance(uint8_t *out_adv_instance)
 {
     uint8_t i;
 
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (!ble_gap_slave[i].configured) {
+    for (i = 0; i < BLE_ADV_INSTANCES; i++)
+    {
+        if (!ble_gap_slave[i].configured)
+        {
             *out_adv_instance = i;
             return 0;
         }
@@ -1448,14 +1555,15 @@ ble_gap_adv_get_free_instance(uint8_t *out_adv_instance)
  * Clears advertisement and discovery state.  This function is necessary
  * when the controller loses its active state (e.g. on stack reset).
  */
-void
-ble_gap_reset_state(int reason)
+void ble_gap_reset_state(int reason)
 {
     uint16_t conn_handle;
 
-    while (1) {
+    while (1)
+    {
         conn_handle = ble_hs_atomic_first_conn_handle();
-        if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
+        if (conn_handle == BLE_HS_CONN_HANDLE_NONE)
+        {
             break;
         }
 
@@ -1465,14 +1573,17 @@ ble_gap_reset_state(int reason)
 #if NIMBLE_BLE_ADVERTISE
 #if MYNEWT_VAL(BLE_EXT_ADV)
     uint8_t i;
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (ble_gap_adv_active_instance(i)) {
+    for (i = 0; i < BLE_ADV_INSTANCES; i++)
+    {
+        if (ble_gap_adv_active_instance(i))
+        {
             /* Indicate to application that advertising has stopped. */
             ble_gap_adv_finished(i, reason, 0, 0);
         }
     }
 #else
-    if (ble_gap_adv_active_instance(0)) {
+    if (ble_gap_adv_active_instance(0))
+    {
         /* Indicate to application that advertising has stopped. */
         ble_gap_adv_finished(0, reason, 0, 0);
     }
@@ -1490,7 +1601,8 @@ ble_gap_accept_master_conn(void)
 {
     int rc;
 
-    switch (ble_gap_master.op) {
+    switch (ble_gap_master.op)
+    {
     case BLE_GAP_OP_NULL:
     case BLE_GAP_OP_M_DISC:
         rc = BLE_HS_ENOENT;
@@ -1506,7 +1618,8 @@ ble_gap_accept_master_conn(void)
         break;
     }
 
-    if (rc == 0) {
+    if (rc == 0)
+    {
         STATS_INC(ble_gap_stats, connect_mst);
     }
 
@@ -1518,19 +1631,28 @@ ble_gap_accept_slave_conn(uint8_t instance)
 {
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-       rc = BLE_HS_ENOENT;
-    } else if (!ble_gap_adv_active_instance(instance)) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
+        rc = BLE_HS_ENOENT;
+    }
+    else if (!ble_gap_adv_active_instance(instance))
+    {
         rc = BLE_HS_ENOENT;
-    } else {
-        if (ble_gap_slave[instance].connectable) {
+    }
+    else
+    {
+        if (ble_gap_slave[instance].connectable)
+        {
             rc = 0;
-        } else {
+        }
+        else
+        {
             rc = BLE_HS_ENOENT;
         }
     }
 
-    if (rc == 0) {
+    if (rc == 0)
+    {
         STATS_INC(ble_gap_stats, connect_slv);
     }
 
@@ -1547,18 +1669,21 @@ ble_gap_rx_adv_report_sanity_check(const uint8_t *adv_data, uint8_t adv_data_len
 
     STATS_INC(ble_gap_stats, rx_adv_report);
 
-    if (ble_gap_master.op != BLE_GAP_OP_M_DISC) {
+    if (ble_gap_master.op != BLE_GAP_OP_M_DISC)
+    {
         return -1;
     }
 
     /* If a limited discovery procedure is active, discard non-limited
      * advertisements.
      */
-    if (ble_gap_master.disc.limited) {
+    if (ble_gap_master.disc.limited)
+    {
         rc = ble_hs_adv_find_field(BLE_HS_ADV_TYPE_FLAGS, adv_data,
                                    adv_data_len, &flags);
         if ((rc == 0) && (flags->length == 2) &&
-            !(flags->value[0] & BLE_HS_ADV_F_DISC_LTD)) {
+            !(flags->value[0] & BLE_HS_ADV_F_DISC_LTD))
+        {
             return -1;
         }
     }
@@ -1567,11 +1692,11 @@ ble_gap_rx_adv_report_sanity_check(const uint8_t *adv_data, uint8_t adv_data_len
 }
 #endif
 
-void
-ble_gap_rx_adv_report(struct ble_gap_disc_desc *desc)
+void ble_gap_rx_adv_report(struct ble_gap_disc_desc *desc)
 {
 #if NIMBLE_BLE_SCAN
-    if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data)) {
+    if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data))
+    {
         return;
     }
 
@@ -1581,16 +1706,15 @@ ble_gap_rx_adv_report(struct ble_gap_disc_desc *desc)
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
 #if NIMBLE_BLE_SCAN
-void
-ble_gap_rx_le_scan_timeout(void)
+void ble_gap_rx_le_scan_timeout(void)
 {
     ble_gap_disc_complete();
 }
 
-void
-ble_gap_rx_ext_adv_report(struct ble_gap_ext_disc_desc *desc)
+void ble_gap_rx_ext_adv_report(struct ble_gap_ext_disc_desc *desc)
 {
-    if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data)) {
+    if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data))
+    {
         return;
     }
 
@@ -1598,18 +1722,20 @@ ble_gap_rx_ext_adv_report(struct ble_gap_ext_disc_desc *desc)
 }
 #endif
 
-void
-ble_gap_rx_adv_set_terminated(const struct ble_hci_ev_le_subev_adv_set_terminated *ev)
+void ble_gap_rx_adv_set_terminated(const struct ble_hci_ev_le_subev_adv_set_terminated *ev)
 {
     uint16_t conn_handle;
     int reason;
 
     /* Currently spec allows only 0x3c and 0x43 when advertising was stopped
      * due to timeout or events limit, mp this for timeout error for now */
-    if (ev->status) {
+    if (ev->status)
+    {
         reason = BLE_HS_ETIMEOUT;
         conn_handle = 0;
-    } else {
+    }
+    else
+    {
         reason = 0;
         conn_handle = le16toh(ev->conn_handle);
     }
@@ -1617,15 +1743,15 @@ ble_gap_rx_adv_set_terminated(const struct ble_hci_ev_le_subev_adv_set_terminate
     ble_gap_adv_finished(ev->adv_handle, reason, conn_handle, ev->num_events);
 }
 
-void
-ble_gap_rx_scan_req_rcvd(const struct ble_hci_ev_le_subev_scan_req_rcvd *ev)
+void ble_gap_rx_scan_req_rcvd(const struct ble_hci_ev_le_subev_scan_req_rcvd *ev)
 {
     struct ble_gap_event event;
     ble_gap_event_fn *cb;
     void *cb_arg;
 
     ble_gap_slave_extract_cb(ev->adv_handle, &cb, &cb_arg);
-    if (cb != NULL) {
+    if (cb != NULL)
+    {
         memset(&event, 0, sizeof event);
         event.type = BLE_GAP_EVENT_SCAN_REQ_RCVD;
         event.scan_req_rcvd.instance = ev->adv_handle;
@@ -1639,8 +1765,7 @@ ble_gap_rx_scan_req_rcvd(const struct ble_hci_ev_le_subev_scan_req_rcvd *ev)
 /* Periodic adv events */
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
 
-void
-ble_gap_rx_peroidic_adv_sync_estab(const struct ble_hci_ev_le_subev_periodic_adv_sync_estab *ev)
+void ble_gap_rx_peroidic_adv_sync_estab(const struct ble_hci_ev_le_subev_periodic_adv_sync_estab *ev)
 {
     uint16_t sync_handle;
     struct ble_gap_event event;
@@ -1656,7 +1781,8 @@ ble_gap_rx_peroidic_adv_sync_estab(const struct ble_hci_ev_le_subev_periodic_adv
 
     BLE_HS_DBG_ASSERT(ble_gap_sync.psync);
 
-    if (!ev->status) {
+    if (!ev->status)
+    {
         sync_handle = le16toh(ev->sync_handle);
 
         ble_gap_sync.psync->sync_handle = sync_handle;
@@ -1675,7 +1801,9 @@ ble_gap_rx_peroidic_adv_sync_estab(const struct ble_hci_ev_le_subev_periodic_adv
         event.periodic_sync.adv_clk_accuracy = ev->aca;
 
         ble_hs_periodic_sync_insert(ble_gap_sync.psync);
-    } else {
+    }
+    else
+    {
         ble_hs_periodic_sync_free(ble_gap_sync.psync);
     }
 
@@ -1690,13 +1818,13 @@ ble_gap_rx_peroidic_adv_sync_estab(const struct ble_hci_ev_le_subev_periodic_adv
     ble_hs_unlock();
 
     ble_gap_event_listener_call(&event);
-    if (cb) {
+    if (cb)
+    {
         cb(&event, cb_arg);
     }
 }
 
-void
-ble_gap_rx_periodic_adv_rpt(const struct ble_hci_ev_le_subev_periodic_adv_rpt *ev)
+void ble_gap_rx_periodic_adv_rpt(const struct ble_hci_ev_le_subev_periodic_adv_rpt *ev)
 {
     struct ble_hs_periodic_sync *psync;
     struct ble_gap_event event;
@@ -1705,13 +1833,15 @@ ble_gap_rx_periodic_adv_rpt(const struct ble_hci_ev_le_subev_periodic_adv_rpt *e
 
     ble_hs_lock();
     psync = ble_hs_periodic_sync_find_by_handle(le16toh(ev->sync_handle));
-    if (psync) {
+    if (psync)
+    {
         cb = psync->cb;
         cb_arg = psync->cb_arg;
     }
     ble_hs_unlock();
 
-    if (!psync || !cb) {
+    if (!psync || !cb)
+    {
         return;
     }
 
@@ -1728,11 +1858,10 @@ ble_gap_rx_periodic_adv_rpt(const struct ble_hci_ev_le_subev_periodic_adv_rpt *e
     /* TODO should we allow for listener too? this can be spammy and is more
      * like ACL data, not general event
      */
-     cb(&event, cb_arg);
+    cb(&event, cb_arg);
 }
 
-void
-ble_gap_rx_periodic_adv_sync_lost(const struct ble_hci_ev_le_subev_periodic_adv_sync_lost *ev)
+void ble_gap_rx_periodic_adv_sync_lost(const struct ble_hci_ev_le_subev_periodic_adv_sync_lost *ev)
 {
     struct ble_hs_periodic_sync *psync;
     struct ble_gap_event event;
@@ -1764,15 +1893,15 @@ ble_gap_rx_periodic_adv_sync_lost(const struct ble_hci_ev_le_subev_periodic_adv_
     ble_hs_periodic_sync_free(psync);
 
     ble_gap_event_listener_call(&event);
-    if (cb) {
+    if (cb)
+    {
         cb(&event, cb_arg);
     }
 }
 #endif
 
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
-void
-ble_gap_rx_le_pathloss_threshold(const struct ble_hci_ev_le_subev_path_loss_threshold *ev)
+void ble_gap_rx_le_pathloss_threshold(const struct ble_hci_ev_le_subev_path_loss_threshold *ev)
 {
     struct ble_gap_event event;
     uint16_t conn_handle = le16toh(ev->conn_handle);
@@ -1788,8 +1917,7 @@ ble_gap_rx_le_pathloss_threshold(const struct ble_hci_ev_le_subev_path_loss_thre
     ble_gap_call_conn_event_cb(&event, conn_handle);
 }
 
-void
-ble_gap_rx_transmit_power_report(const struct ble_hci_ev_le_subev_transmit_power_report *ev)
+void ble_gap_rx_transmit_power_report(const struct ble_hci_ev_le_subev_transmit_power_report *ev)
 {
     struct ble_gap_event event;
     uint16_t conn_handle = le16toh(ev->conn_handle);
@@ -1828,15 +1956,15 @@ periodic_adv_transfer_disable(uint16_t conn_handle)
     cmd.sync_timeout = 0x000a;
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (!rc) {
+    if (!rc)
+    {
         BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
     }
 
     return rc;
 }
 
-void
-ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_adv_sync_transfer *ev)
+void ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_adv_sync_transfer *ev)
 {
     struct ble_hci_le_periodic_adv_term_sync_cp cmd_term;
     struct ble_gap_event event;
@@ -1858,9 +1986,11 @@ ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_
     periodic_adv_transfer_disable(conn_handle);
 
     conn = ble_hs_conn_find(le16toh(ev->conn_handle));
-    if (!conn || !conn->psync) {
+    if (!conn || !conn->psync)
+    {
         /* terminate sync if we didn't expect it */
-        if (!ev->status) {
+        if (!ev->status)
+        {
             opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC);
             cmd_term.sync_handle = ev->sync_handle;
             ble_hs_hci_cmd_tx(opcode, &cmd_term, sizeof(cmd_term), NULL, 0);
@@ -1879,10 +2009,13 @@ ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_
     event.periodic_transfer.status = ev->status;
 
     /* only sync handle is not valid on error */
-    if (ev->status) {
+    if (ev->status)
+    {
         sync_handle = 0;
         ble_hs_periodic_sync_free(conn->psync);
-    } else {
+    }
+    else
+    {
         sync_handle = le16toh(ev->sync_handle);
 
         conn->psync->sync_handle = sync_handle;
@@ -1912,8 +2045,7 @@ ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_
 #endif
 
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_BIGINFO_REPORTS)
-void
-ble_gap_rx_biginfo_adv_rpt(const struct ble_hci_ev_le_subev_biginfo_adv_report *ev)
+void ble_gap_rx_biginfo_adv_rpt(const struct ble_hci_ev_le_subev_biginfo_adv_report *ev)
 {
     struct ble_hs_periodic_sync *psync;
     struct ble_gap_event event;
@@ -1925,7 +2057,8 @@ ble_gap_rx_biginfo_adv_rpt(const struct ble_hci_ev_le_subev_biginfo_adv_report *
 
     ble_hs_lock();
     psync = ble_hs_periodic_sync_find_by_handle(le16toh(ev->sync_handle));
-    if (psync) {
+    if (psync)
+    {
         cb = psync->cb;
         cb_arg = psync->cb_arg;
     }
@@ -1949,15 +2082,15 @@ ble_gap_rx_biginfo_adv_rpt(const struct ble_hci_ev_le_subev_biginfo_adv_report *
     event.biginfo_report.encryption = ev->encryption;
 
     ble_gap_event_listener_call(&event);
-    if (cb) {
+    if (cb)
+    {
         cb(&event, cb_arg);
     }
 }
 #endif
 
 #if MYNEWT_VAL(BLE_CONN_SUBRATING)
-void
-ble_gap_rx_subrate_change(const struct ble_hci_ev_le_subev_subrate_change *ev)
+void ble_gap_rx_subrate_change(const struct ble_hci_ev_le_subev_subrate_change *ev)
 {
     struct ble_gap_event event;
 
@@ -1993,8 +2126,7 @@ ble_gap_rd_rem_sup_feat_tx(uint16_t handle)
  * Processes an incoming connection-complete HCI event.
  * instance parameter is valid only for slave connection.
  */
-int
-ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
+int ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -2006,26 +2138,33 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
     /* in that case *only* status field is valid so we determine role
      * based on error code
      */
-    if (evt->status != BLE_ERR_SUCCESS) {
-        switch (evt->status) {
+    if (evt->status != BLE_ERR_SUCCESS)
+    {
+        switch (evt->status)
+        {
         case BLE_ERR_DIR_ADV_TMO:
             /* slave role (HD directed advertising)
              *
              * with ext advertising this is send from set terminated event
              */
 #if !MYNEWT_VAL(BLE_EXT_ADV)
-            if (ble_gap_adv_active()) {
+            if (ble_gap_adv_active())
+            {
                 ble_gap_adv_finished(0, 0, 0, 0);
             }
 #endif
             break;
         case BLE_ERR_UNK_CONN_ID:
             /* master role */
-            if (ble_gap_master_in_progress()) {
+            if (ble_gap_master_in_progress())
+            {
                 /* Connect procedure successfully cancelled. */
-                if (ble_gap_master.preempted_op == BLE_GAP_OP_M_CONN) {
+                if (ble_gap_master.preempted_op == BLE_GAP_OP_M_CONN)
+                {
                     ble_gap_master_failed(BLE_HS_EPREEMPTED);
-                } else {
+                }
+                else
+                {
                     ble_gap_master_connect_cancelled();
                 }
             }
@@ -2033,7 +2172,8 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
         default:
             /* this should never happen, unless controller is broken */
             BLE_HS_LOG(INFO, "controller reported invalid error code in conn"
-                             "complete event: %u", evt->status);
+                             "complete event: %u",
+                       evt->status);
             assert(0);
             break;
         }
@@ -2041,24 +2181,28 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
     }
 
     /* Apply the event to the existing connection if it exists. */
-    if (ble_hs_atomic_conn_flags(evt->connection_handle, NULL) == 0) {
+    if (ble_hs_atomic_conn_flags(evt->connection_handle, NULL) == 0)
+    {
         /* XXX: Does this ever happen? */
         return 0;
     }
 
     /* This event refers to a new connection. */
 
-    switch (evt->role) {
+    switch (evt->role)
+    {
     case BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER:
         rc = ble_gap_accept_master_conn();
-        if (rc != 0) {
+        if (rc != 0)
+        {
             return rc;
         }
         break;
 
     case BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE:
         rc = ble_gap_accept_slave_conn(instance);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             return rc;
         }
         break;
@@ -2076,13 +2220,16 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
     conn->bhc_latency = evt->conn_latency;
     conn->bhc_supervision_timeout = evt->supervision_timeout;
     conn->bhc_master_clock_accuracy = evt->master_clk_acc;
-    if (evt->role == BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER) {
+    if (evt->role == BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER)
+    {
         conn->bhc_cb = ble_gap_master.cb;
         conn->bhc_cb_arg = ble_gap_master.cb_arg;
         conn->bhc_flags |= BLE_HS_CONN_F_MASTER;
         conn->bhc_our_addr_type = ble_gap_master.conn.our_addr_type;
         ble_gap_master_reset_state();
-    } else {
+    }
+    else
+    {
         conn->bhc_cb = ble_gap_slave[instance].cb;
         conn->bhc_cb_arg = ble_gap_slave[instance].cb_arg;
         conn->bhc_our_addr_type = ble_gap_slave[instance].our_addr_type;
@@ -2102,11 +2249,15 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
      * is RPA then store the peer RPA address so when the peer
      * address is resolved, the RPA is not forgotten.
      */
-    if (memcmp(BLE_ADDR_ANY->val, evt->peer_rpa, 6) == 0) {
-        if (BLE_ADDR_IS_RPA(&conn->bhc_peer_addr)) {
+    if (memcmp(BLE_ADDR_ANY->val, evt->peer_rpa, 6) == 0)
+    {
+        if (BLE_ADDR_IS_RPA(&conn->bhc_peer_addr))
+        {
             conn->bhc_peer_rpa_addr = conn->bhc_peer_addr;
         }
-    } else {
+    }
+    else
+    {
         conn->bhc_peer_rpa_addr.type = BLE_ADDR_RANDOM;
         memcpy(conn->bhc_peer_rpa_addr.val, evt->peer_rpa, 6);
     }
@@ -2133,8 +2284,7 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
 #endif
 }
 
-void
-ble_gap_rx_rd_rem_sup_feat_complete(const struct ble_hci_ev_le_subev_rd_rem_used_feat *ev)
+void ble_gap_rx_rd_rem_sup_feat_complete(const struct ble_hci_ev_le_subev_rd_rem_used_feat *ev)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hs_conn *conn;
@@ -2142,7 +2292,8 @@ ble_gap_rx_rd_rem_sup_feat_complete(const struct ble_hci_ev_le_subev_rd_rem_used
     ble_hs_lock();
 
     conn = ble_hs_conn_find(le16toh(ev->conn_handle));
-    if ((conn != NULL) && (ev->status == 0)) {
+    if ((conn != NULL) && (ev->status == 0))
+    {
         conn->supported_feat = get_le32(ev->features);
     }
 
@@ -2150,9 +2301,8 @@ ble_gap_rx_rd_rem_sup_feat_complete(const struct ble_hci_ev_le_subev_rd_rem_used
 #endif
 }
 
-int
-ble_gap_rx_l2cap_update_req(uint16_t conn_handle,
-                            struct ble_gap_upd_params *params)
+int ble_gap_rx_l2cap_update_req(uint16_t conn_handle,
+                                struct ble_gap_upd_params *params)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -2170,8 +2320,7 @@ ble_gap_rx_l2cap_update_req(uint16_t conn_handle,
 #endif
 }
 
-void
-ble_gap_rx_phy_update_complete(const struct ble_hci_ev_le_subev_phy_update_complete *ev)
+void ble_gap_rx_phy_update_complete(const struct ble_hci_ev_le_subev_phy_update_complete *ev)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -2198,21 +2347,26 @@ ble_gap_master_timer(void)
 #endif
 
     ticks_until_exp = ble_gap_master_ticks_until_exp();
-    if (ticks_until_exp != 0) {
+    if (ticks_until_exp != 0)
+    {
         /* Timer not expired yet. */
         return ticks_until_exp;
     }
 
     /*** Timer expired; process event. */
 
-    switch (ble_gap_master.op) {
+    switch (ble_gap_master.op)
+    {
 #if NIMBLE_BLE_CONNECT
     case BLE_GAP_OP_M_CONN:
         rc = ble_gap_conn_cancel_tx();
-        if (rc != 0) {
+        if (rc != 0)
+        {
             /* Failed to stop connecting; try again in 100 ms. */
             return ble_npl_time_ms_to_ticks32(BLE_GAP_CANCEL_RETRY_TIMEOUT_MS);
-        } else {
+        }
+        else
+        {
             /* Stop the timer now that the cancel command has been acked. */
             ble_gap_master.exp_set = 0;
 
@@ -2230,7 +2384,8 @@ ble_gap_master_timer(void)
 #if NIMBLE_BLE_SCAN && !MYNEWT_VAL(BLE_EXT_ADV)
         /* When a discovery procedure times out, it is not a failure. */
         rc = ble_gap_disc_enable_tx(0, 0);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             /* Failed to stop discovery; try again in 100 ms. */
             return ble_npl_time_ms_to_ticks32(BLE_GAP_CANCEL_RETRY_TIMEOUT_MS);
         }
@@ -2257,7 +2412,8 @@ ble_gap_slave_timer(void)
     int rc;
 
     ticks_until_exp = ble_gap_slave_ticks_until_exp();
-    if (ticks_until_exp != 0) {
+    if (ticks_until_exp != 0)
+    {
         /* Timer not expired yet. */
         return ticks_until_exp;
     }
@@ -2266,7 +2422,8 @@ ble_gap_slave_timer(void)
 
     /* Stop advertising. */
     rc = ble_gap_adv_enable_tx(0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         /* Failed to stop advertising; try again in 100 ms. */
         return 100;
     }
@@ -2288,19 +2445,24 @@ ble_gap_update_timer(void)
     int32_t ticks_until_exp;
     uint16_t conn_handle;
 
-    do {
+    do
+    {
         ble_hs_lock();
 
         conn_handle = ble_gap_update_next_exp(&ticks_until_exp);
-        if (ticks_until_exp == 0) {
+        if (ticks_until_exp == 0)
+        {
             entry = ble_gap_update_entry_remove(conn_handle);
-        } else {
+        }
+        else
+        {
             entry = NULL;
         }
 
         ble_hs_unlock();
 
-        if (entry != NULL) {
+        if (entry != NULL)
+        {
             ble_gap_update_entry_free(entry);
         }
     } while (entry != NULL);
@@ -2308,8 +2470,7 @@ ble_gap_update_timer(void)
     return ticks_until_exp;
 }
 
-int
-ble_gap_set_event_cb(uint16_t conn_handle, ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_set_event_cb(uint16_t conn_handle, ble_gap_event_fn *cb, void *cb_arg)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hs_conn *conn;
@@ -2317,14 +2478,16 @@ ble_gap_set_event_cb(uint16_t conn_handle, ble_gap_event_fn *cb, void *cb_arg)
     ble_hs_lock();
 
     conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
+    if (conn != NULL)
+    {
         conn->bhc_cb = cb;
         conn->bhc_cb_arg = cb_arg;
     }
 
     ble_hs_unlock();
 
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         return BLE_HS_ENOTCONN;
     }
 
@@ -2379,7 +2542,8 @@ ble_gap_wl_tx_add(const ble_addr_t *addr)
 {
     struct ble_hci_le_add_whte_list_cp cmd;
 
-    if (addr->type > BLE_ADDR_RANDOM) {
+    if (addr->type > BLE_ADDR_RANDOM)
+    {
         return BLE_HS_EINVAL;
     }
 
@@ -2396,12 +2560,11 @@ ble_gap_wl_tx_clear(void)
 {
     return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
                                         BLE_HCI_OCF_LE_CLEAR_WHITE_LIST),
-                             NULL, 0, NULL, 0 );
+                             NULL, 0, NULL, 0);
 }
 #endif
 
-int
-ble_gap_wl_set(const ble_addr_t *addrs, uint8_t white_list_count)
+int ble_gap_wl_set(const ble_addr_t *addrs, uint8_t white_list_count)
 {
 #if MYNEWT_VAL(BLE_WHITELIST)
     int rc;
@@ -2409,22 +2572,26 @@ ble_gap_wl_set(const ble_addr_t *addrs, uint8_t white_list_count)
 
     STATS_INC(ble_gap_stats, wl_set);
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
-    for (i = 0; i < white_list_count; i++) {
+    for (i = 0; i < white_list_count; i++)
+    {
         if (addrs[i].type != BLE_ADDR_PUBLIC &&
-            addrs[i].type != BLE_ADDR_RANDOM) {
+            addrs[i].type != BLE_ADDR_RANDOM)
+        {
 
             rc = BLE_HS_EINVAL;
             goto done;
         }
     }
 
-    if (ble_gap_wl_busy()) {
+    if (ble_gap_wl_busy())
+    {
         rc = BLE_HS_EBUSY;
         goto done;
     }
@@ -2434,13 +2601,16 @@ ble_gap_wl_set(const ble_addr_t *addrs, uint8_t white_list_count)
     BLE_HS_LOG(INFO, "\n");
 
     rc = ble_gap_wl_tx_clear();
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
-    for (i = 0; i < white_list_count; i++) {
+    for (i = 0; i < white_list_count; i++)
+    {
         rc = ble_gap_wl_tx_add(addrs + i);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             goto done;
         }
     }
@@ -2450,7 +2620,8 @@ ble_gap_wl_set(const ble_addr_t *addrs, uint8_t white_list_count)
 done:
     ble_hs_unlock();
 
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, wl_set_fail);
     }
     return rc;
@@ -2490,20 +2661,25 @@ ble_gap_adv_stop_no_lock(void)
     BLE_HS_LOG(INFO, "GAP procedure initiated: stop advertising.\n");
 
     rc = ble_gap_adv_enable_tx(0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
     ble_gap_slave_reset_state(0);
 
-    if (!active) {
+    if (!active)
+    {
         rc = BLE_HS_EALREADY;
-    } else {
+    }
+    else
+    {
         rc = 0;
     }
 
 done:
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, adv_stop_fail);
     }
 
@@ -2511,13 +2687,13 @@ done:
 }
 #endif
 
-int
-ble_gap_adv_stop(void)
+int ble_gap_adv_stop(void)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -2538,11 +2714,15 @@ ble_gap_adv_stop(void)
 static int
 ble_gap_adv_type(const struct ble_gap_adv_params *adv_params)
 {
-    switch (adv_params->conn_mode) {
+    switch (adv_params->conn_mode)
+    {
     case BLE_GAP_CONN_MODE_NON:
-        if (adv_params->disc_mode == BLE_GAP_DISC_MODE_NON) {
+        if (adv_params->disc_mode == BLE_GAP_DISC_MODE_NON)
+        {
             return BLE_HCI_ADV_TYPE_ADV_NONCONN_IND;
-        } else {
+        }
+        else
+        {
             return BLE_HCI_ADV_TYPE_ADV_SCAN_IND;
         }
 
@@ -2550,9 +2730,12 @@ ble_gap_adv_type(const struct ble_gap_adv_params *adv_params)
         return BLE_HCI_ADV_TYPE_ADV_IND;
 
     case BLE_GAP_CONN_MODE_DIR:
-        if (adv_params->high_duty_cycle) {
+        if (adv_params->high_duty_cycle)
+        {
             return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD;
-        } else {
+        }
+        else
+        {
             return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD;
         }
 
@@ -2566,7 +2749,8 @@ static void
 ble_gap_adv_dflt_itvls(uint8_t conn_mode,
                        uint16_t *out_itvl_min, uint16_t *out_itvl_max)
 {
-    switch (conn_mode) {
+    switch (conn_mode)
+    {
     case BLE_GAP_CONN_MODE_NON:
         *out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL2_MIN;
         *out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL2_MAX;
@@ -2602,11 +2786,14 @@ ble_gap_adv_params_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
     uint16_t max;
 
     /* Fill optional fields if application did not specify them. */
-    if ((adv_params->itvl_min == 0) && (adv_params->itvl_max == 0)) {
+    if ((adv_params->itvl_min == 0) && (adv_params->itvl_max == 0))
+    {
         ble_gap_adv_dflt_itvls(adv_params->conn_mode, &min, &max);
         cmd.min_interval = htole16(min);
         cmd.max_interval = htole16(max);
-    } else {
+    }
+    else
+    {
         cmd.min_interval = htole16(adv_params->itvl_min);
         cmd.max_interval = htole16(adv_params->itvl_max);
     }
@@ -2614,16 +2801,20 @@ ble_gap_adv_params_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
     cmd.type = ble_gap_adv_type(adv_params);
     cmd.own_addr_type = own_addr_type;
 
-    if (peer_addr == NULL) {
+    if (peer_addr == NULL)
+    {
         peer_addr = peer_any;
     }
 
     cmd.peer_addr_type = peer_addr->type;
     memcpy(&cmd.peer_addr, peer_addr->val, sizeof(cmd.peer_addr));
 
-    if (adv_params->channel_map == 0) {
+    if (adv_params->channel_map == 0)
+    {
         cmd.chan_map = BLE_GAP_ADV_DFLT_CHANNEL_MAP;
-    } else {
+    }
+    else
+    {
         cmd.chan_map = adv_params->channel_map;
     }
 
@@ -2639,53 +2830,63 @@ static int
 ble_gap_adv_validate(uint8_t own_addr_type, const ble_addr_t *peer_addr,
                      const struct ble_gap_adv_params *adv_params)
 {
-    if (adv_params == NULL) {
+    if (adv_params == NULL)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (adv_params->disc_mode >= BLE_GAP_DISC_MODE_MAX) {
+    if (adv_params->disc_mode >= BLE_GAP_DISC_MODE_MAX)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (ble_gap_slave[0].op != BLE_GAP_OP_NULL) {
+    if (ble_gap_slave[0].op != BLE_GAP_OP_NULL)
+    {
         return BLE_HS_EALREADY;
     }
 
-    switch (adv_params->conn_mode) {
+    switch (adv_params->conn_mode)
+    {
     case BLE_GAP_CONN_MODE_NON:
         /* High duty cycle only allowed for directed advertising. */
-        if (adv_params->high_duty_cycle) {
+        if (adv_params->high_duty_cycle)
+        {
             return BLE_HS_EINVAL;
         }
         break;
 
     case BLE_GAP_CONN_MODE_UND:
         /* High duty cycle only allowed for directed advertising. */
-        if (adv_params->high_duty_cycle) {
+        if (adv_params->high_duty_cycle)
+        {
             return BLE_HS_EINVAL;
         }
 
         /* Don't allow connectable advertising if we won't be able to allocate
          * a new connection.
          */
-        if (!ble_hs_conn_can_alloc()) {
+        if (!ble_hs_conn_can_alloc())
+        {
             return BLE_HS_ENOMEM;
         }
         break;
 
     case BLE_GAP_CONN_MODE_DIR:
-        if (peer_addr == NULL) {
+        if (peer_addr == NULL)
+        {
             return BLE_HS_EINVAL;
         }
 
         if (peer_addr->type != BLE_ADDR_PUBLIC &&
             peer_addr->type != BLE_ADDR_RANDOM &&
             peer_addr->type != BLE_ADDR_PUBLIC_ID &&
-            peer_addr->type != BLE_ADDR_RANDOM_ID) {
+            peer_addr->type != BLE_ADDR_RANDOM_ID)
+        {
 
             return BLE_HS_EINVAL;
         }
@@ -2693,7 +2894,8 @@ ble_gap_adv_validate(uint8_t own_addr_type, const ble_addr_t *peer_addr,
         /* Don't allow connectable advertising if we won't be able to allocate
          * a new connection.
          */
-        if (!ble_hs_conn_can_alloc()) {
+        if (!ble_hs_conn_can_alloc())
+        {
             return BLE_HS_ENOMEM;
         }
         break;
@@ -2706,11 +2908,10 @@ ble_gap_adv_validate(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 }
 #endif
 
-int
-ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
-                  int32_t duration_ms,
-                  const struct ble_gap_adv_params *adv_params,
-                  ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
+                      int32_t duration_ms,
+                      const struct ble_gap_adv_params *adv_params,
+                      ble_gap_event_fn *cb, void *cb_arg)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
     uint32_t duration_ticks;
@@ -2718,33 +2919,39 @@ ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
 
     STATS_INC(ble_gap_stats, adv_start);
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
     rc = ble_gap_adv_validate(own_addr_type, direct_addr, adv_params);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
-    if (duration_ms != BLE_HS_FOREVER) {
+    if (duration_ms != BLE_HS_FOREVER)
+    {
         rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             /* Duration too great. */
             rc = BLE_HS_EINVAL;
             goto done;
         }
     }
 
-    if (ble_gap_is_preempted()) {
+    if (ble_gap_is_preempted())
+    {
         rc = BLE_HS_EPREEMPTED;
         goto done;
     }
 
     rc = ble_hs_id_use_addr(own_addr_type);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
@@ -2756,26 +2963,32 @@ ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
     ble_gap_slave[0].cb_arg = cb_arg;
     ble_gap_slave[0].our_addr_type = own_addr_type;
 
-    if (adv_params->conn_mode != BLE_GAP_CONN_MODE_NON) {
+    if (adv_params->conn_mode != BLE_GAP_CONN_MODE_NON)
+    {
         ble_gap_slave[0].connectable = 1;
-    } else {
+    }
+    else
+    {
         ble_gap_slave[0].connectable = 0;
     }
 
     rc = ble_gap_adv_params_tx(own_addr_type, direct_addr, adv_params);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
     ble_gap_slave[0].op = BLE_GAP_OP_S_ADV;
 
     rc = ble_gap_adv_enable_tx(1);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_gap_slave_reset_state(0);
         goto done;
     }
 
-    if (duration_ms != BLE_HS_FOREVER) {
+    if (duration_ms != BLE_HS_FOREVER)
+    {
         ble_gap_slave_set_timer(duration_ticks);
     }
 
@@ -2784,7 +2997,8 @@ ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
 done:
     ble_hs_unlock();
 
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, adv_start_fail);
     }
     return rc;
@@ -2793,8 +3007,7 @@ done:
 #endif
 }
 
-int
-ble_gap_adv_set_data(const uint8_t *data, int data_len)
+int ble_gap_adv_set_data(const uint8_t *data, int data_len)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
     struct ble_hci_le_set_adv_data_cp cmd;
@@ -2802,13 +3015,15 @@ ble_gap_adv_set_data(const uint8_t *data, int data_len)
 
     STATS_INC(ble_gap_stats, adv_set_data);
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     /* Check for valid parameters */
     if (((data == NULL) && (data_len != 0)) ||
-            (data_len > BLE_HCI_MAX_ADV_DATA_LEN)) {
+        (data_len > BLE_HCI_MAX_ADV_DATA_LEN))
+    {
         return BLE_HS_EINVAL;
     }
 
@@ -2823,20 +3038,21 @@ ble_gap_adv_set_data(const uint8_t *data, int data_len)
 #endif
 }
 
-int
-ble_gap_adv_rsp_set_data(const uint8_t *data, int data_len)
+int ble_gap_adv_rsp_set_data(const uint8_t *data, int data_len)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
     struct ble_hci_le_set_scan_rsp_data_cp cmd;
     uint16_t opcode;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     /* Check for valid parameters */
     if (((data == NULL) && (data_len != 0)) ||
-            (data_len > BLE_HCI_MAX_SCAN_RSP_DATA_LEN)) {
+        (data_len > BLE_HCI_MAX_SCAN_RSP_DATA_LEN))
+    {
         return BLE_HS_EINVAL;
     }
 
@@ -2851,25 +3067,27 @@ ble_gap_adv_rsp_set_data(const uint8_t *data, int data_len)
 #endif
 }
 
-int
-ble_gap_adv_set_fields(const struct ble_hs_adv_fields *adv_fields)
+int ble_gap_adv_set_fields(const struct ble_hs_adv_fields *adv_fields)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
     uint8_t buf[BLE_HS_ADV_MAX_SZ];
     uint8_t buf_sz;
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     rc = ble_hs_adv_set_fields(adv_fields, buf, &buf_sz, sizeof buf);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
     rc = ble_gap_adv_set_data(buf, buf_sz);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -2879,8 +3097,7 @@ ble_gap_adv_set_fields(const struct ble_hs_adv_fields *adv_fields)
 #endif
 }
 
-int
-ble_gap_adv_rsp_set_fields(const struct ble_hs_adv_fields *rsp_fields)
+int ble_gap_adv_rsp_set_fields(const struct ble_hs_adv_fields *rsp_fields)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
     uint8_t buf[BLE_HS_ADV_MAX_SZ];
@@ -2888,12 +3105,14 @@ ble_gap_adv_rsp_set_fields(const struct ble_hs_adv_fields *rsp_fields)
     int rc;
 
     rc = ble_hs_adv_set_fields(rsp_fields, buf, &buf_sz, sizeof buf);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
     rc = ble_gap_adv_rsp_set_data(buf, buf_sz);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -2903,8 +3122,7 @@ ble_gap_adv_rsp_set_fields(const struct ble_hs_adv_fields *rsp_fields)
 #endif
 }
 
-int
-ble_gap_adv_active(void)
+int ble_gap_adv_active(void)
 {
 #if NIMBLE_BLE_ADVERTISE
     return ble_gap_adv_active_instance(0);
@@ -2928,56 +3146,70 @@ ble_gap_ext_adv_params_tx(uint8_t instance,
 
     cmd.adv_handle = instance;
 
-    if (params->connectable) {
+    if (params->connectable)
+    {
         cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_CONNECTABLE;
     }
-    if (params->scannable) {
+    if (params->scannable)
+    {
         cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_SCANNABLE;
     }
-    if (params->directed) {
+    if (params->directed)
+    {
         cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_DIRECTED;
         cmd.peer_addr_type = params->peer.type;
         memcpy(cmd.peer_addr, params->peer.val, BLE_DEV_ADDR_LEN);
     }
-    if (params->high_duty_directed) {
+    if (params->high_duty_directed)
+    {
         cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_HD_DIRECTED;
     }
-    if (params->anonymous) {
+    if (params->anonymous)
+    {
         cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_ANON_ADV;
     }
-    if (params->include_tx_power) {
+    if (params->include_tx_power)
+    {
         cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_INC_TX_PWR;
     }
-    if (params->legacy_pdu) {
+    if (params->legacy_pdu)
+    {
         cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY;
 
         /* check right away if the applied configuration is valid before handing
          * the command to the controller to improve error reporting */
-        switch (cmd.props) {
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN:
-                break;
-            default:
-                return BLE_HS_EINVAL;
+        switch (cmd.props)
+        {
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND:
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR:
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR:
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN:
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN:
+            break;
+        default:
+            return BLE_HS_EINVAL;
         }
     }
 
     /* Fill optional fields if application did not specify them. */
-    if (params->itvl_min == 0 && params->itvl_max == 0) {
+    if (params->itvl_min == 0 && params->itvl_max == 0)
+    {
         /* TODO for now limited to legacy values*/
         put_le24(cmd.pri_itvl_min, BLE_GAP_ADV_FAST_INTERVAL1_MIN);
         put_le24(cmd.pri_itvl_max, BLE_GAP_ADV_FAST_INTERVAL2_MAX);
-    } else {
+    }
+    else
+    {
         put_le24(cmd.pri_itvl_min, params->itvl_min);
         put_le24(cmd.pri_itvl_max, params->itvl_max);
     }
 
-    if (params->channel_map == 0) {
+    if (params->channel_map == 0)
+    {
         cmd.pri_chan_map = BLE_GAP_ADV_DFLT_CHANNEL_MAP;
-    } else {
+    }
+    else
+    {
         cmd.pri_chan_map = params->channel_map;
     }
 
@@ -2985,10 +3217,13 @@ ble_gap_ext_adv_params_tx(uint8_t instance,
     cmd.filter_policy = params->filter_policy;
     cmd.tx_power = params->tx_power;
 
-    if (params->legacy_pdu) {
+    if (params->legacy_pdu)
+    {
         cmd.pri_phy = BLE_HCI_LE_PHY_1M;
         cmd.sec_phy = BLE_HCI_LE_PHY_1M;
-    } else {
+    }
+    else
+    {
         cmd.pri_phy = params->primary_phy;
         cmd.sec_phy = params->secondary_phy;
     }
@@ -3002,11 +3237,13 @@ ble_gap_ext_adv_params_tx(uint8_t instance,
                                       BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM),
                            &cmd, sizeof(cmd), &rsp, sizeof(rsp));
 
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
-    if (selected_tx_power) {
+    if (selected_tx_power)
+    {
         *selected_tx_power = rsp.tx_power;
     }
 
@@ -3016,42 +3253,52 @@ ble_gap_ext_adv_params_tx(uint8_t instance,
 static int
 ble_gap_ext_adv_params_validate(const struct ble_gap_ext_adv_params *params)
 {
-    if (!params) {
+    if (!params)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (params->own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+    if (params->own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX)
+    {
         return BLE_HS_EINVAL;
     }
 
     /* Don't allow connectable advertising if we won't be able to allocate
      * a new connection.
      */
-    if (params->connectable && !ble_hs_conn_can_alloc()) {
+    if (params->connectable && !ble_hs_conn_can_alloc())
+    {
         return BLE_HS_ENOMEM;
     }
 
-    if (params->legacy_pdu) {
+    if (params->legacy_pdu)
+    {
         /* not allowed for legacy PDUs */
-        if (params->anonymous || params->include_tx_power) {
+        if (params->anonymous || params->include_tx_power)
+        {
             return BLE_HS_EINVAL;
         }
     }
 
-    if (params->directed) {
-        if (params->scannable && params->connectable) {
+    if (params->directed)
+    {
+        if (params->scannable && params->connectable)
+        {
             return BLE_HS_EINVAL;
         }
     }
 
-    if (!params->legacy_pdu) {
+    if (!params->legacy_pdu)
+    {
         /* not allowed for extended advertising PDUs */
-        if (params->connectable && params->scannable) {
+        if (params->connectable && params->scannable)
+        {
             return BLE_HS_EINVAL;
         }
 
         /* HD directed advertising allowed only for legacy PDUs */
-        if (params->high_duty_directed) {
+        if (params->high_duty_directed)
+        {
             return BLE_HS_EINVAL;
         }
     }
@@ -3059,36 +3306,40 @@ ble_gap_ext_adv_params_validate(const struct ble_gap_ext_adv_params *params)
     return 0;
 }
 
-int
-ble_gap_ext_adv_configure(uint8_t instance,
-                          const struct ble_gap_ext_adv_params *params,
-                          int8_t *selected_tx_power,
-                          ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_ext_adv_configure(uint8_t instance,
+                              const struct ble_gap_ext_adv_params *params,
+                              int8_t *selected_tx_power,
+                              ble_gap_event_fn *cb, void *cb_arg)
 {
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     rc = ble_gap_ext_adv_params_validate(params);
-    if (rc) {
+    if (rc)
+    {
         return rc;
     }
 
     ble_hs_lock();
 
-    if (ble_gap_adv_active_instance(instance)) {
+    if (ble_gap_adv_active_instance(instance))
+    {
         ble_hs_unlock();
         return BLE_HS_EBUSY;
     }
 
     rc = ble_gap_ext_adv_params_tx(instance, params, selected_tx_power);
-    if (rc) {
+    if (rc)
+    {
         ble_hs_unlock();
         return rc;
     }
@@ -3120,7 +3371,8 @@ ble_gap_ext_adv_set_addr_no_lock(uint8_t instance, const uint8_t *addr)
     rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
                                       BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR),
                            &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -3130,16 +3382,17 @@ ble_gap_ext_adv_set_addr_no_lock(uint8_t instance, const uint8_t *addr)
     return 0;
 }
 
-int
-ble_gap_ext_adv_set_addr(uint8_t instance, const ble_addr_t *addr)
+int ble_gap_ext_adv_set_addr(uint8_t instance, const ble_addr_t *addr)
 {
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES || addr->type != BLE_ADDR_RANDOM) {
+    if (instance >= BLE_ADV_INSTANCES || addr->type != BLE_ADDR_RANDOM)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -3150,8 +3403,7 @@ ble_gap_ext_adv_set_addr(uint8_t instance, const ble_addr_t *addr)
     return rc;
 }
 
-int
-ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
+int ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
 {
     struct ble_hci_le_set_ext_adv_enable_cp *cmd;
     uint8_t buf[sizeof(*cmd) + sizeof(cmd->sets[0])];
@@ -3159,28 +3411,33 @@ ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
     uint16_t opcode;
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
-    if (!ble_gap_slave[instance].configured) {
+    if (!ble_gap_slave[instance].configured)
+    {
         ble_hs_unlock();
         return BLE_HS_EINVAL;
     }
 
-    if (ble_gap_slave[instance].op != BLE_GAP_OP_NULL) {
+    if (ble_gap_slave[instance].op != BLE_GAP_OP_NULL)
+    {
         ble_hs_unlock();
-        return  BLE_HS_EALREADY;
+        return BLE_HS_EALREADY;
     }
 
     /* HD directed duration shall not be 0 or larger than >1.28s */
     if (ble_gap_slave[instance].high_duty_directed &&
-            ((duration == 0) || (duration > 128)) ) {
+        ((duration == 0) || (duration > 128)))
+    {
         ble_hs_unlock();
         return BLE_HS_EINVAL;
     }
@@ -3188,10 +3445,12 @@ ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
     /* verify own address type if random address for instance wasn't explicitly
      * set
      */
-    switch (ble_gap_slave[instance].our_addr_type) {
+    switch (ble_gap_slave[instance].our_addr_type)
+    {
     case BLE_OWN_ADDR_RANDOM:
     case BLE_OWN_ADDR_RPA_RANDOM_DEFAULT:
-        if (ble_gap_slave[instance].rnd_addr_set) {
+        if (ble_gap_slave[instance].rnd_addr_set)
+        {
             break;
         }
     /* fall through */
@@ -3199,7 +3458,8 @@ ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
     case BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT:
     default:
         rc = ble_hs_id_use_addr(ble_gap_slave[instance].our_addr_type);
-        if (rc) {
+        if (rc)
+        {
             ble_hs_unlock();
             return BLE_HS_EINVAL;
         }
@@ -3209,18 +3469,22 @@ ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
     /* fallback to ID static random address if using random address and instance
      * wasn't configured with own address
      */
-    if (!ble_gap_slave[instance].rnd_addr_set) {
-        switch (ble_gap_slave[instance].our_addr_type) {
+    if (!ble_gap_slave[instance].rnd_addr_set)
+    {
+        switch (ble_gap_slave[instance].our_addr_type)
+        {
         case BLE_OWN_ADDR_RANDOM:
         case BLE_OWN_ADDR_RPA_RANDOM_DEFAULT:
             rc = ble_hs_id_addr(BLE_ADDR_RANDOM, &rnd_addr, NULL);
-            if (rc != 0) {
+            if (rc != 0)
+            {
                 ble_hs_unlock();
                 return rc;
             }
 
             rc = ble_gap_ext_adv_set_addr_no_lock(instance, rnd_addr);
-            if (rc != 0) {
+            if (rc != 0)
+            {
                 ble_hs_unlock();
                 return rc;
             }
@@ -3232,7 +3496,7 @@ ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
 
     opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE);
 
-    cmd = (void *) buf;
+    cmd = (void *)buf;
 
     cmd->enable = 0x01;
     cmd->num_sets = 1;
@@ -3242,7 +3506,8 @@ ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
     cmd->sets[0].max_events = max_events;
 
     rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(buf), NULL, 0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_hs_unlock();
         return rc;
     }
@@ -3262,13 +3527,14 @@ ble_gap_ext_adv_stop_no_lock(uint8_t instance)
     bool active;
     int rc;
 
-    if (!ble_gap_slave[instance].configured) {
+    if (!ble_gap_slave[instance].configured)
+    {
         return BLE_HS_EINVAL;
     }
 
     active = ble_gap_adv_active_instance(instance);
 
-    cmd = (void *) buf;
+    cmd = (void *)buf;
 
     cmd->enable = 0x00;
     cmd->num_sets = 1;
@@ -3279,25 +3545,29 @@ ble_gap_ext_adv_stop_no_lock(uint8_t instance)
     opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE);
 
     rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(buf), NULL, 0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
     ble_gap_slave[instance].op = BLE_GAP_OP_NULL;
 
-    if (!active) {
+    if (!active)
+    {
         return BLE_HS_EALREADY;
-    } else {
+    }
+    else
+    {
         return 0;
     }
 }
 
-int
-ble_gap_ext_adv_stop(uint8_t instance)
+int ble_gap_ext_adv_stop(uint8_t instance)
 {
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         return BLE_HS_EINVAL;
     }
 
@@ -3308,24 +3578,27 @@ ble_gap_ext_adv_stop(uint8_t instance)
     return rc;
 }
 
-
 static int
 ble_gap_ext_adv_set_data_validate(uint8_t instance, struct os_mbuf *data)
 {
     uint16_t len = OS_MBUF_PKTLEN(data);
 
-    if (!ble_gap_slave[instance].configured) {
+    if (!ble_gap_slave[instance].configured)
+    {
         return BLE_HS_EINVAL;
     }
 
     /* not allowed with directed advertising for legacy*/
-    if (ble_gap_slave[instance].legacy_pdu && ble_gap_slave[instance].directed) {
+    if (ble_gap_slave[instance].legacy_pdu && ble_gap_slave[instance].directed)
+    {
         return BLE_HS_EINVAL;
     }
 
     /* always allowed with legacy PDU but limited to legacy length */
-    if (ble_gap_slave[instance].legacy_pdu) {
-        if (len > BLE_HS_ADV_MAX_SZ) {
+    if (ble_gap_slave[instance].legacy_pdu)
+    {
+        if (len > BLE_HS_ADV_MAX_SZ)
+        {
             return BLE_HS_EINVAL;
         }
 
@@ -3336,14 +3609,17 @@ ble_gap_ext_adv_set_data_validate(uint8_t instance, struct os_mbuf *data)
      * as per BT 5.0 Vol 2, Part E, 7.8.54. Don't bother Controller with such
      * a request.
      */
-    if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV) {
-        if (len > min(MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE), 251)) {
+    if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV)
+    {
+        if (len > min(MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE), 251))
+        {
             return BLE_HS_EINVAL;
         }
     }
 
     /* not allowed with scannable advertising */
-    if (ble_gap_slave[instance].scannable) {
+    if (ble_gap_slave[instance].scannable)
+    {
         return BLE_HS_EINVAL;
     }
 
@@ -3355,7 +3631,7 @@ ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
 {
     /* in that case we always fit all data in single HCI command */
 #if MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE) <= BLE_HCI_MAX_EXT_ADV_DATA_LEN
-    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) + \
+    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) +
                        MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE)];
     struct ble_hci_le_set_ext_adv_data_cp *cmd = (void *)buf;
     uint16_t len = OS_MBUF_PKTLEN(*data);
@@ -3373,19 +3649,20 @@ ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
     return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
                              NULL, 0);
 #else
-    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) + \
+    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) +
                        BLE_HCI_MAX_EXT_ADV_DATA_LEN];
     struct ble_hci_le_set_ext_adv_data_cp *cmd = (void *)buf;
     uint16_t len = OS_MBUF_PKTLEN(*data);
     uint8_t op;
     int rc;
 
-    opcode =  BLE_HCI_OP(BLE_HCI_OGF_LE, opcode);
+    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, opcode);
 
     cmd->adv_handle = instance;
 
     /* complete data */
-    if (len <= BLE_HCI_MAX_EXT_ADV_DATA_LEN) {
+    if (len <= BLE_HCI_MAX_EXT_ADV_DATA_LEN)
+    {
         cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
         cmd->fragment_pref = 0;
         cmd->adv_data_len = len;
@@ -3401,7 +3678,8 @@ ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
     /* first fragment  */
     op = BLE_HCI_LE_SET_DATA_OPER_FIRST;
 
-    do {
+    do
+    {
         cmd->operation = op;
         cmd->fragment_pref = 0;
         cmd->adv_data_len = BLE_HCI_MAX_EXT_ADV_DATA_LEN;
@@ -3412,7 +3690,8 @@ ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
 
         rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
                                NULL, 0);
-        if (rc) {
+        if (rc)
+        {
             return rc;
         }
 
@@ -3434,24 +3713,26 @@ ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
 #endif
 }
 
-int
-ble_gap_ext_adv_set_data(uint8_t instance, struct os_mbuf *data)
+int ble_gap_ext_adv_set_data(uint8_t instance, struct os_mbuf *data)
 {
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         rc = BLE_HS_EINVAL;
         goto done;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         rc = BLE_HS_EDISABLED;
         goto done;
     }
 
     ble_hs_lock();
     rc = ble_gap_ext_adv_set_data_validate(instance, data);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_hs_unlock();
         goto done;
     }
@@ -3466,27 +3747,32 @@ done:
 }
 
 static int
-ble_gap_ext_adv_rsp_set_validate(uint8_t instance,  struct os_mbuf *data)
+ble_gap_ext_adv_rsp_set_validate(uint8_t instance, struct os_mbuf *data)
 {
     uint16_t len = OS_MBUF_PKTLEN(data);
 
-    if (!ble_gap_slave[instance].configured) {
+    if (!ble_gap_slave[instance].configured)
+    {
         return BLE_HS_EINVAL;
     }
 
     /* not allowed with directed advertising */
-    if (ble_gap_slave[instance].directed && ble_gap_slave[instance].connectable) {
+    if (ble_gap_slave[instance].directed && ble_gap_slave[instance].connectable)
+    {
         return BLE_HS_EINVAL;
     }
 
     /* only allowed with scannable advertising */
-    if (!ble_gap_slave[instance].scannable) {
+    if (!ble_gap_slave[instance].scannable)
+    {
         return BLE_HS_EINVAL;
     }
 
     /* with legacy PDU limited to legacy length */
-    if (ble_gap_slave[instance].legacy_pdu) {
-        if (len > BLE_HS_ADV_MAX_SZ) {
+    if (ble_gap_slave[instance].legacy_pdu)
+    {
+        if (len > BLE_HS_ADV_MAX_SZ)
+        {
             return BLE_HS_EINVAL;
         }
 
@@ -3497,8 +3783,10 @@ ble_gap_ext_adv_rsp_set_validate(uint8_t instance,  struct os_mbuf *data)
      * as per BT 5.0 Vol 2, Part E, 7.8.55. Don't bother Controller with such
      * a request.
      */
-    if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV) {
-        if (len > min(MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE), 251)) {
+    if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV)
+    {
+        if (len > min(MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE), 251))
+        {
             return BLE_HS_EINVAL;
         }
     }
@@ -3506,24 +3794,26 @@ ble_gap_ext_adv_rsp_set_validate(uint8_t instance,  struct os_mbuf *data)
     return 0;
 }
 
-int
-ble_gap_ext_adv_rsp_set_data(uint8_t instance, struct os_mbuf *data)
+int ble_gap_ext_adv_rsp_set_data(uint8_t instance, struct os_mbuf *data)
 {
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         rc = BLE_HS_EINVAL;
         goto done;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         rc = BLE_HS_EDISABLED;
         goto done;
     }
 
     ble_hs_lock();
     rc = ble_gap_ext_adv_rsp_set_validate(instance, data);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_hs_unlock();
         goto done;
     }
@@ -3538,28 +3828,31 @@ done:
     return rc;
 }
 
-int
-ble_gap_ext_adv_remove(uint8_t instance)
+int ble_gap_ext_adv_remove(uint8_t instance)
 {
     struct ble_hci_le_remove_adv_set_cp cmd;
     uint16_t opcode;
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
-    if (!ble_gap_slave[instance].configured) {
+    if (!ble_gap_slave[instance].configured)
+    {
         ble_hs_unlock();
         return BLE_HS_EALREADY;
     }
 
-    if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV) {
+    if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV)
+    {
         ble_hs_unlock();
         return BLE_HS_EBUSY;
     }
@@ -3568,7 +3861,8 @@ ble_gap_ext_adv_remove(uint8_t instance)
     opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REMOVE_ADV_SET);
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_hs_unlock();
         return rc;
     }
@@ -3579,30 +3873,33 @@ ble_gap_ext_adv_remove(uint8_t instance)
     return 0;
 }
 
-int
-ble_gap_ext_adv_clear(void)
+int ble_gap_ext_adv_clear(void)
 {
     int rc;
     uint8_t instance;
     uint16_t opcode;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
-    for (instance = 0; instance < BLE_ADV_INSTANCES; instance++) {
+    for (instance = 0; instance < BLE_ADV_INSTANCES; instance++)
+    {
         /* If there is an active instance or periodic adv instance,
          * Don't send the command
          * */
-        if ((ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV)) {
+        if ((ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV))
+        {
             ble_hs_unlock();
             return BLE_HS_EBUSY;
         }
 
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-        if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV) {
+        if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV)
+        {
             ble_hs_unlock();
             return BLE_HS_EBUSY;
         }
@@ -3612,7 +3909,8 @@ ble_gap_ext_adv_clear(void)
     opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CLEAR_ADV_SETS);
 
     rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, NULL, 0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_hs_unlock();
         return rc;
     }
@@ -3635,18 +3933,23 @@ ble_gap_periodic_adv_params_tx(uint8_t instance,
     cmd.adv_handle = instance;
 
     /* Fill optional fields if application did not specify them. */
-    if (params->itvl_min == 0 && params->itvl_max == 0) {
+    if (params->itvl_min == 0 && params->itvl_max == 0)
+    {
         cmd.min_itvl = BLE_GAP_PERIODIC_ITVL_MS(30);
         cmd.max_itvl = BLE_GAP_PERIODIC_ITVL_MS(60);
-
-    } else {
+    }
+    else
+    {
         cmd.min_itvl = htole16(params->itvl_min);
         cmd.max_itvl = htole16(params->itvl_max);
     }
 
-    if (params->include_tx_power) {
+    if (params->include_tx_power)
+    {
         cmd.props = BLE_HCI_LE_SET_PERIODIC_ADV_PROP_INC_TX_PWR;
-    } else {
+    }
+    else
+    {
         cmd.props = 0;
     }
 
@@ -3657,44 +3960,50 @@ ble_gap_periodic_adv_params_tx(uint8_t instance,
 
 static int
 ble_gap_periodic_adv_params_validate(
-        const struct ble_gap_periodic_adv_params *params)
+    const struct ble_gap_periodic_adv_params *params)
 {
-    if (!params) {
+    if (!params)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (params->itvl_min && params->itvl_min < 6) {
+    if (params->itvl_min && params->itvl_min < 6)
+    {
         return BLE_HS_EINVAL;
     }
-    if (params->itvl_max && params->itvl_max < 6) {
-            return BLE_HS_EINVAL;
+    if (params->itvl_max && params->itvl_max < 6)
+    {
+        return BLE_HS_EINVAL;
     }
     return 0;
 }
 
-int
-ble_gap_periodic_adv_configure(uint8_t instance,
-        const struct ble_gap_periodic_adv_params *params)
+int ble_gap_periodic_adv_configure(uint8_t instance,
+                                   const struct ble_gap_periodic_adv_params *params)
 {
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     rc = ble_gap_periodic_adv_params_validate(params);
-    if (rc) {
+    if (rc)
+    {
         return rc;
     }
 
     ble_hs_lock();
 
     /* The corresponding extended advertising instance should be configured */
-    if (!ble_gap_slave[instance].configured) {
+    if (!ble_gap_slave[instance].configured)
+    {
         ble_hs_unlock();
         return ENOMEM;
     }
@@ -3703,13 +4012,15 @@ ble_gap_periodic_adv_configure(uint8_t instance,
      * running.
      * Bluetooth Core Specification, Section 7.8.61
      */
-    if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV) {
+    if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV)
+    {
         ble_hs_unlock();
         return BLE_HS_EINVAL;
     }
 
     rc = ble_gap_periodic_adv_params_tx(instance, params);
-    if (rc) {
+    if (rc)
+    {
         ble_hs_unlock();
         return rc;
     }
@@ -3721,25 +4032,27 @@ ble_gap_periodic_adv_configure(uint8_t instance,
     return 0;
 }
 
-int
-ble_gap_periodic_adv_start(uint8_t instance, const struct ble_gap_periodic_adv_start_params *params)
+int ble_gap_periodic_adv_start(uint8_t instance, const struct ble_gap_periodic_adv_start_params *params)
 {
     struct ble_hci_le_set_periodic_adv_enable_cp cmd;
     uint16_t opcode;
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
     /* Periodic advertising cannot start unless it is configured before */
-    if (!ble_gap_slave[instance].periodic_configured) {
+    if (!ble_gap_slave[instance].periodic_configured)
+    {
         ble_hs_unlock();
         return BLE_HS_EINVAL;
     }
@@ -3749,14 +4062,16 @@ ble_gap_periodic_adv_start(uint8_t instance, const struct ble_gap_periodic_adv_s
     cmd.enable = 0x01;
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-    if (params && params->include_adi) {
+    if (params && params->include_adi)
+    {
         SET_BIT(cmd.enable, 1);
     }
 #endif
     cmd.adv_handle = instance;
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_hs_unlock();
         return rc;
     }
@@ -3772,7 +4087,7 @@ static int
 ble_gap_periodic_adv_update_did(uint8_t instance)
 {
     static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp)];
-    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
+    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *)buf;
     uint16_t opcode;
 
     memset(buf, 0, sizeof(buf));
@@ -3795,11 +4110,12 @@ ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
 #if MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE) <= BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN
     static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp) +
                        MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE)];
-    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
+    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *)buf;
     uint16_t len = 0;
     uint16_t opcode;
 
-    if (*data) {
+    if (*data)
+    {
         len = OS_MBUF_PKTLEN(*data);
     }
 
@@ -3809,7 +4125,8 @@ ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
     cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
     cmd->adv_data_len = len;
 
-    if (len) {
+    if (len)
+    {
         os_mbuf_copydata(*data, 0, len, cmd->adv_data);
 
         os_mbuf_adj(*data, len);
@@ -3821,13 +4138,14 @@ ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
 #else
     static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp) +
                        BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN];
-    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
+    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *)buf;
     uint16_t len = 0;
     uint16_t opcode;
     uint8_t op;
     int rc;
 
-    if (*data) {
+    if (*data)
+    {
         len = OS_MBUF_PKTLEN(*data);
     }
 
@@ -3835,11 +4153,13 @@ ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
     cmd->adv_handle = instance;
 
     /* Complete data */
-    if (len <= BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN) {
+    if (len <= BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN)
+    {
         cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
         cmd->adv_data_len = len;
 
-        if (len) {
+        if (len)
+        {
             os_mbuf_copydata(*data, 0, len, cmd->adv_data);
 
             os_mbuf_adj(*data, len);
@@ -3854,14 +4174,16 @@ ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
      * the op code shall be nothing but 0x03
      * Bluetooth Core Specification, section 7.8.62
      */
-    if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV) {
+    if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV)
+    {
         return BLE_HS_EINVAL;
     }
 
     /* First fragment  */
     op = BLE_HCI_LE_SET_DATA_OPER_FIRST;
 
-    do{
+    do
+    {
         cmd->operation = op;
         cmd->adv_data_len = BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN;
         os_mbuf_copydata(*data, 0, BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN,
@@ -3872,7 +4194,8 @@ ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
 
         rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
                                NULL, 0);
-        if (rc) {
+        if (rc)
+        {
             return rc;
         }
 
@@ -3898,11 +4221,13 @@ ble_gap_periodic_adv_set_data_validate(uint8_t instance,
                                        struct os_mbuf *data)
 {
     /* The corresponding extended advertising instance should be configured */
-    if (!ble_gap_slave[instance].configured) {
+    if (!ble_gap_slave[instance].configured)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (ble_gap_slave[instance].legacy_pdu) {
+    if (ble_gap_slave[instance].legacy_pdu)
+    {
         return BLE_HS_EINVAL;
     }
 
@@ -3915,25 +4240,27 @@ ble_gap_periodic_adv_set_data_validate(uint8_t instance,
     return 0;
 }
 
-int
-ble_gap_periodic_adv_set_data(uint8_t instance,
-                              struct os_mbuf *data,
-                              const struct ble_gap_periodic_adv_set_data_params *params)
+int ble_gap_periodic_adv_set_data(uint8_t instance,
+                                  struct os_mbuf *data,
+                                  const struct ble_gap_periodic_adv_set_data_params *params)
 {
     int rc;
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         rc = BLE_HS_EINVAL;
         goto done;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         rc = BLE_HS_EDISABLED;
         goto done;
     }
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
     /* update_did and data cannot be set at the same time */
-    if (params && params->update_did && data) {
+    if (params && params->update_did && data)
+    {
         rc = BLE_HS_EINVAL;
         goto done;
     }
@@ -3942,15 +4269,19 @@ ble_gap_periodic_adv_set_data(uint8_t instance,
     ble_hs_lock();
 
     rc = ble_gap_periodic_adv_set_data_validate(instance, data);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_hs_unlock();
         goto done;
     }
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-    if (params && params->update_did) {
+    if (params && params->update_did)
+    {
         rc = ble_gap_periodic_adv_update_did(instance);
-    } else {
+    }
+    else
+    {
         rc = ble_gap_periodic_adv_set(instance, &data);
     }
 #else
@@ -3977,7 +4308,8 @@ ble_gap_periodic_adv_stop_no_lock(uint8_t instance)
     opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE);
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -3986,16 +4318,17 @@ ble_gap_periodic_adv_stop_no_lock(uint8_t instance)
     return 0;
 }
 
-int
-ble_gap_periodic_adv_stop(uint8_t instance)
+int ble_gap_periodic_adv_stop(uint8_t instance)
 {
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -4029,64 +4362,74 @@ ble_gap_npl_sync_lost(struct ble_npl_event *ev)
     ble_hs_periodic_sync_free(psync);
 
     ble_gap_event_listener_call(&event);
-    if (cb) {
+    if (cb)
+    {
         cb(&event, cb_arg);
     }
 }
 
-int
-ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
-                                 const struct ble_gap_periodic_sync_params *params,
-                                 ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
+                                     const struct ble_gap_periodic_sync_params *params,
+                                     ble_gap_event_fn *cb, void *cb_arg)
 {
     struct ble_hci_le_periodic_adv_create_sync_cp cmd;
     struct ble_hs_periodic_sync *psync;
     uint16_t opcode;
     int rc;
 
-    if (addr && (addr->type > BLE_ADDR_RANDOM)) {
+    if (addr && (addr->type > BLE_ADDR_RANDOM))
+    {
         return BLE_HS_EINVAL;
     }
-    if (adv_sid > 0x0f) {
+    if (adv_sid > 0x0f)
+    {
         return BLE_HS_EINVAL;
     }
     if ((params->skip > 0x1f3) || (params->sync_timeout > 0x4000) ||
-            (params->sync_timeout < 0x0A)) {
+        (params->sync_timeout < 0x0A))
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
     /* No sync can be created if another sync is still pending */
-    if (ble_gap_sync.op == BLE_GAP_OP_SYNC) {
+    if (ble_gap_sync.op == BLE_GAP_OP_SYNC)
+    {
         ble_hs_unlock();
         return BLE_HS_EBUSY;
     }
 
     /* cannot create another sync if already synchronized */
-    if (ble_hs_periodic_sync_find(addr, adv_sid)) {
+    if (ble_hs_periodic_sync_find(addr, adv_sid))
+    {
         ble_hs_unlock();
         return BLE_HS_EALREADY;
     }
 
     /* preallocate sync element */
     psync = ble_hs_periodic_sync_alloc();
-    if (!psync) {
+    if (!psync)
+    {
         ble_hs_unlock();
         return BLE_HS_ENOMEM;
     }
 
     ble_npl_event_init(&psync->lost_ev, ble_gap_npl_sync_lost, psync);
 
-    if (addr) {
+    if (addr)
+    {
         cmd.options = 0x00;
         cmd.peer_addr_type = addr->type;
         memcpy(cmd.peer_addr, addr->val, BLE_DEV_ADDR_LEN);
-    } else {
+    }
+    else
+    {
         cmd.options = 0x01;
         cmd.peer_addr_type = BLE_ADDR_ANY->type;
         memcpy(cmd.peer_addr, BLE_ADDR_ANY->val, BLE_DEV_ADDR_LEN);
@@ -4094,10 +4437,12 @@ ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
     /* LE Periodic Advertising Create Sync command */
-    if (params->reports_disabled) {
+    if (params->reports_disabled)
+    {
         SET_BIT(cmd.options, 1);
     }
-    if (params->filter_duplicates) {
+    if (params->filter_duplicates)
+    {
         SET_BIT(cmd.options, 2);
     }
 #endif
@@ -4108,7 +4453,8 @@ ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
 
     opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC);
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (!rc) {
+    if (!rc)
+    {
         /* This shall be reset upon receiving sync_established event,
          * or if the sync is cancelled before receiving that event.
          */
@@ -4116,7 +4462,9 @@ ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
         ble_gap_sync.cb = cb;
         ble_gap_sync.cb_arg = cb_arg;
         ble_gap_sync.psync = psync;
-    } else {
+    }
+    else
+    {
         ble_hs_periodic_sync_free(psync);
     }
 
@@ -4125,15 +4473,15 @@ ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
     return rc;
 }
 
-int
-ble_gap_periodic_adv_sync_create_cancel(void)
+int ble_gap_periodic_adv_sync_create_cancel(void)
 {
     uint16_t opcode;
     int rc = 0;
 
     ble_hs_lock();
 
-    if (ble_gap_sync.op != BLE_GAP_OP_SYNC) {
+    if (ble_gap_sync.op != BLE_GAP_OP_SYNC)
+    {
         ble_hs_unlock();
         return BLE_HS_EBUSY;
     }
@@ -4148,21 +4496,22 @@ ble_gap_periodic_adv_sync_create_cancel(void)
     return rc;
 }
 
-int
-ble_gap_periodic_adv_sync_terminate(uint16_t sync_handle)
+int ble_gap_periodic_adv_sync_terminate(uint16_t sync_handle)
 {
     struct ble_hci_le_periodic_adv_term_sync_cp cmd;
     struct ble_hs_periodic_sync *psync;
     uint16_t opcode;
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
-    if (ble_gap_sync.op == BLE_GAP_OP_SYNC) {
+    if (ble_gap_sync.op == BLE_GAP_OP_SYNC)
+    {
         ble_hs_unlock();
         return BLE_HS_EBUSY;
     }
@@ -4172,7 +4521,8 @@ ble_gap_periodic_adv_sync_terminate(uint16_t sync_handle)
      * the app wants to terminate that sync handle
      */
     psync = ble_hs_periodic_sync_find_by_handle(sync_handle);
-    if (!psync) {
+    if (!psync)
+    {
         /* Sync already terminated.*/
         ble_hs_unlock();
         return BLE_HS_ENOTCONN;
@@ -4183,7 +4533,8 @@ ble_gap_periodic_adv_sync_terminate(uint16_t sync_handle)
     cmd.sync_handle = htole16(sync_handle);
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (rc == 0) {
+    if (rc == 0)
+    {
         /* Remove the handle from the list */
         ble_hs_periodic_sync_remove(psync);
 
@@ -4199,29 +4550,31 @@ ble_gap_periodic_adv_sync_terminate(uint16_t sync_handle)
 }
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_TRANSFER)
 /* LE Set Periodic Advertising Receive Enable command */
-int
-ble_gap_periodic_adv_sync_reporting(uint16_t sync_handle,
-                                    bool enable,
-                                    const struct ble_gap_periodic_adv_sync_reporting_params *params)
+int ble_gap_periodic_adv_sync_reporting(uint16_t sync_handle,
+                                        bool enable,
+                                        const struct ble_gap_periodic_adv_sync_reporting_params *params)
 {
     struct ble_hci_le_periodic_adv_receive_enable_cp cmd;
     struct ble_hs_periodic_sync *psync;
     uint16_t opcode;
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
-    if (ble_gap_sync.op == BLE_GAP_OP_SYNC) {
+    if (ble_gap_sync.op == BLE_GAP_OP_SYNC)
+    {
         ble_hs_unlock();
         return BLE_HS_EBUSY;
     }
 
     psync = ble_hs_periodic_sync_find_by_handle(sync_handle);
-    if (!psync) {
+    if (!psync)
+    {
         ble_hs_unlock();
         return BLE_HS_ENOTCONN;
     }
@@ -4231,7 +4584,8 @@ ble_gap_periodic_adv_sync_reporting(uint16_t sync_handle,
     cmd.sync_handle = htole16(sync_handle);
     cmd.enable = enable ? 0x01 : 0x00;
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-    if (params && params->filter_duplicates) {
+    if (params && params->filter_duplicates)
+    {
         SET_BIT(cmd.enable, 1);
     }
 #endif
@@ -4243,9 +4597,8 @@ ble_gap_periodic_adv_sync_reporting(uint16_t sync_handle,
     return rc;
 }
 
-int
-ble_gap_periodic_adv_sync_transfer(uint16_t sync_handle, uint16_t conn_handle,
-                                   uint16_t service_data)
+int ble_gap_periodic_adv_sync_transfer(uint16_t sync_handle, uint16_t conn_handle,
+                                       uint16_t service_data)
 {
     struct ble_hci_le_periodic_adv_sync_transfer_cp cmd;
     struct ble_hci_le_periodic_adv_sync_transfer_rp rsp;
@@ -4254,20 +4607,23 @@ ble_gap_periodic_adv_sync_transfer(uint16_t sync_handle, uint16_t conn_handle,
     uint16_t opcode;
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
     conn = ble_hs_conn_find(conn_handle);
-    if (!conn) {
+    if (!conn)
+    {
         ble_hs_unlock();
         return BLE_HS_ENOTCONN;
     }
 
     psync = ble_hs_periodic_sync_find_by_handle(sync_handle);
-    if (!psync) {
+    if (!psync)
+    {
         ble_hs_unlock();
         return BLE_HS_ENOTCONN;
     }
@@ -4279,7 +4635,8 @@ ble_gap_periodic_adv_sync_transfer(uint16_t sync_handle, uint16_t conn_handle,
     cmd.service_data = htole16(service_data);
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (!rc) {
+    if (!rc)
+    {
         BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
     }
 
@@ -4288,9 +4645,8 @@ ble_gap_periodic_adv_sync_transfer(uint16_t sync_handle, uint16_t conn_handle,
     return rc;
 }
 
-int
-ble_gap_periodic_adv_sync_set_info(uint8_t instance, uint16_t conn_handle,
-                                   uint16_t service_data)
+int ble_gap_periodic_adv_sync_set_info(uint8_t instance, uint16_t conn_handle,
+                                       uint16_t service_data)
 {
     struct ble_hci_le_periodic_adv_set_info_transfer_cp cmd;
     struct ble_hci_le_periodic_adv_set_info_transfer_rp rsp;
@@ -4298,23 +4654,27 @@ ble_gap_periodic_adv_sync_set_info(uint8_t instance, uint16_t conn_handle,
     uint16_t opcode;
     int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
+    if (instance >= BLE_ADV_INSTANCES)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
-    if (ble_gap_slave[instance].periodic_op != BLE_GAP_OP_S_PERIODIC_ADV) {
+    if (ble_gap_slave[instance].periodic_op != BLE_GAP_OP_S_PERIODIC_ADV)
+    {
         /* periodic adv not enabled */
         ble_hs_unlock();
         return BLE_HS_EINVAL;
     }
 
     conn = ble_hs_conn_find(conn_handle);
-    if (!conn) {
+    if (!conn)
+    {
         ble_hs_unlock();
         return BLE_HS_ENOTCONN;
     }
@@ -4326,7 +4686,8 @@ ble_gap_periodic_adv_sync_set_info(uint8_t instance, uint16_t conn_handle,
     cmd.service_data = htole16(service_data);
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (!rc) {
+    if (!rc)
+    {
         BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
     }
 
@@ -4349,12 +4710,14 @@ periodic_adv_transfer_enable(uint16_t conn_handle,
     memset(&cmd, 0, sizeof(cmd));
     cmd.conn_handle = htole16(conn_handle);
 
-    if (params != NULL) {
+    if (params != NULL)
+    {
         cmd.sync_cte_type = 0x00;
         cmd.mode = params->reports_disabled ? 0x01 : 0x02;
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-        if (!params->reports_disabled && params->filter_duplicates) {
+        if (!params->reports_disabled && params->filter_duplicates)
+        {
             cmd.mode = 0x03;
         }
 #endif
@@ -4364,20 +4727,21 @@ periodic_adv_transfer_enable(uint16_t conn_handle,
     }
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (!rc) {
+    if (!rc)
+    {
         BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
     }
 
     return rc;
 }
 
-int
-periodic_adv_set_default_sync_params(const struct ble_gap_periodic_sync_params *params)
+int periodic_adv_set_default_sync_params(const struct ble_gap_periodic_sync_params *params)
 {
     struct ble_hci_le_set_default_periodic_sync_transfer_params_cp cmd;
     uint16_t opcode;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -4385,12 +4749,14 @@ periodic_adv_set_default_sync_params(const struct ble_gap_periodic_sync_params *
 
     memset(&cmd, 0, sizeof(cmd));
 
-    if (params != NULL) {
+    if (params != NULL)
+    {
         cmd.sync_cte_type = 0x00;
         cmd.mode = params->reports_disabled ? 0x01 : 0x02;
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-        if (!params->reports_disabled && params->filter_duplicates) {
+        if (!params->reports_disabled && params->filter_duplicates)
+        {
             cmd.mode = 0x03;
         }
 #endif
@@ -4402,56 +4768,67 @@ periodic_adv_set_default_sync_params(const struct ble_gap_periodic_sync_params *
     return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-int
-ble_gap_periodic_adv_sync_receive(uint16_t conn_handle,
-                                  const struct ble_gap_periodic_sync_params *params,
-                                  ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_periodic_adv_sync_receive(uint16_t conn_handle,
+                                      const struct ble_gap_periodic_sync_params *params,
+                                      ble_gap_event_fn *cb, void *cb_arg)
 {
     struct ble_hs_conn *conn;
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
     conn = ble_hs_conn_find(conn_handle);
-    if (!conn) {
+    if (!conn)
+    {
         ble_hs_unlock();
         return BLE_HS_ENOTCONN;
     }
 
-    if (params) {
-        if (conn->psync) {
+    if (params)
+    {
+        if (conn->psync)
+        {
             ble_hs_unlock();
             return BLE_HS_EALREADY;
         }
 
         conn->psync = ble_hs_periodic_sync_alloc();
-        if (!conn->psync) {
+        if (!conn->psync)
+        {
             ble_hs_unlock();
             return BLE_HS_ENOMEM;
         }
 
         rc = periodic_adv_transfer_enable(conn_handle, params);
-        if (rc) {
+        if (rc)
+        {
             ble_hs_periodic_sync_free(conn->psync);
             conn->psync = NULL;
-        } else {
+        }
+        else
+        {
             conn->psync->cb = cb;
             conn->psync->cb_arg = cb_arg;
             ble_npl_event_init(&conn->psync->lost_ev, ble_gap_npl_sync_lost,
                                conn->psync);
         }
-    } else {
-        if (!conn->psync) {
+    }
+    else
+    {
+        if (!conn->psync)
+        {
             ble_hs_unlock();
             return BLE_HS_EALREADY;
         }
 
         rc = periodic_adv_transfer_disable(conn_handle);
-        if (!rc) {
+        if (!rc)
+        {
             ble_hs_periodic_sync_free(conn->psync);
             conn->psync = NULL;
         }
@@ -4463,18 +4840,19 @@ ble_gap_periodic_adv_sync_receive(uint16_t conn_handle,
 }
 #endif
 
-int
-ble_gap_add_dev_to_periodic_adv_list(const ble_addr_t *peer_addr,
-                                     uint8_t adv_sid)
+int ble_gap_add_dev_to_periodic_adv_list(const ble_addr_t *peer_addr,
+                                         uint8_t adv_sid)
 {
     struct ble_hci_le_add_dev_to_periodic_adv_list_cp cmd;
     uint16_t opcode;
 
-    if ((peer_addr->type > BLE_ADDR_RANDOM) || (adv_sid > 0x0f)) {
+    if ((peer_addr->type > BLE_ADDR_RANDOM) || (adv_sid > 0x0f))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -4488,17 +4866,18 @@ ble_gap_add_dev_to_periodic_adv_list(const ble_addr_t *peer_addr,
     return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-int
-ble_gap_rem_dev_from_periodic_adv_list(const ble_addr_t *peer_addr, uint8_t adv_sid)
+int ble_gap_rem_dev_from_periodic_adv_list(const ble_addr_t *peer_addr, uint8_t adv_sid)
 {
     struct ble_hci_le_rem_dev_from_periodic_adv_list_cp cmd;
     uint16_t opcode;
 
-    if ((peer_addr->type > BLE_ADDR_RANDOM) || (adv_sid > 0x0f)) {
+    if ((peer_addr->type > BLE_ADDR_RANDOM) || (adv_sid > 0x0f))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -4512,8 +4891,7 @@ ble_gap_rem_dev_from_periodic_adv_list(const ble_addr_t *peer_addr, uint8_t adv_
     return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-int
-ble_gap_clear_periodic_adv_list(void)
+int ble_gap_clear_periodic_adv_list(void)
 {
     uint16_t opcode;
     int rc = 0;
@@ -4525,8 +4903,7 @@ ble_gap_clear_periodic_adv_list(void)
     return rc;
 }
 
-int
-ble_gap_read_periodic_adv_list_size(uint8_t *per_adv_list_size)
+int ble_gap_read_periodic_adv_list_size(uint8_t *per_adv_list_size)
 {
     struct ble_hci_le_rd_periodic_adv_list_size_rp rsp;
     uint16_t opcode;
@@ -4535,7 +4912,8 @@ ble_gap_read_periodic_adv_list_size(uint8_t *per_adv_list_size)
     opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE);
 
     rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, &rsp, sizeof(rsp));
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -4552,8 +4930,8 @@ ble_gap_read_periodic_adv_list_size(uint8_t *per_adv_list_size)
 #if MYNEWT_VAL(BLE_EXT_ADV) && NIMBLE_BLE_SCAN
 static int
 ble_gap_ext_disc_tx_params(uint8_t own_addr_type, uint8_t filter_policy,
-                       const struct ble_hs_hci_ext_scan_param *uncoded_params,
-                       const struct ble_hs_hci_ext_scan_param *coded_params)
+                           const struct ble_hs_hci_ext_scan_param *uncoded_params,
+                           const struct ble_hs_hci_ext_scan_param *coded_params)
 {
     struct ble_hci_le_set_ext_scan_params_cp *cmd;
     struct scan_params *params;
@@ -4561,23 +4939,26 @@ ble_gap_ext_disc_tx_params(uint8_t own_addr_type, uint8_t filter_policy,
     uint8_t len = sizeof(*cmd);
 
     /* Check own addr type */
-    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX)
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
     /* Check scanner filter policy */
-    if (filter_policy > BLE_HCI_SCAN_FILT_MAX) {
+    if (filter_policy > BLE_HCI_SCAN_FILT_MAX)
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    cmd = (void *) buf;
+    cmd = (void *)buf;
     params = cmd->scans;
 
     cmd->filter_policy = filter_policy;
     cmd->own_addr_type = own_addr_type;
     cmd->phys = 0;
 
-    if (uncoded_params) {
+    if (uncoded_params)
+    {
         cmd->phys |= BLE_HCI_LE_PHY_1M_PREF_MASK;
 
         params->type = uncoded_params->scan_type;
@@ -4588,7 +4969,8 @@ ble_gap_ext_disc_tx_params(uint8_t own_addr_type, uint8_t filter_policy,
         params++;
     }
 
-    if (coded_params) {
+    if (coded_params)
+    {
         cmd->phys |= BLE_HCI_LE_PHY_CODED_PREF_MASK;
 
         params->type = coded_params->scan_type;
@@ -4599,7 +4981,8 @@ ble_gap_ext_disc_tx_params(uint8_t own_addr_type, uint8_t filter_policy,
         params++;
     }
 
-    if (!cmd->phys) {
+    if (!cmd->phys)
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -4648,9 +5031,12 @@ ble_gap_disc_tx_params(uint8_t own_addr_type,
     struct ble_hci_le_set_scan_params_cp cmd;
     uint16_t opcode;
 
-    if (disc_params->passive) {
+    if (disc_params->passive)
+    {
         cmd.scan_type = BLE_HCI_SCAN_TYPE_PASSIVE;
-    } else {
+    }
+    else
+    {
         cmd.scan_type = BLE_HCI_SCAN_TYPE_ACTIVE;
     }
 
@@ -4682,20 +5068,23 @@ ble_gap_disc_cancel_no_lock(void)
 
     STATS_INC(ble_gap_stats, discover_cancel);
 
-    if (!ble_gap_disc_active()) {
+    if (!ble_gap_disc_active())
+    {
         rc = BLE_HS_EALREADY;
         goto done;
     }
 
     rc = ble_gap_disc_disable_tx();
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
     ble_gap_master_reset_state();
 
 done:
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, discover_cancel_fail);
     }
 
@@ -4703,13 +5092,13 @@ done:
 }
 #endif
 
-int
-ble_gap_disc_cancel(void)
+int ble_gap_disc_cancel(void)
 {
 #if NIMBLE_BLE_SCAN
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -4727,23 +5116,28 @@ ble_gap_disc_cancel(void)
 static int
 ble_gap_disc_ext_validate(uint8_t own_addr_type)
 {
-    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX)
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (ble_gap_conn_active()) {
+    if (ble_gap_conn_active())
+    {
         return BLE_HS_EBUSY;
     }
 
-    if (ble_gap_disc_active()) {
+    if (ble_gap_disc_active())
+    {
         return BLE_HS_EALREADY;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
-    if (ble_gap_is_preempted()) {
+    if (ble_gap_is_preempted())
+    {
         return BLE_HS_EPREEMPTED;
     }
 
@@ -4756,18 +5150,26 @@ static void
 ble_gap_ext_disc_fill_dflts(uint8_t limited,
                             struct ble_hs_hci_ext_scan_param *disc_params)
 {
-   if (disc_params->scan_itvl == 0) {
-        if (limited) {
+    if (disc_params->scan_itvl == 0)
+    {
+        if (limited)
+        {
             disc_params->scan_itvl = BLE_GAP_LIM_DISC_SCAN_INT;
-        } else {
+        }
+        else
+        {
             disc_params->scan_itvl = BLE_GAP_SCAN_FAST_INTERVAL_MIN;
         }
     }
 
-    if (disc_params->scan_window == 0) {
-        if (limited) {
+    if (disc_params->scan_window == 0)
+    {
+        if (limited)
+        {
             disc_params->scan_window = BLE_GAP_LIM_DISC_SCAN_WINDOW;
-        } else {
+        }
+        else
+        {
             disc_params->scan_window = BLE_GAP_SCAN_FAST_WINDOW;
         }
     }
@@ -4780,9 +5182,12 @@ ble_gap_ext_scan_params_to_hci(const struct ble_gap_ext_disc_params *params,
 
     memset(hci_params, 0, sizeof(*hci_params));
 
-    if (params->passive) {
-        hci_params->scan_type =  BLE_HCI_SCAN_TYPE_PASSIVE;
-    } else {
+    if (params->passive)
+    {
+        hci_params->scan_type = BLE_HCI_SCAN_TYPE_PASSIVE;
+    }
+    else
+    {
         hci_params->scan_type = BLE_HCI_SCAN_TYPE_ACTIVE;
     }
 
@@ -4791,13 +5196,12 @@ ble_gap_ext_scan_params_to_hci(const struct ble_gap_ext_disc_params *params,
 }
 #endif
 
-int
-ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
-                 uint8_t filter_duplicates, uint8_t filter_policy,
-                 uint8_t limited,
-                 const struct ble_gap_ext_disc_params *uncoded_params,
-                 const struct ble_gap_ext_disc_params *coded_params,
-                 ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
+                     uint8_t filter_duplicates, uint8_t filter_policy,
+                     uint8_t limited,
+                     const struct ble_gap_ext_disc_params *uncoded_params,
+                     const struct ble_gap_ext_disc_params *coded_params,
+                     ble_gap_event_fn *cb, void *cb_arg)
 {
 #if NIMBLE_BLE_SCAN && MYNEWT_VAL(BLE_EXT_ADV)
     struct ble_hs_hci_ext_scan_param ucp;
@@ -4806,14 +5210,16 @@ ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
 
     STATS_INC(ble_gap_stats, discover);
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
     rc = ble_gap_disc_ext_validate(own_addr_type);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
@@ -4821,27 +5227,33 @@ ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
      * defaults.
      */
 
-    if (uncoded_params) {
+    if (uncoded_params)
+    {
         ble_gap_ext_scan_params_to_hci(uncoded_params, &ucp);
         ble_gap_ext_disc_fill_dflts(limited, &ucp);
 
         /* XXX: We should do it only once */
-        if (!uncoded_params->passive) {
+        if (!uncoded_params->passive)
+        {
             rc = ble_hs_id_use_addr(own_addr_type);
-            if (rc != 0) {
+            if (rc != 0)
+            {
                 goto done;
             }
         }
     }
 
-    if (coded_params) {
+    if (coded_params)
+    {
         ble_gap_ext_scan_params_to_hci(coded_params, &cp);
         ble_gap_ext_disc_fill_dflts(limited, &cp);
 
         /* XXX: We should do it only once */
-        if (!coded_params->passive) {
+        if (!coded_params->passive)
+        {
             rc = ble_hs_id_use_addr(own_addr_type);
-            if (rc != 0) {
+            if (rc != 0)
+            {
                 goto done;
             }
         }
@@ -4854,7 +5266,8 @@ ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
     rc = ble_gap_ext_disc_tx_params(own_addr_type, filter_policy,
                                     uncoded_params ? &ucp : NULL,
                                     coded_params ? &cp : NULL);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
@@ -4862,7 +5275,8 @@ ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
     ble_gap_master.legacy_discovery = 0;
 
     rc = ble_gap_ext_disc_enable_tx(1, filter_duplicates, duration, period);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_gap_master_reset_state();
         goto done;
     }
@@ -4872,7 +5286,8 @@ ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
 done:
     ble_hs_unlock();
 
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, discover_fail);
     }
     return rc;
@@ -4885,18 +5300,26 @@ done:
 static void
 ble_gap_disc_fill_dflts(struct ble_gap_disc_params *disc_params)
 {
-   if (disc_params->itvl == 0) {
-        if (disc_params->limited) {
+    if (disc_params->itvl == 0)
+    {
+        if (disc_params->limited)
+        {
             disc_params->itvl = BLE_GAP_LIM_DISC_SCAN_INT;
-        } else {
+        }
+        else
+        {
             disc_params->itvl = BLE_GAP_SCAN_FAST_INTERVAL_MIN;
         }
     }
 
-    if (disc_params->window == 0) {
-        if (disc_params->limited) {
+    if (disc_params->window == 0)
+    {
+        if (disc_params->limited)
+        {
             disc_params->window = BLE_GAP_LIM_DISC_SCAN_WINDOW;
-        } else {
+        }
+        else
+        {
             disc_params->window = BLE_GAP_SCAN_FAST_WINDOW;
         }
     }
@@ -4906,7 +5329,8 @@ static int
 ble_gap_disc_validate(uint8_t own_addr_type,
                       const struct ble_gap_disc_params *disc_params)
 {
-    if (disc_params == NULL) {
+    if (disc_params == NULL)
+    {
         return BLE_HS_EINVAL;
     }
 
@@ -4915,12 +5339,14 @@ ble_gap_disc_validate(uint8_t own_addr_type,
         (disc_params->itvl > BLE_HCI_SCAN_ITVL_MAX) ||
         (disc_params->window < BLE_HCI_SCAN_WINDOW_MIN) ||
         (disc_params->window > BLE_HCI_SCAN_WINDOW_MAX) ||
-        (disc_params->itvl < disc_params->window)) {
+        (disc_params->itvl < disc_params->window))
+    {
         return BLE_HS_EINVAL;
     }
 
     /* Check scanner filter policy */
-    if (disc_params->filter_policy > BLE_HCI_SCAN_FILT_MAX) {
+    if (disc_params->filter_policy > BLE_HCI_SCAN_FILT_MAX)
+    {
         return BLE_HS_EINVAL;
     }
 
@@ -4928,17 +5354,17 @@ ble_gap_disc_validate(uint8_t own_addr_type,
 }
 #endif
 
-int
-ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
-             const struct ble_gap_disc_params *disc_params,
-             ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
+                 const struct ble_gap_disc_params *disc_params,
+                 ble_gap_event_fn *cb, void *cb_arg)
 {
 #if NIMBLE_BLE_SCAN
 #if MYNEWT_VAL(BLE_EXT_ADV)
     struct ble_gap_ext_disc_params p = {0};
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -4946,13 +5372,16 @@ ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
     p.passive = disc_params->passive;
     p.window = disc_params->window;
 
-    if (duration_ms == BLE_HS_FOREVER) {
+    if (duration_ms == BLE_HS_FOREVER)
+    {
         duration_ms = 0;
-    } else if (duration_ms == 0) {
+    }
+    else if (duration_ms == 0)
+    {
         duration_ms = BLE_GAP_DISC_DUR_DFLT;
     }
 
-    rc = ble_gap_ext_disc(own_addr_type, duration_ms/10, 0,
+    rc = ble_gap_ext_disc(own_addr_type, duration_ms / 10, 0,
                           disc_params->filter_duplicates,
                           disc_params->filter_policy, disc_params->limited,
                           &p, NULL, cb, cb_arg);
@@ -4967,7 +5396,8 @@ ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
 
     STATS_INC(ble_gap_stats, discover);
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -4980,26 +5410,32 @@ ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
     ble_gap_disc_fill_dflts(&params);
 
     rc = ble_gap_disc_validate(own_addr_type, &params);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
-    if (duration_ms == 0) {
+    if (duration_ms == 0)
+    {
         duration_ms = BLE_GAP_DISC_DUR_DFLT;
     }
 
-    if (duration_ms != BLE_HS_FOREVER) {
+    if (duration_ms != BLE_HS_FOREVER)
+    {
         rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             /* Duration too great. */
             rc = BLE_HS_EINVAL;
             goto done;
         }
     }
 
-    if (!params.passive) {
+    if (!params.passive)
+    {
         rc = ble_hs_id_use_addr(own_addr_type);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             goto done;
         }
     }
@@ -5013,19 +5449,22 @@ ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
     BLE_HS_LOG(INFO, "\n");
 
     rc = ble_gap_disc_tx_params(own_addr_type, &params);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
     ble_gap_master.op = BLE_GAP_OP_M_DISC;
 
     rc = ble_gap_disc_enable_tx(1, params.filter_duplicates);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_gap_master_reset_state();
         goto done;
     }
 
-    if (duration_ms != BLE_HS_FOREVER) {
+    if (duration_ms != BLE_HS_FOREVER)
+    {
         ble_gap_master_set_timer(duration_ticks);
     }
 
@@ -5034,7 +5473,8 @@ ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
 done:
     ble_hs_unlock();
 
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, discover_fail);
     }
     return rc;
@@ -5044,8 +5484,7 @@ done:
 #endif
 }
 
-int
-ble_gap_disc_active(void)
+int ble_gap_disc_active(void)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
     /* Assume read is atomic; mutex not necessary. */
@@ -5069,7 +5508,8 @@ ble_gap_conn_create_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 
     cmd.scan_itvl = htole16(params->scan_itvl);
     cmd.scan_window = htole16(params->scan_window);
-    if (peer_addr == NULL) {
+    if (peer_addr == NULL)
+    {
         /* Application wants to connect to any device in the white list.  The
          * peer address type and peer address fields are ignored by the
          * controller; fill them with dummy values.
@@ -5077,7 +5517,9 @@ ble_gap_conn_create_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
         cmd.filter_policy = BLE_HCI_CONN_FILT_USE_WL;
         cmd.peer_addr_type = 0;
         memset(cmd.peer_addr, 0, sizeof(cmd.peer_addr));
-    } else {
+    }
+    else
+    {
         cmd.filter_policy = BLE_HCI_CONN_FILT_NO_WL;
         cmd.peer_addr_type = peer_addr->type;
         memcpy(cmd.peer_addr, peer_addr->val, sizeof(cmd.peer_addr));
@@ -5098,9 +5540,8 @@ ble_gap_conn_create_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 #endif
 
 #if MYNEWT_VAL(BLE_CONN_SUBRATING)
-int
-ble_gap_set_default_subrate(uint16_t subrate_min, uint16_t subrate_max, uint16_t max_latency,
-                            uint16_t cont_num, uint16_t supervision_tmo)
+int ble_gap_set_default_subrate(uint16_t subrate_min, uint16_t subrate_max, uint16_t max_latency,
+                                uint16_t cont_num, uint16_t supervision_tmo)
 {
     struct ble_hci_le_set_default_subrate_cp cmd;
     uint16_t opcode;
@@ -5116,10 +5557,9 @@ ble_gap_set_default_subrate(uint16_t subrate_min, uint16_t subrate_max, uint16_t
     return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-int
-ble_gap_subrate_req(uint16_t conn_handle, uint16_t subrate_min, uint16_t subrate_max,
-                    uint16_t max_latency, uint16_t cont_num,
-                    uint16_t supervision_tmo)
+int ble_gap_subrate_req(uint16_t conn_handle, uint16_t subrate_min, uint16_t subrate_max,
+                        uint16_t max_latency, uint16_t cont_num,
+                        uint16_t supervision_tmo)
 {
     struct ble_hci_le_subrate_req_cp cmd;
     uint16_t opcode;
@@ -5142,41 +5582,48 @@ ble_gap_subrate_req(uint16_t conn_handle, uint16_t subrate_min, uint16_t subrate
 static int
 ble_gap_check_conn_params(uint8_t phy, const struct ble_gap_conn_params *params)
 {
-    if (phy != BLE_HCI_LE_PHY_2M) {
+    if (phy != BLE_HCI_LE_PHY_2M)
+    {
         /* Check scan interval and window */
         if ((params->scan_itvl < BLE_HCI_SCAN_ITVL_MIN) ||
             (params->scan_itvl > BLE_HCI_SCAN_ITVL_MAX) ||
             (params->scan_window < BLE_HCI_SCAN_WINDOW_MIN) ||
             (params->scan_window > BLE_HCI_SCAN_WINDOW_MAX) ||
-            (params->scan_itvl < params->scan_window)) {
+            (params->scan_itvl < params->scan_window))
+        {
             return BLE_ERR_INV_HCI_CMD_PARMS;
         }
     }
-        /* Check connection interval min */
+    /* Check connection interval min */
     if ((params->itvl_min < BLE_HCI_CONN_ITVL_MIN) ||
-        (params->itvl_min > BLE_HCI_CONN_ITVL_MAX)) {
+        (params->itvl_min > BLE_HCI_CONN_ITVL_MAX))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
     /* Check connection interval max */
     if ((params->itvl_max < BLE_HCI_CONN_ITVL_MIN) ||
         (params->itvl_max > BLE_HCI_CONN_ITVL_MAX) ||
-        (params->itvl_max < params->itvl_min)) {
+        (params->itvl_max < params->itvl_min))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
     /* Check connection latency */
-    if (params->latency > BLE_HCI_CONN_LATENCY_MAX) {
+    if (params->latency > BLE_HCI_CONN_LATENCY_MAX)
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
     /* Check supervision timeout */
     if ((params->supervision_timeout < BLE_HCI_CONN_SPVN_TIMEOUT_MIN) ||
-        (params->supervision_timeout > BLE_HCI_CONN_SPVN_TIMEOUT_MAX)) {
+        (params->supervision_timeout > BLE_HCI_CONN_SPVN_TIMEOUT_MAX))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
     /* Check connection event length */
-    if (params->min_ce_len > params->max_ce_len) {
+    if (params->min_ce_len > params->max_ce_len)
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -5197,20 +5644,23 @@ ble_gap_ext_conn_create_tx(
     int rc;
 
     /* Check own addr type */
-    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX)
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
     if (phy_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
                     BLE_HCI_LE_PHY_2M_PREF_MASK |
-                    BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+                    BLE_HCI_LE_PHY_CODED_PREF_MASK))
+    {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    cmd = (void *) buf;
+    cmd = (void *)buf;
     params = cmd->conn_params;
 
-    if (peer_addr == NULL) {
+    if (peer_addr == NULL)
+    {
         /* Application wants to connect to any device in the white list.  The
          * peer address type and peer address fields are ignored by the
          * controller; fill them with dummy values.
@@ -5218,9 +5668,12 @@ ble_gap_ext_conn_create_tx(
         cmd->filter_policy = BLE_HCI_CONN_FILT_USE_WL;
         cmd->peer_addr_type = 0;
         memset(cmd->peer_addr, 0, sizeof(cmd->peer_addr));
-    } else {
+    }
+    else
+    {
         /* Check peer addr type */
-        if (peer_addr->type > BLE_HCI_CONN_PEER_ADDR_MAX) {
+        if (peer_addr->type > BLE_HCI_CONN_PEER_ADDR_MAX)
+        {
             return BLE_ERR_INV_HCI_CMD_PARMS;
         }
 
@@ -5232,9 +5685,11 @@ ble_gap_ext_conn_create_tx(
     cmd->own_addr_type = own_addr_type;
     cmd->init_phy_mask = phy_mask;
 
-    if (phy_mask & BLE_GAP_LE_PHY_1M_MASK) {
+    if (phy_mask & BLE_GAP_LE_PHY_1M_MASK)
+    {
         rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_1M, phy_1m_conn_params);
-        if (rc) {
+        if (rc)
+        {
             return rc;
         }
 
@@ -5251,9 +5706,11 @@ ble_gap_ext_conn_create_tx(
         len += sizeof(*params);
     }
 
-    if (phy_mask & BLE_GAP_LE_PHY_2M_MASK) {
+    if (phy_mask & BLE_GAP_LE_PHY_2M_MASK)
+    {
         rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_2M, phy_2m_conn_params);
-        if (rc) {
+        if (rc)
+        {
             return rc;
         }
 
@@ -5270,9 +5727,11 @@ ble_gap_ext_conn_create_tx(
         len += sizeof(*params);
     }
 
-    if (phy_mask & BLE_GAP_LE_PHY_CODED_MASK) {
+    if (phy_mask & BLE_GAP_LE_PHY_CODED_MASK)
+    {
         rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_CODED, phy_coded_conn_params);
-        if (rc) {
+        if (rc)
+        {
             return rc;
         }
 
@@ -5291,7 +5750,7 @@ ble_gap_ext_conn_create_tx(
 
     return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
                                         BLE_HCI_OCF_LE_EXT_CREATE_CONN),
-                                       cmd, len, NULL, 0);
+                             cmd, len, NULL, 0);
 }
 #endif
 
@@ -5346,13 +5805,12 @@ ble_gap_ext_conn_create_tx(
  *                                  connected;
  *                              Other nonzero on error.
  */
-int
-ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                int32_t duration_ms, uint8_t phy_mask,
-                const struct ble_gap_conn_params *phy_1m_conn_params,
-                const struct ble_gap_conn_params *phy_2m_conn_params,
-                const struct ble_gap_conn_params *phy_coded_conn_params,
-                ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
+                        int32_t duration_ms, uint8_t phy_mask,
+                        const struct ble_gap_conn_params *phy_1m_conn_params,
+                        const struct ble_gap_conn_params *phy_2m_conn_params,
+                        const struct ble_gap_conn_params *phy_coded_conn_params,
+                        ble_gap_event_fn *cb, void *cb_arg)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
     ble_npl_time_t duration_ticks;
@@ -5362,27 +5820,32 @@ ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 
     ble_hs_lock();
 
-    if (ble_gap_conn_active()) {
+    if (ble_gap_conn_active())
+    {
         rc = BLE_HS_EALREADY;
         goto done;
     }
 
-    if (ble_gap_disc_active()) {
+    if (ble_gap_disc_active())
+    {
         rc = BLE_HS_EBUSY;
         goto done;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         rc = BLE_HS_EDISABLED;
         goto done;
     }
 
-    if (ble_gap_is_preempted()) {
+    if (ble_gap_is_preempted())
+    {
         rc = BLE_HS_EPREEMPTED;
         goto done;
     }
 
-    if (!ble_hs_conn_can_alloc()) {
+    if (!ble_hs_conn_can_alloc())
+    {
         rc = BLE_HS_ENOMEM;
         goto done;
     }
@@ -5391,33 +5854,40 @@ ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
         peer_addr->type != BLE_ADDR_PUBLIC &&
         peer_addr->type != BLE_ADDR_RANDOM &&
         peer_addr->type != BLE_ADDR_PUBLIC_ID &&
-        peer_addr->type != BLE_ADDR_RANDOM_ID) {
+        peer_addr->type != BLE_ADDR_RANDOM_ID)
+    {
 
         rc = BLE_HS_EINVAL;
         goto done;
     }
 
-    if ((phy_mask & BLE_GAP_LE_PHY_1M_MASK) && phy_1m_conn_params == NULL) {
+    if ((phy_mask & BLE_GAP_LE_PHY_1M_MASK) && phy_1m_conn_params == NULL)
+    {
         phy_1m_conn_params = &ble_gap_conn_params_dflt;
     }
 
-    if ((phy_mask & BLE_GAP_LE_PHY_2M_MASK) && phy_2m_conn_params == NULL) {
+    if ((phy_mask & BLE_GAP_LE_PHY_2M_MASK) && phy_2m_conn_params == NULL)
+    {
         phy_2m_conn_params = &ble_gap_conn_params_dflt;
     }
 
     if ((phy_mask & BLE_GAP_LE_PHY_CODED_MASK) &&
-        phy_coded_conn_params == NULL) {
+        phy_coded_conn_params == NULL)
+    {
 
         phy_coded_conn_params = &ble_gap_conn_params_dflt;
     }
 
-    if (duration_ms == 0) {
+    if (duration_ms == 0)
+    {
         duration_ms = BLE_GAP_CONN_DUR_DFLT;
     }
 
-    if (duration_ms != BLE_HS_FOREVER) {
+    if (duration_ms != BLE_HS_FOREVER)
+    {
         rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             /* Duration too great. */
             rc = BLE_HS_EINVAL;
             goto done;
@@ -5425,7 +5895,8 @@ ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
     }
 
     /* Verify peer not already connected. */
-    if (ble_hs_conn_find_by_addr(peer_addr) != NULL) {
+    if (ble_hs_conn_find_by_addr(peer_addr) != NULL)
+    {
         rc = BLE_HS_EDONE;
         goto done;
     }
@@ -5433,7 +5904,8 @@ ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
     /* XXX: Verify conn_params. */
 
     rc = ble_hs_id_use_addr(own_addr_type);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
@@ -5447,12 +5919,14 @@ ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
     rc = ble_gap_ext_conn_create_tx(own_addr_type, peer_addr, phy_mask,
                                     phy_1m_conn_params, phy_2m_conn_params,
                                     phy_coded_conn_params);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_gap_master_reset_state();
         goto done;
     }
 
-    if (duration_ms != BLE_HS_FOREVER) {
+    if (duration_ms != BLE_HS_FOREVER)
+    {
         ble_gap_master_set_timer(duration_ticks);
     }
 
@@ -5461,22 +5935,21 @@ ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 done:
     ble_hs_unlock();
 
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, initiate_fail);
     }
     return rc;
 #else
     return BLE_HS_ENOTSUP;
 #endif
-
 }
 #endif
 
-int
-ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                int32_t duration_ms,
-                const struct ble_gap_conn_params *conn_params,
-                ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
+                    int32_t duration_ms,
+                    const struct ble_gap_conn_params *conn_params,
+                    ble_gap_event_fn *cb, void *cb_arg)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
 #if MYNEWT_VAL(BLE_EXT_ADV)
@@ -5491,27 +5964,32 @@ ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 
     ble_hs_lock();
 
-    if (ble_gap_conn_active()) {
+    if (ble_gap_conn_active())
+    {
         rc = BLE_HS_EALREADY;
         goto done;
     }
 
-    if (ble_gap_disc_active()) {
+    if (ble_gap_disc_active())
+    {
         rc = BLE_HS_EBUSY;
         goto done;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         rc = BLE_HS_EDISABLED;
         goto done;
     }
 
-    if (ble_gap_is_preempted()) {
+    if (ble_gap_is_preempted())
+    {
         rc = BLE_HS_EPREEMPTED;
         goto done;
     }
 
-    if (!ble_hs_conn_can_alloc()) {
+    if (!ble_hs_conn_can_alloc())
+    {
         rc = BLE_HS_ENOMEM;
         goto done;
     }
@@ -5520,23 +5998,28 @@ ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
         peer_addr->type != BLE_ADDR_PUBLIC &&
         peer_addr->type != BLE_ADDR_RANDOM &&
         peer_addr->type != BLE_ADDR_PUBLIC_ID &&
-        peer_addr->type != BLE_ADDR_RANDOM_ID) {
+        peer_addr->type != BLE_ADDR_RANDOM_ID)
+    {
 
         rc = BLE_HS_EINVAL;
         goto done;
     }
 
-    if (conn_params == NULL) {
+    if (conn_params == NULL)
+    {
         conn_params = &ble_gap_conn_params_dflt;
     }
 
-    if (duration_ms == 0) {
+    if (duration_ms == 0)
+    {
         duration_ms = BLE_GAP_CONN_DUR_DFLT;
     }
 
-    if (duration_ms != BLE_HS_FOREVER) {
+    if (duration_ms != BLE_HS_FOREVER)
+    {
         rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             /* Duration too great. */
             rc = BLE_HS_EINVAL;
             goto done;
@@ -5544,7 +6027,8 @@ ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
     }
 
     /* Verify peer not already connected. */
-    if (ble_hs_conn_find_by_addr(peer_addr) != NULL) {
+    if (ble_hs_conn_find_by_addr(peer_addr) != NULL)
+    {
         rc = BLE_HS_EDONE;
         goto done;
     }
@@ -5552,7 +6036,8 @@ ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
     /* XXX: Verify conn_params. */
 
     rc = ble_hs_id_use_addr(own_addr_type);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
@@ -5569,12 +6054,14 @@ ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 
     rc = ble_gap_conn_create_tx(own_addr_type, peer_addr,
                                 conn_params);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         ble_gap_master_reset_state();
         goto done;
     }
 
-    if (duration_ms != BLE_HS_FOREVER) {
+    if (duration_ms != BLE_HS_FOREVER)
+    {
         ble_gap_master_set_timer(duration_ticks);
     }
 
@@ -5583,7 +6070,8 @@ ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 done:
     ble_hs_unlock();
 
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, initiate_fail);
     }
     return rc;
@@ -5591,11 +6079,9 @@ done:
 #else
     return BLE_HS_ENOTSUP;
 #endif
-
 }
 
-int
-ble_gap_conn_active(void)
+int ble_gap_conn_active(void)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
     /* Assume read is atomic; mutex not necessary. */
@@ -5608,29 +6094,30 @@ ble_gap_conn_active(void)
 /*****************************************************************************
  * $terminate connection procedure                                           *
  *****************************************************************************/
-int
-ble_gap_terminate_with_conn(struct ble_hs_conn *conn, uint8_t hci_reason)
+int ble_gap_terminate_with_conn(struct ble_hs_conn *conn, uint8_t hci_reason)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hci_lc_disconnect_cp cmd;
     int rc;
 
     BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
-    if (conn->bhc_flags & BLE_HS_CONN_F_TERMINATING) {
+    if (conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)
+    {
         return BLE_HS_EALREADY;
     }
 
     BLE_HS_LOG(INFO, "GAP procedure initiated: terminate connection; "
                      "conn_handle=%d hci_reason=%d\n",
-                     conn->bhc_handle, hci_reason);
+               conn->bhc_handle, hci_reason);
 
     cmd.conn_handle = htole16(conn->bhc_handle);
     cmd.reason = hci_reason;
 
     rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LINK_CTRL,
                                       BLE_HCI_OCF_DISCONNECT_CMD),
-                                      &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
+                           &cmd, sizeof(cmd), NULL, 0);
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -5641,8 +6128,7 @@ ble_gap_terminate_with_conn(struct ble_hs_conn *conn, uint8_t hci_reason)
 #endif
 }
 
-int
-ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
+int ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hs_conn *conn;
@@ -5650,14 +6136,16 @@ ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
 
     STATS_INC(ble_gap_stats, terminate);
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
 
     conn = ble_hs_conn_find(conn_handle);
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         rc = BLE_HS_ENOTCONN;
         goto done;
     }
@@ -5667,7 +6155,8 @@ ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
 done:
     ble_hs_unlock();
 
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, terminate_fail);
     }
     return rc;
@@ -5689,7 +6178,8 @@ ble_gap_conn_cancel_tx(void)
     rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
                                       BLE_HCI_OCF_LE_CREATE_CONN_CANCEL),
                            NULL, 0, NULL, 0);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -5703,7 +6193,8 @@ ble_gap_conn_cancel_no_lock(void)
 
     STATS_INC(ble_gap_stats, cancel);
 
-    if (!ble_gap_conn_active()) {
+    if (!ble_gap_conn_active())
+    {
         rc = BLE_HS_EALREADY;
         goto done;
     }
@@ -5711,7 +6202,8 @@ ble_gap_conn_cancel_no_lock(void)
     BLE_HS_LOG(INFO, "GAP procedure initiated: cancel connection\n");
 
     rc = ble_gap_conn_cancel_tx();
-    if (rc != 0) {
+    if (rc != 0)
+    {
         goto done;
     }
 
@@ -5719,7 +6211,8 @@ ble_gap_conn_cancel_no_lock(void)
     rc = 0;
 
 done:
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, cancel_fail);
     }
 
@@ -5727,13 +6220,13 @@ done:
 }
 #endif
 
-int
-ble_gap_conn_cancel(void)
+int ble_gap_conn_cancel(void)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -5745,7 +6238,6 @@ ble_gap_conn_cancel(void)
 #else
     return BLE_HS_ENOTSUP;
 #endif
-
 }
 
 /*****************************************************************************
@@ -5759,7 +6251,8 @@ ble_gap_update_entry_alloc(void)
     struct ble_gap_update_entry *entry;
 
     entry = os_memblock_get(&ble_gap_update_entry_pool);
-    if (entry != NULL) {
+    if (entry != NULL)
+    {
         memset(entry, 0, sizeof *entry);
     }
 
@@ -5772,7 +6265,8 @@ ble_gap_update_entry_free(struct ble_gap_update_entry *entry)
 {
     int rc;
 
-    if (entry != NULL) {
+    if (entry != NULL)
+    {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
         memset(entry, 0xff, sizeof *entry);
 #endif
@@ -5791,15 +6285,18 @@ ble_gap_update_entry_find(uint16_t conn_handle,
     BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
     prev = NULL;
-    SLIST_FOREACH(entry, &ble_gap_update_entries, next) {
-        if (entry->conn_handle == conn_handle) {
+    SLIST_FOREACH(entry, &ble_gap_update_entries, next)
+    {
+        if (entry->conn_handle == conn_handle)
+        {
             break;
         }
 
         prev = entry;
     }
 
-    if (out_prev != NULL) {
+    if (out_prev != NULL)
+    {
         *out_prev = prev;
     }
 
@@ -5813,10 +6310,14 @@ ble_gap_update_entry_remove(uint16_t conn_handle)
     struct ble_gap_update_entry *prev;
 
     entry = ble_gap_update_entry_find(conn_handle, &prev);
-    if (entry != NULL) {
-        if (prev == NULL) {
+    if (entry != NULL)
+    {
+        if (prev == NULL)
+        {
             SLIST_REMOVE_HEAD(&ble_gap_update_entries, next);
-        } else {
+        }
+        else
+        {
             SLIST_NEXT(prev, next) = SLIST_NEXT(entry, next);
         }
         ble_hs_timer_resched();
@@ -5839,9 +6340,11 @@ ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void *arg)
     entry = ble_gap_update_entry_remove(conn_handle);
     ble_hs_unlock();
 
-    if (entry != NULL) {
+    if (entry != NULL)
+    {
         ble_gap_update_entry_free(entry);
-        if (status != 0) {
+        if (status != 0)
+        {
             ble_gap_update_notify(conn_handle, status);
         }
         /* On success let's wait for the controller to notify about update */
@@ -5877,12 +6380,11 @@ ble_gap_tx_param_neg_reply(uint16_t conn_handle, uint8_t reject_reason)
 
     return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
                                         BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR),
-                                     &cmd, sizeof(cmd), NULL, 0);
+                             &cmd, sizeof(cmd), NULL, 0);
 }
 #endif
 
-void
-ble_gap_rx_param_req(const struct ble_hci_ev_le_subev_rem_conn_param_req *ev)
+void ble_gap_rx_param_req(const struct ble_hci_ev_le_subev_rem_conn_param_req *ev)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_upd_params peer_params;
@@ -5914,12 +6416,16 @@ ble_gap_rx_param_req(const struct ble_hci_ev_le_subev_rem_conn_param_req *ev)
     event.conn_update_req.self_params = &self_params;
     event.conn_update_req.peer_params = &peer_params;
     rc = ble_gap_call_conn_event_cb(&event, conn_handle);
-    if (rc == 0) {
+    if (rc == 0)
+    {
         rc = ble_gap_tx_param_pos_reply(conn_handle, &self_params);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             ble_gap_update_failed(conn_handle, rc);
         }
-    } else {
+    }
+    else
+    {
         ble_gap_tx_param_neg_reply(conn_handle, rc);
     }
 #endif
@@ -5942,7 +6448,7 @@ ble_gap_update_tx(uint16_t conn_handle,
 
     return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
                                         BLE_HCI_OCF_LE_CONN_UPDATE),
-                                        &cmd, sizeof(cmd), NULL, 0);
+                             &cmd, sizeof(cmd), NULL, 0);
 }
 
 static bool
@@ -5950,15 +6456,18 @@ ble_gap_validate_conn_params(const struct ble_gap_upd_params *params)
 {
 
     /* Requirements from Bluetooth spec. v4.2 [Vol 2, Part E], 7.8.18 */
-    if (params->itvl_min > params->itvl_max) {
+    if (params->itvl_min > params->itvl_max)
+    {
         return false;
     }
 
-    if (params->itvl_min < 0x0006 || params->itvl_max > 0x0C80) {
+    if (params->itvl_min < 0x0006 || params->itvl_max > 0x0C80)
+    {
         return false;
     }
 
-    if (params->latency > 0x01F3) {
+    if (params->latency > 0x01F3)
+    {
         return false;
     }
 
@@ -5968,7 +6477,8 @@ ble_gap_validate_conn_params(const struct ble_gap_upd_params *params)
      * supervision_timeout * 10 ms > (1 + latency) * 2 * itvl_max * 1.25ms
      */
     if (params->supervision_timeout <=
-                   (((1 + params->latency) * params->itvl_max) / 4)) {
+        (((1 + params->latency) * params->itvl_max) / 4))
+    {
         return false;
     }
 
@@ -5976,9 +6486,8 @@ ble_gap_validate_conn_params(const struct ble_gap_upd_params *params)
 }
 #endif
 
-int
-ble_gap_update_params(uint16_t conn_handle,
-                      const struct ble_gap_upd_params *params)
+int ble_gap_update_params(uint16_t conn_handle,
+                          const struct ble_gap_upd_params *params)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_l2cap_sig_update_params l2cap_params;
@@ -5991,11 +6500,13 @@ ble_gap_update_params(uint16_t conn_handle,
     l2cap_update = 0;
 
     /* Validate parameters with a spec */
-    if (!ble_gap_validate_conn_params(params)) {
+    if (!ble_gap_validate_conn_params(params))
+    {
         return BLE_HS_EINVAL;
     }
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -6006,20 +6517,23 @@ ble_gap_update_params(uint16_t conn_handle,
     ble_hs_lock();
 
     conn = ble_hs_conn_find(conn_handle);
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         rc = BLE_HS_ENOTCONN;
         goto done;
     }
 
     /* Don't allow two concurrent updates to the same connection. */
     dup = ble_gap_update_entry_find(conn_handle, NULL);
-    if (dup != NULL) {
+    if (dup != NULL)
+    {
         rc = BLE_HS_EALREADY;
         goto done;
     }
 
     entry = ble_gap_update_entry_alloc();
-    if (entry == NULL) {
+    if (entry == NULL)
+    {
         rc = BLE_HS_ENOMEM;
         goto done;
     }
@@ -6039,29 +6553,38 @@ ble_gap_update_params(uint16_t conn_handle,
      * the slave, fail over to the L2CAP update procedure.
      */
     if ((conn->supported_feat & BLE_HS_HCI_LE_FEAT_CONN_PARAM_REQUEST) == 0 &&
-            !(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
+        !(conn->bhc_flags & BLE_HS_CONN_F_MASTER))
+    {
         l2cap_update = 1;
         rc = 0;
-    } else {
+    }
+    else
+    {
         rc = ble_gap_update_tx(conn_handle, params);
     }
 
 done:
     ble_hs_unlock();
 
-    if (!l2cap_update) {
+    if (!l2cap_update)
+    {
         ble_hs_timer_resched();
-    } else {
+    }
+    else
+    {
         ble_gap_update_to_l2cap(params, &l2cap_params);
 
         rc = ble_l2cap_sig_update(conn_handle, &l2cap_params,
-                                              ble_gap_update_l2cap_cb, NULL);
+                                  ble_gap_update_l2cap_cb, NULL);
     }
 
     ble_hs_lock();
-    if (rc == 0) {
+    if (rc == 0)
+    {
         SLIST_INSERT_HEAD(&ble_gap_update_entries, entry, next);
-    } else {
+    }
+    else
+    {
         ble_gap_update_entry_free(entry);
         STATS_INC(ble_gap_stats, update_fail);
     }
@@ -6073,34 +6596,30 @@ done:
 #endif
 }
 
-int
-ble_gap_set_data_len(uint16_t conn_handle, uint16_t tx_octets,
-                     uint16_t tx_time)
+int ble_gap_set_data_len(uint16_t conn_handle, uint16_t tx_octets,
+                         uint16_t tx_time)
 {
     return ble_hs_hci_util_set_data_len(conn_handle, tx_octets, tx_time);
 }
 
-int
-ble_gap_read_sugg_def_data_len(uint16_t *out_sugg_max_tx_octets,
-                               uint16_t *out_sugg_max_tx_time)
+int ble_gap_read_sugg_def_data_len(uint16_t *out_sugg_max_tx_octets,
+                                   uint16_t *out_sugg_max_tx_time)
 {
     return ble_hs_hci_util_read_sugg_def_data_len(out_sugg_max_tx_octets,
                                                   out_sugg_max_tx_time);
 }
 
-int
-ble_gap_write_sugg_def_data_len(uint16_t sugg_max_tx_octets,
-                                uint16_t sugg_max_tx_time)
+int ble_gap_write_sugg_def_data_len(uint16_t sugg_max_tx_octets,
+                                    uint16_t sugg_max_tx_time)
 {
     return ble_hs_hci_util_write_sugg_def_data_len(sugg_max_tx_octets,
                                                    sugg_max_tx_time);
 }
 
 /*****************************************************************************
-* $security                                                                  *
-*****************************************************************************/
-int
-ble_gap_security_initiate(uint16_t conn_handle)
+ * $security                                                                  *
+ *****************************************************************************/
+int ble_gap_security_initiate(uint16_t conn_handle)
 {
 #if NIMBLE_BLE_SM
     struct ble_store_value_sec value_sec;
@@ -6112,13 +6631,15 @@ ble_gap_security_initiate(uint16_t conn_handle)
 
     STATS_INC(ble_gap_stats, security_initiate);
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     ble_hs_lock();
     conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
+    if (conn != NULL)
+    {
         conn_flags = conn->bhc_flags;
         ble_hs_conn_addrs(conn, &addrs);
 
@@ -6127,34 +6648,44 @@ ble_gap_security_initiate(uint16_t conn_handle)
     }
     ble_hs_unlock();
 
-    if (conn == NULL) {
+    if (conn == NULL)
+    {
         rc = BLE_HS_ENOTCONN;
         goto done;
     }
 
-    if (conn_flags & BLE_HS_CONN_F_MASTER) {
+    if (conn_flags & BLE_HS_CONN_F_MASTER)
+    {
         /* Search the security database for an LTK for this peer.  If one
          * is found, perform the encryption procedure rather than the pairing
          * procedure.
          */
         rc = ble_store_read_peer_sec(&key_sec, &value_sec);
-        if (rc == 0 && value_sec.ltk_present) {
+        if (rc == 0 && value_sec.ltk_present)
+        {
             rc = ble_sm_enc_initiate(conn_handle, value_sec.key_size,
                                      value_sec.ltk, value_sec.ediv,
                                      value_sec.rand_num,
                                      value_sec.authenticated);
-            if (rc != 0) {
+            if (rc != 0)
+            {
                 goto done;
             }
-        } else {
+        }
+        else
+        {
             rc = ble_sm_pair_initiate(conn_handle);
-            if (rc != 0) {
+            if (rc != 0)
+            {
                 goto done;
             }
         }
-    } else {
+    }
+    else
+    {
         rc = ble_sm_slave_initiate(conn_handle);
-        if (rc != 0) {
+        if (rc != 0)
+        {
             goto done;
         }
     }
@@ -6162,7 +6693,8 @@ ble_gap_security_initiate(uint16_t conn_handle)
     rc = 0;
 
 done:
-    if (rc != 0) {
+    if (rc != 0)
+    {
         STATS_INC(ble_gap_stats, security_initiate_fail);
     }
 
@@ -6172,12 +6704,12 @@ done:
 #endif
 }
 
-int
-ble_gap_pair_initiate(uint16_t conn_handle)
+int ble_gap_pair_initiate(uint16_t conn_handle)
 {
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -6186,28 +6718,30 @@ ble_gap_pair_initiate(uint16_t conn_handle)
     return rc;
 }
 
-int
-ble_gap_encryption_initiate(uint16_t conn_handle,
-                            uint8_t key_size,
-                            const uint8_t *ltk,
-                            uint16_t ediv,
-                            uint64_t rand_val,
-                            int auth)
+int ble_gap_encryption_initiate(uint16_t conn_handle,
+                                uint8_t key_size,
+                                const uint8_t *ltk,
+                                uint16_t ediv,
+                                uint64_t rand_val,
+                                int auth)
 {
 #if NIMBLE_BLE_SM
     ble_hs_conn_flags_t conn_flags;
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     rc = ble_hs_atomic_conn_flags(conn_handle, &conn_flags);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
-    if (!(conn_flags & BLE_HS_CONN_F_MASTER)) {
+    if (!(conn_flags & BLE_HS_CONN_F_MASTER))
+    {
         return BLE_HS_EROLE;
     }
 
@@ -6219,38 +6753,41 @@ ble_gap_encryption_initiate(uint16_t conn_handle,
 #endif
 }
 
-int
-ble_gap_unpair(const ble_addr_t *peer_addr)
+int ble_gap_unpair(const ble_addr_t *peer_addr)
 {
 #if NIMBLE_BLE_SM
     int rc;
     struct ble_hs_conn *conn;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
-    if (ble_addr_cmp(peer_addr, BLE_ADDR_ANY) == 0) {
+    if (ble_addr_cmp(peer_addr, BLE_ADDR_ANY) == 0)
+    {
         return BLE_HS_EINVAL;
     }
 
     ble_hs_lock();
 
     conn = ble_hs_conn_find_by_addr(peer_addr);
-    if (conn != NULL) {
+    if (conn != NULL)
+    {
         ble_gap_terminate_with_conn(conn, BLE_ERR_REM_USER_CONN_TERM);
     }
 
     ble_hs_unlock();
 
     rc = ble_hs_pvcy_remove_entry(peer_addr->type,
-                             peer_addr->val);
+                                  peer_addr->val);
 
     /* We allow BLE_ERR_UNK_CONN_ID as the IRK of the peer might not be
      * present on the resolving list, but we still should be able to
      * remove that entry.
      */
-    if (rc != 0 && rc != (BLE_HS_ERR_HCI_BASE + BLE_ERR_UNK_CONN_ID)) {
+    if (rc != 0 && rc != (BLE_HS_ERR_HCI_BASE + BLE_ERR_UNK_CONN_ID))
+    {
         return rc;
     }
 
@@ -6260,30 +6797,33 @@ ble_gap_unpair(const ble_addr_t *peer_addr)
 #endif
 }
 
-int
-ble_gap_unpair_oldest_peer(void)
+int ble_gap_unpair_oldest_peer(void)
 {
 #if NIMBLE_BLE_SM
     ble_addr_t oldest_peer_id_addr;
     int num_peers;
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     rc = ble_store_util_bonded_peers(
-            &oldest_peer_id_addr, &num_peers, 1);
-    if (rc != 0) {
+        &oldest_peer_id_addr, &num_peers, 1);
+    if (rc != 0)
+    {
         return rc;
     }
 
-    if (num_peers == 0) {
+    if (num_peers == 0)
+    {
         return BLE_HS_ENOENT;
     }
 
     rc = ble_gap_unpair(&oldest_peer_id_addr);
-    if (rc != 0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -6293,8 +6833,7 @@ ble_gap_unpair_oldest_peer(void)
 #endif
 }
 
-int
-ble_gap_unpair_oldest_except(const ble_addr_t *peer_addr)
+int ble_gap_unpair_oldest_except(const ble_addr_t *peer_addr)
 {
 #if NIMBLE_BLE_SM
 #if MYNEWT_VAL(BLE_STORE_MAX_BONDS)
@@ -6302,27 +6841,33 @@ ble_gap_unpair_oldest_except(const ble_addr_t *peer_addr)
     int num_peers;
     int rc, i;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
     rc = ble_store_util_bonded_peers(
-            &peer_id_addrs[0], &num_peers, MYNEWT_VAL(BLE_STORE_MAX_BONDS));
-    if (rc != 0) {
+        &peer_id_addrs[0], &num_peers, MYNEWT_VAL(BLE_STORE_MAX_BONDS));
+    if (rc != 0)
+    {
         return rc;
     }
 
-    if (num_peers == 0) {
+    if (num_peers == 0)
+    {
         return BLE_HS_ENOENT;
     }
 
-    for (i = 0; i < num_peers; i++) {
-        if (ble_addr_cmp(peer_addr, &peer_id_addrs[i]) != 0) {
+    for (i = 0; i < num_peers; i++)
+    {
+        if (ble_addr_cmp(peer_addr, &peer_id_addrs[i]) != 0)
+        {
             break;
         }
     }
 
-    if (i >= num_peers) {
+    if (i >= num_peers)
+    {
         return BLE_HS_ENOMEM;
     }
 
@@ -6335,9 +6880,8 @@ ble_gap_unpair_oldest_except(const ble_addr_t *peer_addr)
 #endif
 }
 
-void
-ble_gap_passkey_event(uint16_t conn_handle,
-                      struct ble_gap_passkey_params *passkey_params)
+void ble_gap_passkey_event(uint16_t conn_handle,
+                           struct ble_gap_passkey_params *passkey_params)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6353,9 +6897,8 @@ ble_gap_passkey_event(uint16_t conn_handle,
 #endif
 }
 
-void
-ble_gap_enc_event(uint16_t conn_handle, int status,
-                  int security_restored, int bonded)
+void ble_gap_enc_event(uint16_t conn_handle, int status,
+                       int security_restored, int bonded)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6368,14 +6911,16 @@ ble_gap_enc_event(uint16_t conn_handle, int status,
     ble_gap_event_listener_call(&event);
     ble_gap_call_conn_event_cb(&event, conn_handle);
 
-    if (status != 0) {
+    if (status != 0)
+    {
         return;
     }
 
     /* If encryption succeeded and encryption has been restored for bonded device,
      * notify gatt server so it has chance to send notification/indication if needed.
      */
-    if (security_restored) {
+    if (security_restored)
+    {
         ble_gatts_bonding_restored(conn_handle);
         return;
     }
@@ -6384,14 +6929,14 @@ ble_gap_enc_event(uint16_t conn_handle, int status,
      * notify gatt server about that so previous subscriptions (before bonding)
      * can be stored.
      */
-    if (bonded) {
+    if (bonded)
+    {
         ble_gatts_bonding_established(conn_handle);
     }
 #endif
 }
 
-void
-ble_gap_identity_event(uint16_t conn_handle, const ble_addr_t *peer_id_addr)
+void ble_gap_identity_event(uint16_t conn_handle, const ble_addr_t *peer_id_addr)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6406,8 +6951,7 @@ ble_gap_identity_event(uint16_t conn_handle, const ble_addr_t *peer_id_addr)
 #endif
 }
 
-int
-ble_gap_repeat_pairing_event(const struct ble_gap_repeat_pairing *rp)
+int ble_gap_repeat_pairing_event(const struct ble_gap_repeat_pairing *rp)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6423,8 +6967,7 @@ ble_gap_repeat_pairing_event(const struct ble_gap_repeat_pairing *rp)
 #endif
 }
 
-void
-ble_gap_pairing_complete_event(uint16_t conn_handle, int status)
+void ble_gap_pairing_complete_event(uint16_t conn_handle, int status)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6441,12 +6984,12 @@ ble_gap_pairing_complete_event(uint16_t conn_handle, int status)
  * $rssi                                                                     *
  *****************************************************************************/
 
-int
-ble_gap_conn_rssi(uint16_t conn_handle, int8_t *out_rssi)
+int ble_gap_conn_rssi(uint16_t conn_handle, int8_t *out_rssi)
 {
     int rc;
 
-    if (!ble_hs_is_enabled()) {
+    if (!ble_hs_is_enabled())
+    {
         return BLE_HS_EDISABLED;
     }
 
@@ -6458,9 +7001,8 @@ ble_gap_conn_rssi(uint16_t conn_handle, int8_t *out_rssi)
  * $notify                                                                   *
  *****************************************************************************/
 
-void
-ble_gap_notify_rx_event(uint16_t conn_handle, uint16_t attr_handle,
-                        struct os_mbuf *om, int is_indication)
+void ble_gap_notify_rx_event(uint16_t conn_handle, uint16_t attr_handle,
+                             struct os_mbuf *om, int is_indication)
 {
 #if (MYNEWT_VAL(BLE_GATT_NOTIFY) || MYNEWT_VAL(BLE_GATT_INDICATE)) && NIMBLE_BLE_CONNECT
 
@@ -6479,9 +7021,8 @@ ble_gap_notify_rx_event(uint16_t conn_handle, uint16_t attr_handle,
 #endif
 }
 
-void
-ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
-                        int is_indication)
+void ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
+                             int is_indication)
 {
 #if (MYNEWT_VAL(BLE_GATT_NOTIFY) || MYNEWT_VAL(BLE_GATT_INDICATE)) && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6501,11 +7042,10 @@ ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
  * $subscribe                                                                *
  *****************************************************************************/
 
-void
-ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
-                        uint8_t reason,
-                        uint8_t prev_notify, uint8_t cur_notify,
-                        uint8_t prev_indicate, uint8_t cur_indicate)
+void ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
+                             uint8_t reason,
+                             uint8_t prev_notify, uint8_t cur_notify,
+                             uint8_t prev_indicate, uint8_t cur_indicate)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6513,7 +7053,7 @@ ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
     BLE_HS_DBG_ASSERT(prev_notify != cur_notify ||
                       prev_indicate != cur_indicate);
     BLE_HS_DBG_ASSERT(reason == BLE_GAP_SUBSCRIBE_REASON_WRITE ||
-                      reason == BLE_GAP_SUBSCRIBE_REASON_TERM  ||
+                      reason == BLE_GAP_SUBSCRIBE_REASON_TERM ||
                       reason == BLE_GAP_SUBSCRIBE_REASON_RESTORE);
 
     memset(&event, 0, sizeof event);
@@ -6535,8 +7075,7 @@ ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
  * $mtu                                                                      *
  *****************************************************************************/
 
-void
-ble_gap_mtu_event(uint16_t conn_handle, uint16_t cid, uint16_t mtu)
+void ble_gap_mtu_event(uint16_t conn_handle, uint16_t cid, uint16_t mtu)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6553,9 +7092,8 @@ ble_gap_mtu_event(uint16_t conn_handle, uint16_t cid, uint16_t mtu)
 }
 
 #if MYNEWT_VAL(BLE_HS_GAP_UNHANDLED_HCI_EVENT)
-void
-ble_gap_unhandled_hci_event(bool is_le_meta, bool is_vs, const void *buf,
-                            uint8_t len)
+void ble_gap_unhandled_hci_event(bool is_le_meta, bool is_vs, const void *buf,
+                                 uint8_t len)
 {
     struct ble_gap_event event;
 
@@ -6574,8 +7112,7 @@ ble_gap_unhandled_hci_event(bool is_le_meta, bool is_vs, const void *buf,
  * $preempt                                                                  *
  *****************************************************************************/
 
-void
-ble_gap_preempt_no_lock(void)
+void ble_gap_preempt_no_lock(void)
 {
     int rc;
     int i;
@@ -6585,15 +7122,18 @@ ble_gap_preempt_no_lock(void)
 
 #if NIMBLE_BLE_ADVERTISE
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
+    for (i = 0; i < BLE_ADV_INSTANCES; i++)
+    {
         rc = ble_gap_ext_adv_stop_no_lock(i);
-        if (rc == 0) {
+        if (rc == 0)
+        {
             ble_gap_slave[i].preempted = 1;
         }
     }
 #else
     rc = ble_gap_adv_stop_no_lock();
-    if (rc == 0) {
+    if (rc == 0)
+    {
         ble_gap_slave[0].preempted = 1;
     }
 #endif
@@ -6601,14 +7141,16 @@ ble_gap_preempt_no_lock(void)
 
 #if NIMBLE_BLE_CONNECT
     rc = ble_gap_conn_cancel_no_lock();
-    if (rc == 0) {
+    if (rc == 0)
+    {
         ble_gap_master.preempted_op = BLE_GAP_OP_M_CONN;
     }
 #endif
 
 #if NIMBLE_BLE_SCAN
     rc = ble_gap_disc_cancel_no_lock();
-    if (rc == 0) {
+    if (rc == 0)
+    {
         ble_gap_master.preempted_op = BLE_GAP_OP_M_DISC;
     }
 #endif
@@ -6626,12 +7168,12 @@ ble_gap_preempt_no_lock(void)
  * reason code of BLE_HS_EPREEMPTED.  An attempt to initiate a new GAP
  * procedure during preemption fails with a return code of BLE_HS_EPREEMPTED.
  */
-void
-ble_gap_preempt(void)
+void ble_gap_preempt(void)
 {
     ble_hs_lock();
 
-    if (!ble_gap_is_preempted()) {
+    if (!ble_gap_is_preempted())
+    {
         ble_gap_preempt_no_lock();
     }
 
@@ -6646,15 +7188,15 @@ ble_gap_preempt(void)
 
 static struct ble_npl_mutex preempt_done_mutex;
 
-void
-ble_gap_preempt_done(void)
+void ble_gap_preempt_done(void)
 {
     struct ble_gap_event event;
     ble_gap_event_fn *master_cb;
     void *master_arg;
     int disc_preempted;
     int i;
-    static struct {
+    static struct
+    {
         ble_gap_event_fn *cb;
         void *arg;
     } slaves[BLE_ADV_INSTANCES];
@@ -6670,15 +7212,18 @@ ble_gap_preempt_done(void)
 
     ble_hs_lock();
 
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (ble_gap_slave[i].preempted) {
+    for (i = 0; i < BLE_ADV_INSTANCES; i++)
+    {
+        if (ble_gap_slave[i].preempted)
+        {
             ble_gap_slave[i].preempted = 0;
             slaves[i].cb = ble_gap_slave[i].cb;
             slaves[i].arg = ble_gap_slave[i].cb_arg;
         }
     }
 
-    if (ble_gap_master.preempted_op == BLE_GAP_OP_M_DISC) {
+    if (ble_gap_master.preempted_op == BLE_GAP_OP_M_DISC)
+    {
         ble_gap_master.preempted_op = BLE_GAP_OP_NULL;
         disc_preempted = 1;
         master_cb = ble_gap_master.cb;
@@ -6690,8 +7235,10 @@ ble_gap_preempt_done(void)
     event.type = BLE_GAP_EVENT_ADV_COMPLETE;
     event.adv_complete.reason = BLE_HS_EPREEMPTED;
 
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (slaves[i].cb) {
+    for (i = 0; i < BLE_ADV_INSTANCES; i++)
+    {
+        if (slaves[i].cb)
+        {
 #if MYNEWT_VAL(BLE_EXT_ADV)
             event.adv_complete.instance = i;
             event.adv_complete.conn_handle = i;
@@ -6701,45 +7248,52 @@ ble_gap_preempt_done(void)
     }
     ble_npl_mutex_release(&preempt_done_mutex);
 
-    if (disc_preempted) {
+    if (disc_preempted)
+    {
         event.type = BLE_GAP_EVENT_DISC_COMPLETE;
         event.disc_complete.reason = BLE_HS_EPREEMPTED;
         ble_gap_call_event_cb(&event, master_cb, master_arg);
     }
 }
 
-int
-ble_gap_event_listener_register(struct ble_gap_event_listener *listener,
-                                ble_gap_event_fn *fn, void *arg)
+int ble_gap_event_listener_register(struct ble_gap_event_listener *listener,
+                                    ble_gap_event_fn *fn, void *arg)
 {
     struct ble_gap_event_listener *evl = NULL;
     int rc;
 
-    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link) {
-        if (evl == listener) {
+    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link)
+    {
+        if (evl == listener)
+        {
             break;
         }
     }
 
-    if (!evl) {
-        if (fn) {
+    if (!evl)
+    {
+        if (fn)
+        {
             memset(listener, 0, sizeof(*listener));
             listener->fn = fn;
             listener->arg = arg;
             SLIST_INSERT_HEAD(&ble_gap_event_listener_list, listener, link);
             rc = 0;
-        } else {
+        }
+        else
+        {
             rc = BLE_HS_EINVAL;
         }
-    } else {
+    }
+    else
+    {
         rc = BLE_HS_EALREADY;
     }
 
     return rc;
 }
 
-int
-ble_gap_event_listener_unregister(struct ble_gap_event_listener *listener)
+int ble_gap_event_listener_unregister(struct ble_gap_event_listener *listener)
 {
     struct ble_gap_event_listener *evl = NULL;
     int rc;
@@ -6749,15 +7303,20 @@ ble_gap_event_listener_unregister(struct ble_gap_event_listener *listener)
      * know whether it registered its listener before.
      */
 
-    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link) {
-        if (evl == listener) {
+    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link)
+    {
+        if (evl == listener)
+        {
             break;
         }
     }
 
-    if (!evl) {
+    if (!evl)
+    {
         rc = BLE_HS_ENOENT;
-    } else {
+    }
+    else
+    {
         SLIST_REMOVE(&ble_gap_event_listener_list, listener,
                      ble_gap_event_listener, link);
         rc = 0;
@@ -6771,7 +7330,8 @@ ble_gap_event_listener_call(struct ble_gap_event *event)
 {
     struct ble_gap_event_listener *evl = NULL;
 
-    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link) {
+    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link)
+    {
         evl->fn(event, evl->arg);
     }
 
@@ -6782,8 +7342,7 @@ ble_gap_event_listener_call(struct ble_gap_event *event)
  * $init                                                                     *
  *****************************************************************************/
 
-int
-ble_gap_init(void)
+int ble_gap_init(void)
 {
     int rc;
 
@@ -6796,9 +7355,10 @@ ble_gap_init(void)
 
     rc = ble_npl_mutex_init(&preempt_done_mutex);
 
-    if (rc) {
-       BLE_HS_LOG(ERROR, "mutex init failed with reason %d \n", rc);
-       return rc;
+    if (rc)
+    {
+        BLE_HS_LOG(ERROR, "mutex init failed with reason %d \n", rc);
+        return rc;
     }
 
     SLIST_INIT(&ble_gap_update_entries);
@@ -6806,10 +7366,11 @@ ble_gap_init(void)
 
     rc = os_mempool_init(&ble_gap_update_entry_pool,
                          MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE),
-                         sizeof (struct ble_gap_update_entry),
+                         sizeof(struct ble_gap_update_entry),
                          ble_gap_update_entry_mem,
                          "ble_gap_update");
-    switch (rc) {
+    switch (rc)
+    {
     case 0:
         break;
     case OS_ENOMEM:
@@ -6821,9 +7382,9 @@ ble_gap_init(void)
     }
 
     rc = stats_init_and_reg(
-        STATS_HDR(ble_gap_stats), STATS_SIZE_INIT_PARMS(ble_gap_stats,
-        STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_gap_stats), "ble_gap");
-    if (rc != 0) {
+        STATS_HDR(ble_gap_stats), STATS_SIZE_INIT_PARMS(ble_gap_stats, STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_gap_stats), "ble_gap");
+    if (rc != 0)
+    {
         goto err;
     }
 
@@ -6833,9 +7394,8 @@ err:
     return rc;
 }
 
-int
-ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy, uint8_t *out_status, uint8_t *out_phy ,
-				      uint8_t *out_curr_tx_power_level, uint8_t *out_max_tx_power_level)
+int ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy, uint8_t *out_status, uint8_t *out_phy,
+                                          uint8_t *out_curr_tx_power_level, uint8_t *out_max_tx_power_level)
 
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
@@ -6851,7 +7411,8 @@ ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy, uint8_t
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
 
-    if (rc!=0) {
+    if (rc != 0)
+    {
         return rc;
     }
 
@@ -6866,9 +7427,8 @@ ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy, uint8_t
 #endif
 }
 
-int
-ble_gap_read_remote_transmit_power_level(uint16_t conn_handle,
-				      uint8_t phy)
+int ble_gap_read_remote_transmit_power_level(uint16_t conn_handle,
+                                             uint8_t phy)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
     struct ble_hci_le_read_remote_transmit_power_level_cp cmd;
@@ -6885,13 +7445,12 @@ ble_gap_read_remote_transmit_power_level(uint16_t conn_handle,
 #endif
 }
 
-int
-ble_gap_set_path_loss_reporting_param(uint16_t conn_handle,
-				      uint8_t high_threshold,
-				      uint8_t high_hysteresis,
-				      uint8_t low_threshold,
-				      uint8_t low_hysteresis,
-				      uint16_t min_time_spent)
+int ble_gap_set_path_loss_reporting_param(uint16_t conn_handle,
+                                          uint8_t high_threshold,
+                                          uint8_t high_hysteresis,
+                                          uint8_t low_threshold,
+                                          uint8_t low_hysteresis,
+                                          uint16_t min_time_spent)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
     struct ble_hci_le_set_path_loss_report_param_cp cmd;
@@ -6912,9 +7471,8 @@ ble_gap_set_path_loss_reporting_param(uint16_t conn_handle,
 #endif
 }
 
-int
-ble_gap_set_path_loss_reporting_enable(uint16_t conn_handle,
-				       uint8_t enable)
+int ble_gap_set_path_loss_reporting_enable(uint16_t conn_handle,
+                                           uint8_t enable)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
     struct ble_hci_le_set_path_loss_report_enable_cp cmd;
@@ -6931,10 +7489,9 @@ ble_gap_set_path_loss_reporting_enable(uint16_t conn_handle,
 #endif
 }
 
-int
-ble_gap_set_transmit_power_reporting_enable(uint16_t conn_handle,
-					    uint8_t local_enable,
-					    uint8_t remote_enable)
+int ble_gap_set_transmit_power_reporting_enable(uint16_t conn_handle,
+                                                uint8_t local_enable,
+                                                uint8_t remote_enable)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
     struct ble_hci_le_set_transmit_power_report_enable_cp cmd;
diff --git a/nimble/host/src/ble_hs_cfg.c b/nimble/host/src/ble_hs_cfg.c
index a46a604a..2fe2030f 100644
--- a/nimble/host/src/ble_hs_cfg.c
+++ b/nimble/host/src/ble_hs_cfg.c
@@ -21,13 +21,23 @@
 #include "host/ble_hs.h"
 
 struct ble_hs_cfg ble_hs_cfg = {
-    /** Security manager settings. */
-    .sm_io_cap = MYNEWT_VAL(BLE_SM_IO_CAP),
-    .sm_oob_data_flag = MYNEWT_VAL(BLE_SM_OOB_DATA_FLAG),
-    .sm_bonding = MYNEWT_VAL(BLE_SM_BONDING),
-    .sm_mitm = MYNEWT_VAL(BLE_SM_MITM),
-    .sm_sc = MYNEWT_VAL(BLE_SM_SC),
-    .sm_keypress = MYNEWT_VAL(BLE_SM_KEYPRESS),
-    .sm_our_key_dist = MYNEWT_VAL(BLE_SM_OUR_KEY_DIST),
-    .sm_their_key_dist = MYNEWT_VAL(BLE_SM_THEIR_KEY_DIST),
+	/** Security manager settings. */
+	.sm_io_cap = MYNEWT_VAL(BLE_SM_IO_CAP),
+	.sm_oob_data_flag = MYNEWT_VAL(BLE_SM_OOB_DATA_FLAG),
+	.sm_bonding = MYNEWT_VAL(BLE_SM_BONDING),
+	.sm_mitm = MYNEWT_VAL(BLE_SM_MITM),
+	.sm_sc = MYNEWT_VAL(BLE_SM_SC),
+	.sm_keypress = MYNEWT_VAL(BLE_SM_KEYPRESS),
+	.sm_our_key_dist = MYNEWT_VAL(BLE_SM_OUR_KEY_DIST),
+	.sm_their_key_dist = MYNEWT_VAL(BLE_SM_THEIR_KEY_DIST),
+	.sm_max_enc_key_size = 16,
 };
+
+struct ble_hs_cfg fake_sec_cfg = {
+	/** Fake AuthReq settings. We only need those four */
+	.sm_bonding = MYNEWT_VAL(BLE_SM_BONDING),
+	.sm_mitm = MYNEWT_VAL(BLE_SM_MITM),
+	.sm_sc = MYNEWT_VAL(BLE_SM_SC),
+	.sm_keypress = MYNEWT_VAL(BLE_SM_KEYPRESS),
+};
+
diff --git a/nimble/host/src/ble_hs_hci_evt.c b/nimble/host/src/ble_hs_hci_evt.c
index cc88bfd8..a19998f5 100644
--- a/nimble/host/src/ble_hs_hci_evt.c
+++ b/nimble/host/src/ble_hs_hci_evt.c
@@ -27,11 +27,10 @@
 #include "ble_hs_priv.h"
 #include "ble_iso_priv.h"
 
-_Static_assert(sizeof (struct hci_data_hdr) == BLE_HCI_DATA_HDR_SZ,
+_Static_assert(sizeof(struct hci_data_hdr) == BLE_HCI_DATA_HDR_SZ,
                "struct hci_data_hdr must be 4 bytes");
 
-typedef int ble_hs_hci_evt_fn(uint8_t event_code, const void *data,
-                              unsigned int len);
+typedef int ble_hs_hci_evt_fn(uint8_t event_code, const void *data, unsigned int len);
 static ble_hs_hci_evt_fn ble_hs_hci_evt_hw_error;
 static ble_hs_hci_evt_fn ble_hs_hci_evt_num_completed_pkts;
 #if NIMBLE_BLE_CONNECT
@@ -44,8 +43,7 @@ static ble_hs_hci_evt_fn ble_hs_hci_evt_le_meta;
 static ble_hs_hci_evt_fn ble_hs_hci_evt_vs;
 #endif
 
-typedef int ble_hs_hci_evt_le_fn(uint8_t subevent, const void *data,
-                                 unsigned int len);
+typedef int ble_hs_hci_evt_le_fn(uint8_t subevent, const void *data, unsigned int len);
 static ble_hs_hci_evt_le_fn ble_hs_hci_evt_le_adv_rpt;
 #if NIMBLE_BLE_CONNECT
 static ble_hs_hci_evt_le_fn ble_hs_hci_evt_le_conn_complete;
@@ -86,266 +84,256 @@ static ble_hs_hci_evt_le_fn ble_hs_hci_evt_le_subrate_change;
 
 /* Statistics */
 struct host_hci_stats {
-    uint32_t events_rxd;
-    uint32_t good_acks_rxd;
-    uint32_t bad_acks_rxd;
-    uint32_t unknown_events_rxd;
+	uint32_t events_rxd;
+	uint32_t good_acks_rxd;
+	uint32_t bad_acks_rxd;
+	uint32_t unknown_events_rxd;
 };
 
-#define BLE_HS_HCI_EVT_TIMEOUT        50      /* Milliseconds. */
+#define BLE_HS_HCI_EVT_TIMEOUT 50 /* Milliseconds. */
 
 /** Dispatch table for incoming HCI events.  Sorted by event code field. */
 struct ble_hs_hci_evt_dispatch_entry {
-    uint8_t event_code;
-    ble_hs_hci_evt_fn *cb;
+	uint8_t event_code;
+	ble_hs_hci_evt_fn *cb;
 };
 
 static const struct ble_hs_hci_evt_dispatch_entry ble_hs_hci_evt_dispatch[] = {
-    { BLE_HCI_EVCODE_LE_META, ble_hs_hci_evt_le_meta },
-    { BLE_HCI_EVCODE_NUM_COMP_PKTS, ble_hs_hci_evt_num_completed_pkts },
+	{BLE_HCI_EVCODE_LE_META, ble_hs_hci_evt_le_meta},
+	{BLE_HCI_EVCODE_NUM_COMP_PKTS, ble_hs_hci_evt_num_completed_pkts},
 #if NIMBLE_BLE_CONNECT
-    { BLE_HCI_EVCODE_DISCONN_CMP, ble_hs_hci_evt_disconn_complete },
-    { BLE_HCI_EVCODE_ENCRYPT_CHG, ble_hs_hci_evt_encrypt_change },
-    { BLE_HCI_EVCODE_ENC_KEY_REFRESH, ble_hs_hci_evt_enc_key_refresh },
+	{BLE_HCI_EVCODE_DISCONN_CMP, ble_hs_hci_evt_disconn_complete},
+	{BLE_HCI_EVCODE_ENCRYPT_CHG, ble_hs_hci_evt_encrypt_change},
+	{BLE_HCI_EVCODE_ENC_KEY_REFRESH, ble_hs_hci_evt_enc_key_refresh},
 #endif
-    { BLE_HCI_EVCODE_HW_ERROR, ble_hs_hci_evt_hw_error },
+	{BLE_HCI_EVCODE_HW_ERROR, ble_hs_hci_evt_hw_error},
 #if MYNEWT_VAL(BLE_HCI_VS)
-    { BLE_HCI_EVCODE_VS, ble_hs_hci_evt_vs },
+	{BLE_HCI_EVCODE_VS, ble_hs_hci_evt_vs},
 #endif
 };
 
 #define BLE_HS_HCI_EVT_DISPATCH_SZ \
-    (sizeof ble_hs_hci_evt_dispatch / sizeof ble_hs_hci_evt_dispatch[0])
+	(sizeof ble_hs_hci_evt_dispatch / sizeof ble_hs_hci_evt_dispatch[0])
 
-static ble_hs_hci_evt_le_fn * const ble_hs_hci_evt_le_dispatch[] = {
+static ble_hs_hci_evt_le_fn *const ble_hs_hci_evt_le_dispatch[] = {
 #if NIMBLE_BLE_CONNECT
-    [BLE_HCI_LE_SUBEV_CONN_COMPLETE] = ble_hs_hci_evt_le_conn_complete,
+	[BLE_HCI_LE_SUBEV_CONN_COMPLETE] = ble_hs_hci_evt_le_conn_complete,
 #endif
-    [BLE_HCI_LE_SUBEV_ADV_RPT] = ble_hs_hci_evt_le_adv_rpt,
+	[BLE_HCI_LE_SUBEV_ADV_RPT] = ble_hs_hci_evt_le_adv_rpt,
 #if NIMBLE_BLE_CONNECT
-    [BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE] = ble_hs_hci_evt_le_conn_upd_complete,
-    [BLE_HCI_LE_SUBEV_LT_KEY_REQ] = ble_hs_hci_evt_le_lt_key_req,
-    [BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ] = ble_hs_hci_evt_le_conn_parm_req,
-    [BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE] = ble_hs_hci_evt_le_enh_conn_complete,
+	[BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE] = ble_hs_hci_evt_le_conn_upd_complete,
+	[BLE_HCI_LE_SUBEV_LT_KEY_REQ] = ble_hs_hci_evt_le_lt_key_req,
+	[BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ] = ble_hs_hci_evt_le_conn_parm_req,
+	[BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE] = ble_hs_hci_evt_le_enh_conn_complete,
 #endif
-    [BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT] = ble_hs_hci_evt_le_dir_adv_rpt,
+	[BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT] = ble_hs_hci_evt_le_dir_adv_rpt,
 #if NIMBLE_BLE_CONNECT
-    [BLE_HCI_LE_SUBEV_PHY_UPDATE_COMPLETE] = ble_hs_hci_evt_le_phy_update_complete,
+	[BLE_HCI_LE_SUBEV_PHY_UPDATE_COMPLETE] = ble_hs_hci_evt_le_phy_update_complete,
 #endif
-    [BLE_HCI_LE_SUBEV_EXT_ADV_RPT] = ble_hs_hci_evt_le_ext_adv_rpt,
-    [BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_ESTAB] = ble_hs_hci_evt_le_periodic_adv_sync_estab,
-    [BLE_HCI_LE_SUBEV_PERIODIC_ADV_RPT] = ble_hs_hci_evt_le_periodic_adv_rpt,
-    [BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_LOST] = ble_hs_hci_evt_le_periodic_adv_sync_lost,
-    [BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT] = ble_hs_hci_evt_le_rd_rem_used_feat_complete,
-    [BLE_HCI_LE_SUBEV_SCAN_TIMEOUT] = ble_hs_hci_evt_le_scan_timeout,
-    [BLE_HCI_LE_SUBEV_ADV_SET_TERMINATED] = ble_hs_hci_evt_le_adv_set_terminated,
-    [BLE_HCI_LE_SUBEV_SCAN_REQ_RCVD] = ble_hs_hci_evt_le_scan_req_rcvd,
-    [BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_TRANSFER] = ble_hs_hci_evt_le_periodic_adv_sync_transfer,
+	[BLE_HCI_LE_SUBEV_EXT_ADV_RPT] = ble_hs_hci_evt_le_ext_adv_rpt,
+	[BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_ESTAB] = ble_hs_hci_evt_le_periodic_adv_sync_estab,
+	[BLE_HCI_LE_SUBEV_PERIODIC_ADV_RPT] = ble_hs_hci_evt_le_periodic_adv_rpt,
+	[BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_LOST] = ble_hs_hci_evt_le_periodic_adv_sync_lost,
+	[BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT] = ble_hs_hci_evt_le_rd_rem_used_feat_complete,
+	[BLE_HCI_LE_SUBEV_SCAN_TIMEOUT] = ble_hs_hci_evt_le_scan_timeout,
+	[BLE_HCI_LE_SUBEV_ADV_SET_TERMINATED] = ble_hs_hci_evt_le_adv_set_terminated,
+	[BLE_HCI_LE_SUBEV_SCAN_REQ_RCVD] = ble_hs_hci_evt_le_scan_req_rcvd,
+	[BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_TRANSFER] =
+		ble_hs_hci_evt_le_periodic_adv_sync_transfer,
 #if MYNEWT_VAL(BLE_ISO_BROADCAST_SOURCE)
-    [BLE_HCI_LE_SUBEV_CREATE_BIG_COMPLETE] =
-        ble_hs_hci_evt_le_create_big_complete,
-    [BLE_HCI_LE_SUBEV_TERMINATE_BIG_COMPLETE] =
-        ble_hs_hci_evt_le_terminate_big_complete,
+	[BLE_HCI_LE_SUBEV_CREATE_BIG_COMPLETE] = ble_hs_hci_evt_le_create_big_complete,
+	[BLE_HCI_LE_SUBEV_TERMINATE_BIG_COMPLETE] = ble_hs_hci_evt_le_terminate_big_complete,
 #endif
 #if MYNEWT_VAL(BLE_ISO_BROADCAST_SINK)
-    [BLE_HCI_LE_SUBEV_BIG_SYNC_ESTABLISHED] =
-        ble_hs_hci_evt_le_big_sync_established,
-    [BLE_HCI_LE_SUBEV_BIG_SYNC_LOST] =
-        ble_hs_hci_evt_le_big_sync_lost,
+	[BLE_HCI_LE_SUBEV_BIG_SYNC_ESTABLISHED] = ble_hs_hci_evt_le_big_sync_established,
+	[BLE_HCI_LE_SUBEV_BIG_SYNC_LOST] = ble_hs_hci_evt_le_big_sync_lost,
 #endif
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_BIGINFO_REPORTS)
-    [BLE_HCI_LE_SUBEV_BIGINFO_ADV_REPORT] = ble_hs_hci_evt_le_biginfo_adv_report,
+	[BLE_HCI_LE_SUBEV_BIGINFO_ADV_REPORT] = ble_hs_hci_evt_le_biginfo_adv_report,
 #endif
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
-    [BLE_HCI_LE_SUBEV_PATH_LOSS_THRESHOLD] = ble_hs_hci_evt_le_pathloss_threshold,
-    [BLE_HCI_LE_SUBEV_TRANSMIT_POWER_REPORT] = ble_hs_hci_evt_le_transmit_power_report,
+	[BLE_HCI_LE_SUBEV_PATH_LOSS_THRESHOLD] = ble_hs_hci_evt_le_pathloss_threshold,
+	[BLE_HCI_LE_SUBEV_TRANSMIT_POWER_REPORT] = ble_hs_hci_evt_le_transmit_power_report,
 #endif
 #if MYNEWT_VAL(BLE_CONN_SUBRATING)
-    [BLE_HCI_LE_SUBEV_SUBRATE_CHANGE] = ble_hs_hci_evt_le_subrate_change,
+	[BLE_HCI_LE_SUBEV_SUBRATE_CHANGE] = ble_hs_hci_evt_le_subrate_change,
 #endif
 };
 
 #define BLE_HS_HCI_EVT_LE_DISPATCH_SZ \
-    (sizeof ble_hs_hci_evt_le_dispatch / sizeof ble_hs_hci_evt_le_dispatch[0])
+	(sizeof ble_hs_hci_evt_le_dispatch / sizeof ble_hs_hci_evt_le_dispatch[0])
 
-static const struct ble_hs_hci_evt_dispatch_entry *
-ble_hs_hci_evt_dispatch_find(uint8_t event_code)
+static const struct ble_hs_hci_evt_dispatch_entry *ble_hs_hci_evt_dispatch_find(uint8_t event_code)
 {
-    const struct ble_hs_hci_evt_dispatch_entry *entry;
-    unsigned int i;
+	const struct ble_hs_hci_evt_dispatch_entry *entry;
+	unsigned int i;
 
-    for (i = 0; i < BLE_HS_HCI_EVT_DISPATCH_SZ; i++) {
-        entry = ble_hs_hci_evt_dispatch + i;
-        if (entry->event_code == event_code) {
-            return entry;
-        }
-    }
+	for (i = 0; i < BLE_HS_HCI_EVT_DISPATCH_SZ; i++) {
+		entry = ble_hs_hci_evt_dispatch + i;
+		if (entry->event_code == event_code) {
+			return entry;
+		}
+	}
 
-    return NULL;
+	return NULL;
 }
 
-static ble_hs_hci_evt_le_fn *
-ble_hs_hci_evt_le_dispatch_find(uint8_t event_code)
+static ble_hs_hci_evt_le_fn *ble_hs_hci_evt_le_dispatch_find(uint8_t event_code)
 {
-    if (event_code >= BLE_HS_HCI_EVT_LE_DISPATCH_SZ) {
-        return NULL;
-    }
+	if (event_code >= BLE_HS_HCI_EVT_LE_DISPATCH_SZ) {
+		return NULL;
+	}
 
-    return ble_hs_hci_evt_le_dispatch[event_code];
+	return ble_hs_hci_evt_le_dispatch[event_code];
 }
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_hs_hci_evt_disconn_complete(uint8_t event_code, const void *data,
-                                unsigned int len)
+static int ble_hs_hci_evt_disconn_complete(uint8_t event_code, const void *data,
+                                           unsigned int len)
 {
-    const struct ble_hci_ev_disconn_cmp *ev = data;
-    const struct ble_hs_conn *conn;
+	const struct ble_hci_ev_disconn_cmp *ev = data;
+	const struct ble_hs_conn *conn;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_hs_lock();
-    conn = ble_hs_conn_find(le16toh(ev->conn_handle));
-    if (conn != NULL) {
-        ble_hs_hci_add_avail_pkts(conn->bhc_outstanding_pkts);
-    }
-    ble_hs_unlock();
+	ble_hs_lock();
+	conn = ble_hs_conn_find(le16toh(ev->conn_handle));
+	if (conn != NULL) {
+		ble_hs_hci_add_avail_pkts(conn->bhc_outstanding_pkts);
+	}
+	ble_hs_unlock();
 
-    ble_gap_rx_disconn_complete(ev);
+	ble_gap_rx_disconn_complete(ev);
 
-    /* The connection termination may have freed up some capacity in the
-     * controller for additional ACL data packets.  Wake up any stalled
-     * connections.
-     */
-    ble_hs_wakeup_tx();
+	/* The connection termination may have freed up some capacity in the
+	 * controller for additional ACL data packets.  Wake up any stalled
+	 * connections.
+	 */
+	ble_hs_wakeup_tx();
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_encrypt_change(uint8_t event_code, const void *data,
-                              unsigned int len)
+static int ble_hs_hci_evt_encrypt_change(uint8_t event_code, const void *data,
+                                         unsigned int len)
 {
-    const struct ble_hci_ev_enrypt_chg *ev = data;
+	const struct ble_hci_ev_enrypt_chg *ev = data;
 
-    if (len != sizeof (*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_sm_enc_change_rx(ev);
+	ble_sm_enc_change_rx(ev);
 
-    return 0;
+	return 0;
 }
 #endif
-static int
-ble_hs_hci_evt_hw_error(uint8_t event_code, const void *data, unsigned int len)
+static int ble_hs_hci_evt_hw_error(uint8_t event_code, const void *data, unsigned int len)
 {
-    const struct ble_hci_ev_hw_error *ev = data;
+	const struct ble_hci_ev_hw_error *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_hs_hw_error(ev->hw_code);
+	ble_hs_hw_error(ev->hw_code);
 
-    return 0;
+	return 0;
 }
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_hs_hci_evt_enc_key_refresh(uint8_t event_code, const void *data,
-                               unsigned int len)
+static int ble_hs_hci_evt_enc_key_refresh(uint8_t event_code, const void *data,
+                                          unsigned int len)
 {
-    const struct ble_hci_ev_enc_key_refresh *ev = data;
+	const struct ble_hci_ev_enc_key_refresh *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_sm_enc_key_refresh_rx(ev);
+	ble_sm_enc_key_refresh_rx(ev);
 
-    return 0;
+	return 0;
 }
 #endif
 
-static int
-ble_hs_hci_evt_num_completed_pkts(uint8_t event_code, const void *data,
-                                  unsigned int len)
+static int ble_hs_hci_evt_num_completed_pkts(uint8_t event_code, const void *data,
+                                             unsigned int len)
 {
-    const struct ble_hci_ev_num_comp_pkts *ev = data;
-    struct ble_hs_conn *conn;
-    uint16_t num_pkts;
-    int i;
-
-    if (len != sizeof(*ev) + (ev->count * sizeof(ev->completed[0]))) {
-        return BLE_HS_ECONTROLLER;
-    }
-
-    for (i = 0; i < ev->count; i++) {
-        num_pkts = le16toh(ev->completed[i].packets);
-
-        if (num_pkts > 0) {
-            ble_hs_lock();
-            conn = ble_hs_conn_find(le16toh(ev->completed[i].handle));
-            if (conn != NULL) {
-                if (conn->bhc_outstanding_pkts < num_pkts) {
-                    ble_hs_sched_reset(BLE_HS_ECONTROLLER);
-                } else {
-                    conn->bhc_outstanding_pkts -= num_pkts;
-                }
-
-                ble_hs_hci_add_avail_pkts(num_pkts);
-            }
-            ble_hs_unlock();
-        }
-    }
-
-    /* If any transmissions have stalled, wake them up now. */
-    ble_hs_wakeup_tx();
-
-    return 0;
+	const struct ble_hci_ev_num_comp_pkts *ev = data;
+	struct ble_hs_conn *conn;
+	uint16_t num_pkts;
+	int i;
+
+	if (len != sizeof(*ev) + (ev->count * sizeof(ev->completed[0]))) {
+		return BLE_HS_ECONTROLLER;
+	}
+
+	for (i = 0; i < ev->count; i++) {
+		num_pkts = le16toh(ev->completed[i].packets);
+
+		if (num_pkts > 0) {
+			ble_hs_lock();
+			conn = ble_hs_conn_find(le16toh(ev->completed[i].handle));
+			if (conn != NULL) {
+				if (conn->bhc_outstanding_pkts < num_pkts) {
+					ble_hs_sched_reset(BLE_HS_ECONTROLLER);
+				}
+				else {
+					conn->bhc_outstanding_pkts -= num_pkts;
+				}
+
+				ble_hs_hci_add_avail_pkts(num_pkts);
+			}
+			ble_hs_unlock();
+		}
+	}
+
+	/* If any transmissions have stalled, wake them up now. */
+	ble_hs_wakeup_tx();
+
+	return 0;
 }
 
 #if MYNEWT_VAL(BLE_HCI_VS)
-static int
-ble_hs_hci_evt_vs(uint8_t event_code, const void *data, unsigned int len)
+static int ble_hs_hci_evt_vs(uint8_t event_code, const void *data, unsigned int len)
 {
-    const struct ble_hci_ev_vs *ev = data;
+	const struct ble_hci_ev_vs *ev = data;
 
-    if (len < sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len < sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
 #if MYNEWT_VAL(BLE_HS_GAP_UNHANDLED_HCI_EVENT)
-    ble_gap_unhandled_hci_event(false, true, data, len);
+	ble_gap_unhandled_hci_event(false, true, data, len);
 #endif
 
-    return 0;
+	return 0;
 }
 #endif
 
-static int
-ble_hs_hci_evt_le_meta(uint8_t event_code, const void *data, unsigned int len)
+static int ble_hs_hci_evt_le_meta(uint8_t event_code, const void *data, unsigned int len)
 {
-    const struct ble_hci_ev_le_meta *ev = data;
-    ble_hs_hci_evt_le_fn *fn;
-
-    if (len < sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
-
-    fn = ble_hs_hci_evt_le_dispatch_find(ev->subevent);
-    if (fn) {
-        return fn(ev->subevent, data, len);
-    } else {
+	const struct ble_hci_ev_le_meta *ev = data;
+	ble_hs_hci_evt_le_fn *fn;
+
+	if (len < sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
+
+	fn = ble_hs_hci_evt_le_dispatch_find(ev->subevent);
+	if (fn) {
+		return fn(ev->subevent, data, len);
+	}
+	else {
 #if MYNEWT_VAL(BLE_HS_GAP_UNHANDLED_HCI_EVENT)
-        ble_gap_unhandled_hci_event(true, false, data, len);
+		ble_gap_unhandled_hci_event(true, false, data, len);
 #endif
-    }
+	}
 
-    return 0;
+	return 0;
 }
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
@@ -353,668 +341,648 @@ static struct ble_gap_conn_complete pend_conn_complete;
 #endif
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_hs_hci_evt_le_enh_conn_complete(uint8_t subevent, const void *data,
-                                    unsigned int len)
+static int ble_hs_hci_evt_le_enh_conn_complete(uint8_t subevent, const void *data,
+                                               unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_enh_conn_complete *ev = data;
-    struct ble_gap_conn_complete evt;
-
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
-
-    memset(&evt, 0, sizeof(evt));
-
-    evt.status = ev->status;
-
-    if (evt.status == BLE_ERR_SUCCESS) {
-        evt.connection_handle = le16toh(ev->conn_handle);
-        evt.role = ev->role;
-        evt.peer_addr_type = ev->peer_addr_type;
-        memcpy(evt.peer_addr, ev->peer_addr, BLE_DEV_ADDR_LEN);
-        memcpy(evt.local_rpa, ev->local_rpa, BLE_DEV_ADDR_LEN);
-        memcpy(evt.peer_rpa,ev->peer_rpa, BLE_DEV_ADDR_LEN);
-        evt.conn_itvl = le16toh(ev->conn_itvl);
-        evt.conn_latency = le16toh(ev->conn_latency);
-        evt.supervision_timeout = le16toh(ev->supervision_timeout);
-        evt.master_clk_acc = ev->mca;
-    } else {
+	const struct ble_hci_ev_le_subev_enh_conn_complete *ev = data;
+	struct ble_gap_conn_complete evt;
+
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
+
+	memset(&evt, 0, sizeof(evt));
+
+	evt.status = ev->status;
+	printf("ble_hs_hci_evt_le_enh_conn_complete: status=%d\n", evt.status);
+	if (evt.status == BLE_ERR_SUCCESS) {
+		evt.connection_handle = le16toh(ev->conn_handle);
+		evt.role = ev->role;
+		evt.peer_addr_type = ev->peer_addr_type;
+		memcpy(evt.peer_addr, ev->peer_addr, BLE_DEV_ADDR_LEN);
+		memcpy(evt.local_rpa, ev->local_rpa, BLE_DEV_ADDR_LEN);
+		memcpy(evt.peer_rpa, ev->peer_rpa, BLE_DEV_ADDR_LEN);
+		evt.conn_itvl = le16toh(ev->conn_itvl);
+		evt.conn_latency = le16toh(ev->conn_latency);
+		evt.supervision_timeout = le16toh(ev->supervision_timeout);
+		evt.master_clk_acc = ev->mca;
+	}
+	else {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-        evt.connection_handle = BLE_HS_CONN_HANDLE_NONE;
+		evt.connection_handle = BLE_HS_CONN_HANDLE_NONE;
 #endif
-    }
+	}
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    if (evt.status == BLE_ERR_DIR_ADV_TMO ||
-                            evt.role == BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE) {
-    /* store this until we get set terminated event with adv handle */
-        memcpy(&pend_conn_complete, &evt, sizeof(evt));
-        return 0;
-    }
+	if (evt.status == BLE_ERR_DIR_ADV_TMO ||
+	    evt.role == BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE) {
+		/* store this until we get set terminated event with adv handle */
+		memcpy(&pend_conn_complete, &evt, sizeof(evt));
+		return 0;
+	}
 #endif
-    return ble_gap_rx_conn_complete(&evt, 0);
-
+	return ble_gap_rx_conn_complete(&evt, 0);
 }
 
-static int
-ble_hs_hci_evt_le_conn_complete(uint8_t subevent, const void *data,
-                                unsigned int len)
+static int ble_hs_hci_evt_le_conn_complete(uint8_t subevent, const void *data,
+                                           unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_conn_complete *ev = data;
-    struct ble_gap_conn_complete evt;
-
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
-
-    memset(&evt, 0, sizeof(evt));
-
-    evt.status = ev->status;
-
-    if (evt.status == BLE_ERR_SUCCESS) {
-        evt.connection_handle = le16toh(ev->conn_handle);
-        evt.role = ev->role;
-        evt.peer_addr_type = ev->peer_addr_type;
-        memcpy(evt.peer_addr, ev->peer_addr, BLE_DEV_ADDR_LEN);
-
-        evt.conn_itvl = le16toh(ev->conn_itvl);
-        evt.conn_latency = le16toh(ev->conn_latency);
-        evt.supervision_timeout = le16toh(ev->supervision_timeout);
-        evt.master_clk_acc = ev->mca;
-    } else {
+	const struct ble_hci_ev_le_subev_conn_complete *ev = data;
+	struct ble_gap_conn_complete evt;
+
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
+
+	memset(&evt, 0, sizeof(evt));
+
+	evt.status = ev->status;
+	printf("ble_hs_hci_evt_le_conn_complete: status=%d\n", evt.status);
+	if (evt.status == BLE_ERR_SUCCESS) {
+		evt.connection_handle = le16toh(ev->conn_handle);
+		evt.role = ev->role;
+		evt.peer_addr_type = ev->peer_addr_type;
+		memcpy(evt.peer_addr, ev->peer_addr, BLE_DEV_ADDR_LEN);
+
+		evt.conn_itvl = le16toh(ev->conn_itvl);
+		evt.conn_latency = le16toh(ev->conn_latency);
+		evt.supervision_timeout = le16toh(ev->supervision_timeout);
+		evt.master_clk_acc = ev->mca;
+	}
+	else {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-        evt.connection_handle = BLE_HS_CONN_HANDLE_NONE;
+		evt.connection_handle = BLE_HS_CONN_HANDLE_NONE;
 #endif
-    }
+	}
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    if (evt.status == BLE_ERR_DIR_ADV_TMO ||
-                            evt.role == BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE) {
-    /* store this until we get set terminated event with adv handle */
-        memcpy(&pend_conn_complete, &evt, sizeof(evt));
-        return 0;
-    }
+	if (evt.status == BLE_ERR_DIR_ADV_TMO ||
+	    evt.role == BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE) {
+		/* store this until we get set terminated event with adv handle */
+		memcpy(&pend_conn_complete, &evt, sizeof(evt));
+		return 0;
+	}
 #endif
-    return ble_gap_rx_conn_complete(&evt, 0);
+	return ble_gap_rx_conn_complete(&evt, 0);
 }
 #endif
 
-static int
-ble_hs_hci_evt_le_adv_rpt_first_pass(const void *data, unsigned int len)
+static int ble_hs_hci_evt_le_adv_rpt_first_pass(const void *data, unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_adv_rpt *ev = data;
-    const struct adv_report *rpt;
-    int i;
+	const struct ble_hci_ev_le_subev_adv_rpt *ev = data;
+	const struct adv_report *rpt;
+	int i;
 
-    if (len < sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len < sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    len -= sizeof(*ev);
-    data += sizeof(*ev);
+	len -= sizeof(*ev);
+	data += sizeof(*ev);
 
-    if (ev->num_reports < BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN ||
-        ev->num_reports > BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX) {
-        return BLE_HS_EBADDATA;
-    }
+	if (ev->num_reports < BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN ||
+	    ev->num_reports > BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX) {
+		return BLE_HS_EBADDATA;
+	}
 
-    for (i = 0; i < ev->num_reports; i++) {
-        /* extra byte for RSSI after adv data */
-        if (len < sizeof(*rpt) + 1) {
-            return BLE_HS_ECONTROLLER;
-        }
+	for (i = 0; i < ev->num_reports; i++) {
+		/* extra byte for RSSI after adv data */
+		if (len < sizeof(*rpt) + 1) {
+			return BLE_HS_ECONTROLLER;
+		}
 
-        rpt = data;
+		rpt = data;
 
-        len -= sizeof(*rpt) + 1;
-        data += sizeof(rpt) + 1;
+		len -= sizeof(*rpt) + 1;
+		data += sizeof(rpt) + 1;
 
-        if (rpt->data_len > len) {
-            return BLE_HS_ECONTROLLER;
-        }
+		if (rpt->data_len > len) {
+			return BLE_HS_ECONTROLLER;
+		}
 
-        len -= rpt->data_len;
-        data += rpt->data_len;
-    }
+		len -= rpt->data_len;
+		data += rpt->data_len;
+	}
 
-    /* Make sure length was correct */
-    if (len) {
-        return BLE_HS_ECONTROLLER;
-    }
+	/* Make sure length was correct */
+	if (len) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_adv_rpt(uint8_t subevent, const void *data, unsigned int len)
+static int ble_hs_hci_evt_le_adv_rpt(uint8_t subevent, const void *data, unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_adv_rpt *ev = data;
-    struct ble_gap_disc_desc desc = {0};
-    const struct adv_report *rpt;
-    int rc;
-    int i;
+	const struct ble_hci_ev_le_subev_adv_rpt *ev = data;
+	struct ble_gap_disc_desc desc = {0};
+	const struct adv_report *rpt;
+	int rc;
+	int i;
 
-    /* Validate the event is formatted correctly */
-    rc = ble_hs_hci_evt_le_adv_rpt_first_pass(data, len);
-    if (rc != 0) {
-        return rc;
-    }
+	/* Validate the event is formatted correctly */
+	rc = ble_hs_hci_evt_le_adv_rpt_first_pass(data, len);
+	if (rc != 0) {
+		return rc;
+	}
 
-    data += sizeof(*ev);
+	data += sizeof(*ev);
 
-    desc.direct_addr = *BLE_ADDR_ANY;
+	desc.direct_addr = *BLE_ADDR_ANY;
 
-    for (i = 0; i < ev->num_reports; i++) {
-        rpt = data;
+	for (i = 0; i < ev->num_reports; i++) {
+		rpt = data;
 
-        data += sizeof(rpt) + rpt->data_len + 1;
+		data += sizeof(rpt) + rpt->data_len + 1;
 
-        desc.event_type = rpt->type;
-        desc.addr.type = rpt->addr_type;
-        memcpy(desc.addr.val, rpt->addr, BLE_DEV_ADDR_LEN);
-        desc.length_data = rpt->data_len;
-        desc.data = rpt->data;
-        desc.rssi = rpt->data[rpt->data_len];
+		desc.event_type = rpt->type;
+		desc.addr.type = rpt->addr_type;
+		memcpy(desc.addr.val, rpt->addr, BLE_DEV_ADDR_LEN);
+		desc.length_data = rpt->data_len;
+		desc.data = rpt->data;
+		desc.rssi = rpt->data[rpt->data_len];
 
-        ble_gap_rx_adv_report(&desc);
-    }
+		ble_gap_rx_adv_report(&desc);
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_dir_adv_rpt(uint8_t subevent, const void *data, unsigned int len)
+static int ble_hs_hci_evt_le_dir_adv_rpt(uint8_t subevent, const void *data,
+                                         unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_direct_adv_rpt *ev = data;
-    struct ble_gap_disc_desc desc = {0};
-    int i;
-
-    if (len < sizeof(*ev) || len != ev->num_reports * sizeof(ev->reports[0])) {
-        return BLE_HS_ECONTROLLER;
-    }
-
-    /* Data fields not present in a direct advertising report. */
-    desc.data = NULL;
-    desc.length_data = 0;
-
-    for (i = 0; i < ev->num_reports; i++) {
-        desc.event_type = ev->reports[i].type;
-        desc.addr.type = ev->reports[i].addr_type;
-        memcpy(desc.addr.val, ev->reports[i].addr, BLE_DEV_ADDR_LEN);
-        desc.direct_addr.type = ev->reports[i].dir_addr_type;
-        memcpy(desc.direct_addr.val, ev->reports[i].dir_addr, BLE_DEV_ADDR_LEN);
-        desc.rssi = ev->reports[i].rssi;
-
-        ble_gap_rx_adv_report(&desc);
-    }
-
-    return 0;
+	const struct ble_hci_ev_le_subev_direct_adv_rpt *ev = data;
+	struct ble_gap_disc_desc desc = {0};
+	int i;
+
+	if (len < sizeof(*ev) || len != ev->num_reports * sizeof(ev->reports[0])) {
+		return BLE_HS_ECONTROLLER;
+	}
+
+	/* Data fields not present in a direct advertising report. */
+	desc.data = NULL;
+	desc.length_data = 0;
+
+	for (i = 0; i < ev->num_reports; i++) {
+		desc.event_type = ev->reports[i].type;
+		desc.addr.type = ev->reports[i].addr_type;
+		memcpy(desc.addr.val, ev->reports[i].addr, BLE_DEV_ADDR_LEN);
+		desc.direct_addr.type = ev->reports[i].dir_addr_type;
+		memcpy(desc.direct_addr.val, ev->reports[i].dir_addr, BLE_DEV_ADDR_LEN);
+		desc.rssi = ev->reports[i].rssi;
+
+		ble_gap_rx_adv_report(&desc);
+	}
+
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_rd_rem_used_feat_complete(uint8_t subevent, const void *data,
-                                            unsigned int len)
+static int ble_hs_hci_evt_le_rd_rem_used_feat_complete(uint8_t subevent,
+                                                       const void *data,
+                                                       unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_rd_rem_used_feat *ev = data;
+	const struct ble_hci_ev_le_subev_rd_rem_used_feat *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_gap_rx_rd_rem_sup_feat_complete(ev);
+	ble_gap_rx_rd_rem_sup_feat_complete(ev);
 
-    return 0;
+	return 0;
 }
 
 #if MYNEWT_VAL(BLE_EXT_ADV) && NIMBLE_BLE_SCAN
-static int
-ble_hs_hci_decode_legacy_type(uint16_t evt_type)
+static int ble_hs_hci_decode_legacy_type(uint16_t evt_type)
 {
-    switch (evt_type) {
-    case BLE_HCI_LEGACY_ADV_EVTYPE_ADV_IND:
-        return BLE_HCI_ADV_RPT_EVTYPE_ADV_IND;
-    case BLE_HCI_LEGACY_ADV_EVTYPE_ADV_DIRECT_IND:
-        return BLE_HCI_ADV_RPT_EVTYPE_DIR_IND;
-    case BLE_HCI_LEGACY_ADV_EVTYPE_ADV_SCAN_IND:
-        return BLE_HCI_ADV_RPT_EVTYPE_SCAN_IND;
-    case BLE_HCI_LEGACY_ADV_EVTYPE_ADV_NONCON_IND:
-        return BLE_HCI_ADV_RPT_EVTYPE_NONCONN_IND;
-    case BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_IND:
-    case BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_SCAN_IND:
-        return BLE_HCI_ADV_RPT_EVTYPE_SCAN_RSP;
-    default:
-        return -1;
-    }
+	switch (evt_type) {
+	case BLE_HCI_LEGACY_ADV_EVTYPE_ADV_IND:
+		return BLE_HCI_ADV_RPT_EVTYPE_ADV_IND;
+	case BLE_HCI_LEGACY_ADV_EVTYPE_ADV_DIRECT_IND:
+		return BLE_HCI_ADV_RPT_EVTYPE_DIR_IND;
+	case BLE_HCI_LEGACY_ADV_EVTYPE_ADV_SCAN_IND:
+		return BLE_HCI_ADV_RPT_EVTYPE_SCAN_IND;
+	case BLE_HCI_LEGACY_ADV_EVTYPE_ADV_NONCON_IND:
+		return BLE_HCI_ADV_RPT_EVTYPE_NONCONN_IND;
+	case BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_IND:
+	case BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_SCAN_IND:
+		return BLE_HCI_ADV_RPT_EVTYPE_SCAN_RSP;
+	default:
+		return -1;
+	}
 }
 #endif
 
-static int
-ble_hs_hci_evt_le_ext_adv_rpt(uint8_t subevent, const void *data,
-                              unsigned int len)
+static int ble_hs_hci_evt_le_ext_adv_rpt(uint8_t subevent, const void *data,
+                                         unsigned int len)
 {
 #if MYNEWT_VAL(BLE_EXT_ADV) && NIMBLE_BLE_SCAN
-    const struct ble_hci_ev_le_subev_ext_adv_rpt *ev = data;
-    const struct ext_adv_report *report;
-    struct ble_gap_ext_disc_desc desc;
-    int i;
-    int legacy_event_type;
-
-    if (len < sizeof(*ev)) {
-        return BLE_HS_EBADDATA;
-    }
-
-    if (ev->num_reports < BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN ||
-        ev->num_reports > BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX) {
-        return BLE_HS_EBADDATA;
-    }
-
-    /* TODO properly validate len of the event */
-
-    report = &ev->reports[0];
-    for (i = 0; i < ev->num_reports; i++) {
-        memset(&desc, 0, sizeof(desc));
-
-        desc.props = (report->evt_type) & 0x1F;
-        if (desc.props & BLE_HCI_ADV_LEGACY_MASK) {
-            legacy_event_type = ble_hs_hci_decode_legacy_type(report->evt_type);
-            if (legacy_event_type < 0) {
-                report = (const void *) &report->data[report->data_len];
-                continue;
-            }
-            desc.legacy_event_type = legacy_event_type;
-            desc.data_status = BLE_GAP_EXT_ADV_DATA_STATUS_COMPLETE;
-        } else {
-            switch(report->evt_type & BLE_HCI_ADV_DATA_STATUS_MASK) {
-            case BLE_HCI_ADV_DATA_STATUS_COMPLETE:
-                desc.data_status = BLE_GAP_EXT_ADV_DATA_STATUS_COMPLETE;
-                break;
-            case BLE_HCI_ADV_DATA_STATUS_INCOMPLETE:
-                desc.data_status = BLE_GAP_EXT_ADV_DATA_STATUS_INCOMPLETE;
-                break;
-            case BLE_HCI_ADV_DATA_STATUS_TRUNCATED:
-                desc.data_status = BLE_GAP_EXT_ADV_DATA_STATUS_TRUNCATED;
-                break;
-            default:
-                assert(false);
-            }
-        }
-        desc.addr.type = report->addr_type;
-        memcpy(desc.addr.val, report->addr, 6);
-        desc.length_data = report->data_len;
-        desc.data = report->data;
-        desc.rssi = report->rssi;
-        desc.tx_power = report->tx_power;
-        memcpy(desc.direct_addr.val, report->dir_addr, 6);
-        desc.direct_addr.type = report->dir_addr_type;
-        desc.sid = report->sid;
-        desc.prim_phy = report->pri_phy;
-        desc.sec_phy = report->sec_phy;
-        desc.periodic_adv_itvl = report->periodic_itvl;
-
-        ble_gap_rx_ext_adv_report(&desc);
-
-        report = (const void *) &report->data[report->data_len];
-    }
+	const struct ble_hci_ev_le_subev_ext_adv_rpt *ev = data;
+	const struct ext_adv_report *report;
+	struct ble_gap_ext_disc_desc desc;
+	int i;
+	int legacy_event_type;
+
+	if (len < sizeof(*ev)) {
+		return BLE_HS_EBADDATA;
+	}
+
+	if (ev->num_reports < BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN ||
+	    ev->num_reports > BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX) {
+		return BLE_HS_EBADDATA;
+	}
+
+	/* TODO properly validate len of the event */
+
+	report = &ev->reports[0];
+	for (i = 0; i < ev->num_reports; i++) {
+		memset(&desc, 0, sizeof(desc));
+
+		desc.props = (report->evt_type) & 0x1F;
+		if (desc.props & BLE_HCI_ADV_LEGACY_MASK) {
+			legacy_event_type = ble_hs_hci_decode_legacy_type(report->evt_type);
+			if (legacy_event_type < 0) {
+				report = (const void *) &report->data[report->data_len];
+				continue;
+			}
+			desc.legacy_event_type = legacy_event_type;
+			desc.data_status = BLE_GAP_EXT_ADV_DATA_STATUS_COMPLETE;
+		}
+		else {
+			switch (report->evt_type & BLE_HCI_ADV_DATA_STATUS_MASK) {
+			case BLE_HCI_ADV_DATA_STATUS_COMPLETE:
+				desc.data_status = BLE_GAP_EXT_ADV_DATA_STATUS_COMPLETE;
+				break;
+			case BLE_HCI_ADV_DATA_STATUS_INCOMPLETE:
+				desc.data_status = BLE_GAP_EXT_ADV_DATA_STATUS_INCOMPLETE;
+				break;
+			case BLE_HCI_ADV_DATA_STATUS_TRUNCATED:
+				desc.data_status = BLE_GAP_EXT_ADV_DATA_STATUS_TRUNCATED;
+				break;
+			default:
+				assert(false);
+			}
+		}
+		desc.addr.type = report->addr_type;
+		memcpy(desc.addr.val, report->addr, 6);
+		desc.length_data = report->data_len;
+		desc.data = report->data;
+		desc.rssi = report->rssi;
+		desc.tx_power = report->tx_power;
+		memcpy(desc.direct_addr.val, report->dir_addr, 6);
+		desc.direct_addr.type = report->dir_addr_type;
+		desc.sid = report->sid;
+		desc.prim_phy = report->pri_phy;
+		desc.sec_phy = report->sec_phy;
+		desc.periodic_adv_itvl = report->periodic_itvl;
+
+		ble_gap_rx_ext_adv_report(&desc);
+
+		report = (const void *) &report->data[report->data_len];
+	}
 #endif
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_periodic_adv_sync_estab(uint8_t subevent, const void *data,
-                                          unsigned int len)
+static int ble_hs_hci_evt_le_periodic_adv_sync_estab(uint8_t subevent,
+                                                     const void *data, unsigned int len)
 {
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-    const struct ble_hci_ev_le_subev_periodic_adv_sync_estab *ev = data;
+	const struct ble_hci_ev_le_subev_periodic_adv_sync_estab *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_gap_rx_peroidic_adv_sync_estab(ev);
+	ble_gap_rx_peroidic_adv_sync_estab(ev);
 #endif
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_periodic_adv_rpt(uint8_t subevent, const void *data,
-                                   unsigned int len)
+static int ble_hs_hci_evt_le_periodic_adv_rpt(uint8_t subevent, const void *data,
+                                              unsigned int len)
 {
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-    const struct ble_hci_ev_le_subev_periodic_adv_rpt *ev = data;
+	const struct ble_hci_ev_le_subev_periodic_adv_rpt *ev = data;
 
-    if (len < sizeof(*ev) || len != (sizeof(*ev) + ev->data_len)) {
-        return BLE_HS_EBADDATA;
-    }
+	if (len < sizeof(*ev) || len != (sizeof(*ev) + ev->data_len)) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_gap_rx_periodic_adv_rpt(ev);
+	ble_gap_rx_periodic_adv_rpt(ev);
 #endif
 
-return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_periodic_adv_sync_lost(uint8_t subevent, const void *data,
-                                         unsigned int len)
+static int ble_hs_hci_evt_le_periodic_adv_sync_lost(uint8_t subevent,
+                                                    const void *data, unsigned int len)
 {
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-    const struct ble_hci_ev_le_subev_periodic_adv_sync_lost *ev = data;
+	const struct ble_hci_ev_le_subev_periodic_adv_sync_lost *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_EBADDATA;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_gap_rx_periodic_adv_sync_lost(ev);
+	ble_gap_rx_periodic_adv_sync_lost(ev);
 
 #endif
-    return 0;
+	return 0;
 }
 
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
-static int
-ble_hs_hci_evt_le_pathloss_threshold(uint8_t subevent, const void *data,
-					     unsigned int len)
+static int ble_hs_hci_evt_le_pathloss_threshold(uint8_t subevent, const void *data,
+                                                unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_path_loss_threshold *ev = data;
+	const struct ble_hci_ev_le_subev_path_loss_threshold *ev = data;
 
-    if (len != sizeof(*ev)) {
-	return BLE_HS_EBADDATA;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_gap_rx_le_pathloss_threshold(ev);
-    return 0;
+	ble_gap_rx_le_pathloss_threshold(ev);
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_transmit_power_report(uint8_t subevent, const void *data,
-					     unsigned int len)
+static int ble_hs_hci_evt_le_transmit_power_report(uint8_t subevent,
+                                                   const void *data, unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_transmit_power_report *ev = data;
+	const struct ble_hci_ev_le_subev_transmit_power_report *ev = data;
 
-    if (len != sizeof(*ev)) {
-	return BLE_HS_EBADDATA;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_gap_rx_transmit_power_report(ev);
-    return 0;
+	ble_gap_rx_transmit_power_report(ev);
+	return 0;
 }
 #endif
 
-static int
-ble_hs_hci_evt_le_periodic_adv_sync_transfer(uint8_t subevent, const void *data,
-                                             unsigned int len)
+static int ble_hs_hci_evt_le_periodic_adv_sync_transfer(uint8_t subevent,
+                                                        const void *data,
+                                                        unsigned int len)
 {
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_TRANSFER)
-    const struct ble_hci_ev_le_subev_periodic_adv_sync_transfer *ev = data;
+	const struct ble_hci_ev_le_subev_periodic_adv_sync_transfer *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_EBADDATA;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_gap_rx_periodic_adv_sync_transfer(ev);
+	ble_gap_rx_periodic_adv_sync_transfer(ev);
 
 #endif
-    return 0;
+	return 0;
 }
 
 #if MYNEWT_VAL(BLE_ISO_BROADCAST_SOURCE)
-static int
-ble_hs_hci_evt_le_create_big_complete(uint8_t subevent, const void *data,
-                                      unsigned int len)
+static int ble_hs_hci_evt_le_create_big_complete(uint8_t subevent, const void *data,
+                                                 unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_create_big_complete *ev = data;
+	const struct ble_hci_ev_le_subev_create_big_complete *ev = data;
 
-    if (len != sizeof(*ev) + (ev->num_bis * sizeof(ev->conn_handle[0]))) {
-        return BLE_HS_EBADDATA;
-    }
+	if (len != sizeof(*ev) + (ev->num_bis * sizeof(ev->conn_handle[0]))) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_iso_rx_create_big_complete(ev);
+	ble_iso_rx_create_big_complete(ev);
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_terminate_big_complete(uint8_t subevent, const void *data,
-                                         unsigned int len)
+static int ble_hs_hci_evt_le_terminate_big_complete(uint8_t subevent,
+                                                    const void *data, unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_terminate_big_complete *ev = data;
+	const struct ble_hci_ev_le_subev_terminate_big_complete *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_EBADDATA;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_iso_rx_terminate_big_complete(ev);
+	ble_iso_rx_terminate_big_complete(ev);
 
-    return 0;
+	return 0;
 }
 #endif
 
 #if MYNEWT_VAL(BLE_ISO_BROADCAST_SINK)
-static int
-ble_hs_hci_evt_le_big_sync_established(uint8_t subevent, const void *data,
-                                       unsigned int len)
+static int ble_hs_hci_evt_le_big_sync_established(uint8_t subevent, const void *data,
+                                                  unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_big_sync_established *ev = data;
+	const struct ble_hci_ev_le_subev_big_sync_established *ev = data;
 
-    if (len < sizeof(*ev) ||
-        len != (sizeof(*ev) + ev->num_bis * sizeof(ev->conn_handle[0]))) {
-        return BLE_HS_EBADDATA;
-    }
+	if (len < sizeof(*ev) ||
+	    len != (sizeof(*ev) + ev->num_bis * sizeof(ev->conn_handle[0]))) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_iso_rx_big_sync_established(ev);
+	ble_iso_rx_big_sync_established(ev);
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_big_sync_lost(uint8_t subevent, const void *data,
-                                unsigned int len)
+static int ble_hs_hci_evt_le_big_sync_lost(uint8_t subevent, const void *data,
+                                           unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_big_sync_lost *ev = data;
+	const struct ble_hci_ev_le_subev_big_sync_lost *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_EBADDATA;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_iso_rx_big_sync_lost(ev);
+	ble_iso_rx_big_sync_lost(ev);
 
-    return 0;
+	return 0;
 }
 #endif
 
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_BIGINFO_REPORTS)
-static int
-ble_hs_hci_evt_le_biginfo_adv_report(uint8_t subevent, const void *data,
-                                     unsigned int len)
+static int ble_hs_hci_evt_le_biginfo_adv_report(uint8_t subevent, const void *data,
+                                                unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_biginfo_adv_report *ev = data;
+	const struct ble_hci_ev_le_subev_biginfo_adv_report *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_EBADDATA;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_gap_rx_biginfo_adv_rpt(ev);
+	ble_gap_rx_biginfo_adv_rpt(ev);
 
-    return 0;
+	return 0;
 }
 #endif
 
-static int
-ble_hs_hci_evt_le_scan_timeout(uint8_t subevent, const void *data,
-                               unsigned int len)
+static int ble_hs_hci_evt_le_scan_timeout(uint8_t subevent, const void *data,
+                                          unsigned int len)
 {
 #if MYNEWT_VAL(BLE_EXT_ADV) && NIMBLE_BLE_SCAN
-    const struct ble_hci_ev_le_subev_scan_timeout *ev = data;
+	const struct ble_hci_ev_le_subev_scan_timeout *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_EBADDATA;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_EBADDATA;
+	}
 
-    ble_gap_rx_le_scan_timeout();
+	ble_gap_rx_le_scan_timeout();
 #endif
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_adv_set_terminated(uint8_t subevent, const void *data,
-                                     unsigned int len)
+static int ble_hs_hci_evt_le_adv_set_terminated(uint8_t subevent, const void *data,
+                                                unsigned int len)
 {
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    const struct ble_hci_ev_le_subev_adv_set_terminated *ev = data;
+	const struct ble_hci_ev_le_subev_adv_set_terminated *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    if (ev->status == 0) {
-        /* ignore return code as we need to terminate advertising set anyway */
-        ble_gap_rx_conn_complete(&pend_conn_complete, ev->adv_handle);
-    }
-    ble_gap_rx_adv_set_terminated(ev);
+	if (ev->status == 0) {
+		/* ignore return code as we need to terminate advertising set anyway */
+		ble_gap_rx_conn_complete(&pend_conn_complete, ev->adv_handle);
+	}
+	ble_gap_rx_adv_set_terminated(ev);
 #endif
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_scan_req_rcvd(uint8_t subevent, const void *data,
-                                unsigned int len)
+static int ble_hs_hci_evt_le_scan_req_rcvd(uint8_t subevent, const void *data,
+                                           unsigned int len)
 {
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    const struct ble_hci_ev_le_subev_scan_req_rcvd *ev = data;
+	const struct ble_hci_ev_le_subev_scan_req_rcvd *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_gap_rx_scan_req_rcvd(ev);
+	ble_gap_rx_scan_req_rcvd(ev);
 #endif
 
-    return 0;
+	return 0;
 }
 
 #if MYNEWT_VAL(BLE_CONN_SUBRATING)
-static int
-ble_hs_hci_evt_le_subrate_change(uint8_t subevent, const void *data,
-                                 unsigned int len)
+static int ble_hs_hci_evt_le_subrate_change(uint8_t subevent, const void *data,
+                                            unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_subrate_change *ev = data;
+	const struct ble_hci_ev_le_subev_subrate_change *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_gap_rx_subrate_change(ev);
+	ble_gap_rx_subrate_change(ev);
 
-    return 0;
+	return 0;
 }
 #endif
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_hs_hci_evt_le_conn_upd_complete(uint8_t subevent, const void *data,
-                                    unsigned int len)
+static int ble_hs_hci_evt_le_conn_upd_complete(uint8_t subevent, const void *data,
+                                               unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_conn_upd_complete *ev = data;
+	const struct ble_hci_ev_le_subev_conn_upd_complete *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    if (ev->status == 0) {
-        BLE_HS_DBG_ASSERT(le16toh(ev->conn_itvl) >= BLE_HCI_CONN_ITVL_MIN);
-        BLE_HS_DBG_ASSERT(le16toh(ev->conn_itvl) <= BLE_HCI_CONN_ITVL_MAX);
+	if (ev->status == 0) {
+		BLE_HS_DBG_ASSERT(le16toh(ev->conn_itvl) >= BLE_HCI_CONN_ITVL_MIN);
+		BLE_HS_DBG_ASSERT(le16toh(ev->conn_itvl) <= BLE_HCI_CONN_ITVL_MAX);
 
-        BLE_HS_DBG_ASSERT(le16toh(ev->conn_latency) >= BLE_HCI_CONN_LATENCY_MIN);
-        BLE_HS_DBG_ASSERT(le16toh(ev->conn_latency) <= BLE_HCI_CONN_LATENCY_MAX);
+		BLE_HS_DBG_ASSERT(le16toh(ev->conn_latency) >= BLE_HCI_CONN_LATENCY_MIN);
+		BLE_HS_DBG_ASSERT(le16toh(ev->conn_latency) <= BLE_HCI_CONN_LATENCY_MAX);
 
-        BLE_HS_DBG_ASSERT(le16toh(ev->supervision_timeout) >= BLE_HCI_CONN_SPVN_TIMEOUT_MIN);
-        BLE_HS_DBG_ASSERT(le16toh(ev->supervision_timeout) <= BLE_HCI_CONN_SPVN_TIMEOUT_MAX);
-    }
+		BLE_HS_DBG_ASSERT(le16toh(ev->supervision_timeout) >= BLE_HCI_CONN_SPVN_TIMEOUT_MIN);
+		BLE_HS_DBG_ASSERT(le16toh(ev->supervision_timeout) <= BLE_HCI_CONN_SPVN_TIMEOUT_MAX);
+	}
 
-    ble_gap_rx_update_complete(ev);
+	ble_gap_rx_update_complete(ev);
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_lt_key_req(uint8_t subevent, const void *data, unsigned int len)
+static int ble_hs_hci_evt_le_lt_key_req(uint8_t subevent, const void *data,
+                                        unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_lt_key_req *ev = data;
+	const struct ble_hci_ev_le_subev_lt_key_req *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_sm_ltk_req_rx(ev);
+	ble_sm_ltk_req_rx(ev);
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_conn_parm_req(uint8_t subevent, const void *data, unsigned int len)
+static int ble_hs_hci_evt_le_conn_parm_req(uint8_t subevent, const void *data,
+                                           unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_rem_conn_param_req *ev = data;
+	const struct ble_hci_ev_le_subev_rem_conn_param_req *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    BLE_HS_DBG_ASSERT(le16toh(ev->min_interval) >= BLE_HCI_CONN_ITVL_MIN);
-    BLE_HS_DBG_ASSERT(le16toh(ev->max_interval) <= BLE_HCI_CONN_ITVL_MAX);
-    BLE_HS_DBG_ASSERT(le16toh(ev->max_interval) >= le16toh(ev->min_interval));
+	BLE_HS_DBG_ASSERT(le16toh(ev->min_interval) >= BLE_HCI_CONN_ITVL_MIN);
+	BLE_HS_DBG_ASSERT(le16toh(ev->max_interval) <= BLE_HCI_CONN_ITVL_MAX);
+	BLE_HS_DBG_ASSERT(le16toh(ev->max_interval) >= le16toh(ev->min_interval));
 
-    BLE_HS_DBG_ASSERT(le16toh(ev->latency) >= BLE_HCI_CONN_LATENCY_MIN);
-    BLE_HS_DBG_ASSERT(le16toh(ev->latency) <= BLE_HCI_CONN_LATENCY_MAX);
+	BLE_HS_DBG_ASSERT(le16toh(ev->latency) >= BLE_HCI_CONN_LATENCY_MIN);
+	BLE_HS_DBG_ASSERT(le16toh(ev->latency) <= BLE_HCI_CONN_LATENCY_MAX);
 
-    BLE_HS_DBG_ASSERT(le16toh(ev->timeout) >= BLE_HCI_CONN_SPVN_TIMEOUT_MIN);
-    BLE_HS_DBG_ASSERT(le16toh(ev->timeout) <= BLE_HCI_CONN_SPVN_TIMEOUT_MAX);
+	BLE_HS_DBG_ASSERT(le16toh(ev->timeout) >= BLE_HCI_CONN_SPVN_TIMEOUT_MIN);
+	BLE_HS_DBG_ASSERT(le16toh(ev->timeout) <= BLE_HCI_CONN_SPVN_TIMEOUT_MAX);
 
-    ble_gap_rx_param_req(ev);
+	ble_gap_rx_param_req(ev);
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_hs_hci_evt_le_phy_update_complete(uint8_t subevent, const void *data,
-                                      unsigned int len)
+static int ble_hs_hci_evt_le_phy_update_complete(uint8_t subevent, const void *data,
+                                                 unsigned int len)
 {
-    const struct ble_hci_ev_le_subev_phy_update_complete *ev = data;
+	const struct ble_hci_ev_le_subev_phy_update_complete *ev = data;
 
-    if (len != sizeof(*ev)) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (len != sizeof(*ev)) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    ble_gap_rx_phy_update_complete(ev);
+	ble_gap_rx_phy_update_complete(ev);
 
-    return 0;
+	return 0;
 }
 #endif
 
-int
-ble_hs_hci_evt_process(struct ble_hci_ev *ev)
+int ble_hs_hci_evt_process(struct ble_hci_ev *ev)
 {
-    const struct ble_hs_hci_evt_dispatch_entry *entry;
-    int rc;
+	const struct ble_hs_hci_evt_dispatch_entry *entry;
+	int rc;
 
-    /* Count events received */
-    STATS_INC(ble_hs_stats, hci_event);
+	/* Count events received */
+	STATS_INC(ble_hs_stats, hci_event);
 
 
-    entry = ble_hs_hci_evt_dispatch_find(ev->opcode);
-    if (entry == NULL) {
+	entry = ble_hs_hci_evt_dispatch_find(ev->opcode);
+	if (entry == NULL) {
 #if MYNEWT_VAL(BLE_HS_GAP_UNHANDLED_HCI_EVENT)
-        ble_gap_unhandled_hci_event(false, false, ev->data, ev->length);
+		ble_gap_unhandled_hci_event(false, false, ev->data, ev->length);
 #endif
-        STATS_INC(ble_hs_stats, hci_unknown_event);
-        rc = BLE_HS_ENOTSUP;
-    } else {
-        rc = entry->cb(ev->opcode, ev->data, ev->length);
-    }
+		STATS_INC(ble_hs_stats, hci_unknown_event);
+		rc = BLE_HS_ENOTSUP;
+	}
+	else {
+		rc = entry->cb(ev->opcode, ev->data, ev->length);
+	}
 
-    ble_transport_free(ev);
+	ble_transport_free(ev);
 
-    return rc;
+	return rc;
 }
 
 /**
@@ -1026,81 +994,81 @@ ble_hs_hci_evt_process(struct ble_hci_ev *ev)
  *
  * @return                      0 on success; nonzero on failure.
  */
-int
-ble_hs_hci_evt_acl_process(struct os_mbuf *om)
+int ble_hs_hci_evt_acl_process(struct os_mbuf *om)
 {
 #if NIMBLE_BLE_CONNECT
-    struct hci_data_hdr hci_hdr;
-    struct ble_hs_conn *conn;
-    ble_l2cap_rx_fn *rx_cb;
-    uint16_t conn_handle;
-    int reject_cid;
-    int rc;
-
-    rc = ble_hs_hci_util_data_hdr_strip(om, &hci_hdr);
-    if (rc != 0) {
-        goto err;
-    }
+	struct hci_data_hdr hci_hdr;
+	struct ble_hs_conn *conn;
+	ble_l2cap_rx_fn *rx_cb;
+	uint16_t conn_handle;
+	int reject_cid;
+	int rc;
+
+	rc = ble_hs_hci_util_data_hdr_strip(om, &hci_hdr);
+	if (rc != 0) {
+		goto err;
+	}
 
 #if (BLETEST_THROUGHPUT_TEST == 0)
 #if !BLE_MONITOR
-    BLE_HS_LOG(DEBUG, "ble_hs_hci_evt_acl_process(): conn_handle=%u pb=%x "
-                      "len=%u data=",
-               BLE_HCI_DATA_HANDLE(hci_hdr.hdh_handle_pb_bc),
-               BLE_HCI_DATA_PB(hci_hdr.hdh_handle_pb_bc),
-               hci_hdr.hdh_len);
-    ble_hs_log_mbuf(om);
-    BLE_HS_LOG(DEBUG, "\n");
+	BLE_HS_LOG(DEBUG,
+	           "ble_hs_hci_evt_acl_process(): conn_handle=%u pb=%x "
+	           "len=%u data=",
+	           BLE_HCI_DATA_HANDLE(hci_hdr.hdh_handle_pb_bc),
+	           BLE_HCI_DATA_PB(hci_hdr.hdh_handle_pb_bc), hci_hdr.hdh_len);
+	ble_hs_log_mbuf(om);
+	BLE_HS_LOG(DEBUG, "\n");
 #endif
 #endif
 
-    if (hci_hdr.hdh_len != OS_MBUF_PKTHDR(om)->omp_len) {
-        rc = BLE_HS_EBADDATA;
-        goto err;
-    }
-
-    conn_handle = BLE_HCI_DATA_HANDLE(hci_hdr.hdh_handle_pb_bc);
-
-    ble_hs_lock();
-
-    conn = ble_hs_conn_find(conn_handle);
-    if (conn == NULL) {
-        /* Peer not connected; quietly discard packet. */
-        rc = BLE_HS_ENOTCONN;
-        reject_cid = -1;
-    } else {
-        /* Forward ACL data to L2CAP. */
-        rc = ble_l2cap_rx(conn, &hci_hdr, om, &rx_cb, &reject_cid);
-        om = NULL;
-    }
-
-    ble_hs_unlock();
-
-    switch (rc) {
-    case 0:
-        /* Final fragment received. */
-        BLE_HS_DBG_ASSERT(rx_cb != NULL);
-        rc = rx_cb(conn->bhc_rx_chan);
-        ble_l2cap_remove_rx(conn, conn->bhc_rx_chan);
-        break;
-
-    case BLE_HS_EAGAIN:
-        /* More fragments on the way. */
-        break;
-
-    default:
-        if (reject_cid != -1) {
-            ble_l2cap_sig_reject_invalid_cid_tx(conn_handle, 0, 0, reject_cid);
-        }
-        goto err;
-    }
-
-    return 0;
+	if (hci_hdr.hdh_len != OS_MBUF_PKTHDR(om)->omp_len) {
+		rc = BLE_HS_EBADDATA;
+		goto err;
+	}
+
+	conn_handle = BLE_HCI_DATA_HANDLE(hci_hdr.hdh_handle_pb_bc);
+
+	ble_hs_lock();
+
+	conn = ble_hs_conn_find(conn_handle);
+	if (conn == NULL) {
+		/* Peer not connected; quietly discard packet. */
+		rc = BLE_HS_ENOTCONN;
+		reject_cid = -1;
+	}
+	else {
+		/* Forward ACL data to L2CAP. */
+		rc = ble_l2cap_rx(conn, &hci_hdr, om, &rx_cb, &reject_cid);
+		om = NULL;
+	}
+
+	ble_hs_unlock();
+
+	switch (rc) {
+	case 0:
+		/* Final fragment received. */
+		BLE_HS_DBG_ASSERT(rx_cb != NULL);
+		rc = rx_cb(conn->bhc_rx_chan);
+		ble_l2cap_remove_rx(conn, conn->bhc_rx_chan);
+		break;
+
+	case BLE_HS_EAGAIN:
+		/* More fragments on the way. */
+		break;
+
+	default:
+		if (reject_cid != -1) {
+			ble_l2cap_sig_reject_invalid_cid_tx(conn_handle, 0, 0, reject_cid);
+		}
+		goto err;
+	}
+
+	return 0;
 
 err:
-    os_mbuf_free_chain(om);
-    return rc;
+	os_mbuf_free_chain(om);
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
diff --git a/nimble/host/src/ble_sm.c b/nimble/host/src/ble_sm.c
index 0b7c28db..ccad0f2c 100644
--- a/nimble/host/src/ble_sm.c
+++ b/nimble/host/src/ble_sm.c
@@ -61,7 +61,7 @@
 #if NIMBLE_BLE_SM
 
 /** Procedure timeout; 30 seconds. */
-#define BLE_SM_TIMEOUT_MS             (30000)
+#define BLE_SM_TIMEOUT_MS (30000)
 
 STAILQ_HEAD(ble_sm_proc_list, ble_sm_proc);
 
@@ -81,38 +81,37 @@ static ble_sm_rx_fn ble_sm_id_addr_info_rx;
 static ble_sm_rx_fn ble_sm_sign_info_rx;
 static ble_sm_rx_fn ble_sm_sec_req_rx;
 
-static ble_sm_rx_fn * const ble_sm_dispatch[] = {
-   [BLE_SM_OP_PAIR_REQ] = ble_sm_pair_req_rx,
-   [BLE_SM_OP_PAIR_RSP] = ble_sm_pair_rsp_rx,
-   [BLE_SM_OP_PAIR_CONFIRM] = ble_sm_confirm_rx,
-   [BLE_SM_OP_PAIR_RANDOM] = ble_sm_random_rx,
-   [BLE_SM_OP_PAIR_FAIL] = ble_sm_fail_rx,
-   [BLE_SM_OP_ENC_INFO] = ble_sm_enc_info_rx,
-   [BLE_SM_OP_MASTER_ID] = ble_sm_master_id_rx,
-   [BLE_SM_OP_IDENTITY_INFO] = ble_sm_id_info_rx,
-   [BLE_SM_OP_IDENTITY_ADDR_INFO] = ble_sm_id_addr_info_rx,
-   [BLE_SM_OP_SIGN_INFO] = ble_sm_sign_info_rx,
-   [BLE_SM_OP_SEC_REQ] = ble_sm_sec_req_rx,
-   [BLE_SM_OP_PAIR_KEYPRESS_NOTIFY] = ble_sm_rx_noop,
+static ble_sm_rx_fn *const ble_sm_dispatch[] = {
+	[BLE_SM_OP_PAIR_REQ] = ble_sm_pair_req_rx,
+	[BLE_SM_OP_PAIR_RSP] = ble_sm_pair_rsp_rx,
+	[BLE_SM_OP_PAIR_CONFIRM] = ble_sm_confirm_rx,
+	[BLE_SM_OP_PAIR_RANDOM] = ble_sm_random_rx,
+	[BLE_SM_OP_PAIR_FAIL] = ble_sm_fail_rx,
+	[BLE_SM_OP_ENC_INFO] = ble_sm_enc_info_rx,
+	[BLE_SM_OP_MASTER_ID] = ble_sm_master_id_rx,
+	[BLE_SM_OP_IDENTITY_INFO] = ble_sm_id_info_rx,
+	[BLE_SM_OP_IDENTITY_ADDR_INFO] = ble_sm_id_addr_info_rx,
+	[BLE_SM_OP_SIGN_INFO] = ble_sm_sign_info_rx,
+	[BLE_SM_OP_SEC_REQ] = ble_sm_sec_req_rx,
+	[BLE_SM_OP_PAIR_KEYPRESS_NOTIFY] = ble_sm_rx_noop,
 #if MYNEWT_VAL(BLE_SM_SC)
-   [BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_sc_public_key_rx,
-   [BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_sc_dhkey_check_rx,
+	[BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_sc_public_key_rx,
+	[BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_sc_dhkey_check_rx,
 #else
-   [BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_rx_noop,
-   [BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_rx_noop,
+	[BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_rx_noop,
+	[BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_rx_noop,
 #endif
 };
 
-struct hci_start_encrypt
-{
-    uint16_t connection_handle;
-    uint16_t encrypted_diversifier;
-    uint64_t random_number;
-    uint8_t long_term_key[16];
+struct hci_start_encrypt {
+	uint16_t connection_handle;
+	uint16_t encrypted_diversifier;
+	uint64_t random_number;
+	uint8_t long_term_key[16];
 };
 
-typedef void ble_sm_state_fn(struct ble_sm_proc *proc,
-                             struct ble_sm_result *res, void *arg);
+typedef void ble_sm_state_fn(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                             void *arg);
 
 static ble_sm_state_fn ble_sm_pair_exec;
 static ble_sm_state_fn ble_sm_confirm_exec;
@@ -124,30 +123,27 @@ static ble_sm_state_fn ble_sm_enc_restore_exec;
 static ble_sm_state_fn ble_sm_key_exch_exec;
 static ble_sm_state_fn ble_sm_sec_req_exec;
 
-static ble_sm_state_fn * const
-ble_sm_state_dispatch[BLE_SM_PROC_STATE_CNT] = {
-    [BLE_SM_PROC_STATE_PAIR]          = ble_sm_pair_exec,
-    [BLE_SM_PROC_STATE_CONFIRM]       = ble_sm_confirm_exec,
-    [BLE_SM_PROC_STATE_RANDOM]        = ble_sm_random_exec,
-    [BLE_SM_PROC_STATE_LTK_START]     = ble_sm_ltk_start_exec,
-    [BLE_SM_PROC_STATE_LTK_RESTORE]   = ble_sm_ltk_restore_exec,
-    [BLE_SM_PROC_STATE_ENC_START]     = ble_sm_enc_start_exec,
-    [BLE_SM_PROC_STATE_ENC_RESTORE]   = ble_sm_enc_restore_exec,
-    [BLE_SM_PROC_STATE_KEY_EXCH]      = ble_sm_key_exch_exec,
-    [BLE_SM_PROC_STATE_SEC_REQ]       = ble_sm_sec_req_exec,
+static ble_sm_state_fn *const ble_sm_state_dispatch[BLE_SM_PROC_STATE_CNT] = {
+	[BLE_SM_PROC_STATE_PAIR] = ble_sm_pair_exec,
+	[BLE_SM_PROC_STATE_CONFIRM] = ble_sm_confirm_exec,
+	[BLE_SM_PROC_STATE_RANDOM] = ble_sm_random_exec,
+	[BLE_SM_PROC_STATE_LTK_START] = ble_sm_ltk_start_exec,
+	[BLE_SM_PROC_STATE_LTK_RESTORE] = ble_sm_ltk_restore_exec,
+	[BLE_SM_PROC_STATE_ENC_START] = ble_sm_enc_start_exec,
+	[BLE_SM_PROC_STATE_ENC_RESTORE] = ble_sm_enc_restore_exec,
+	[BLE_SM_PROC_STATE_KEY_EXCH] = ble_sm_key_exch_exec,
+	[BLE_SM_PROC_STATE_SEC_REQ] = ble_sm_sec_req_exec,
 #if MYNEWT_VAL(BLE_SM_SC)
-    [BLE_SM_PROC_STATE_PUBLIC_KEY]    = ble_sm_sc_public_key_exec,
-    [BLE_SM_PROC_STATE_DHKEY_CHECK]   = ble_sm_sc_dhkey_check_exec,
+	[BLE_SM_PROC_STATE_PUBLIC_KEY] = ble_sm_sc_public_key_exec,
+	[BLE_SM_PROC_STATE_DHKEY_CHECK] = ble_sm_sc_dhkey_check_exec,
 #else
-    [BLE_SM_PROC_STATE_PUBLIC_KEY]    = NULL,
-    [BLE_SM_PROC_STATE_DHKEY_CHECK]   = NULL,
+	[BLE_SM_PROC_STATE_PUBLIC_KEY] = NULL,
+	[BLE_SM_PROC_STATE_DHKEY_CHECK] = NULL,
 #endif
 };
 
-static os_membuf_t ble_sm_proc_mem[
-    OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_SM_MAX_PROCS),
-                    sizeof (struct ble_sm_proc))
-];
+static os_membuf_t ble_sm_proc_mem[OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_SM_MAX_PROCS),
+                                                   sizeof(struct ble_sm_proc))];
 
 static struct os_mempool ble_sm_proc_pool;
 
@@ -174,63 +170,54 @@ static uint8_t ble_sm_dbg_next_ltk_set;
 static uint8_t ble_sm_dbg_next_csrk[16];
 static uint8_t ble_sm_dbg_next_csrk_set;
 
-void
-ble_sm_dbg_set_next_pair_rand(uint8_t *next_pair_rand)
+void ble_sm_dbg_set_next_pair_rand(uint8_t *next_pair_rand)
 {
-    memcpy(ble_sm_dbg_next_pair_rand, next_pair_rand,
-           sizeof ble_sm_dbg_next_pair_rand);
-    ble_sm_dbg_next_pair_rand_set = 1;
+	memcpy(ble_sm_dbg_next_pair_rand, next_pair_rand, sizeof ble_sm_dbg_next_pair_rand);
+	ble_sm_dbg_next_pair_rand_set = 1;
 }
 
-void
-ble_sm_dbg_set_next_ediv(uint16_t next_ediv)
+void ble_sm_dbg_set_next_ediv(uint16_t next_ediv)
 {
-    ble_sm_dbg_next_ediv = next_ediv;
-    ble_sm_dbg_next_ediv_set = 1;
+	ble_sm_dbg_next_ediv = next_ediv;
+	ble_sm_dbg_next_ediv_set = 1;
 }
 
-void
-ble_sm_dbg_set_next_master_id_rand(uint64_t next_master_id_rand)
+void ble_sm_dbg_set_next_master_id_rand(uint64_t next_master_id_rand)
 {
-    ble_sm_dbg_next_master_id_rand = next_master_id_rand;
-    ble_sm_dbg_next_master_id_rand_set = 1;
+	ble_sm_dbg_next_master_id_rand = next_master_id_rand;
+	ble_sm_dbg_next_master_id_rand_set = 1;
 }
 
-void
-ble_sm_dbg_set_next_ltk(uint8_t *next_ltk)
+void ble_sm_dbg_set_next_ltk(uint8_t *next_ltk)
 {
-    memcpy(ble_sm_dbg_next_ltk, next_ltk,
-           sizeof ble_sm_dbg_next_ltk);
-    ble_sm_dbg_next_ltk_set = 1;
+	memcpy(ble_sm_dbg_next_ltk, next_ltk, sizeof ble_sm_dbg_next_ltk);
+	ble_sm_dbg_next_ltk_set = 1;
 }
 
-void
-ble_sm_dbg_set_next_csrk(uint8_t *next_csrk)
+void ble_sm_dbg_set_next_csrk(uint8_t *next_csrk)
 {
-    memcpy(ble_sm_dbg_next_csrk, next_csrk,
-           sizeof ble_sm_dbg_next_csrk);
-    ble_sm_dbg_next_csrk_set = 1;
+	memcpy(ble_sm_dbg_next_csrk, next_csrk, sizeof ble_sm_dbg_next_csrk);
+	ble_sm_dbg_next_csrk_set = 1;
 }
 
 #endif
 
-static void
-ble_sm_dbg_assert_no_cycles(void)
+static void ble_sm_dbg_assert_no_cycles(void)
 {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    ble_sm_num_procs();
+	ble_sm_num_procs();
 #endif
 }
 
-static void
-ble_sm_dbg_assert_not_inserted(struct ble_sm_proc *proc)
+static void ble_sm_dbg_assert_not_inserted(struct ble_sm_proc *proc)
 {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    struct ble_sm_proc *cur;
+	struct ble_sm_proc *cur;
 
-    STAILQ_FOREACH(cur, &ble_sm_procs, next) {
-        BLE_HS_DBG_ASSERT(cur != proc);
-    }
+	STAILQ_FOREACH(cur, &ble_sm_procs, next)
+	{
+		BLE_HS_DBG_ASSERT(cur != proc);
+	}
 #endif
 }
 
@@ -241,148 +228,138 @@ ble_sm_dbg_assert_not_inserted(struct ble_sm_proc *proc)
 /**
  * Calculates the number of active SM procedures.
  */
-int
-ble_sm_num_procs(void)
+int ble_sm_num_procs(void)
 {
-    struct ble_sm_proc *proc;
-    int cnt;
+	struct ble_sm_proc *proc;
+	int cnt;
 
-    cnt = 0;
-    STAILQ_FOREACH(proc, &ble_sm_procs, next) {
-        BLE_HS_DBG_ASSERT(cnt < MYNEWT_VAL(BLE_SM_MAX_PROCS));
-        cnt++;
-    }
+	cnt = 0;
+	STAILQ_FOREACH(proc, &ble_sm_procs, next)
+	{
+		BLE_HS_DBG_ASSERT(cnt < MYNEWT_VAL(BLE_SM_MAX_PROCS));
+		cnt++;
+	}
 
-    return cnt;
+	return cnt;
 }
 
-int
-ble_sm_gen_pair_rand(uint8_t *pair_rand)
+int ble_sm_gen_pair_rand(uint8_t *pair_rand)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_pair_rand_set) {
-        ble_sm_dbg_next_pair_rand_set = 0;
-        memcpy(pair_rand, ble_sm_dbg_next_pair_rand,
-               sizeof ble_sm_dbg_next_pair_rand);
-        return 0;
-    }
+	if (ble_sm_dbg_next_pair_rand_set) {
+		ble_sm_dbg_next_pair_rand_set = 0;
+		memcpy(pair_rand, ble_sm_dbg_next_pair_rand, sizeof ble_sm_dbg_next_pair_rand);
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(pair_rand, 16);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(pair_rand, 16);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_gen_ediv(struct ble_sm_master_id *master_id)
+static int ble_sm_gen_ediv(struct ble_sm_master_id *master_id)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_ediv_set) {
-        ble_sm_dbg_next_ediv_set = 0;
-        master_id->ediv = ble_sm_dbg_next_ediv;
-        return 0;
-    }
+	if (ble_sm_dbg_next_ediv_set) {
+		ble_sm_dbg_next_ediv_set = 0;
+		master_id->ediv = ble_sm_dbg_next_ediv;
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(&master_id->ediv, sizeof master_id->ediv);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(&master_id->ediv, sizeof master_id->ediv);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_gen_master_id_rand(struct ble_sm_master_id *master_id)
+static int ble_sm_gen_master_id_rand(struct ble_sm_master_id *master_id)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_master_id_rand_set) {
-        ble_sm_dbg_next_master_id_rand_set = 0;
-        master_id->rand_val = ble_sm_dbg_next_master_id_rand;
-        return 0;
-    }
+	if (ble_sm_dbg_next_master_id_rand_set) {
+		ble_sm_dbg_next_master_id_rand_set = 0;
+		master_id->rand_val = ble_sm_dbg_next_master_id_rand;
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(&master_id->rand_val, sizeof master_id->rand_val);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(&master_id->rand_val, sizeof master_id->rand_val);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_gen_ltk(struct ble_sm_proc *proc, uint8_t *ltk)
+static int ble_sm_gen_ltk(struct ble_sm_proc *proc, uint8_t *ltk)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_ltk_set) {
-        ble_sm_dbg_next_ltk_set = 0;
-        memcpy(ltk, ble_sm_dbg_next_ltk,
-               sizeof ble_sm_dbg_next_ltk);
-        return 0;
-    }
+	if (ble_sm_dbg_next_ltk_set) {
+		ble_sm_dbg_next_ltk_set = 0;
+		memcpy(ltk, ble_sm_dbg_next_ltk, sizeof ble_sm_dbg_next_ltk);
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(ltk, proc->key_size);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(ltk, proc->key_size);
+	if (rc != 0) {
+		return rc;
+	}
 
-    /* Ensure proper key size */
-    memset(ltk + proc->key_size, 0, sizeof proc->ltk - proc->key_size);
+	/* Ensure proper key size */
+	memset(ltk + proc->key_size, 0, sizeof proc->ltk - proc->key_size);
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_gen_csrk(struct ble_sm_proc *proc, uint8_t *csrk)
+static int ble_sm_gen_csrk(struct ble_sm_proc *proc, uint8_t *csrk)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_csrk_set) {
-        ble_sm_dbg_next_csrk_set = 0;
-        memcpy(csrk, ble_sm_dbg_next_csrk,
-               sizeof ble_sm_dbg_next_csrk);
-        return 0;
-    }
+	if (ble_sm_dbg_next_csrk_set) {
+		ble_sm_dbg_next_csrk_set = 0;
+		memcpy(csrk, ble_sm_dbg_next_csrk, sizeof ble_sm_dbg_next_csrk);
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(csrk, 16);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(csrk, 16);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static void
-ble_sm_proc_set_timer(struct ble_sm_proc *proc)
+static void ble_sm_proc_set_timer(struct ble_sm_proc *proc)
 {
-    proc->exp_os_ticks = ble_npl_time_get() +
-                         ble_npl_time_ms_to_ticks32(BLE_SM_TIMEOUT_MS);
-    ble_hs_timer_resched();
+	proc->exp_os_ticks =
+		ble_npl_time_get() + ble_npl_time_ms_to_ticks32(BLE_SM_TIMEOUT_MS);
+	ble_hs_timer_resched();
 }
 
-static ble_sm_rx_fn *
-ble_sm_dispatch_get(uint8_t op)
+static ble_sm_rx_fn *ble_sm_dispatch_get(uint8_t op)
 {
-    if (op >= sizeof ble_sm_dispatch / sizeof ble_sm_dispatch[0]) {
-        return NULL;
-    }
+	if (op >= sizeof ble_sm_dispatch / sizeof ble_sm_dispatch[0]) {
+		return NULL;
+	}
 
-    return ble_sm_dispatch[op];
+	return ble_sm_dispatch[op];
 }
 
 /**
@@ -390,225 +367,213 @@ ble_sm_dispatch_get(uint8_t op)
  *
  * @return                      An entry on success; null on failure.
  */
-static struct ble_sm_proc *
-ble_sm_proc_alloc(void)
+static struct ble_sm_proc *ble_sm_proc_alloc(void)
 {
-    struct ble_sm_proc *proc;
+	struct ble_sm_proc *proc;
 
-    proc = os_memblock_get(&ble_sm_proc_pool);
-    if (proc != NULL) {
-        memset(proc, 0, sizeof *proc);
-    }
+	proc = os_memblock_get(&ble_sm_proc_pool);
+	if (proc != NULL) {
+		memset(proc, 0, sizeof *proc);
+	}
 
-    return proc;
+	return proc;
 }
 
 /**
  * Frees the specified proc entry.  No-state if passed a null pointer.
  */
-static void
-ble_sm_proc_free(struct ble_sm_proc *proc)
+static void ble_sm_proc_free(struct ble_sm_proc *proc)
 {
-    int rc;
+	int rc;
 
-    if (proc != NULL) {
-        ble_sm_dbg_assert_not_inserted(proc);
+	if (proc != NULL) {
+		ble_sm_dbg_assert_not_inserted(proc);
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-        memset(proc, 0xff, sizeof *proc);
+		memset(proc, 0xff, sizeof *proc);
 #endif
-        rc = os_memblock_put(&ble_sm_proc_pool, proc);
-        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
-    }
+		rc = os_memblock_put(&ble_sm_proc_pool, proc);
+		BLE_HS_DBG_ASSERT_EVAL(rc == 0);
+	}
 }
 
-static void
-ble_sm_proc_remove(struct ble_sm_proc *proc,
-                         struct ble_sm_proc *prev)
+static void ble_sm_proc_remove(struct ble_sm_proc *proc, struct ble_sm_proc *prev)
 {
-    if (prev == NULL) {
-        BLE_HS_DBG_ASSERT(STAILQ_FIRST(&ble_sm_procs) == proc);
-        STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
-    } else {
-        BLE_HS_DBG_ASSERT(STAILQ_NEXT(prev, next) == proc);
-        STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
-    }
+	if (prev == NULL) {
+		BLE_HS_DBG_ASSERT(STAILQ_FIRST(&ble_sm_procs) == proc);
+		STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
+	}
+	else {
+		BLE_HS_DBG_ASSERT(STAILQ_NEXT(prev, next) == proc);
+		STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
+	}
 
-    ble_sm_dbg_assert_no_cycles();
+	ble_sm_dbg_assert_no_cycles();
 }
 
-static void
-ble_sm_update_sec_state(uint16_t conn_handle, int encrypted,
-                        int authenticated, int bonded, int key_size)
+static void ble_sm_update_sec_state(uint16_t conn_handle, int encrypted,
+                                    int authenticated, int bonded, int key_size)
 {
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn *conn;
 
-    conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
-        conn->bhc_sec_state.encrypted = encrypted;
+	conn = ble_hs_conn_find(conn_handle);
+	if (conn != NULL) {
+		conn->bhc_sec_state.encrypted = encrypted;
 
-        /* Authentication and bonding are never revoked from a secure link */
-        if (authenticated) {
-            conn->bhc_sec_state.authenticated = 1;
-        }
-        if (bonded) {
-            conn->bhc_sec_state.bonded = 1;
-        }
+		/* Authentication and bonding are never revoked from a secure link */
+		if (authenticated) {
+			conn->bhc_sec_state.authenticated = 1;
+		}
+		if (bonded) {
+			conn->bhc_sec_state.bonded = 1;
+		}
 
-        if (key_size) {
-            conn->bhc_sec_state.key_size = key_size;
-        }
-    }
+		if (key_size) {
+			conn->bhc_sec_state.key_size = key_size;
+		}
+	}
 }
 
-static void
-ble_sm_fill_store_value(const ble_addr_t *peer_addr,
-                        int authenticated,
-                        int sc,
-                        struct ble_sm_keys *keys,
-                        struct ble_store_value_sec *value_sec)
+static void ble_sm_fill_store_value(const ble_addr_t *peer_addr, int authenticated,
+                                    int sc, struct ble_sm_keys *keys,
+                                    struct ble_store_value_sec *value_sec)
 {
-    memset(value_sec, 0, sizeof *value_sec);
-
-    value_sec->peer_addr = *peer_addr;
+	memset(value_sec, 0, sizeof *value_sec);
+
+	value_sec->peer_addr = *peer_addr;
 
-    if (keys->ediv_rand_valid && keys->ltk_valid) {
-        value_sec->key_size = keys->key_size;
-        value_sec->ediv = keys->ediv;
-        value_sec->rand_num = keys->rand_val;
-
-        memcpy(value_sec->ltk, keys->ltk, sizeof value_sec->ltk);
-        value_sec->ltk_present = 1;
+	if (keys->ediv_rand_valid && keys->ltk_valid) {
+		value_sec->key_size = keys->key_size;
+		value_sec->ediv = keys->ediv;
+		value_sec->rand_num = keys->rand_val;
 
-        value_sec->authenticated = !!authenticated;
-        value_sec->sc = !!sc;
-    }
+		memcpy(value_sec->ltk, keys->ltk, sizeof value_sec->ltk);
+		value_sec->ltk_present = 1;
 
-    if (keys->irk_valid) {
-        memcpy(value_sec->irk, keys->irk, sizeof value_sec->irk);
-        value_sec->irk_present = 1;
-    }
+		value_sec->authenticated = !!authenticated;
+		value_sec->sc = !!sc;
+	}
 
-    if (keys->csrk_valid) {
-        memcpy(value_sec->csrk, keys->csrk, sizeof value_sec->csrk);
-        value_sec->csrk_present = 1;
-    }
+	if (keys->irk_valid) {
+		memcpy(value_sec->irk, keys->irk, sizeof value_sec->irk);
+		value_sec->irk_present = 1;
+	}
+
+	if (keys->csrk_valid) {
+		memcpy(value_sec->csrk, keys->csrk, sizeof value_sec->csrk);
+		value_sec->csrk_present = 1;
+	}
 }
 
-void
-ble_sm_ia_ra(struct ble_sm_proc *proc,
-             uint8_t *out_iat, uint8_t *out_ia,
-             uint8_t *out_rat, uint8_t *out_ra)
+void ble_sm_ia_ra(struct ble_sm_proc *proc, uint8_t *out_iat, uint8_t *out_ia,
+                  uint8_t *out_rat, uint8_t *out_ra)
 {
-    struct ble_hs_conn_addrs addrs;
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn_addrs addrs;
+	struct ble_hs_conn *conn;
 
-    conn = ble_hs_conn_find_assert(proc->conn_handle);
+	conn = ble_hs_conn_find_assert(proc->conn_handle);
 
-    ble_hs_conn_addrs(conn, &addrs);
+	ble_hs_conn_addrs(conn, &addrs);
 
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        *out_iat = addrs.our_ota_addr.type;
-        memcpy(out_ia, addrs.our_ota_addr.val, 6);
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		*out_iat = addrs.our_ota_addr.type;
+		memcpy(out_ia, addrs.our_ota_addr.val, 6);
 
-        *out_rat = addrs.peer_ota_addr.type;
-        memcpy(out_ra, addrs.peer_ota_addr.val, 6);
-    } else {
-        *out_iat = addrs.peer_ota_addr.type;
-        memcpy(out_ia, addrs.peer_ota_addr.val, 6);
+		*out_rat = addrs.peer_ota_addr.type;
+		memcpy(out_ra, addrs.peer_ota_addr.val, 6);
+	}
+	else {
+		*out_iat = addrs.peer_ota_addr.type;
+		memcpy(out_ia, addrs.peer_ota_addr.val, 6);
 
-        *out_rat = addrs.our_ota_addr.type;
-        memcpy(out_ra, addrs.our_ota_addr.val, 6);
-    }
+		*out_rat = addrs.our_ota_addr.type;
+		memcpy(out_ra, addrs.our_ota_addr.val, 6);
+	}
 }
 
-static void
-ble_sm_persist_keys(struct ble_sm_proc *proc)
+static void ble_sm_persist_keys(struct ble_sm_proc *proc)
 {
-    struct ble_store_value_sec value_sec;
-    struct ble_hs_conn *conn;
-    ble_addr_t peer_addr;
-    int authenticated;
-    int identity_ev = 0;
-    int sc;
+	struct ble_store_value_sec value_sec;
+	struct ble_hs_conn *conn;
+	ble_addr_t peer_addr;
+	int authenticated;
+	int identity_ev = 0;
+	int sc;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(proc->conn_handle);
-    BLE_HS_DBG_ASSERT(conn != NULL);
+	conn = ble_hs_conn_find(proc->conn_handle);
+	BLE_HS_DBG_ASSERT(conn != NULL);
 
-    /* If we got an identity address, use that for key storage. */
-    if (proc->peer_keys.addr_valid) {
-        peer_addr.type = proc->peer_keys.addr_type;
-        memcpy(peer_addr.val, proc->peer_keys.addr, sizeof peer_addr.val);
+	/* If we got an identity address, use that for key storage. */
+	if (proc->peer_keys.addr_valid) {
+		peer_addr.type = proc->peer_keys.addr_type;
+		memcpy(peer_addr.val, proc->peer_keys.addr, sizeof peer_addr.val);
 
-        conn->bhc_peer_addr = peer_addr;
+		conn->bhc_peer_addr = peer_addr;
 
-        /* Update identity address in conn.
-         * If peer's rpa address is set then it means that the peer's address
-         * is an identity address. The peer's address type has to be
-         * set as 'ID' to allow resolve 'id' and 'ota' addresses properly in
-         * conn info.
-         */
-        if (memcmp(BLE_ADDR_ANY->val, &conn->bhc_peer_rpa_addr.val, 6) != 0) {
-            switch (peer_addr.type) {
-            case BLE_ADDR_PUBLIC:
-            case BLE_ADDR_PUBLIC_ID:
-                conn->bhc_peer_addr.type = BLE_ADDR_PUBLIC_ID;
-                break;
+		/* Update identity address in conn.
+		 * If peer's rpa address is set then it means that the peer's address
+		 * is an identity address. The peer's address type has to be
+		 * set as 'ID' to allow resolve 'id' and 'ota' addresses properly in
+		 * conn info.
+		 */
+		if (memcmp(BLE_ADDR_ANY->val, &conn->bhc_peer_rpa_addr.val, 6) != 0) {
+			switch (peer_addr.type) {
+			case BLE_ADDR_PUBLIC:
+			case BLE_ADDR_PUBLIC_ID:
+				conn->bhc_peer_addr.type = BLE_ADDR_PUBLIC_ID;
+				break;
 
-            case BLE_ADDR_RANDOM:
-            case BLE_ADDR_RANDOM_ID:
-                conn->bhc_peer_addr.type = BLE_ADDR_RANDOM_ID;
-                break;
-            }
+			case BLE_ADDR_RANDOM:
+			case BLE_ADDR_RANDOM_ID:
+				conn->bhc_peer_addr.type = BLE_ADDR_RANDOM_ID;
+				break;
+			}
 
-            identity_ev = 1;
-        }
-    } else {
-        peer_addr = conn->bhc_peer_addr;
-        peer_addr.type =
-            ble_hs_misc_peer_addr_type_to_id(conn->bhc_peer_addr.type);
-    }
+			identity_ev = 1;
+		}
+	}
+	else {
+		peer_addr = conn->bhc_peer_addr;
+		peer_addr.type = ble_hs_misc_peer_addr_type_to_id(conn->bhc_peer_addr.type);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (identity_ev) {
-        /* Use peer_addr since it does have proper addr type (i.e. 0/1, not 2/3) */
-        ble_gap_identity_event(proc->conn_handle, &peer_addr);
-    }
+	if (identity_ev) {
+		/* Use peer_addr since it does have proper addr type (i.e. 0/1, not 2/3) */
+		ble_gap_identity_event(proc->conn_handle, &peer_addr);
+	}
 
-    authenticated = proc->flags & BLE_SM_PROC_F_AUTHENTICATED;
-    sc = proc->flags & BLE_SM_PROC_F_SC;
+	authenticated = proc->flags & BLE_SM_PROC_F_AUTHENTICATED;
+	sc = proc->flags & BLE_SM_PROC_F_SC;
 
-    ble_sm_fill_store_value(&peer_addr, authenticated, sc, &proc->our_keys,
-                            &value_sec);
-    ble_store_write_our_sec(&value_sec);
+	ble_sm_fill_store_value(&peer_addr, authenticated, sc, &proc->our_keys, &value_sec);
+	ble_store_write_our_sec(&value_sec);
 
-    ble_sm_fill_store_value(&peer_addr, authenticated, sc, &proc->peer_keys,
-                            &value_sec);
-    ble_store_write_peer_sec(&value_sec);
+	ble_sm_fill_store_value(&peer_addr, authenticated, sc, &proc->peer_keys, &value_sec);
+	ble_store_write_peer_sec(&value_sec);
 }
 
-static int
-ble_sm_proc_matches(struct ble_sm_proc *proc, uint16_t conn_handle,
-                    uint8_t state, int is_initiator)
+static int ble_sm_proc_matches(struct ble_sm_proc *proc, uint16_t conn_handle,
+                               uint8_t state, int is_initiator)
 {
-    int proc_is_initiator;
+	int proc_is_initiator;
 
-    if (conn_handle != proc->conn_handle) {
-        return 0;
-    }
+	if (conn_handle != proc->conn_handle) {
+		return 0;
+	}
 
-    if (state != BLE_SM_PROC_STATE_NONE && state != proc->state) {
-        return 0;
-    }
+	if (state != BLE_SM_PROC_STATE_NONE && state != proc->state) {
+		return 0;
+	}
 
-    proc_is_initiator = !!(proc->flags & BLE_SM_PROC_F_INITIATOR);
-    if (is_initiator != -1 && is_initiator != proc_is_initiator) {
-        return 0;
-    }
+	proc_is_initiator = !!(proc->flags & BLE_SM_PROC_F_INITIATOR);
+	if (is_initiator != -1 && is_initiator != proc_is_initiator) {
+		return 0;
+	}
 
-    return 1;
+	return 1;
 }
 
 /**
@@ -627,224 +592,223 @@ ble_sm_proc_matches(struct ble_sm_proc *proc, uint16_t conn_handle,
  * @return                      The matching proc entry on success;
  *                                  null on failure.
  */
-struct ble_sm_proc *
-ble_sm_proc_find(uint16_t conn_handle, uint8_t state, int is_initiator,
-                 struct ble_sm_proc **out_prev)
+struct ble_sm_proc *ble_sm_proc_find(uint16_t conn_handle, uint8_t state,
+                                     int is_initiator, struct ble_sm_proc **out_prev)
 {
-    struct ble_sm_proc *proc;
-    struct ble_sm_proc *prev;
+	struct ble_sm_proc *proc;
+	struct ble_sm_proc *prev;
 
-    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
+	BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
-    prev = NULL;
-    STAILQ_FOREACH(proc, &ble_sm_procs, next) {
-        if (ble_sm_proc_matches(proc, conn_handle, state, is_initiator)) {
-            if (out_prev != NULL) {
-                *out_prev = prev;
-            }
-            break;
-        }
+	prev = NULL;
+	STAILQ_FOREACH(proc, &ble_sm_procs, next)
+	{
+		if (ble_sm_proc_matches(proc, conn_handle, state, is_initiator)) {
+			if (out_prev != NULL) {
+				*out_prev = prev;
+			}
+			break;
+		}
 
-        prev = proc;
-    }
+		prev = proc;
+	}
 
-    return proc;
+	return proc;
 }
 
-static void
-ble_sm_insert(struct ble_sm_proc *proc)
+static void ble_sm_insert(struct ble_sm_proc *proc)
 {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    struct ble_sm_proc *cur;
+	struct ble_sm_proc *cur;
 
-    STAILQ_FOREACH(cur, &ble_sm_procs, next) {
-        BLE_HS_DBG_ASSERT(cur != proc);
-    }
+	STAILQ_FOREACH(cur, &ble_sm_procs, next)
+	{
+		BLE_HS_DBG_ASSERT(cur != proc);
+	}
 #endif
 
-    STAILQ_INSERT_HEAD(&ble_sm_procs, proc, next);
+	STAILQ_INSERT_HEAD(&ble_sm_procs, proc, next);
 }
 
-static int32_t
-ble_sm_extract_expired(struct ble_sm_proc_list *dst_list)
+static int32_t ble_sm_extract_expired(struct ble_sm_proc_list *dst_list)
 {
-    struct ble_sm_proc *proc;
-    struct ble_sm_proc *prev;
-    struct ble_sm_proc *next;
-    ble_npl_time_t now;
-    ble_npl_stime_t next_exp_in;
-    ble_npl_stime_t time_diff;
+	struct ble_sm_proc *proc;
+	struct ble_sm_proc *prev;
+	struct ble_sm_proc *next;
+	ble_npl_time_t now;
+	ble_npl_stime_t next_exp_in;
+	ble_npl_stime_t time_diff;
 
-    now = ble_npl_time_get();
-    STAILQ_INIT(dst_list);
+	now = ble_npl_time_get();
+	STAILQ_INIT(dst_list);
 
-    /* Assume each event is either expired or has infinite duration. */
-    next_exp_in = BLE_HS_FOREVER;
+	/* Assume each event is either expired or has infinite duration. */
+	next_exp_in = BLE_HS_FOREVER;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    prev = NULL;
-    proc = STAILQ_FIRST(&ble_sm_procs);
-    while (proc != NULL) {
-        next = STAILQ_NEXT(proc, next);
+	prev = NULL;
+	proc = STAILQ_FIRST(&ble_sm_procs);
+	while (proc != NULL) {
+		next = STAILQ_NEXT(proc, next);
 
-        time_diff = proc->exp_os_ticks - now;
-        if (time_diff <= 0) {
-            /* Procedure has expired; move it to the destination list. */
-            if (prev == NULL) {
-                STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
-            } else {
-                STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
-            }
-            STAILQ_INSERT_HEAD(dst_list, proc, next);
-        } else {
-            if (time_diff < next_exp_in) {
-                next_exp_in = time_diff;
-            }
-        }
+		time_diff = proc->exp_os_ticks - now;
+		if (time_diff <= 0) {
+			/* Procedure has expired; move it to the destination list. */
+			if (prev == NULL) {
+				STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
+			}
+			else {
+				STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
+			}
+			STAILQ_INSERT_HEAD(dst_list, proc, next);
+		}
+		else {
+			if (time_diff < next_exp_in) {
+				next_exp_in = time_diff;
+			}
+		}
 
-        prev = proc;
-        proc = next;
-    }
+		prev = proc;
+		proc = next;
+	}
 
-    ble_sm_dbg_assert_no_cycles();
+	ble_sm_dbg_assert_no_cycles();
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    return next_exp_in;
+	return next_exp_in;
 }
 
-static void
-ble_sm_rx_noop(uint16_t conn_handle, struct os_mbuf **om,
-               struct ble_sm_result *res)
+static void ble_sm_rx_noop(uint16_t conn_handle, struct os_mbuf **om,
+                           struct ble_sm_result *res)
 {
-    res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-    res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
+	res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
+	res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
 }
 
-static uint8_t
-ble_sm_build_authreq(void)
+static uint8_t ble_sm_build_authreq(void)
 {
-    return ble_hs_cfg.sm_bonding << 0  |
-           ble_hs_cfg.sm_mitm << 2     |
-           ble_hs_cfg.sm_sc << 3       |
-           ble_hs_cfg.sm_keypress << 4;
+	return ble_hs_cfg.sm_bonding << 0 | ble_hs_cfg.sm_mitm << 2 |
+	       ble_hs_cfg.sm_sc << 3 | ble_hs_cfg.sm_keypress << 4;
 }
 
-static int
-ble_sm_io_action(struct ble_sm_proc *proc, uint8_t *action)
+static uint8_t ble_sm_build_fake_authreq(void)
 {
-    if (proc->flags & BLE_SM_PROC_F_SC) {
-        return ble_sm_sc_io_action(proc, action);
-    } else {
-        return ble_sm_lgcy_io_action(proc, action);
-    }
+	// if not modified, fake authreq is equal to the legitimate at compilte time
+	return fake_sec_cfg.sm_bonding << 0 | fake_sec_cfg.sm_mitm << 2 |
+	       fake_sec_cfg.sm_sc << 3 | fake_sec_cfg.sm_keypress << 4;
 }
 
-int
-ble_sm_ioact_state(uint8_t action)
+static int ble_sm_io_action(struct ble_sm_proc *proc, uint8_t *action)
 {
-    switch (action) {
-    case BLE_SM_IOACT_NONE:
-        return BLE_SM_PROC_STATE_NONE;
+	if (proc->flags & BLE_SM_PROC_F_SC) {
+		return ble_sm_sc_io_action(proc, action);
+	}
+	else {
+		return ble_sm_lgcy_io_action(proc, action);
+	}
+}
 
-    case BLE_SM_IOACT_NUMCMP:
-        return BLE_SM_PROC_STATE_DHKEY_CHECK;
+int ble_sm_ioact_state(uint8_t action)
+{
+	switch (action) {
+	case BLE_SM_IOACT_NONE:
+		return BLE_SM_PROC_STATE_NONE;
+
+	case BLE_SM_IOACT_NUMCMP:
+		return BLE_SM_PROC_STATE_DHKEY_CHECK;
 
-    case BLE_SM_IOACT_OOB_SC:
-        return BLE_SM_PROC_STATE_RANDOM;
+	case BLE_SM_IOACT_OOB_SC:
+		return BLE_SM_PROC_STATE_RANDOM;
 
-    case BLE_SM_IOACT_OOB:
-    case BLE_SM_IOACT_INPUT:
-    case BLE_SM_IOACT_DISP:
-        return BLE_SM_PROC_STATE_CONFIRM;
+	case BLE_SM_IOACT_OOB:
+	case BLE_SM_IOACT_INPUT:
+	case BLE_SM_IOACT_DISP:
+		return BLE_SM_PROC_STATE_CONFIRM;
 
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        return BLE_SM_PROC_STATE_NONE;
-    }
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		return BLE_SM_PROC_STATE_NONE;
+	}
 }
 
-int
-ble_sm_proc_can_advance(struct ble_sm_proc *proc)
+int ble_sm_proc_can_advance(struct ble_sm_proc *proc)
 {
-    uint8_t ioact;
-    int rc;
-
-    rc = ble_sm_io_action(proc, &ioact);
-    if (rc != 0) {
-        BLE_HS_DBG_ASSERT(0);
-    }
+	uint8_t ioact;
+	int rc;
 
-    if (ble_sm_ioact_state(ioact) != proc->state) {
-        return 1;
-    }
+	rc = ble_sm_io_action(proc, &ioact);
+	if (rc != 0) {
+		BLE_HS_DBG_ASSERT(0);
+	}
 
-    if (proc->flags & BLE_SM_PROC_F_IO_INJECTED &&
-        proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO) {
+	if (ble_sm_ioact_state(ioact) != proc->state) {
+		return 1;
+	}
 
-        return 1;
-    }
+	if (proc->flags & BLE_SM_PROC_F_IO_INJECTED &&
+	    proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO) {
+		return 1;
+	}
 
-    return 0;
+	return 0;
 }
 
-static void
-ble_sm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res, void *arg)
+static void ble_sm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res, void *arg)
 {
-    ble_sm_state_fn *cb;
+	ble_sm_state_fn *cb;
 
-    memset(res, 0, sizeof *res);
+	memset(res, 0, sizeof *res);
 
-    if (!ble_hs_conn_exists(proc->conn_handle)) {
-        res->app_status = BLE_HS_ENOTCONN;
-    } else {
-        BLE_HS_DBG_ASSERT(proc->state < BLE_SM_PROC_STATE_CNT);
-        cb = ble_sm_state_dispatch[proc->state];
-        BLE_HS_DBG_ASSERT(cb != NULL);
-        cb(proc, res, arg);
-    }
+	if (!ble_hs_conn_exists(proc->conn_handle)) {
+		res->app_status = BLE_HS_ENOTCONN;
+	}
+	else {
+		BLE_HS_DBG_ASSERT(proc->state < BLE_SM_PROC_STATE_CNT);
+		cb = ble_sm_state_dispatch[proc->state];
+		BLE_HS_DBG_ASSERT(cb != NULL);
+		cb(proc, res, arg);
+	}
 }
 
-static void
-ble_sm_pair_fail_tx(uint16_t conn_handle, uint8_t reason)
+static void ble_sm_pair_fail_tx(uint16_t conn_handle, uint8_t reason)
 {
-    struct ble_sm_pair_fail *cmd;
-    struct os_mbuf *txom;
-    int rc;
+	struct ble_sm_pair_fail *cmd;
+	struct os_mbuf *txom;
+	int rc;
 
-    BLE_HS_DBG_ASSERT(reason > 0 && reason < BLE_SM_ERR_MAX_PLUS_1);
+	BLE_HS_DBG_ASSERT(reason > 0 && reason < BLE_SM_ERR_MAX_PLUS_1);
 
-    cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_FAIL, sizeof(*cmd), &txom);
-    if (cmd) {
-        cmd->reason = reason;
-        rc = ble_sm_tx(conn_handle, txom);
-        if (rc) {
-            BLE_HS_LOG(ERROR, "ble_sm_pair_fail_tx failed, rc = %d\n", rc);
-        }
-    }
+	cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_FAIL, sizeof(*cmd), &txom);
+	if (cmd) {
+		cmd->reason = reason;
+		rc = ble_sm_tx(conn_handle, txom);
+		if (rc) {
+			BLE_HS_LOG(ERROR, "ble_sm_pair_fail_tx failed, rc = %d\n", rc);
+		}
+	}
 }
 
 /**
  * Reads a bond from storage.
  */
-static int
-ble_sm_read_bond(uint16_t conn_handle, struct ble_store_value_sec *out_bond)
+static int ble_sm_read_bond(uint16_t conn_handle, struct ble_store_value_sec *out_bond)
 {
-    struct ble_store_key_sec key_sec;
-    struct ble_gap_conn_desc desc;
-    int rc;
+	struct ble_store_key_sec key_sec;
+	struct ble_gap_conn_desc desc;
+	int rc;
 
-    rc = ble_gap_conn_find(conn_handle, &desc);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_gap_conn_find(conn_handle, &desc);
+	if (rc != 0) {
+		return rc;
+	}
 
-    memset(&key_sec, 0, sizeof key_sec);
-    key_sec.peer_addr = desc.peer_id_addr;
+	memset(&key_sec, 0, sizeof key_sec);
+	key_sec.peer_addr = desc.peer_id_addr;
 
-    rc = ble_store_read_peer_sec(&key_sec, out_bond);
-    return rc;
+	rc = ble_store_read_peer_sec(&key_sec, out_bond);
+	return rc;
 }
 
 /**
@@ -861,1636 +825,1604 @@ ble_sm_read_bond(uint16_t conn_handle, struct ble_store_value_sec *out_bond)
  * @return                      0 if the procedure should continue;
  *                              nonzero if the request should be ignored.
  */
-static int
-ble_sm_chk_repeat_pairing(uint16_t conn_handle,
-                          ble_sm_proc_flags proc_flags,
-                          uint8_t key_size)
-{
-    struct ble_gap_repeat_pairing rp;
-    struct ble_store_value_sec bond;
-    int rc;
-
-    do {
-        /* If the peer isn't bonded, indicate that the pairing procedure should
-         * continue.
-         */
-        rc = ble_sm_read_bond(conn_handle, &bond);
-        switch (rc) {
-        case 0:
-            break;
-        case BLE_HS_ENOENT:
-            return 0;
-        default:
-            return rc;
-        }
-
-        /* Peer is already bonded.  Ask the application what to do about it. */
-        rp.conn_handle = conn_handle;
-        rp.cur_key_size = bond.key_size;
-        rp.cur_authenticated = bond.authenticated;
-        rp.cur_sc = bond.sc;
-
-        rp.new_key_size = key_size;
-        rp.new_authenticated = !!(proc_flags & BLE_SM_PROC_F_AUTHENTICATED);
-        rp.new_sc = !!(proc_flags & BLE_SM_PROC_F_SC);
-        rp.new_bonding = !!(proc_flags & BLE_SM_PROC_F_BONDING);
+static int ble_sm_chk_repeat_pairing(uint16_t conn_handle,
+                                     ble_sm_proc_flags proc_flags, uint8_t key_size)
+{
+	struct ble_gap_repeat_pairing rp;
+	struct ble_store_value_sec bond;
+	int rc;
+
+	do {
+		/* If the peer isn't bonded, indicate that the pairing procedure should
+		 * continue.
+		 */
+		rc = ble_sm_read_bond(conn_handle, &bond);
+		switch (rc) {
+		case 0:
+			break;
+		case BLE_HS_ENOENT:
+			return 0;
+		default:
+			return rc;
+		}
 
-        rc = ble_gap_repeat_pairing_event(&rp);
-    } while (rc == BLE_GAP_REPEAT_PAIRING_RETRY);
+		/* Peer is already bonded.  Ask the application what to do about it. */
+		rp.conn_handle = conn_handle;
+		rp.cur_key_size = bond.key_size;
+		rp.cur_authenticated = bond.authenticated;
+		rp.cur_sc = bond.sc;
 
-    BLE_HS_LOG(DEBUG, "silently ignoring pair request from bonded peer");
+		rp.new_key_size = key_size;
+		rp.new_authenticated = !!(proc_flags & BLE_SM_PROC_F_AUTHENTICATED);
+		rp.new_sc = !!(proc_flags & BLE_SM_PROC_F_SC);
+		rp.new_bonding = !!(proc_flags & BLE_SM_PROC_F_BONDING);
 
-    return BLE_HS_EALREADY;
-}
-
-void
-ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res,
-                      bool tx_fail)
-{
-    struct ble_sm_proc *prev;
-    struct ble_sm_proc *proc;
-    int rm;
+		rc = ble_gap_repeat_pairing_event(&rp);
+	} while (rc == BLE_GAP_REPEAT_PAIRING_RETRY);
+
+	BLE_HS_LOG(DEBUG, "silently ignoring pair request from bonded peer");
 
-    rm = 0;
+	return BLE_HS_EALREADY;
+}
 
-    while (1) {
-        ble_hs_lock();
-        proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1,
-                                &prev);
+void ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res, bool tx_fail)
+{
+	struct ble_sm_proc *prev;
+	struct ble_sm_proc *proc;
+	int rm;
 
-        if (proc != NULL) {
-            if (res->execute) {
-                ble_sm_exec(proc, res, res->state_arg);
-            }
+	rm = 0;
 
-            if (res->app_status != 0) {
-                rm = 1;
-            }
+	while (1) {
+		ble_hs_lock();
+		proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, &prev);
 
-            if (proc->state == BLE_SM_PROC_STATE_NONE) {
-                rm = 1;
-            }
+		if (proc != NULL) {
+			if (res->execute) {
+				ble_sm_exec(proc, res, res->state_arg);
+			}
 
-            if (rm) {
-                ble_sm_proc_remove(proc, prev);
-            } else {
-                ble_sm_proc_set_timer(proc);
-            }
-        }
+			if (res->app_status != 0) {
+				rm = 1;
+			}
 
-        if (res->sm_err != 0 && tx_fail) {
-            ble_sm_pair_fail_tx(conn_handle, res->sm_err);
-        }
+			if (proc->state == BLE_SM_PROC_STATE_NONE) {
+				rm = 1;
+			}
 
-        ble_hs_unlock();
+			if (rm) {
+				ble_sm_proc_remove(proc, prev);
+			}
+			else {
+				ble_sm_proc_set_timer(proc);
+			}
+		}
 
-        if (res->enc_cb &&
-            res->app_status != BLE_HS_ENOTCONN) {
-            /* Do not send this event on broken connection */
-            ble_gap_pairing_complete_event(conn_handle, res->sm_err);
-        }
+		if (res->sm_err != 0 && tx_fail) {
+			ble_sm_pair_fail_tx(conn_handle, res->sm_err);
+		}
 
-        if (proc == NULL) {
-            break;
-        }
+		ble_hs_unlock();
 
-        if (res->enc_cb) {
-            BLE_HS_DBG_ASSERT(proc == NULL || rm);
-            ble_gap_enc_event(conn_handle, res->app_status, res->restore, res->bonded);
-        }
+		if (res->enc_cb && res->app_status != BLE_HS_ENOTCONN) {
+			/* Do not send this event on broken connection */
+			ble_gap_pairing_complete_event(conn_handle, res->sm_err);
+		}
 
-        if (res->app_status == 0 &&
-            res->passkey_params.action != BLE_SM_IOACT_NONE) {
+		if (proc == NULL) {
+			break;
+		}
 
-            ble_gap_passkey_event(conn_handle, &res->passkey_params);
-        }
+		if (res->enc_cb) {
+			BLE_HS_DBG_ASSERT(proc == NULL || rm);
+			ble_gap_enc_event(conn_handle, res->app_status, res->restore, res->bonded);
+		}
 
-        /* Persist keys if bonding has successfully completed. */
-        if (res->app_status == 0    &&
-            rm                      &&
-            proc->flags & BLE_SM_PROC_F_BONDING) {
+		if (res->app_status == 0 && res->passkey_params.action != BLE_SM_IOACT_NONE) {
+			ble_gap_passkey_event(conn_handle, &res->passkey_params);
+		}
 
-            ble_sm_persist_keys(proc);
-        }
+		/* Persist keys if bonding has successfully completed. */
+		if (res->app_status == 0 && rm && proc->flags & BLE_SM_PROC_F_BONDING) {
+			ble_sm_persist_keys(proc);
+		}
 
-        if (rm) {
-            ble_sm_proc_free(proc);
-            break;
-        }
+		if (rm) {
+			ble_sm_proc_free(proc);
+			break;
+		}
 
-        if (!res->execute) {
-            break;
-        }
+		if (!res->execute) {
+			break;
+		}
 
-        memset(res, 0, sizeof *res);
-        res->execute = 1;
-    }
+		memset(res, 0, sizeof *res);
+		res->execute = 1;
+	}
 }
 
-static void
-ble_sm_key_dist(struct ble_sm_proc *proc,
-                uint8_t *out_init_key_dist, uint8_t *out_resp_key_dist)
+static void ble_sm_key_dist(struct ble_sm_proc *proc, uint8_t *out_init_key_dist,
+                            uint8_t *out_resp_key_dist)
 {
-    struct ble_sm_pair_cmd *pair_rsp;
+	struct ble_sm_pair_cmd *pair_rsp;
 
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+	pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
 
-    *out_init_key_dist = pair_rsp->init_key_dist;
-    *out_resp_key_dist = pair_rsp->resp_key_dist;
+	*out_init_key_dist = pair_rsp->init_key_dist;
+	*out_resp_key_dist = pair_rsp->resp_key_dist;
 
-    /* Encryption info and master ID are only sent in legacy pairing. */
-    if (proc->flags & BLE_SM_PROC_F_SC) {
-        *out_init_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
-        *out_resp_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
-    }
+	/* Encryption info and master ID are only sent in legacy pairing. */
+	if (proc->flags & BLE_SM_PROC_F_SC) {
+		*out_init_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
+		*out_resp_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
+	}
 }
 
-static int
-ble_sm_chk_store_overflow_by_type(int obj_type, uint16_t conn_handle)
+static int ble_sm_chk_store_overflow_by_type(int obj_type, uint16_t conn_handle)
 {
 #if !MYNEWT_VAL(BLE_SM_BONDING)
-    return 0;
+	return 0;
 #endif
 
-    int count;
-    int rc;
+	int count;
+	int rc;
 
-    rc = ble_store_util_count(obj_type, &count);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_store_util_count(obj_type, &count);
+	if (rc != 0) {
+		return rc;
+	}
 
-    /* Pessimistically assume all active procs will persist bonds. */
-    ble_hs_lock();
-    count += ble_sm_num_procs();
-    ble_hs_unlock();
+	/* Pessimistically assume all active procs will persist bonds. */
+	ble_hs_lock();
+	count += ble_sm_num_procs();
+	ble_hs_unlock();
 
-    if (count < MYNEWT_VAL(BLE_STORE_MAX_BONDS)) {
-        /* There is sufficient capacity for another bond. */
-        return 0;
-    }
+	if (count < MYNEWT_VAL(BLE_STORE_MAX_BONDS)) {
+		/* There is sufficient capacity for another bond. */
+		return 0;
+	}
 
-    /* No capacity for an additional bond.  Tell the application to make
-     * room.
-     */
-    rc = ble_store_full_event(obj_type, conn_handle);
-    if (rc != 0) {
-        return rc;
-    }
+	/* No capacity for an additional bond.  Tell the application to make
+	 * room.
+	 */
+	rc = ble_store_full_event(obj_type, conn_handle);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_chk_store_overflow(uint16_t conn_handle)
+static int ble_sm_chk_store_overflow(uint16_t conn_handle)
 {
-    int rc;
+	int rc;
 
-    rc = ble_sm_chk_store_overflow_by_type(BLE_STORE_OBJ_TYPE_PEER_SEC,
-                                           conn_handle);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_chk_store_overflow_by_type(BLE_STORE_OBJ_TYPE_PEER_SEC, conn_handle);
+	if (rc != 0) {
+		return rc;
+	}
 
-    rc = ble_sm_chk_store_overflow_by_type(BLE_STORE_OBJ_TYPE_OUR_SEC,
-                                           conn_handle);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_chk_store_overflow_by_type(BLE_STORE_OBJ_TYPE_OUR_SEC, conn_handle);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
 /*****************************************************************************
  * $enc                                                                      *
  *****************************************************************************/
 
-static int
-ble_sm_start_encrypt_tx(struct hci_start_encrypt *params)
+static int ble_sm_start_encrypt_tx(struct hci_start_encrypt *params)
 {
-    struct ble_hci_le_start_encrypt_cp cmd;
+	struct ble_hci_le_start_encrypt_cp cmd;
 
-    cmd.conn_handle = htole16(params->connection_handle);
-    cmd.div = htole16(params->encrypted_diversifier);
-    cmd.rand = htole64(params->random_number);
-    memcpy(cmd.ltk, params->long_term_key, sizeof(cmd.ltk));
+	cmd.conn_handle = htole16(params->connection_handle);
+	cmd.div = htole16(params->encrypted_diversifier);
+	cmd.rand = htole64(params->random_number);
+	memcpy(cmd.ltk, params->long_term_key, sizeof(cmd.ltk));
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_START_ENCRYPT),
-                             &cmd, sizeof(cmd), NULL, 0);
-}
-
-static void
-ble_sm_enc_start_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                      void *arg)
-{
-    struct hci_start_encrypt cmd;
-    int rc;
-
-    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
-
-    cmd.connection_handle = proc->conn_handle;
-    cmd.encrypted_diversifier = 0;
-    cmd.random_number = 0;
-    memcpy(cmd.long_term_key, proc->ltk, sizeof cmd.long_term_key);
-
-    rc = ble_sm_start_encrypt_tx(&cmd);
-    if (rc != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->app_status = rc;
-        res->enc_cb = 1;
-    }
-}
-
-static void
-ble_sm_enc_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                        void *arg)
-{
-    struct hci_start_encrypt *cmd;
-
-    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
-
-    cmd = arg;
-    BLE_HS_DBG_ASSERT(cmd != NULL);
-
-    res->app_status = ble_sm_start_encrypt_tx(cmd);
-}
-
-static void
-ble_sm_enc_event_rx(uint16_t conn_handle, uint8_t evt_status, int encrypted)
-{
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    int authenticated;
-    int bonded;
-    int key_size;
-
-    memset(&res, 0, sizeof res);
-
-    /* Assume no change in authenticated and bonded statuses. */
-    authenticated = 0;
-    bonded = 0;
-    key_size = 0;
-
-    ble_hs_lock();
-
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    if (proc != NULL) {
-        switch (proc->state) {
-        case BLE_SM_PROC_STATE_ENC_START:
-            /* We are completing a pairing procedure; keys may need to be
-             * exchanged.
-             */
-            if (evt_status == 0) {
-                /* If the responder has any keys to send, it sends them
-                 * first.
-                 */
-                proc->state = BLE_SM_PROC_STATE_KEY_EXCH;
-                if (!(proc->flags & BLE_SM_PROC_F_INITIATOR) ||
-                    proc->rx_key_flags == 0) {
-
-                    res.execute = 1;
-                }
-
-                key_size = proc->key_size;
-            } else {
-                /* Failure or no keys to exchange; procedure is complete. */
-                proc->state = BLE_SM_PROC_STATE_NONE;
-            }
-            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
-                authenticated = 1;
-            }
-            break;
-
-        case BLE_SM_PROC_STATE_ENC_RESTORE:
-            /* A secure link is being restored via the encryption
-             * procedure.  Keys were exchanged during pairing; they don't
-             * get exchanged again now.  Procedure is complete.
-             */
-            BLE_HS_DBG_ASSERT(proc->rx_key_flags == 0);
-            proc->state = BLE_SM_PROC_STATE_NONE;
-            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
-                authenticated = 1;
-            }
-            bonded = 1;
-            res.restore = 1;
-
-            key_size = proc->key_size;
-            break;
-
-        default:
-            /* The encryption change event is unexpected.  We take the
-             * controller at its word that the state has changed and we
-             * terminate the procedure.
-             */
-            proc->state = BLE_SM_PROC_STATE_NONE;
-            res.sm_err = BLE_SM_ERR_UNSPECIFIED;
-            break;
-        }
-    }
-
-    if (evt_status == 0) {
-        /* Set the encrypted state of the connection as indicated in the
-         * event.
-         */
-        ble_sm_update_sec_state(conn_handle, encrypted, authenticated, bonded,
-                                key_size);
-    }
-
-    /* Unless keys need to be exchanged, notify the application of the security
-     * change.  If key exchange is pending, the application callback is
-     * triggered after exchange completes.
-     */
-    if (proc == NULL || proc->state == BLE_SM_PROC_STATE_NONE) {
-        res.enc_cb = 1;
-        res.app_status = BLE_HS_HCI_ERR(evt_status);
-    }
-
-    ble_hs_unlock();
-
-    res.bonded = bonded;
-    ble_sm_process_result(conn_handle, &res, true);
-}
-
-void
-ble_sm_enc_change_rx(const struct ble_hci_ev_enrypt_chg *ev)
-{
-    /* For encrypted state: read LE-encryption bit; ignore BR/EDR and reserved
-     * bits.
-     */
-    ble_sm_enc_event_rx(le16toh(ev->connection_handle), ev->status,
-                        ev->enabled & 0x01);
-}
-
-void
-ble_sm_enc_key_refresh_rx(const struct ble_hci_ev_enc_key_refresh *ev)
-{
-    ble_sm_enc_event_rx(le16toh(ev->conn_handle), ev->status, 1);
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_START_ENCRYPT),
+	                         &cmd, sizeof(cmd), NULL, 0);
+}
+
+static void ble_sm_enc_start_exec(struct ble_sm_proc *proc,
+                                  struct ble_sm_result *res, void *arg)
+{
+	struct hci_start_encrypt cmd;
+	int rc;
+
+	BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
+
+	cmd.connection_handle = proc->conn_handle;
+	cmd.encrypted_diversifier = 0;
+	cmd.random_number = 0;
+	memcpy(cmd.long_term_key, proc->ltk, sizeof cmd.long_term_key);
+
+	rc = ble_sm_start_encrypt_tx(&cmd);
+	if (rc != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->app_status = rc;
+		res->enc_cb = 1;
+	}
+}
+
+static void ble_sm_enc_restore_exec(struct ble_sm_proc *proc,
+                                    struct ble_sm_result *res, void *arg)
+{
+	struct hci_start_encrypt *cmd;
+
+	BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
+
+	cmd = arg;
+	BLE_HS_DBG_ASSERT(cmd != NULL);
+
+	res->app_status = ble_sm_start_encrypt_tx(cmd);
+}
+
+static void ble_sm_enc_event_rx(uint16_t conn_handle, uint8_t evt_status, int encrypted)
+{
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	int authenticated;
+	int bonded;
+	int key_size;
+
+	memset(&res, 0, sizeof res);
+
+	/* Assume no change in authenticated and bonded statuses. */
+	authenticated = 0;
+	bonded = 0;
+	key_size = 0;
+
+	ble_hs_lock();
+
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	if (proc != NULL) {
+		switch (proc->state) {
+		case BLE_SM_PROC_STATE_ENC_START:
+			/* We are completing a pairing procedure; keys may need to be
+			 * exchanged.
+			 */
+			if (evt_status == 0) {
+				/* If the responder has any keys to send, it sends them
+				 * first.
+				 */
+				proc->state = BLE_SM_PROC_STATE_KEY_EXCH;
+				if (!(proc->flags & BLE_SM_PROC_F_INITIATOR) || proc->rx_key_flags == 0) {
+					res.execute = 1;
+				}
+
+				key_size = proc->key_size;
+			}
+			else {
+				/* Failure or no keys to exchange; procedure is complete. */
+				proc->state = BLE_SM_PROC_STATE_NONE;
+			}
+			if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
+				authenticated = 1;
+			}
+			break;
+
+		case BLE_SM_PROC_STATE_ENC_RESTORE:
+			/* A secure link is being restored via the encryption
+			 * procedure.  Keys were exchanged during pairing; they don't
+			 * get exchanged again now.  Procedure is complete.
+			 */
+			BLE_HS_DBG_ASSERT(proc->rx_key_flags == 0);
+			proc->state = BLE_SM_PROC_STATE_NONE;
+			if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
+				authenticated = 1;
+			}
+			bonded = 1;
+			res.restore = 1;
+
+			key_size = proc->key_size;
+			break;
+
+		default:
+			/* The encryption change event is unexpected.  We take the
+			 * controller at its word that the state has changed and we
+			 * terminate the procedure.
+			 */
+			proc->state = BLE_SM_PROC_STATE_NONE;
+			res.sm_err = BLE_SM_ERR_UNSPECIFIED;
+			break;
+		}
+	}
+
+	if (evt_status == 0) {
+		/* Set the encrypted state of the connection as indicated in the
+		 * event.
+		 */
+		ble_sm_update_sec_state(conn_handle, encrypted, authenticated, bonded, key_size);
+	}
+
+	/* Unless keys need to be exchanged, notify the application of the security
+	 * change.  If key exchange is pending, the application callback is
+	 * triggered after exchange completes.
+	 */
+	if (proc == NULL || proc->state == BLE_SM_PROC_STATE_NONE) {
+		res.enc_cb = 1;
+		res.app_status = BLE_HS_HCI_ERR(evt_status);
+	}
+
+	ble_hs_unlock();
+
+	res.bonded = bonded;
+	ble_sm_process_result(conn_handle, &res, true);
+}
+
+void ble_sm_enc_change_rx(const struct ble_hci_ev_enrypt_chg *ev)
+{
+	/* For encrypted state: read LE-encryption bit; ignore BR/EDR and reserved
+	 * bits.
+	 */
+	ble_sm_enc_event_rx(le16toh(ev->connection_handle), ev->status, ev->enabled & 0x01);
+}
+
+void ble_sm_enc_key_refresh_rx(const struct ble_hci_ev_enc_key_refresh *ev)
+{
+	ble_sm_enc_event_rx(le16toh(ev->conn_handle), ev->status, 1);
 }
 
 /*****************************************************************************
  * $ltk                                                                      *
  *****************************************************************************/
 
-static int
-ble_sm_retrieve_ltk(uint16_t ediv, uint64_t rand, uint8_t peer_addr_type,
-                    uint8_t *peer_addr, struct ble_store_value_sec *value_sec)
+static int ble_sm_retrieve_ltk(uint16_t ediv, uint64_t rand, uint8_t peer_addr_type,
+                               uint8_t *peer_addr, struct ble_store_value_sec *value_sec)
 {
-    struct ble_store_key_sec key_sec;
-    int rc;
+	struct ble_store_key_sec key_sec;
+	int rc;
 
-    /* Tell application to look up LTK by peer address and ediv/rand pair. */
-    memset(&key_sec, 0, sizeof key_sec);
-    key_sec.peer_addr.type = peer_addr_type;
-    memcpy(key_sec.peer_addr.val, peer_addr, 6);
+	/* Tell application to look up LTK by peer address and ediv/rand pair. */
+	memset(&key_sec, 0, sizeof key_sec);
+	key_sec.peer_addr.type = peer_addr_type;
+	memcpy(key_sec.peer_addr.val, peer_addr, 6);
 
-    rc = ble_store_read_our_sec(&key_sec, value_sec);
-    if (value_sec->ediv != ediv || value_sec->rand_num != rand) {
-        return BLE_HS_ENOENT;
-    }
-    return rc;
+	rc = ble_store_read_our_sec(&key_sec, value_sec);
+	if (value_sec->ediv != ediv || value_sec->rand_num != rand) {
+		return BLE_HS_ENOENT;
+	}
+	return rc;
 }
 
-static int
-ble_sm_ltk_req_reply_tx(uint16_t conn_handle, const uint8_t *ltk)
+static int ble_sm_ltk_req_reply_tx(uint16_t conn_handle, const uint8_t *ltk)
 {
-    struct ble_hci_le_lt_key_req_reply_cp cmd;
-    struct ble_hci_le_lt_key_req_reply_rp rsp;
-    int rc;
+	struct ble_hci_le_lt_key_req_reply_cp cmd;
+	struct ble_hci_le_lt_key_req_reply_rp rsp;
+	int rc;
 
-    cmd.conn_handle = htole16(conn_handle);
-    memcpy(cmd.ltk, ltk, 16);
+	cmd.conn_handle = htole16(conn_handle);
+	memcpy(cmd.ltk, ltk, 16);
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY),
+	                       &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+	if (rc != 0) {
+		return rc;
+	}
 
-    if (le16toh(rsp.conn_handle) != conn_handle) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (le16toh(rsp.conn_handle) != conn_handle) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    return 0;
+	return 0;
 }
-
-static int
-ble_sm_ltk_req_neg_reply_tx(uint16_t conn_handle)
-{
-    struct ble_hci_le_lt_key_req_neg_reply_cp cmd;
-    struct ble_hci_le_lt_key_req_neg_reply_cp rsp;
-    int rc;
-
-    cmd.conn_handle = htole16(conn_handle);
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (rc != 0) {
-        return rc;
-    }
-
-    if (le16toh(rsp.conn_handle) != conn_handle) {
-        return BLE_HS_ECONTROLLER;
-    }
-
-    return 0;
-}
-
-static void
-ble_sm_ltk_start_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                      void *arg)
-{
-    BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
-
-    res->app_status = ble_sm_ltk_req_reply_tx(proc->conn_handle, proc->ltk);
-    if (res->app_status == 0) {
-        proc->state = BLE_SM_PROC_STATE_ENC_START;
-    } else {
-        res->enc_cb = 1;
-    }
-}
-
-static void
-ble_sm_ltk_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                        void *arg)
-{
-    struct ble_store_value_sec *value_sec;
-
-    BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
-
-    value_sec = arg;
-
-    if (value_sec != NULL) {
-        /* Store provided a key; send it to the controller. */
-        res->app_status = ble_sm_ltk_req_reply_tx(
-            proc->conn_handle, value_sec->ltk);
-
-        if (res->app_status == 0) {
-            proc->key_size = value_sec->key_size;
-            if (value_sec->authenticated) {
-                proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
-            }
-        } else {
-            /* Notify the app if it provided a key and the procedure failed. */
-            res->enc_cb = 1;
-        }
-    } else {
-        /* Application does not have the requested key in its database.  Send a
-         * negative reply to the controller.
-         */
-        ble_sm_ltk_req_neg_reply_tx(proc->conn_handle);
-        res->app_status = BLE_HS_ENOENT;
-    }
-
-    if (res->app_status == 0) {
-        proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
-    }
-}
-
-int
-ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req *ev)
-{
-    struct ble_store_value_sec value_sec;
-    struct ble_hs_conn_addrs addrs;
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    struct ble_hs_conn *conn;
-    uint8_t peer_id_addr[6];
-    int store_rc;
-    int restore;
-
-    uint16_t conn_handle = le16toh(ev->conn_handle);
-
-    memset(&res, 0, sizeof res);
-
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, 0, NULL);
-    if (proc == NULL) {
-        /* The peer is attempting to restore a encrypted connection via the
-         * encryption procedure.  Create a proc entry to indicate that security
-         * establishment is in progress and execute the procedure after the
-         * mutex gets unlocked.
-         */
-        restore = 1;
-        proc = ble_sm_proc_alloc();
-        if (proc == NULL) {
-            res.app_status = BLE_HS_ENOMEM;
-        } else {
-            proc->conn_handle = conn_handle;
-            proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
-            ble_sm_insert(proc);
-
-            res.execute = 1;
-        }
-    } else if (proc->state == BLE_SM_PROC_STATE_SEC_REQ) {
-        /* Same as above, except we solicited the encryption procedure by
-         * sending a security request.
-         */
-        restore = 1;
-        proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
-        res.execute = 1;
-    } else if (proc->state == BLE_SM_PROC_STATE_LTK_START) {
-        /* Legacy pairing just completed.  Send the short term key to the
-         * controller.
-         */
-        restore = 0;
-        res.execute = 1;
-    } else {
-        /* The request is unexpected; nack and forget. */
-        restore = 0;
-        ble_sm_ltk_req_neg_reply_tx(conn_handle);
-        proc = NULL;
-    }
-
-    if (restore) {
-        conn = ble_hs_conn_find_assert(conn_handle);
-        ble_hs_conn_addrs(conn, &addrs);
-        memcpy(peer_id_addr, addrs.peer_id_addr.val, 6);
-    }
-
-    ble_hs_unlock();
-
-    if (proc == NULL) {
-        return res.app_status;
-    }
-
-    if (res.app_status == 0) {
-        if (restore) {
-            store_rc = ble_sm_retrieve_ltk(le16toh(ev->div), le64toh(ev->rand),
-                                            addrs.peer_id_addr.type,
-                                           peer_id_addr, &value_sec);
-            if (store_rc == 0) {
-                /* Send the key to the controller. */
-                res.state_arg = &value_sec;
-            } else {
-                /* Send a nack to the controller. */
-                res.state_arg = NULL;
-            }
-        }
-    }
-
-    ble_sm_process_result(conn_handle, &res, true);
-
-    return 0;
+
+static int ble_sm_ltk_req_neg_reply_tx(uint16_t conn_handle)
+{
+	struct ble_hci_le_lt_key_req_neg_reply_cp cmd;
+	struct ble_hci_le_lt_key_req_neg_reply_cp rsp;
+	int rc;
+
+	cmd.conn_handle = htole16(conn_handle);
+	rc =
+		ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY),
+	                    &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+	if (rc != 0) {
+		return rc;
+	}
+
+	if (le16toh(rsp.conn_handle) != conn_handle) {
+		return BLE_HS_ECONTROLLER;
+	}
+
+	return 0;
+}
+
+static void ble_sm_ltk_start_exec(struct ble_sm_proc *proc,
+                                  struct ble_sm_result *res, void *arg)
+{
+	BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
+
+	res->app_status = ble_sm_ltk_req_reply_tx(proc->conn_handle, proc->ltk);
+	if (res->app_status == 0) {
+		proc->state = BLE_SM_PROC_STATE_ENC_START;
+	}
+	else {
+		res->enc_cb = 1;
+	}
+}
+
+static void ble_sm_ltk_restore_exec(struct ble_sm_proc *proc,
+                                    struct ble_sm_result *res, void *arg)
+{
+	struct ble_store_value_sec *value_sec;
+
+	BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
+
+	value_sec = arg;
+
+	if (value_sec != NULL) {
+		/* Store provided a key; send it to the controller. */
+		res->app_status = ble_sm_ltk_req_reply_tx(proc->conn_handle, value_sec->ltk);
+
+		if (res->app_status == 0) {
+			proc->key_size = value_sec->key_size;
+			if (value_sec->authenticated) {
+				proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
+			}
+		}
+		else {
+			/* Notify the app if it provided a key and the procedure failed. */
+			res->enc_cb = 1;
+		}
+	}
+	else {
+		/* Application does not have the requested key in its database.  Send a
+		 * negative reply to the controller.
+		 */
+		ble_sm_ltk_req_neg_reply_tx(proc->conn_handle);
+		res->app_status = BLE_HS_ENOENT;
+	}
+
+	if (res->app_status == 0) {
+		proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
+	}
+}
+
+int ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req *ev)
+{
+	struct ble_store_value_sec value_sec;
+	struct ble_hs_conn_addrs addrs;
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	struct ble_hs_conn *conn;
+	uint8_t peer_id_addr[6];
+	int store_rc;
+	int restore;
+
+	uint16_t conn_handle = le16toh(ev->conn_handle);
+
+	memset(&res, 0, sizeof res);
+
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, 0, NULL);
+	if (proc == NULL) {
+		/* The peer is attempting to restore a encrypted connection via the
+		 * encryption procedure.  Create a proc entry to indicate that security
+		 * establishment is in progress and execute the procedure after the
+		 * mutex gets unlocked.
+		 */
+		restore = 1;
+		proc = ble_sm_proc_alloc();
+		if (proc == NULL) {
+			res.app_status = BLE_HS_ENOMEM;
+		}
+		else {
+			proc->conn_handle = conn_handle;
+			proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
+			ble_sm_insert(proc);
+
+			res.execute = 1;
+		}
+	}
+	else if (proc->state == BLE_SM_PROC_STATE_SEC_REQ) {
+		/* Same as above, except we solicited the encryption procedure by
+		 * sending a security request.
+		 */
+		restore = 1;
+		proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
+		res.execute = 1;
+	}
+	else if (proc->state == BLE_SM_PROC_STATE_LTK_START) {
+		/* Legacy pairing just completed.  Send the short term key to the
+		 * controller.
+		 */
+		restore = 0;
+		res.execute = 1;
+	}
+	else {
+		/* The request is unexpected; nack and forget. */
+		restore = 0;
+		ble_sm_ltk_req_neg_reply_tx(conn_handle);
+		proc = NULL;
+	}
+
+	if (restore) {
+		conn = ble_hs_conn_find_assert(conn_handle);
+		ble_hs_conn_addrs(conn, &addrs);
+		memcpy(peer_id_addr, addrs.peer_id_addr.val, 6);
+	}
+
+	ble_hs_unlock();
+
+	if (proc == NULL) {
+		return res.app_status;
+	}
+
+	if (res.app_status == 0) {
+		if (restore) {
+			store_rc = ble_sm_retrieve_ltk(le16toh(ev->div), le64toh(ev->rand),
+			                               addrs.peer_id_addr.type, peer_id_addr, &value_sec);
+			if (store_rc == 0) {
+				/* Send the key to the controller. */
+				res.state_arg = &value_sec;
+			}
+			else {
+				/* Send a nack to the controller. */
+				res.state_arg = NULL;
+			}
+		}
+	}
+
+	ble_sm_process_result(conn_handle, &res, true);
+
+	return 0;
 }
 
 /*****************************************************************************
  * $random                                                                   *
  *****************************************************************************/
 
-uint8_t *
-ble_sm_our_pair_rand(struct ble_sm_proc *proc)
+uint8_t *ble_sm_our_pair_rand(struct ble_sm_proc *proc)
 {
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        return proc->randm;
-    } else {
-        return proc->rands;
-    }
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		return proc->randm;
+	}
+	else {
+		return proc->rands;
+	}
 }
 
-uint8_t *
-ble_sm_peer_pair_rand(struct ble_sm_proc *proc)
+uint8_t *ble_sm_peer_pair_rand(struct ble_sm_proc *proc)
 {
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        return proc->rands;
-    } else {
-        return proc->randm;
-    }
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		return proc->rands;
+	}
+	else {
+		return proc->randm;
+	}
 }
 
-static void
-ble_sm_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                   void *arg)
+static void ble_sm_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                               void *arg)
 {
-    if (proc->flags & BLE_SM_PROC_F_SC) {
-        ble_sm_sc_random_exec(proc, res);
-    } else {
-        ble_sm_lgcy_random_exec(proc, res);
-    }
+	if (proc->flags & BLE_SM_PROC_F_SC) {
+		ble_sm_sc_random_exec(proc, res);
+	}
+	else {
+		ble_sm_lgcy_random_exec(proc, res);
+	}
 }
 
-static void
-ble_sm_random_rx(uint16_t conn_handle, struct os_mbuf **om,
-                 struct ble_sm_result *res)
+static void ble_sm_random_rx(uint16_t conn_handle, struct os_mbuf **om,
+                             struct ble_sm_result *res)
 {
-    struct ble_sm_pair_random *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_pair_random *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_pair_random *)(*om)->om_data;
+	cmd = (struct ble_sm_pair_random *) (*om)->om_data;
 
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_RANDOM, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-    } else {
-        memcpy(ble_sm_peer_pair_rand(proc), cmd->value, 16);
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_RANDOM, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+	}
+	else {
+		memcpy(ble_sm_peer_pair_rand(proc), cmd->value, 16);
 
-        if (proc->flags & BLE_SM_PROC_F_SC) {
-            ble_sm_sc_random_rx(proc, res);
-        } else {
-            ble_sm_lgcy_random_rx(proc, res);
-        }
-    }
-    ble_hs_unlock();
+		if (proc->flags & BLE_SM_PROC_F_SC) {
+			ble_sm_sc_random_rx(proc, res);
+		}
+		else {
+			ble_sm_lgcy_random_rx(proc, res);
+		}
+	}
+	ble_hs_unlock();
 }
 
 /*****************************************************************************
  * $confirm                                                                  *
  *****************************************************************************/
 
-static void
-ble_sm_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                    void *arg)
-{
-    if (!(proc->flags & BLE_SM_PROC_F_SC)) {
-        ble_sm_lgcy_confirm_exec(proc, res);
-    } else {
-        ble_sm_sc_confirm_exec(proc, res);
-    }
-}
-
-static void
-ble_sm_confirm_rx(uint16_t conn_handle, struct os_mbuf **om,
-                  struct ble_sm_result *res)
-{
-    struct ble_sm_pair_confirm *cmd;
-    struct ble_sm_proc *proc;
-    uint8_t ioact;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
-
-    cmd = (struct ble_sm_pair_confirm *)(*om)->om_data;
-
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_CONFIRM, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-    } else {
-        memcpy(proc->confirm_peer, cmd->value, 16);
-
-        if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-            proc->state = BLE_SM_PROC_STATE_RANDOM;
-            res->execute = 1;
-        } else {
-            int rc;
-
-            rc = ble_sm_io_action(proc, &ioact);
-            if (rc != 0) {
-                BLE_HS_DBG_ASSERT(0);
-            }
-
-            if (ble_sm_ioact_state(ioact) == proc->state) {
-                proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
-            }
-            if (ble_sm_proc_can_advance(proc)) {
-                res->execute = 1;
-            }
-        }
-    }
-    ble_hs_unlock();
+static void ble_sm_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                                void *arg)
+{
+	if (!(proc->flags & BLE_SM_PROC_F_SC)) {
+		ble_sm_lgcy_confirm_exec(proc, res);
+	}
+	else {
+		ble_sm_sc_confirm_exec(proc, res);
+	}
+}
+
+static void ble_sm_confirm_rx(uint16_t conn_handle, struct os_mbuf **om,
+                              struct ble_sm_result *res)
+{
+	struct ble_sm_pair_confirm *cmd;
+	struct ble_sm_proc *proc;
+	uint8_t ioact;
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
+
+	cmd = (struct ble_sm_pair_confirm *) (*om)->om_data;
+
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_CONFIRM, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+	}
+	else {
+		memcpy(proc->confirm_peer, cmd->value, 16);
+
+		if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+			proc->state = BLE_SM_PROC_STATE_RANDOM;
+			res->execute = 1;
+		}
+		else {
+			int rc;
+
+			rc = ble_sm_io_action(proc, &ioact);
+			if (rc != 0) {
+				BLE_HS_DBG_ASSERT(0);
+			}
+
+			if (ble_sm_ioact_state(ioact) == proc->state) {
+				proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
+			}
+			if (ble_sm_proc_can_advance(proc)) {
+				res->execute = 1;
+			}
+		}
+	}
+	ble_hs_unlock();
 }
 
 /*****************************************************************************
  * $pair                                                                     *
  *****************************************************************************/
 
-static uint8_t
-ble_sm_state_after_pair(struct ble_sm_proc *proc)
+static uint8_t ble_sm_state_after_pair(struct ble_sm_proc *proc)
 {
-    if (proc->flags & BLE_SM_PROC_F_SC) {
-        return BLE_SM_PROC_STATE_PUBLIC_KEY;
-    } else {
-        return BLE_SM_PROC_STATE_CONFIRM;
-    }
+	if (proc->flags & BLE_SM_PROC_F_SC) {
+		return BLE_SM_PROC_STATE_PUBLIC_KEY;
+	}
+	else {
+		return BLE_SM_PROC_STATE_CONFIRM;
+	}
 }
 
-static void
-ble_sm_pair_cfg(struct ble_sm_proc *proc)
+static void ble_sm_pair_cfg(struct ble_sm_proc *proc)
 {
-    struct ble_sm_pair_cmd *pair_req, *pair_rsp;
-    uint8_t init_key_dist;
-    uint8_t resp_key_dist;
-    uint8_t rx_key_dist;
-    uint8_t ioact;
-    int rc;
-
-    pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+	struct ble_sm_pair_cmd *pair_req, *pair_rsp;
+	uint8_t init_key_dist;
+	uint8_t resp_key_dist;
+	uint8_t rx_key_dist;
+	uint8_t ioact;
+	int rc;
 
-    if (pair_req->authreq & BLE_SM_PAIR_AUTHREQ_SC &&
-        pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_SC) {
+	pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+	pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
 
-        proc->flags |= BLE_SM_PROC_F_SC;
-    }
+	if (pair_req->authreq & BLE_SM_PAIR_AUTHREQ_SC &&
+	    pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_SC) {
+		proc->flags |= BLE_SM_PROC_F_SC;
+	}
 
-    ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        rx_key_dist = resp_key_dist;
-    } else {
-        rx_key_dist = init_key_dist;
-    }
+	ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		rx_key_dist = resp_key_dist;
+	}
+	else {
+		rx_key_dist = init_key_dist;
+	}
 
-    if (pair_req->authreq & BLE_SM_PAIR_AUTHREQ_BOND &&
-        pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
+	if (pair_req->authreq & BLE_SM_PAIR_AUTHREQ_BOND &&
+	    pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
+		proc->flags |= BLE_SM_PROC_F_BONDING;
+	}
 
-        proc->flags |= BLE_SM_PROC_F_BONDING;
-    }
+	/* In legacy mode, bonding requires the exchange of keys
+	 * at least from one side.  If no key exchange was specified,
+	 * pretend bonding is not enabled.
+	 */
+	if (!(proc->flags & BLE_SM_PROC_F_SC) && (init_key_dist == 0 && resp_key_dist == 0)) {
+		proc->flags &= ~BLE_SM_PROC_F_BONDING;
+	}
 
-    /* In legacy mode, bonding requires the exchange of keys
-     * at least from one side.  If no key exchange was specified,
-     * pretend bonding is not enabled.
-     */
-    if (!(proc->flags & BLE_SM_PROC_F_SC) &&
-        (init_key_dist == 0 && resp_key_dist == 0)) {
+	proc->rx_key_flags = 0;
+	if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
+		proc->rx_key_flags |= BLE_SM_KE_F_ENC_INFO | BLE_SM_KE_F_MASTER_ID;
+	}
+	if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
+		proc->rx_key_flags |= BLE_SM_KE_F_ID_INFO | BLE_SM_KE_F_ADDR_INFO;
+	}
+	if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
+		proc->rx_key_flags |= BLE_SM_KE_F_SIGN_INFO;
+	}
 
-        proc->flags &= ~BLE_SM_PROC_F_BONDING;
-    }
+	proc->key_size = min(pair_req->max_enc_key_size, pair_rsp->max_enc_key_size);
 
-    proc->rx_key_flags = 0;
-    if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
-        proc->rx_key_flags |= BLE_SM_KE_F_ENC_INFO |
-                              BLE_SM_KE_F_MASTER_ID;
-    }
-    if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
-        proc->rx_key_flags |= BLE_SM_KE_F_ID_INFO |
-                              BLE_SM_KE_F_ADDR_INFO;
-    }
-    if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
-        proc->rx_key_flags |= BLE_SM_KE_F_SIGN_INFO;
-    }
-
-    proc->key_size = min(pair_req->max_enc_key_size,
-                         pair_rsp->max_enc_key_size);
-
-    rc = ble_sm_io_action(proc, &ioact);
-    BLE_HS_DBG_ASSERT_EVAL(rc == 0);
+	rc = ble_sm_io_action(proc, &ioact);
+	BLE_HS_DBG_ASSERT_EVAL(rc == 0);
 }
 
-static void
-ble_sm_pair_base_fill(struct ble_sm_pair_cmd *cmd)
+static void ble_sm_pair_base_fill(struct ble_sm_pair_cmd *cmd)
 {
-    cmd->io_cap = ble_hs_cfg.sm_io_cap;
-    cmd->oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
-    cmd->authreq = ble_sm_build_authreq();
-    cmd->max_enc_key_size = BLE_SM_PAIR_KEY_SZ_MAX;
+	cmd->io_cap = ble_hs_cfg.sm_io_cap;
+	cmd->oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
+	cmd->authreq = ble_sm_build_authreq();
+	cmd->max_enc_key_size = ble_hs_cfg.sm_max_enc_key_size;
 }
 
-static void
-ble_sm_pair_req_fill(struct ble_sm_proc *proc)
+static void ble_sm_pair_req_fill(struct ble_sm_proc *proc)
 {
-    struct ble_sm_pair_cmd *req;
+	struct ble_sm_pair_cmd *req;
 
-    req = (void *)(proc->pair_req + 1);
+	req = (void *) (proc->pair_req + 1);
 
-    proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
-    ble_sm_pair_base_fill(req);
-    req->init_key_dist = ble_hs_cfg.sm_our_key_dist;
-    req->resp_key_dist = ble_hs_cfg.sm_their_key_dist;
+	proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
+	ble_sm_pair_base_fill(req);
+	req->init_key_dist = ble_hs_cfg.sm_our_key_dist;
+	req->resp_key_dist = ble_hs_cfg.sm_their_key_dist;
 }
 
-static void
-ble_sm_pair_rsp_fill(struct ble_sm_proc *proc)
+static void ble_sm_pair_rsp_fill(struct ble_sm_proc *proc)
 {
-    const struct ble_sm_pair_cmd *req;
-    struct ble_sm_pair_cmd *rsp;
+	const struct ble_sm_pair_cmd *req;
+	struct ble_sm_pair_cmd *rsp;
 
-    req = (void *)(proc->pair_req + 1);
-    rsp = (void *)(proc->pair_rsp + 1);
+	req = (void *) (proc->pair_req + 1);
+	rsp = (void *) (proc->pair_rsp + 1);
 
-    proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
-    ble_sm_pair_base_fill(rsp);
+	proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
+	ble_sm_pair_base_fill(rsp);
 
-    /* The response's key distribution flags field is the intersection of
-     * the peer's preferences and our capabilities.
-     */
-    rsp->init_key_dist = req->init_key_dist &
-                         ble_hs_cfg.sm_their_key_dist;
-    rsp->resp_key_dist = req->resp_key_dist &
-                         ble_hs_cfg.sm_our_key_dist;
+	/* The response's key distribution flags field is the intersection of
+	 * the peer's preferences and our capabilities.
+	 */
+	rsp->init_key_dist = req->init_key_dist & ble_hs_cfg.sm_their_key_dist;
+	rsp->resp_key_dist = req->resp_key_dist & ble_hs_cfg.sm_our_key_dist;
 }
 
-static void
-ble_sm_pair_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                 void *arg)
+static void ble_sm_pair_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                             void *arg)
 {
-    struct ble_sm_pair_cmd *cmd;
-    struct os_mbuf *txom;
-    uint8_t ioact;
-    int is_req;
-    int rc;
+	struct ble_sm_pair_cmd *cmd;
+	struct os_mbuf *txom;
+	uint8_t ioact;
+	int is_req;
+	int rc;
 
-    is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;
+	is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;
 
-    cmd = ble_sm_cmd_get(is_req ? BLE_SM_OP_PAIR_REQ : BLE_SM_OP_PAIR_RSP,
-                         sizeof(*cmd), &txom);
-    if (cmd == NULL) {
-        rc = BLE_HS_ENOMEM;
-        goto err;
-    }
+	cmd = ble_sm_cmd_get(is_req ? BLE_SM_OP_PAIR_REQ : BLE_SM_OP_PAIR_RSP,
+	                     sizeof(*cmd), &txom);
+	if (cmd == NULL) {
+		rc = BLE_HS_ENOMEM;
+		goto err;
+	}
 
-    if (is_req) {
-        ble_sm_pair_req_fill(proc);
-        memcpy(cmd, proc->pair_req + 1, sizeof(*cmd));
-    } else {
-        /* The response was already generated when we processed the incoming
-         * request.
-         */
-        memcpy(cmd, proc->pair_rsp + 1, sizeof(*cmd));
+	if (is_req) {
+		ble_sm_pair_req_fill(proc);
+		memcpy(cmd, proc->pair_req + 1, sizeof(*cmd));
+	}
+	else {
+		/* The response was already generated when we processed the incoming
+		 * request.
+		 */
+		memcpy(cmd, proc->pair_rsp + 1, sizeof(*cmd));
 
-        proc->state = ble_sm_state_after_pair(proc);
+		proc->state = ble_sm_state_after_pair(proc);
 
-        rc = ble_sm_io_action(proc, &ioact);
-        BLE_HS_DBG_ASSERT(rc == 0);
+		rc = ble_sm_io_action(proc, &ioact);
+		BLE_HS_DBG_ASSERT(rc == 0);
 
-        if (ble_sm_ioact_state(ioact) == proc->state) {
-            res->passkey_params.action = ioact;
-        }
-    }
+		if (ble_sm_ioact_state(ioact) == proc->state) {
+			res->passkey_params.action = ioact;
+		}
+	}
 
-    rc = ble_sm_tx(proc->conn_handle, txom);
-    if (rc != 0) {
-        goto err;
-    }
+	rc = ble_sm_tx(proc->conn_handle, txom);
+	if (rc != 0) {
+		goto err;
+	}
 
-    res->app_status = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    return;
+	return;
 
 err:
-    res->app_status = rc;
-
-    if (!is_req) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    }
-}
-
-static bool
-ble_sm_verify_auth_requirements(uint8_t cmd)
-{
-    /* For now we check only SC only mode. I.e.: when remote indicates
-     * to not support SC pairing, let us make sure legacy pairing is supported
-     * on our side. If not, we can fail right away.
-     */
-    if (!(cmd & BLE_SM_PAIR_AUTHREQ_SC)) {
-        if (MYNEWT_VAL(BLE_SM_LEGACY) == 0) {
-            return false;
-        }
-    }
-    /* Fail if security level forces MITM protection and remote does not
-     * support it
-     */
-    if (MYNEWT_VAL(BLE_SM_LVL) >= 3 && !(cmd & BLE_SM_PAIR_AUTHREQ_MITM)) {
-        return false;
-    }
-    return true;
-}
-
-static void
-ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf **om,
-                   struct ble_sm_result *res)
-{
-    struct ble_sm_pair_cmd *req;
-    struct ble_sm_proc *proc;
-    struct ble_sm_proc *prev;
-    struct ble_hs_conn *conn;
-    ble_sm_proc_flags proc_flags;
-    uint8_t key_size;
-    int rc;
-
-    /* Silence spurious unused-variable warnings. */
-    proc_flags = 0;
-    key_size = 0;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*req));
-    if (res->app_status != 0) {
-        return;
-    }
-
-    req = (struct ble_sm_pair_cmd *)(*om)->om_data;
-
-    ble_hs_lock();
-
-    /* XXX: Check connection state; reject if not appropriate. */
-    /* XXX: Ensure enough time has passed since the previous failed pairing
-     * attempt.
-     */
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, &prev);
-    if (proc != NULL) {
-        /* Fail if procedure is in progress unless we sent a slave security
-         * request to peer.
-         */
-        if (proc->state != BLE_SM_PROC_STATE_SEC_REQ) {
-            res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_UNSPECIFIED);
-            ble_hs_unlock();
-            return;
-        }
-
-        /* Remove the procedure because it was allocated when
-         * sending the Slave Security Request and it will be allocated
-         * again later in this method. We should probably refactor this
-         * in the future.
-         */
-        ble_sm_proc_remove(proc, prev);
-        ble_sm_proc_free(proc);
-    }
-
-    ble_hs_unlock();
-
-    /* Check if there is storage capacity for a new bond.  If there isn't, ask
-     * the application to make room.
-     */
-    rc = ble_sm_chk_store_overflow(conn_handle);
-    if (rc != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->app_status = rc;
-        return;
-    }
-
-    ble_hs_lock();
-
-    proc = ble_sm_proc_alloc();
-    if (proc != NULL) {
-        proc->conn_handle = conn_handle;
-        proc->state = BLE_SM_PROC_STATE_PAIR;
-        ble_sm_insert(proc);
-
-        proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
-        memcpy(proc->pair_req + 1, req, sizeof(*req));
-
-        conn = ble_hs_conn_find_assert(proc->conn_handle);
-        if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
-            res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-        } else if (MYNEWT_VAL(BLE_SM_LVL) == 1) {
-            res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-        } else if (req->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
-            res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-        } else if (req->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
-            res->sm_err = BLE_SM_ERR_INVAL;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
-        } else if (MYNEWT_VAL(BLE_SM_SC_ONLY)) {
-            /* Fail if Secure Connections Only mode is on and remote does not
-             * meet key size requirements - MITM was checked in last step.
-             * Fail if SC is not supported by peer or key size is too small
-             */
-            if (!(req->authreq & BLE_SM_PAIR_AUTHREQ_SC)) {
-                res->sm_err = BLE_SM_ERR_AUTHREQ;
-                res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-            } else if (req->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX) {
-                res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
-                res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-            }
-        } else if (!ble_sm_verify_auth_requirements(req->authreq)) {
-            res->sm_err = BLE_SM_ERR_AUTHREQ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-        } else {
-            /* The request looks good.  Precalculate our pairing response and
-             * determine some properties of the imminent link.  We need this
-             * information in case this is a repeated pairing attempt (i.e., we
-             * are already bonded to this peer).  In that case, we include the
-             * information in a notification to the app.
-             */
-            ble_sm_pair_rsp_fill(proc);
-            ble_sm_pair_cfg(proc);
-
-            proc_flags = proc->flags;
-            key_size = proc->key_size;
-            res->execute = 1;
-        }
-    }
-
-    ble_hs_unlock();
-
-    /* Check if we are already bonded to this peer.  If so, give the
-     * application an opportunity to delete the old bond.
-     */
-    if (res->app_status == 0) {
-        rc = ble_sm_chk_repeat_pairing(conn_handle, proc_flags, key_size);
-        if (rc != 0) {
-            /* The app indicated that the pairing request should be ignored. */
-            res->app_status = rc;
-            res->execute = 0;
-        }
-    }
-}
-
-static void
-ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf **om,
-                   struct ble_sm_result *res)
-{
-    struct ble_sm_pair_cmd *rsp;
-    struct ble_sm_proc *proc;
-    uint8_t ioact;
-    int rc;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*rsp));
-    if (res->app_status != 0) {
-        res->enc_cb = 1;
-        return;
-    }
-
-    rsp = (struct ble_sm_pair_cmd *)(*om)->om_data;
-
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PAIR, 1, NULL);
-    if (proc != NULL) {
-        proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
-        memcpy(proc->pair_rsp + 1, rsp, sizeof(*rsp));
-
-        if (rsp->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
-            res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-        } else if (rsp->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
-            res->sm_err = BLE_SM_ERR_INVAL;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
-        } else if (MYNEWT_VAL(BLE_SM_SC_ONLY) && (rsp->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX)) {
-            /* Fail if Secure Connections Only mode is on and remote does not meet
-            * key size requirements - MITM was checked in last step
-            */
-            res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-        } else if (!ble_sm_verify_auth_requirements(rsp->authreq)) {
-            res->sm_err = BLE_SM_ERR_AUTHREQ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-        } else {
-            ble_sm_pair_cfg(proc);
-
-            rc = ble_sm_io_action(proc, &ioact);
-            if (rc != 0) {
-                res->sm_err = BLE_SM_ERR_AUTHREQ;
-                res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-                res->enc_cb = 1;
-            } else {
-                proc->state = ble_sm_state_after_pair(proc);
-                if (ble_sm_ioact_state(ioact) == proc->state) {
-                    res->passkey_params.action = ioact;
-                }
-                if (ble_sm_proc_can_advance(proc)) {
-                    res->execute = 1;
-                }
-            }
-        }
-    }
-
-    ble_hs_unlock();
+	res->app_status = rc;
+
+	if (!is_req) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+}
+
+static bool ble_sm_verify_auth_requirements(uint8_t cmd)
+{
+	/* For now we check only SC only mode. I.e.: when remote indicates
+	 * to not support SC pairing, let us make sure legacy pairing is supported
+	 * on our side. If not, we can fail right away.
+	 */
+	if (!(cmd & BLE_SM_PAIR_AUTHREQ_SC)) {
+		if (MYNEWT_VAL(BLE_SM_LEGACY) == 0) {
+			return false;
+		}
+	}
+	/* Fail if security level forces MITM protection and remote does not
+	 * support it
+	 */
+	if (MYNEWT_VAL(BLE_SM_LVL) >= 3 && !(cmd & BLE_SM_PAIR_AUTHREQ_MITM)) {
+		return false;
+	}
+	return true;
+}
+
+static void ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf **om,
+                               struct ble_sm_result *res)
+{
+	struct ble_sm_pair_cmd *req;
+	struct ble_sm_proc *proc;
+	struct ble_sm_proc *prev;
+	struct ble_hs_conn *conn;
+	ble_sm_proc_flags proc_flags;
+	uint8_t key_size;
+	int rc;
+
+	/* Silence spurious unused-variable warnings. */
+	proc_flags = 0;
+	key_size = 0;
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*req));
+	if (res->app_status != 0) {
+		return;
+	}
+
+	req = (struct ble_sm_pair_cmd *) (*om)->om_data;
+
+	ble_hs_lock();
+
+	/* XXX: Check connection state; reject if not appropriate. */
+	/* XXX: Ensure enough time has passed since the previous failed pairing
+	 * attempt.
+	 */
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, &prev);
+	if (proc != NULL) {
+		/* Fail if procedure is in progress unless we sent a slave security
+		 * request to peer.
+		 */
+		if (proc->state != BLE_SM_PROC_STATE_SEC_REQ) {
+			res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_UNSPECIFIED);
+			ble_hs_unlock();
+			return;
+		}
+
+		/* Remove the procedure because it was allocated when
+		 * sending the Slave Security Request and it will be allocated
+		 * again later in this method. We should probably refactor this
+		 * in the future.
+		 */
+		ble_sm_proc_remove(proc, prev);
+		ble_sm_proc_free(proc);
+	}
+
+	ble_hs_unlock();
+
+	/* Check if there is storage capacity for a new bond.  If there isn't, ask
+	 * the application to make room.
+	 */
+	rc = ble_sm_chk_store_overflow(conn_handle);
+	if (rc != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->app_status = rc;
+		return;
+	}
+
+	ble_hs_lock();
+
+	proc = ble_sm_proc_alloc();
+	if (proc != NULL) {
+		proc->conn_handle = conn_handle;
+		proc->state = BLE_SM_PROC_STATE_PAIR;
+		ble_sm_insert(proc);
+
+		proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
+		memcpy(proc->pair_req + 1, req, sizeof(*req));
+
+		conn = ble_hs_conn_find_assert(proc->conn_handle);
+		if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
+			res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
+		}
+		else if (MYNEWT_VAL(BLE_SM_LVL) == 1) {
+			res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
+		}
+		else if (req->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
+			res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
+		}
+		else if (req->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
+			res->sm_err = BLE_SM_ERR_INVAL;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
+		}
+		else if (MYNEWT_VAL(BLE_SM_SC_ONLY)) {
+			/* Fail if Secure Connections Only mode is on and remote does not
+			 * meet key size requirements - MITM was checked in last step.
+			 * Fail if SC is not supported by peer or key size is too small
+			 */
+			if (!(req->authreq & BLE_SM_PAIR_AUTHREQ_SC)) {
+				res->sm_err = BLE_SM_ERR_AUTHREQ;
+				res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+			}
+			else if (req->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX) {
+				res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
+				res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
+			}
+		}
+		else if (!ble_sm_verify_auth_requirements(req->authreq)) {
+			res->sm_err = BLE_SM_ERR_AUTHREQ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+		}
+		else {
+			/* The request looks good.  Precalculate our pairing response and
+			 * determine some properties of the imminent link.  We need this
+			 * information in case this is a repeated pairing attempt (i.e., we
+			 * are already bonded to this peer).  In that case, we include the
+			 * information in a notification to the app.
+			 */
+			ble_sm_pair_rsp_fill(proc);
+			ble_sm_pair_cfg(proc);
+
+			proc_flags = proc->flags;
+			key_size = proc->key_size;
+			res->execute = 1;
+		}
+	}
+
+	ble_hs_unlock();
+
+	/* Check if we are already bonded to this peer.  If so, give the
+	 * application an opportunity to delete the old bond.
+	 */
+	if (res->app_status == 0) {
+		rc = ble_sm_chk_repeat_pairing(conn_handle, proc_flags, key_size);
+		if (rc != 0) {
+			/* The app indicated that the pairing request should be ignored. */
+			res->app_status = rc;
+			res->execute = 0;
+		}
+	}
+}
+
+static void ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf **om,
+                               struct ble_sm_result *res)
+{
+	struct ble_sm_pair_cmd *rsp;
+	struct ble_sm_proc *proc;
+	uint8_t ioact;
+	int rc;
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*rsp));
+	if (res->app_status != 0) {
+		res->enc_cb = 1;
+		return;
+	}
+
+	rsp = (struct ble_sm_pair_cmd *) (*om)->om_data;
+
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PAIR, 1, NULL);
+	if (proc != NULL) {
+		proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
+		memcpy(proc->pair_rsp + 1, rsp, sizeof(*rsp));
+
+		if (rsp->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
+			res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
+		}
+		else if (rsp->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
+			res->sm_err = BLE_SM_ERR_INVAL;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
+		}
+		else if (MYNEWT_VAL(BLE_SM_SC_ONLY) &&
+		         (rsp->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX)) {
+			/* Fail if Secure Connections Only mode is on and remote does not meet
+			 * key size requirements - MITM was checked in last step
+			 */
+			res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
+		}
+		else if (!ble_sm_verify_auth_requirements(rsp->authreq)) {
+			res->sm_err = BLE_SM_ERR_AUTHREQ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+		}
+		else {
+			ble_sm_pair_cfg(proc);
+
+			rc = ble_sm_io_action(proc, &ioact);
+			if (rc != 0) {
+				res->sm_err = BLE_SM_ERR_AUTHREQ;
+				res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+				res->enc_cb = 1;
+			}
+			else {
+				proc->state = ble_sm_state_after_pair(proc);
+				if (ble_sm_ioact_state(ioact) == proc->state) {
+					res->passkey_params.action = ioact;
+				}
+				if (ble_sm_proc_can_advance(proc)) {
+					res->execute = 1;
+				}
+			}
+		}
+	}
+
+	ble_hs_unlock();
 }
 
 /*****************************************************************************
  * $security request                                                         *
  *****************************************************************************/
 
-static void
-ble_sm_sec_req_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                    void *arg)
-{
-    struct ble_sm_sec_req *cmd;
-    struct os_mbuf *txom;
-    int rc;
-
-    cmd = ble_sm_cmd_get(BLE_SM_OP_SEC_REQ, sizeof(*cmd), &txom);
-    if (!cmd) {
-        res->app_status = BLE_HS_ENOMEM;
-        return;
-    }
-
-    cmd->authreq = ble_sm_build_authreq();
-    rc = ble_sm_tx(proc->conn_handle, txom);
-    if (rc != 0) {
-        res->app_status = rc;
-        return;
-    }
-}
-
-static void
-ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
-                  struct ble_sm_result *res)
-{
-    struct ble_store_value_sec value_sec;
-    struct ble_store_key_sec key_sec;
-    struct ble_hs_conn_addrs addrs;
-    struct ble_sm_sec_req *cmd;
-    struct ble_hs_conn *conn;
-    int authreq_mitm;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        return;
-    }
-
-    cmd = (struct ble_sm_sec_req *)(*om)->om_data;
-
-    /* XXX: Reject if:
-     *     o authreq-reserved flags set?
-     */
-
-    ble_hs_lock();
-
-    conn = ble_hs_conn_find_assert(conn_handle);
-    if (!(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
-        res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-        res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
-    } else {
-        /* We will be querying the SM database for a key corresponding to the
-         * sender; remember the sender's address while the connection list is
-         * locked.
-         */
-        ble_hs_conn_addrs(conn, &addrs);
-        memset(&key_sec, 0, sizeof key_sec);
-        key_sec.peer_addr = addrs.peer_id_addr;
-    }
-
-    ble_hs_unlock();
-
-    if (res->app_status == 0) {
-        /* If the peer is requesting a bonded connection, query database for an
-         * LTK corresponding to the sender.
-         */
-        if (cmd->authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
-            res->app_status = ble_store_read_peer_sec(&key_sec, &value_sec);
-        } else {
-            res->app_status = BLE_HS_ENOENT;
-        }
-        if (res->app_status == 0) {
-            /* Found a key corresponding to this peer.  Make sure it meets the
-             * requested minimum authreq.
-             */
-            authreq_mitm = cmd->authreq & BLE_SM_PAIR_AUTHREQ_MITM;
-            if (authreq_mitm && !value_sec.authenticated) {
-                res->app_status = BLE_HS_EREJECT;
-            }
-        }
-
-        if (res->app_status == 0) {
-            res->app_status = ble_sm_enc_initiate(conn_handle,
-                                                  value_sec.key_size,
-                                                  value_sec.ltk,
-                                                  value_sec.ediv,
-                                                  value_sec.rand_num,
-                                                  value_sec.authenticated);
-        } else {
-            res->app_status = ble_sm_pair_initiate(conn_handle);
-        }
-    }
+static void ble_sm_sec_req_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                                void *arg)
+{
+	struct ble_sm_sec_req *cmd;
+	struct os_mbuf *txom;
+	int rc;
+
+	cmd = ble_sm_cmd_get(BLE_SM_OP_SEC_REQ, sizeof(*cmd), &txom);
+	if (!cmd) {
+		res->app_status = BLE_HS_ENOMEM;
+		return;
+	}
+
+	cmd->authreq = ble_sm_build_fake_authreq();
+	rc = ble_sm_tx(proc->conn_handle, txom);
+	if (rc != 0) {
+		res->app_status = rc;
+		return;
+	}
+}
+
+static void ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
+                              struct ble_sm_result *res)
+{
+	struct ble_store_value_sec value_sec;
+	struct ble_store_key_sec key_sec;
+	struct ble_hs_conn_addrs addrs;
+	struct ble_sm_sec_req *cmd;
+	struct ble_hs_conn *conn;
+	int authreq_mitm;
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		return;
+	}
+
+	cmd = (struct ble_sm_sec_req *) (*om)->om_data;
+
+	/* XXX: Reject if:
+	 *     o authreq-reserved flags set?
+	 */
+
+	ble_hs_lock();
+
+	conn = ble_hs_conn_find_assert(conn_handle);
+	if (!(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
+		res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
+		res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
+	}
+	else {
+		/* We will be querying the SM database for a key corresponding to the
+		 * sender; remember the sender's address while the connection list is
+		 * locked.
+		 */
+		ble_hs_conn_addrs(conn, &addrs);
+		memset(&key_sec, 0, sizeof key_sec);
+		key_sec.peer_addr = addrs.peer_id_addr;
+	}
+
+	ble_hs_unlock();
+
+	if (res->app_status == 0) {
+		/* If the peer is requesting a bonded connection, query database for an
+		 * LTK corresponding to the sender.
+		 */
+		if (cmd->authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
+			res->app_status = ble_store_read_peer_sec(&key_sec, &value_sec);
+		}
+		else {
+			res->app_status = BLE_HS_ENOENT;
+		}
+		if (res->app_status == 0) {
+			/* Found a key corresponding to this peer.  Make sure it meets the
+			 * requested minimum authreq.
+			 */
+			authreq_mitm = cmd->authreq & BLE_SM_PAIR_AUTHREQ_MITM;
+			if (authreq_mitm && !value_sec.authenticated) {
+				res->app_status = BLE_HS_EREJECT;
+			}
+		}
+
+		if (res->app_status == 0) {
+			res->app_status = ble_sm_enc_initiate(
+				conn_handle, value_sec.key_size, value_sec.ltk, value_sec.ediv,
+				value_sec.rand_num, value_sec.authenticated);
+		}
+		else {
+			res->app_status = ble_sm_pair_initiate(conn_handle);
+		}
+	}
 }
 
 /*****************************************************************************
  * $key exchange                                                             *
  *****************************************************************************/
 
-static void
-ble_sm_key_exch_success(struct ble_sm_proc *proc, struct ble_sm_result *res)
-{
-    /* The procedure is now complete.  Update connection bonded state and
-     * terminate procedure.
-     */
-    int bonded = !!(proc->flags & BLE_SM_PROC_F_BONDING);
-    ble_sm_update_sec_state(proc->conn_handle, 1,
-                            !!(proc->flags & BLE_SM_PROC_F_AUTHENTICATED),
-                            bonded,
-                            proc->key_size);
-    proc->state = BLE_SM_PROC_STATE_NONE;
-
-    res->app_status = 0;
-    res->enc_cb = 1;
-    res->bonded = bonded;
-    res->sm_err = BLE_SM_ERR_SUCCESS;
-}
-
-static void
-ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                     void *arg)
-{
-    struct ble_sm_id_addr_info *addr_info;
-    struct ble_hs_conn_addrs addrs;
-    struct ble_sm_sign_info *sign_info;
-    struct ble_sm_master_id *master_id;
-    struct ble_sm_enc_info *enc_info;
-    struct ble_sm_id_info *id_info;
-    struct ble_hs_conn *conn;
-    uint8_t init_key_dist;
-    uint8_t resp_key_dist;
-    uint8_t our_key_dist;
-    struct os_mbuf *txom;
-    const uint8_t *irk;
-    struct ble_store_gen_key gen_key;
-    int ltk_gen = 0;
-    int rc;
-
-    ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        our_key_dist = init_key_dist;
-    } else {
-        our_key_dist = resp_key_dist;
-    }
-
-    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
-        /* Send encryption information. */
-        enc_info = ble_sm_cmd_get(BLE_SM_OP_ENC_INFO, sizeof(*enc_info), &txom);
-        if (!enc_info) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        proc->our_keys.key_size = proc->key_size;
-
-        if (ble_hs_cfg.store_gen_key_cb) {
-            memset(&gen_key, 0, sizeof(gen_key));
-            rc = ble_hs_cfg.store_gen_key_cb(BLE_STORE_GEN_KEY_LTK, &gen_key,
-                                             proc->conn_handle);
-            if (rc == 0) {
-                /* Trim LRK to keysize */
-                memset(gen_key.ltk_periph + proc->key_size, 0,
-                       16 - proc->key_size);
-
-                proc->our_keys.ediv = gen_key.ediv;
-                proc->our_keys.rand_val = gen_key.rand;
-                memcpy(proc->our_keys.ltk, gen_key.ltk_periph, 16);
-
-                ltk_gen = 1;
-            }
-        }
-
-        if (!ltk_gen) {
-            rc = ble_sm_gen_ltk(proc, enc_info->ltk);
-            if (rc != 0) {
-                os_mbuf_free_chain(txom);
-                goto err;
-            }
-
-            /* store LTK before sending since ble_sm_tx consumes tx mbuf */
-            memcpy(proc->our_keys.ltk, enc_info->ltk, 16);
-        } else {
-            memcpy(enc_info->ltk, proc->our_keys.ltk, 16);
-        }
-        proc->our_keys.ltk_valid = 1;
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-
-        /* Send master identification. */
-        master_id = ble_sm_cmd_get(BLE_SM_OP_MASTER_ID, sizeof(*master_id),
-                                   &txom);
-        if (!master_id) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        if (!ltk_gen) {
-            rc = ble_sm_gen_ediv(master_id);
-            if (rc != 0) {
-                os_mbuf_free_chain(txom);
-                goto err;
-            }
-            rc = ble_sm_gen_master_id_rand(master_id);
-            if (rc != 0) {
-                os_mbuf_free_chain(txom);
-                goto err;
-            }
-
-            proc->our_keys.rand_val = master_id->rand_val;
-            proc->our_keys.ediv = master_id->ediv;
-        } else {
-            master_id->ediv = proc->our_keys.ediv;
-            master_id->rand_val = proc->our_keys.rand_val;
-        }
-        proc->our_keys.ediv_rand_valid = 1;
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-    }
-
-    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
-        /* Send identity information. */
-        id_info = ble_sm_cmd_get(BLE_SM_OP_IDENTITY_INFO, sizeof(*id_info),
-                                 &txom);
-        if (!id_info) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        rc = ble_hs_pvcy_our_irk(&irk);
-        if (rc != 0) {
-            os_mbuf_free_chain(txom);
-            goto err;
-        }
-
-        memcpy(id_info->irk, irk, 16);
-        proc->our_keys.irk_valid = 1;
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-
-        /* Send identity address information. */
-        addr_info = ble_sm_cmd_get(BLE_SM_OP_IDENTITY_ADDR_INFO,
-                                   sizeof(*addr_info), &txom);
-        if (!addr_info) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        conn = ble_hs_conn_find_assert(proc->conn_handle);
-        ble_hs_conn_addrs(conn, &addrs);
-
-        addr_info->addr_type = addrs.our_id_addr.type;
-        memcpy(addr_info->bd_addr, addrs.our_id_addr.val, 6);
-
-        proc->our_keys.addr_valid = 1;
-        memcpy(proc->our_keys.irk, irk, 16);
-        proc->our_keys.addr_type = addr_info->addr_type;
-        memcpy(proc->our_keys.addr, addr_info->bd_addr, 6);
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-    }
-
-    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
-        /* Send signing information. */
-        sign_info = ble_sm_cmd_get(BLE_SM_OP_SIGN_INFO, sizeof(*sign_info),
-                                   &txom);
-        if (!sign_info) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        if (ble_hs_cfg.store_gen_key_cb) {
-            memset(&gen_key, 0, sizeof(gen_key));
-            rc = ble_hs_cfg.store_gen_key_cb(BLE_STORE_GEN_KEY_CSRK, &gen_key,
-                                             proc->conn_handle);
-            if (rc == 0) {
-                memcpy(proc->our_keys.csrk, gen_key.csrk, 16);
-            }
-        } else {
-            rc = -1;
-        }
-
-        if (rc != 0) {
-            rc = ble_sm_gen_csrk(proc, sign_info->sig_key);
-            if (rc != 0) {
-                os_mbuf_free_chain(txom);
-                goto err;
-            }
-
-            memcpy(proc->our_keys.csrk, sign_info->sig_key, 16);
-        } else {
-            memcpy(sign_info->sig_key, proc->our_keys.csrk, 16);
-        }
-        proc->our_keys.csrk_valid = 1;
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-    }
-
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR || proc->rx_key_flags == 0) {
-        /* The procedure is now complete. */
-        ble_sm_key_exch_success(proc, res);
-    }
-
-    return;
+static void ble_sm_key_exch_success(struct ble_sm_proc *proc, struct ble_sm_result *res)
+{
+	/* The procedure is now complete.  Update connection bonded state and
+	 * terminate procedure.
+	 */
+	int bonded = !!(proc->flags & BLE_SM_PROC_F_BONDING);
+	ble_sm_update_sec_state(proc->conn_handle, 1,
+	                        !!(proc->flags & BLE_SM_PROC_F_AUTHENTICATED), bonded,
+	                        proc->key_size);
+	proc->state = BLE_SM_PROC_STATE_NONE;
+
+	res->app_status = 0;
+	res->enc_cb = 1;
+	res->bonded = bonded;
+	res->sm_err = BLE_SM_ERR_SUCCESS;
+}
+
+static void ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                                 void *arg)
+{
+	struct ble_sm_id_addr_info *addr_info;
+	struct ble_hs_conn_addrs addrs;
+	struct ble_sm_sign_info *sign_info;
+	struct ble_sm_master_id *master_id;
+	struct ble_sm_enc_info *enc_info;
+	struct ble_sm_id_info *id_info;
+	struct ble_hs_conn *conn;
+	uint8_t init_key_dist;
+	uint8_t resp_key_dist;
+	uint8_t our_key_dist;
+	struct os_mbuf *txom;
+	const uint8_t *irk;
+	struct ble_store_gen_key gen_key;
+	int ltk_gen = 0;
+	int rc;
+
+	ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		our_key_dist = init_key_dist;
+	}
+	else {
+		our_key_dist = resp_key_dist;
+	}
+
+	if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
+		/* Send encryption information. */
+		enc_info = ble_sm_cmd_get(BLE_SM_OP_ENC_INFO, sizeof(*enc_info), &txom);
+		if (!enc_info) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		proc->our_keys.key_size = proc->key_size;
+
+		if (ble_hs_cfg.store_gen_key_cb) {
+			memset(&gen_key, 0, sizeof(gen_key));
+			rc = ble_hs_cfg.store_gen_key_cb(BLE_STORE_GEN_KEY_LTK, &gen_key,
+			                                 proc->conn_handle);
+			if (rc == 0) {
+				/* Trim LRK to keysize */
+				memset(gen_key.ltk_periph + proc->key_size, 0, 16 - proc->key_size);
+
+				proc->our_keys.ediv = gen_key.ediv;
+				proc->our_keys.rand_val = gen_key.rand;
+				memcpy(proc->our_keys.ltk, gen_key.ltk_periph, 16);
+
+				ltk_gen = 1;
+			}
+		}
+
+		if (!ltk_gen) {
+			rc = ble_sm_gen_ltk(proc, enc_info->ltk);
+			if (rc != 0) {
+				os_mbuf_free_chain(txom);
+				goto err;
+			}
+
+			/* store LTK before sending since ble_sm_tx consumes tx mbuf */
+			memcpy(proc->our_keys.ltk, enc_info->ltk, 16);
+		}
+		else {
+			memcpy(enc_info->ltk, proc->our_keys.ltk, 16);
+		}
+		proc->our_keys.ltk_valid = 1;
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+
+		/* Send master identification. */
+		master_id = ble_sm_cmd_get(BLE_SM_OP_MASTER_ID, sizeof(*master_id), &txom);
+		if (!master_id) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		if (!ltk_gen) {
+			rc = ble_sm_gen_ediv(master_id);
+			if (rc != 0) {
+				os_mbuf_free_chain(txom);
+				goto err;
+			}
+			rc = ble_sm_gen_master_id_rand(master_id);
+			if (rc != 0) {
+				os_mbuf_free_chain(txom);
+				goto err;
+			}
+
+			proc->our_keys.rand_val = master_id->rand_val;
+			proc->our_keys.ediv = master_id->ediv;
+		}
+		else {
+			master_id->ediv = proc->our_keys.ediv;
+			master_id->rand_val = proc->our_keys.rand_val;
+		}
+		proc->our_keys.ediv_rand_valid = 1;
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+	}
+
+	if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
+		/* Send identity information. */
+		id_info = ble_sm_cmd_get(BLE_SM_OP_IDENTITY_INFO, sizeof(*id_info), &txom);
+		if (!id_info) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		rc = ble_hs_pvcy_our_irk(&irk);
+		if (rc != 0) {
+			os_mbuf_free_chain(txom);
+			goto err;
+		}
+
+		memcpy(id_info->irk, irk, 16);
+		proc->our_keys.irk_valid = 1;
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+
+		/* Send identity address information. */
+		addr_info = ble_sm_cmd_get(BLE_SM_OP_IDENTITY_ADDR_INFO, sizeof(*addr_info), &txom);
+		if (!addr_info) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		conn = ble_hs_conn_find_assert(proc->conn_handle);
+		ble_hs_conn_addrs(conn, &addrs);
+
+		addr_info->addr_type = addrs.our_id_addr.type;
+		memcpy(addr_info->bd_addr, addrs.our_id_addr.val, 6);
+
+		proc->our_keys.addr_valid = 1;
+		memcpy(proc->our_keys.irk, irk, 16);
+		proc->our_keys.addr_type = addr_info->addr_type;
+		memcpy(proc->our_keys.addr, addr_info->bd_addr, 6);
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+	}
+
+	if (our_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
+		/* Send signing information. */
+		sign_info = ble_sm_cmd_get(BLE_SM_OP_SIGN_INFO, sizeof(*sign_info), &txom);
+		if (!sign_info) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		if (ble_hs_cfg.store_gen_key_cb) {
+			memset(&gen_key, 0, sizeof(gen_key));
+			rc = ble_hs_cfg.store_gen_key_cb(BLE_STORE_GEN_KEY_CSRK, &gen_key,
+			                                 proc->conn_handle);
+			if (rc == 0) {
+				memcpy(proc->our_keys.csrk, gen_key.csrk, 16);
+			}
+		}
+		else {
+			rc = -1;
+		}
+
+		if (rc != 0) {
+			rc = ble_sm_gen_csrk(proc, sign_info->sig_key);
+			if (rc != 0) {
+				os_mbuf_free_chain(txom);
+				goto err;
+			}
+
+			memcpy(proc->our_keys.csrk, sign_info->sig_key, 16);
+		}
+		else {
+			memcpy(sign_info->sig_key, proc->our_keys.csrk, 16);
+		}
+		proc->our_keys.csrk_valid = 1;
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+	}
+
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR || proc->rx_key_flags == 0) {
+		/* The procedure is now complete. */
+		ble_sm_key_exch_success(proc, res);
+	}
+
+	return;
 
 err:
-    res->app_status = rc;
-    res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    res->enc_cb = 1;
+	res->app_status = rc;
+	res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	res->enc_cb = 1;
 }
 
-static void
-ble_sm_key_rxed(struct ble_sm_proc *proc, struct ble_sm_result *res)
+static void ble_sm_key_rxed(struct ble_sm_proc *proc, struct ble_sm_result *res)
 {
-    BLE_HS_LOG(DEBUG, "rx_key_flags=0x%02x\n", proc->rx_key_flags);
+	BLE_HS_LOG(DEBUG, "rx_key_flags=0x%02x\n", proc->rx_key_flags);
 
-    if (proc->rx_key_flags == 0) {
-        /* The peer is done sending keys.  If we are the initiator, we need to
-         * send ours.  If we are the responder, the procedure is complete.
-         */
-        if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-            res->execute = 1;
-        } else {
-            ble_sm_key_exch_success(proc, res);
-        }
-    }
+	if (proc->rx_key_flags == 0) {
+		/* The peer is done sending keys.  If we are the initiator, we need to
+		 * send ours.  If we are the responder, the procedure is complete.
+		 */
+		if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+			res->execute = 1;
+		}
+		else {
+			ble_sm_key_exch_success(proc, res);
+		}
+	}
 }
 
-static void
-ble_sm_enc_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                   struct ble_sm_result *res)
+static void ble_sm_enc_info_rx(uint16_t conn_handle, struct os_mbuf **om,
+                               struct ble_sm_result *res)
 {
-    struct ble_sm_enc_info *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_enc_info *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_enc_info *)(*om)->om_data;
+	cmd = (struct ble_sm_enc_info *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_ENC_INFO;
-        proc->peer_keys.ltk_valid = 1;
-        memcpy(proc->peer_keys.ltk, cmd->ltk, 16);
-        proc->peer_keys.key_size = proc->key_size;
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_ENC_INFO;
+		proc->peer_keys.ltk_valid = 1;
+		memcpy(proc->peer_keys.ltk, cmd->ltk, 16);
+		proc->peer_keys.key_size = proc->key_size;
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
-static void
-ble_sm_master_id_rx(uint16_t conn_handle, struct os_mbuf **om,
-                    struct ble_sm_result *res)
+static void ble_sm_master_id_rx(uint16_t conn_handle, struct os_mbuf **om,
+                                struct ble_sm_result *res)
 {
-    struct ble_sm_master_id *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_master_id *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_master_id *)(*om)->om_data;
+	cmd = (struct ble_sm_master_id *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_MASTER_ID;
-        proc->peer_keys.ediv_rand_valid = 1;
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_MASTER_ID;
+		proc->peer_keys.ediv_rand_valid = 1;
 
-        proc->peer_keys.ediv = le16toh(cmd->ediv);
-        proc->peer_keys.rand_val = le64toh(cmd->rand_val);
+		proc->peer_keys.ediv = le16toh(cmd->ediv);
+		proc->peer_keys.rand_val = le64toh(cmd->rand_val);
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
-static void
-ble_sm_id_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                  struct ble_sm_result *res)
+static void ble_sm_id_info_rx(uint16_t conn_handle, struct os_mbuf **om,
+                              struct ble_sm_result *res)
 {
-    struct ble_sm_id_info *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_id_info *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_id_info *)(*om)->om_data;
+	cmd = (struct ble_sm_id_info *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_ID_INFO;
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_ID_INFO;
 
-        memcpy(proc->peer_keys.irk, cmd->irk, 16);
-        proc->peer_keys.irk_valid = 1;
+		memcpy(proc->peer_keys.irk, cmd->irk, 16);
+		proc->peer_keys.irk_valid = 1;
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
-static void
-ble_sm_id_addr_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                       struct ble_sm_result *res)
+static void ble_sm_id_addr_info_rx(uint16_t conn_handle, struct os_mbuf **om,
+                                   struct ble_sm_result *res)
 {
-    struct ble_sm_id_addr_info *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_id_addr_info *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_id_addr_info *)(*om)->om_data;
+	cmd = (struct ble_sm_id_addr_info *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_ADDR_INFO;
-        proc->peer_keys.addr_valid = 1;
-        proc->peer_keys.addr_type = cmd->addr_type;
-        memcpy(proc->peer_keys.addr, cmd->bd_addr, 6);
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_ADDR_INFO;
+		proc->peer_keys.addr_valid = 1;
+		proc->peer_keys.addr_type = cmd->addr_type;
+		memcpy(proc->peer_keys.addr, cmd->bd_addr, 6);
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
-static void
-ble_sm_sign_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                    struct ble_sm_result *res)
+static void ble_sm_sign_info_rx(uint16_t conn_handle, struct os_mbuf **om,
+                                struct ble_sm_result *res)
 {
-    struct ble_sm_sign_info *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_sign_info *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_sign_info *)(*om)->om_data;
+	cmd = (struct ble_sm_sign_info *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_SIGN_INFO;
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_SIGN_INFO;
 
-        memcpy(proc->peer_keys.csrk, cmd->sig_key, 16);
-        proc->peer_keys.csrk_valid = 1;
+		memcpy(proc->peer_keys.csrk, cmd->sig_key, 16);
+		proc->peer_keys.csrk_valid = 1;
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
 /*****************************************************************************
  * $fail                                                                     *
  *****************************************************************************/
 
-static void
-ble_sm_fail_rx(uint16_t conn_handle, struct os_mbuf **om,
-               struct ble_sm_result *res)
+static void ble_sm_fail_rx(uint16_t conn_handle, struct os_mbuf **om,
+                           struct ble_sm_result *res)
 {
-    struct ble_sm_pair_fail *cmd;
+	struct ble_sm_pair_fail *cmd;
 
-    res->enc_cb = 1;
+	res->enc_cb = 1;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status == 0) {
-        cmd = (struct ble_sm_pair_fail *)(*om)->om_data;
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status == 0) {
+		cmd = (struct ble_sm_pair_fail *) (*om)->om_data;
 
-        res->app_status = BLE_HS_SM_PEER_ERR(cmd->reason);
-        res->sm_err =  cmd->reason;
-    }
+		res->app_status = BLE_HS_SM_PEER_ERR(cmd->reason);
+		res->sm_err = cmd->reason;
+	}
 }
 
 /*****************************************************************************
@@ -2503,513 +2435,507 @@ ble_sm_fail_rx(uint16_t conn_handle, struct os_mbuf **om,
  * @return                      The number of ticks until this function should
  *                                  be called again.
  */
-int32_t
-ble_sm_timer(void)
+int32_t ble_sm_timer(void)
 {
-    struct ble_sm_proc_list exp_list;
-    struct ble_sm_proc *proc;
-    int32_t ticks_until_exp;
+	struct ble_sm_proc_list exp_list;
+	struct ble_sm_proc *proc;
+	int32_t ticks_until_exp;
 
-    /* Remove timed-out procedures from the main list and insert them into a
-     * temporary list.  This function also calculates the number of ticks until
-     * the next expiration will occur.
-     */
-    ticks_until_exp = ble_sm_extract_expired(&exp_list);
+	/* Remove timed-out procedures from the main list and insert them into a
+	 * temporary list.  This function also calculates the number of ticks until
+	 * the next expiration will occur.
+	 */
+	ticks_until_exp = ble_sm_extract_expired(&exp_list);
 
-    /* Notify application of each failure and free the corresponding procedure
-     * object.
-     * XXX: Mark connection as tainted; don't allow any subsequent SMP
-     * procedures without reconnect.
-     */
-    while ((proc = STAILQ_FIRST(&exp_list)) != NULL) {
-        ble_gap_enc_event(proc->conn_handle, BLE_HS_ETIMEOUT, 0, 0);
+	/* Notify application of each failure and free the corresponding procedure
+	 * object.
+	 * XXX: Mark connection as tainted; don't allow any subsequent SMP
+	 * procedures without reconnect.
+	 */
+	while ((proc = STAILQ_FIRST(&exp_list)) != NULL) {
+		ble_gap_enc_event(proc->conn_handle, BLE_HS_ETIMEOUT, 0, 0);
 
-        STAILQ_REMOVE_HEAD(&exp_list, next);
-        ble_sm_proc_free(proc);
-    }
+		STAILQ_REMOVE_HEAD(&exp_list, next);
+		ble_sm_proc_free(proc);
+	}
 
-    return ticks_until_exp;
+	return ticks_until_exp;
 }
 
 /**
  * Initiates the pairing procedure for the specified connection.
  */
-int
-ble_sm_pair_initiate(uint16_t conn_handle)
+int ble_sm_pair_initiate(uint16_t conn_handle)
 {
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    int rc;
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	int rc;
 
-    memset(&res, 0, sizeof(res));
+	memset(&res, 0, sizeof(res));
 
-    /* Make sure a procedure isn't already in progress for this connection. */
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    ble_hs_unlock();
+	/* Make sure a procedure isn't already in progress for this connection. */
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	ble_hs_unlock();
 
-    if (proc != NULL) {
-        res.app_status = BLE_HS_EALREADY;
-        return BLE_HS_EALREADY;
-    }
+	if (proc != NULL) {
+		res.app_status = BLE_HS_EALREADY;
+		return BLE_HS_EALREADY;
+	}
 
-    /* Check if there is storage capacity for a new bond.  If there isn't, ask
-     * the application to make room.
-     */
-    rc = ble_sm_chk_store_overflow(conn_handle);
-    if (rc != 0) {
-        return rc;
-    }
+	/* Check if there is storage capacity for a new bond.  If there isn't, ask
+	 * the application to make room.
+	 */
+	rc = ble_sm_chk_store_overflow(conn_handle);
+	if (rc != 0) {
+		return rc;
+	}
 
-    proc = ble_sm_proc_alloc();
-    if (proc == NULL) {
-        res.app_status = BLE_HS_ENOMEM;
-    } else {
-        proc->conn_handle = conn_handle;
-        proc->state = BLE_SM_PROC_STATE_PAIR;
-        proc->flags |= BLE_SM_PROC_F_INITIATOR;
+	proc = ble_sm_proc_alloc();
+	if (proc == NULL) {
+		res.app_status = BLE_HS_ENOMEM;
+	}
+	else {
+		proc->conn_handle = conn_handle;
+		proc->state = BLE_SM_PROC_STATE_PAIR;
+		proc->flags |= BLE_SM_PROC_F_INITIATOR;
 
-        ble_hs_lock();
-        ble_sm_insert(proc);
-        ble_hs_unlock();
+		ble_hs_lock();
+		ble_sm_insert(proc);
+		ble_hs_unlock();
 
-        res.execute = 1;
-    }
+		res.execute = 1;
+	}
 
-    if (proc != NULL) {
-        ble_sm_process_result(conn_handle, &res, true);
-    }
+	if (proc != NULL) {
+		ble_sm_process_result(conn_handle, &res, true);
+	}
 
-    return res.app_status;
+	return res.app_status;
 }
 
-int
-ble_sm_slave_initiate(uint16_t conn_handle)
+int ble_sm_slave_initiate(uint16_t conn_handle)
 {
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
 
-    memset(&res, 0, sizeof(res));
+	memset(&res, 0, sizeof(res));
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    /* Make sure a procedure isn't already in progress for this connection. */
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    if (proc != NULL) {
-        res.app_status = BLE_HS_EALREADY;
+	/* Make sure a procedure isn't already in progress for this connection. */
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	if (proc != NULL) {
+		res.app_status = BLE_HS_EALREADY;
 
-        /* Set pointer to null so that existing entry doesn't get freed. */
-        proc = NULL;
-    } else {
-        proc = ble_sm_proc_alloc();
-        if (proc == NULL) {
-            res.app_status = BLE_HS_ENOMEM;
-        } else {
-            proc->conn_handle = conn_handle;
-            proc->state = BLE_SM_PROC_STATE_SEC_REQ;
-            ble_sm_insert(proc);
+		/* Set pointer to null so that existing entry doesn't get freed. */
+		proc = NULL;
+	}
+	else {
+		proc = ble_sm_proc_alloc();
+		if (proc == NULL) {
+			res.app_status = BLE_HS_ENOMEM;
+		}
+		else {
+			proc->conn_handle = conn_handle;
+			proc->state = BLE_SM_PROC_STATE_SEC_REQ;
+			ble_sm_insert(proc);
 
-            res.execute = 1;
-        }
-    }
+			res.execute = 1;
+		}
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (proc != NULL) {
-        ble_sm_process_result(conn_handle, &res, true);
-    }
+	if (proc != NULL) {
+		ble_sm_process_result(conn_handle, &res, true);
+	}
 
-    return res.app_status;
+	return res.app_status;
 }
 
 /**
  * Initiates the encryption procedure for the specified connection.
  */
-int
-ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size,
-                    const uint8_t *ltk, uint16_t ediv,
-                    uint64_t rand_val, int auth)
+int ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size, const uint8_t *ltk,
+                        uint16_t ediv, uint64_t rand_val, int auth)
 {
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    struct hci_start_encrypt cmd;
-
-    memset(&res, 0, sizeof res);
-
-    /* Make sure a procedure isn't already in progress for this connection. */
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    if (proc != NULL) {
-        res.app_status = BLE_HS_EALREADY;
-
-        /* Set pointer to null so that existing entry doesn't get freed. */
-        proc = NULL;
-    } else {
-        proc = ble_sm_proc_alloc();
-        if (proc == NULL) {
-            res.app_status = BLE_HS_ENOMEM;
-        } else {
-            proc->conn_handle = conn_handle;
-            proc->key_size = key_size;
-            proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
-            proc->flags |= BLE_SM_PROC_F_INITIATOR;
-            if (auth) {
-                proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
-            }
-            ble_sm_insert(proc);
-
-            cmd.connection_handle = conn_handle;
-            cmd.encrypted_diversifier = ediv;
-            cmd.random_number = rand_val;
-            memcpy(cmd.long_term_key, ltk, sizeof cmd.long_term_key);
-
-            res.execute = 1;
-            res.state_arg = &cmd;
-        }
-    }
-
-    ble_hs_unlock();
-
-    ble_sm_process_result(conn_handle, &res, true);
-
-    return res.app_status;
-}
-
-static int
-ble_sm_rx(struct ble_l2cap_chan *chan)
-{
-    struct ble_sm_result res;
-    ble_sm_rx_fn *rx_cb;
-    uint8_t op;
-    uint16_t conn_handle;
-    struct os_mbuf **om;
-    int rc;
-
-    STATS_INC(ble_l2cap_stats, sm_rx);
-
-    conn_handle = ble_l2cap_get_conn_handle(chan);
-    if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
-        return BLE_HS_ENOTCONN;
-    }
-
-    om = &chan->rx_buf;
-    BLE_HS_DBG_ASSERT(*om != NULL);
-
-    rc = os_mbuf_copydata(*om, 0, 1, &op);
-    if (rc != 0) {
-        return BLE_HS_EBADDATA;
-    }
-
-    /* Strip L2CAP SM header from the front of the mbuf. */
-    os_mbuf_adj(*om, 1);
-
-    rx_cb = ble_sm_dispatch_get(op);
-    if (rx_cb != NULL) {
-        memset(&res, 0, sizeof res);
-
-        rx_cb(conn_handle, om, &res);
-        ble_sm_process_result(conn_handle, &res, op == BLE_SM_OP_PAIR_FAIL ?
-                              false : true);
-        rc = res.app_status;
-    } else {
-        rc = BLE_HS_ENOTSUP;
-    }
-
-    return rc;
-}
-
-int
-ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io *pkey)
-{
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    int rc;
-    uint8_t action;
-
-    memset(&res, 0, sizeof res);
-
-    ble_hs_lock();
-
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    if (proc == NULL) {
-        rc = BLE_HS_ENOENT;
-    } else if (proc->flags & BLE_SM_PROC_F_IO_INJECTED) {
-        rc = BLE_HS_EALREADY;
-    } else if ((ble_sm_io_action(proc, &action) == 0) && pkey->action != action) {
-        /* Application provided incorrect IO type. */
-        rc = BLE_HS_EINVAL;
-    } else if (ble_sm_ioact_state(pkey->action) != proc->state) {
-        /* Procedure is not ready for user input. */
-        rc = BLE_HS_EINVAL;
-    } else {
-        /* Assume valid input. */
-        rc = 0;
-
-        switch (pkey->action) {
-        case BLE_SM_IOACT_OOB:
-            proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
-            memcpy(proc->tk, pkey->oob, 16);
-            if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
-                (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
-
-                res.execute = 1;
-            }
-            break;
-
-        case BLE_SM_IOACT_INPUT:
-        case BLE_SM_IOACT_DISP:
-            if (pkey->passkey > 999999) {
-                rc = BLE_HS_EINVAL;
-            } else {
-                proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
-                memset(proc->tk, 0, 16);
-                proc->tk[0] = (pkey->passkey >> 0) & 0xff;
-                proc->tk[1] = (pkey->passkey >> 8) & 0xff;
-                proc->tk[2] = (pkey->passkey >> 16) & 0xff;
-                proc->tk[3] = (pkey->passkey >> 24) & 0xff;
-                if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
-                    (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
-
-                    res.execute = 1;
-                }
-            }
-            break;
-
-        case BLE_SM_IOACT_NUMCMP:
-            if (!pkey->numcmp_accept) {
-                res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_NUMCMP);
-                res.sm_err = BLE_SM_ERR_NUMCMP;
-            } else {
-                proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
-                if (proc->flags & BLE_SM_PROC_F_INITIATOR ||
-                    proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO) {
-
-                    res.execute = 1;
-                }
-            }
-            break;
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	struct hci_start_encrypt cmd;
+
+	memset(&res, 0, sizeof res);
+
+	/* Make sure a procedure isn't already in progress for this connection. */
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	if (proc != NULL) {
+		res.app_status = BLE_HS_EALREADY;
+
+		/* Set pointer to null so that existing entry doesn't get freed. */
+		proc = NULL;
+	}
+	else {
+		proc = ble_sm_proc_alloc();
+		if (proc == NULL) {
+			res.app_status = BLE_HS_ENOMEM;
+		}
+		else {
+			proc->conn_handle = conn_handle;
+			proc->key_size = key_size;
+			proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
+			proc->flags |= BLE_SM_PROC_F_INITIATOR;
+			if (auth) {
+				proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
+			}
+			ble_sm_insert(proc);
+
+			cmd.connection_handle = conn_handle;
+			cmd.encrypted_diversifier = ediv;
+			cmd.random_number = rand_val;
+			memcpy(cmd.long_term_key, ltk, sizeof cmd.long_term_key);
+
+			res.execute = 1;
+			res.state_arg = &cmd;
+		}
+	}
+
+	ble_hs_unlock();
+
+	ble_sm_process_result(conn_handle, &res, true);
+
+	return res.app_status;
+}
+
+static int ble_sm_rx(struct ble_l2cap_chan *chan)
+{
+	struct ble_sm_result res;
+	ble_sm_rx_fn *rx_cb;
+	uint8_t op;
+	uint16_t conn_handle;
+	struct os_mbuf **om;
+	int rc;
+
+	STATS_INC(ble_l2cap_stats, sm_rx);
+	conn_handle = ble_l2cap_get_conn_handle(chan);
+	if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
+		return BLE_HS_ENOTCONN;
+	}
+
+
+	om = &chan->rx_buf;
+	BLE_HS_DBG_ASSERT(*om != NULL);
+
+	rc = os_mbuf_copydata(*om, 0, 1, &op);
+	if (rc != 0) {
+		return BLE_HS_EBADDATA;
+	}
+
+	/* Strip L2CAP SM header from the front of the mbuf. */
+	os_mbuf_adj(*om, 1);
+
+	rx_cb = ble_sm_dispatch_get(op);
+	if (rx_cb != NULL) {
+		memset(&res, 0, sizeof res);
+
+		rx_cb(conn_handle, om, &res);
+		ble_sm_process_result(conn_handle, &res, op == BLE_SM_OP_PAIR_FAIL ? false : true);
+		rc = res.app_status;
+	}
+	else {
+		rc = BLE_HS_ENOTSUP;
+	}
+
+	return rc;
+}
+
+int ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io *pkey)
+{
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	int rc;
+	uint8_t action;
+
+	memset(&res, 0, sizeof res);
+
+	ble_hs_lock();
+
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	if (proc == NULL) {
+		rc = BLE_HS_ENOENT;
+	}
+	else if (proc->flags & BLE_SM_PROC_F_IO_INJECTED) {
+		rc = BLE_HS_EALREADY;
+	}
+	else if ((ble_sm_io_action(proc, &action) == 0) && pkey->action != action) {
+		/* Application provided incorrect IO type. */
+		rc = BLE_HS_EINVAL;
+	}
+	else if (ble_sm_ioact_state(pkey->action) != proc->state) {
+		/* Procedure is not ready for user input. */
+		rc = BLE_HS_EINVAL;
+	}
+	else {
+		/* Assume valid input. */
+		rc = 0;
+
+		switch (pkey->action) {
+		case BLE_SM_IOACT_OOB:
+			proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
+			memcpy(proc->tk, pkey->oob, 16);
+			if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
+			    (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
+				res.execute = 1;
+			}
+			break;
+
+		case BLE_SM_IOACT_INPUT:
+		case BLE_SM_IOACT_DISP:
+			if (pkey->passkey > 999999) {
+				rc = BLE_HS_EINVAL;
+			}
+			else {
+				proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
+				memset(proc->tk, 0, 16);
+				proc->tk[0] = (pkey->passkey >> 0) & 0xff;
+				proc->tk[1] = (pkey->passkey >> 8) & 0xff;
+				proc->tk[2] = (pkey->passkey >> 16) & 0xff;
+				proc->tk[3] = (pkey->passkey >> 24) & 0xff;
+				if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
+				    (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
+					res.execute = 1;
+				}
+			}
+			break;
+
+		case BLE_SM_IOACT_NUMCMP:
+			if (!pkey->numcmp_accept) {
+				res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_NUMCMP);
+				res.sm_err = BLE_SM_ERR_NUMCMP;
+			}
+			else {
+				proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
+				if (proc->flags & BLE_SM_PROC_F_INITIATOR ||
+				    proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO) {
+					res.execute = 1;
+				}
+			}
+			break;
 
 #if MYNEWT_VAL(BLE_SM_SC)
-        case BLE_SM_IOACT_OOB_SC:
-            if (!ble_sm_sc_oob_data_check(proc,
-                                          (pkey->oob_sc_data.local != NULL),
-                                          (pkey->oob_sc_data.remote != NULL))) {
-                res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_OOB);
-                res.sm_err = BLE_SM_ERR_OOB;
-            } else {
-                proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
-                proc->oob_data_local = pkey->oob_sc_data.local;
-                proc->oob_data_remote = pkey->oob_sc_data.remote;
-
-                /* Execute Confirm step */
-                ble_sm_sc_oob_confirm(proc, &res);
-            }
-            break;
+		case BLE_SM_IOACT_OOB_SC:
+			if (!ble_sm_sc_oob_data_check(proc, (pkey->oob_sc_data.local != NULL),
+			                              (pkey->oob_sc_data.remote != NULL))) {
+				res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_OOB);
+				res.sm_err = BLE_SM_ERR_OOB;
+			}
+			else {
+				proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
+				proc->oob_data_local = pkey->oob_sc_data.local;
+				proc->oob_data_remote = pkey->oob_sc_data.remote;
+
+				/* Execute Confirm step */
+				ble_sm_sc_oob_confirm(proc, &res);
+			}
+			break;
 #endif
 
-        default:
-            BLE_HS_DBG_ASSERT(0);
-            rc = BLE_HS_EINVAL;
-            break;
-        }
-    }
+		default:
+			BLE_HS_DBG_ASSERT(0);
+			rc = BLE_HS_EINVAL;
+			break;
+		}
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    /* If application provided invalid input, return error without modifying
-     * SMP state.
-     */
-    if (rc != 0) {
-        return rc;
-    }
+	/* If application provided invalid input, return error without modifying
+	 * SMP state.
+	 */
+	if (rc != 0) {
+		return rc;
+	}
 
-    ble_sm_process_result(conn_handle, &res, true);
-    return res.app_status;
+	ble_sm_process_result(conn_handle, &res, true);
+	return res.app_status;
 }
 
-void
-ble_sm_connection_broken(uint16_t conn_handle)
+void ble_sm_connection_broken(uint16_t conn_handle)
 {
-    struct ble_sm_result res;
+	struct ble_sm_result res;
 
-    memset(&res, 0, sizeof res);
-    res.app_status = BLE_HS_ENOTCONN;
-    res.enc_cb = 1;
+	memset(&res, 0, sizeof res);
+	res.app_status = BLE_HS_ENOTCONN;
+	res.enc_cb = 1;
 
-    ble_sm_process_result(conn_handle, &res, true);
+	ble_sm_process_result(conn_handle, &res, true);
 }
 
-int
-ble_sm_init(void)
+int ble_sm_init(void)
 {
-    int rc;
+	int rc;
 
-    STAILQ_INIT(&ble_sm_procs);
+	STAILQ_INIT(&ble_sm_procs);
 
-    rc = os_mempool_init(&ble_sm_proc_pool,
-                         MYNEWT_VAL(BLE_SM_MAX_PROCS),
-                         sizeof (struct ble_sm_proc),
-                         ble_sm_proc_mem,
-                         "ble_sm_proc_pool");
-    if (rc != 0) {
-        return rc;
-    }
+	rc =
+		os_mempool_init(&ble_sm_proc_pool, MYNEWT_VAL(BLE_SM_MAX_PROCS),
+	                  sizeof(struct ble_sm_proc), ble_sm_proc_mem, "ble_sm_proc_pool");
+	if (rc != 0) {
+		return rc;
+	}
 
-    ble_sm_sc_init();
+	ble_sm_sc_init();
 
-    return 0;
+	return 0;
 }
 #else
 /* if pairing is not supported it is only needed to reply with Pairing
  * Failed with 'Pairing not Supported' reason so this function can be very
  * simple
  */
-static int
-ble_sm_rx(struct ble_l2cap_chan *chan)
+static int ble_sm_rx(struct ble_l2cap_chan *chan)
 {
-    struct ble_sm_pair_fail *cmd;
-    struct os_mbuf *txom;
-    uint16_t handle;
-    int rc;
+	struct ble_sm_pair_fail *cmd;
+	struct os_mbuf *txom;
+	uint16_t handle;
+	int rc;
 
-    handle = ble_l2cap_get_conn_handle(chan);
-    if (!handle) {
-        return BLE_HS_ENOTCONN;
-    }
+	handle = ble_l2cap_get_conn_handle(chan);
+	if (!handle) {
+		return BLE_HS_ENOTCONN;
+	}
 
-    cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_FAIL, sizeof(*cmd), &txom);
-    if (cmd == NULL) {
-        return BLE_HS_ENOMEM;
-    }
+	cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_FAIL, sizeof(*cmd), &txom);
+	if (cmd == NULL) {
+		return BLE_HS_ENOMEM;
+	}
 
-    cmd->reason = BLE_SM_ERR_PAIR_NOT_SUPP;
+	cmd->reason = BLE_SM_ERR_PAIR_NOT_SUPP;
 
-    ble_hs_lock();
-    rc = ble_sm_tx(handle, txom);
-    ble_hs_unlock();
+	ble_hs_lock();
+	rc = ble_sm_tx(handle, txom);
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 #endif
 
-struct ble_l2cap_chan *
-ble_sm_create_chan(uint16_t conn_handle)
+struct ble_l2cap_chan *ble_sm_create_chan(uint16_t conn_handle)
 {
-    struct ble_l2cap_chan *chan;
+	struct ble_l2cap_chan *chan;
 
-    chan = ble_l2cap_chan_alloc(conn_handle);
-    if (chan == NULL) {
-        return NULL;
-    }
+	chan = ble_l2cap_chan_alloc(conn_handle);
+	if (chan == NULL) {
+		return NULL;
+	}
 
-    chan->scid = BLE_L2CAP_CID_SM;
-    chan->dcid = BLE_L2CAP_CID_SM;
-    chan->my_mtu = BLE_SM_MTU;
-    chan->rx_fn = ble_sm_rx;
+	chan->scid = BLE_L2CAP_CID_SM;
+	chan->dcid = BLE_L2CAP_CID_SM;
+	chan->my_mtu = BLE_SM_MTU;
+	chan->rx_fn = ble_sm_rx;
 
-    return chan;
+	return chan;
 }
 
 #if MYNEWT_VAL(BLE_SM_CSIS_SIRK)
-int
-ble_sm_csis_decrypt_sirk(const uint8_t *ltk, const uint8_t *enc_sirk, uint8_t *out)
+int ble_sm_csis_decrypt_sirk(const uint8_t *ltk, const uint8_t *enc_sirk, uint8_t *out)
 {
-    int rc;
+	int rc;
 
-    /* Decrypt SIRK with sdf(K, EncSIRK)  */
-    rc = ble_sm_alg_csis_sdf(ltk, enc_sirk, out);
+	/* Decrypt SIRK with sdf(K, EncSIRK)  */
+	rc = ble_sm_alg_csis_sdf(ltk, enc_sirk, out);
 
-    return rc;
+	return rc;
 }
 
-int
-ble_sm_csis_resolve_rsi(const uint8_t *rsi, const uint8_t *sirk,
-                        const ble_addr_t *ltk_peer_addr)
+int ble_sm_csis_resolve_rsi(const uint8_t *rsi, const uint8_t *sirk,
+                            const ble_addr_t *ltk_peer_addr)
 {
-    struct ble_store_key_sec key_sec;
-    struct ble_store_value_sec value_sec;
-    uint8_t plaintext_sirk[16] = {0};
-    uint8_t local_hash[3] = {0};
-    uint8_t prand[3] = {0};
-    uint8_t hash[3] = {0};
-    int rc;
+	struct ble_store_key_sec key_sec;
+	struct ble_store_value_sec value_sec;
+	uint8_t plaintext_sirk[16] = {0};
+	uint8_t local_hash[3] = {0};
+	uint8_t prand[3] = {0};
+	uint8_t hash[3] = {0};
+	int rc;
 
-    memcpy(hash, rsi, 3);
-    memcpy(prand, rsi + 3, 3);
+	memcpy(hash, rsi, 3);
+	memcpy(prand, rsi + 3, 3);
 
-    if (ltk_peer_addr) {
-        memset(&key_sec, 0, sizeof(key_sec));
-        key_sec.peer_addr = *ltk_peer_addr;
+	if (ltk_peer_addr) {
+		memset(&key_sec, 0, sizeof(key_sec));
+		key_sec.peer_addr = *ltk_peer_addr;
 
-        rc = ble_store_read_peer_sec(&key_sec, &value_sec);
-        if (rc != 0) {
-            return rc;
-        } else if (!value_sec.ltk_present) {
-            return BLE_HS_ENOENT;
-        }
+		rc = ble_store_read_peer_sec(&key_sec, &value_sec);
+		if (rc != 0) {
+			return rc;
+		}
+		else if (!value_sec.ltk_present) {
+			return BLE_HS_ENOENT;
+		}
 
-        rc = ble_sm_csis_decrypt_sirk(value_sec.ltk, sirk, plaintext_sirk);
-        if (rc != 0) {
-            return rc;
-        }
-    } else {
-        memcpy(plaintext_sirk, sirk, 16);
-    }
+		rc = ble_sm_csis_decrypt_sirk(value_sec.ltk, sirk, plaintext_sirk);
+		if (rc != 0) {
+			return rc;
+		}
+	}
+	else {
+		memcpy(plaintext_sirk, sirk, 16);
+	}
 
-    rc = ble_sm_alg_csis_sih(plaintext_sirk, prand, local_hash);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_alg_csis_sih(plaintext_sirk, prand, local_hash);
+	if (rc != 0) {
+		return rc;
+	}
 
-    if (memcmp(local_hash, hash, 3)) {
-        return BLE_HS_EAUTHEN;
-    }
+	if (memcmp(local_hash, hash, 3)) {
+		return BLE_HS_EAUTHEN;
+	}
 
-    return 0;
+	return 0;
 }
 
-int
-ble_sm_csis_encrypt_sirk(const uint8_t *ltk, const uint8_t *plaintext_sirk, uint8_t *out)
+int ble_sm_csis_encrypt_sirk(const uint8_t *ltk, const uint8_t *plaintext_sirk,
+                             uint8_t *out)
 {
-    int rc;
+	int rc;
 
-    /* Encrypt SIRK with sef(K, SIRK) */
-    rc = ble_sm_alg_csis_sef(ltk, plaintext_sirk, out);
+	/* Encrypt SIRK with sef(K, SIRK) */
+	rc = ble_sm_alg_csis_sef(ltk, plaintext_sirk, out);
 
-    return rc;
+	return rc;
 }
 
-int
-ble_sm_csis_generate_rsi(const uint8_t *sirk, uint8_t *out)
+int ble_sm_csis_generate_rsi(const uint8_t *sirk, uint8_t *out)
 {
-    const uint8_t prand_check_all_set[3] = {0xff, 0xff, 0xef};
-    const uint8_t prand_check_all_reset[3] = {0x0, 0x0, 0x40};
-    uint8_t prand[3] = {0};
-    uint8_t hash[3] = {0};
-    int rc;
+	const uint8_t prand_check_all_set[3] = {0xff, 0xff, 0xef};
+	const uint8_t prand_check_all_reset[3] = {0x0, 0x0, 0x40};
+	uint8_t prand[3] = {0};
+	uint8_t hash[3] = {0};
+	int rc;
 
-    do {
-        rc = ble_hs_hci_rand(prand, 3);
-        if (rc != 0) {
-            return rc;
-        }
-        /* Two MSBs of prand shall be equal to 0 and 1 */
-        prand[2] &= ~0xc0;
-        prand[2] |= 0x40;
+	do {
+		rc = ble_hs_hci_rand(prand, 3);
+		if (rc != 0) {
+			return rc;
+		}
+		/* Two MSBs of prand shall be equal to 0 and 1 */
+		prand[2] &= ~0xc0;
+		prand[2] |= 0x40;
 
-        /* prand's random part shall not be all 0s nor all 1s */
-    } while (memcmp(prand, prand_check_all_set, 3) ||
-             memcmp(prand, prand_check_all_reset, 3));
+		/* prand's random part shall not be all 0s nor all 1s */
+	} while (memcmp(prand, prand_check_all_set, 3) ||
+	         memcmp(prand, prand_check_all_reset, 3));
 
-    rc = ble_sm_alg_csis_sih(sirk, prand, hash);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_alg_csis_sih(sirk, prand, hash);
+	if (rc != 0) {
+		return rc;
+	}
 
-    memcpy(out, hash, 3);
-    memcpy(out + 3, prand, 3);
+	memcpy(out, hash, 3);
+	memcpy(out + 3, prand, 3);
 
-    return 0;
+	return 0;
 }
 
 #endif
diff --git a/nimble/host/src/ble_sm_alg.c b/nimble/host/src/ble_sm_alg.c
index bf81f21f..e00d405c 100644
--- a/nimble/host/src/ble_sm_alg.c
+++ b/nimble/host/src/ble_sm_alg.c
@@ -44,154 +44,146 @@
 static struct trng_dev *g_trng;
 #endif
 
-static void
-ble_sm_alg_xor_128(const uint8_t *p, const uint8_t *q, uint8_t *r)
+static void ble_sm_alg_xor_128(const uint8_t *p, const uint8_t *q, uint8_t *r)
 {
-    int i;
+	int i;
 
-    for (i = 0; i < 16; i++) {
-        r[i] = p[i] ^ q[i];
-    }
+	for (i = 0; i < 16; i++) {
+		r[i] = p[i] ^ q[i];
+	}
 }
 
-static int
-ble_sm_alg_encrypt(const uint8_t *key, const uint8_t *plaintext,
-                   uint8_t *enc_data)
+static int ble_sm_alg_encrypt(const uint8_t *key, const uint8_t *plaintext,
+                              uint8_t *enc_data)
 {
-    struct tc_aes_key_sched_struct s;
-    uint8_t tmp[16];
+	struct tc_aes_key_sched_struct s;
+	uint8_t tmp[16];
 
-    swap_buf(tmp, key, 16);
+	swap_buf(tmp, key, 16);
 
-    if (tc_aes128_set_encrypt_key(&s, tmp) == TC_CRYPTO_FAIL) {
-        return BLE_HS_EUNKNOWN;
-    }
+	if (tc_aes128_set_encrypt_key(&s, tmp) == TC_CRYPTO_FAIL) {
+		return BLE_HS_EUNKNOWN;
+	}
 
-    swap_buf(tmp, plaintext, 16);
+	swap_buf(tmp, plaintext, 16);
 
-    if (tc_aes_encrypt(enc_data, tmp, &s) == TC_CRYPTO_FAIL) {
-        return BLE_HS_EUNKNOWN;
-    }
+	if (tc_aes_encrypt(enc_data, tmp, &s) == TC_CRYPTO_FAIL) {
+		return BLE_HS_EUNKNOWN;
+	}
 
-    swap_in_place(enc_data, 16);
+	swap_in_place(enc_data, 16);
 
-    return 0;
+	return 0;
 }
 
-int
-ble_sm_alg_s1(const uint8_t *k, const uint8_t *r1, const uint8_t *r2,
-              uint8_t *out)
+int ble_sm_alg_s1(const uint8_t *k, const uint8_t *r1, const uint8_t *r2, uint8_t *out)
 {
-    int rc;
-
-    /* The most significant 64-bits of r1 are discarded to generate
-     * r1' and the most significant 64-bits of r2 are discarded to
-     * generate r2'.
-     * r1' is concatenated with r2' to generate r' which is used as
-     * the 128-bit input parameter plaintextData to security function e:
-     *
-     *    r' = r1' || r2'
-     */
-    memcpy(out, r2, 8);
-    memcpy(out + 8, r1, 8);
-
-    /* s1(k, r1 , r2) = e(k, r') */
-    rc = ble_sm_alg_encrypt(k, out, out);
-    if (rc != 0) {
-        return rc;
-    }
-
-    BLE_HS_LOG(DEBUG, "ble_sm_alg_s1()\n    k=");
-    ble_hs_log_flat_buf(k, 16);
-    BLE_HS_LOG(DEBUG, "\n    r1=");
-    ble_hs_log_flat_buf(r1, 16);
-    BLE_HS_LOG(DEBUG, "\n    r2=");
-    ble_hs_log_flat_buf(r2, 16);
-    BLE_HS_LOG(DEBUG, "\n    out=");
-    ble_hs_log_flat_buf(out, 16);
-    BLE_HS_LOG(DEBUG, "\n");
-
-    return 0;
+	int rc;
+
+	/* The most significant 64-bits of r1 are discarded to generate
+	 * r1' and the most significant 64-bits of r2 are discarded to
+	 * generate r2'.
+	 * r1' is concatenated with r2' to generate r' which is used as
+	 * the 128-bit input parameter plaintextData to security function e:
+	 *
+	 *    r' = r1' || r2'
+	 */
+	memcpy(out, r2, 8);
+	memcpy(out + 8, r1, 8);
+
+	/* s1(k, r1 , r2) = e(k, r') */
+	rc = ble_sm_alg_encrypt(k, out, out);
+	if (rc != 0) {
+		return rc;
+	}
+
+	BLE_HS_LOG(DEBUG, "ble_sm_alg_s1()\n    k=");
+	ble_hs_log_flat_buf(k, 16);
+	BLE_HS_LOG(DEBUG, "\n    r1=");
+	ble_hs_log_flat_buf(r1, 16);
+	BLE_HS_LOG(DEBUG, "\n    r2=");
+	ble_hs_log_flat_buf(r2, 16);
+	BLE_HS_LOG(DEBUG, "\n    out=");
+	ble_hs_log_flat_buf(out, 16);
+	BLE_HS_LOG(DEBUG, "\n");
+
+	return 0;
 }
 
-int
-ble_sm_alg_c1(const uint8_t *k, const uint8_t *r,
-              const uint8_t *preq, const uint8_t *pres,
-              uint8_t iat, uint8_t rat,
-              const uint8_t *ia, const uint8_t *ra,
-              uint8_t *out_enc_data)
+int ble_sm_alg_c1(const uint8_t *k, const uint8_t *r, const uint8_t *preq,
+                  const uint8_t *pres, uint8_t iat, uint8_t rat, const uint8_t *ia,
+                  const uint8_t *ra, uint8_t *out_enc_data)
 {
-    uint8_t p1[16], p2[16];
-    int rc;
-
-    BLE_HS_LOG(DEBUG, "ble_sm_alg_c1()\n    k=");
-    ble_hs_log_flat_buf(k, 16);
-    BLE_HS_LOG(DEBUG, "\n    r=");
-    ble_hs_log_flat_buf(r, 16);
-    BLE_HS_LOG(DEBUG, "\n    iat=%d rat=%d", iat, rat);
-    BLE_HS_LOG(DEBUG, "\n    ia=");
-    ble_hs_log_flat_buf(ia, 6);
-    BLE_HS_LOG(DEBUG, "\n    ra=");
-    ble_hs_log_flat_buf(ra, 6);
-    BLE_HS_LOG(DEBUG, "\n    preq=");
-    ble_hs_log_flat_buf(preq, 7);
-    BLE_HS_LOG(DEBUG, "\n    pres=");
-    ble_hs_log_flat_buf(pres, 7);
-
-    /* pres, preq, rat and iat are concatenated to generate p1 */
-    p1[0] = iat;
-    p1[1] = rat;
-    memcpy(p1 + 2, preq, 7);
-    memcpy(p1 + 9, pres, 7);
-
-    BLE_HS_LOG(DEBUG, "\n    p1=");
-    ble_hs_log_flat_buf(p1, sizeof p1);
-
-    /* c1 = e(k, e(k, r XOR p1) XOR p2) */
-
-    /* Using out_enc_data as temporary output buffer */
-    ble_sm_alg_xor_128(r, p1, out_enc_data);
-
-    rc = ble_sm_alg_encrypt(k, out_enc_data, out_enc_data);
-    if (rc != 0) {
-        rc = BLE_HS_EUNKNOWN;
-        goto done;
-    }
-
-    /* ra is concatenated with ia and padding to generate p2 */
-    memcpy(p2, ra, 6);
-    memcpy(p2 + 6, ia, 6);
-    memset(p2 + 12, 0, 4);
-
-    BLE_HS_LOG(DEBUG, "\n    p2=");
-    ble_hs_log_flat_buf(p2, sizeof p2);
-
-    ble_sm_alg_xor_128(out_enc_data, p2, out_enc_data);
-
-    rc = ble_sm_alg_encrypt(k, out_enc_data, out_enc_data);
-    if (rc != 0) {
-        rc = BLE_HS_EUNKNOWN;
-        goto done;
-    }
-
-    BLE_HS_LOG(DEBUG, "\n    out_enc_data=");
-    ble_hs_log_flat_buf(out_enc_data, 16);
-
-    rc = 0;
+	uint8_t p1[16], p2[16];
+	int rc;
+
+	BLE_HS_LOG(DEBUG, "ble_sm_alg_c1()\n    k=");
+	ble_hs_log_flat_buf(k, 16);
+	BLE_HS_LOG(DEBUG, "\n    r=");
+	ble_hs_log_flat_buf(r, 16);
+	BLE_HS_LOG(DEBUG, "\n    iat=%d rat=%d", iat, rat);
+	BLE_HS_LOG(DEBUG, "\n    ia=");
+	ble_hs_log_flat_buf(ia, 6);
+	BLE_HS_LOG(DEBUG, "\n    ra=");
+	ble_hs_log_flat_buf(ra, 6);
+	BLE_HS_LOG(DEBUG, "\n    preq=");
+	ble_hs_log_flat_buf(preq, 7);
+	BLE_HS_LOG(DEBUG, "\n    pres=");
+	ble_hs_log_flat_buf(pres, 7);
+
+	/* pres, preq, rat and iat are concatenated to generate p1 */
+	p1[0] = iat;
+	p1[1] = rat;
+	memcpy(p1 + 2, preq, 7);
+	memcpy(p1 + 9, pres, 7);
+
+	BLE_HS_LOG(DEBUG, "\n    p1=");
+	ble_hs_log_flat_buf(p1, sizeof p1);
+
+	/* c1 = e(k, e(k, r XOR p1) XOR p2) */
+
+	/* Using out_enc_data as temporary output buffer */
+	ble_sm_alg_xor_128(r, p1, out_enc_data);
+
+	rc = ble_sm_alg_encrypt(k, out_enc_data, out_enc_data);
+	if (rc != 0) {
+		rc = BLE_HS_EUNKNOWN;
+		goto done;
+	}
+
+	/* ra is concatenated with ia and padding to generate p2 */
+	memcpy(p2, ra, 6);
+	memcpy(p2 + 6, ia, 6);
+	memset(p2 + 12, 0, 4);
+
+	BLE_HS_LOG(DEBUG, "\n    p2=");
+	ble_hs_log_flat_buf(p2, sizeof p2);
+
+	ble_sm_alg_xor_128(out_enc_data, p2, out_enc_data);
+
+	rc = ble_sm_alg_encrypt(k, out_enc_data, out_enc_data);
+	if (rc != 0) {
+		rc = BLE_HS_EUNKNOWN;
+		goto done;
+	}
+
+	BLE_HS_LOG(DEBUG, "\n    out_enc_data=");
+	ble_hs_log_flat_buf(out_enc_data, 16);
+
+	rc = 0;
 
 done:
-    BLE_HS_LOG(DEBUG, "\n    rc=%d\n", rc);
-    return rc;
+	BLE_HS_LOG(DEBUG, "\n    rc=%d\n", rc);
+	return rc;
 }
 
 #if MYNEWT_VAL(BLE_SM_SC)
 
-static void
-ble_sm_alg_log_buf(const char *name, const uint8_t *buf, int len)
+static void ble_sm_alg_log_buf(const char *name, const uint8_t *buf, int len)
 {
-    BLE_HS_LOG(DEBUG, "    %s=", name);
-    ble_hs_log_flat_buf(buf, len);
-    BLE_HS_LOG(DEBUG, "\n");
+	BLE_HS_LOG(DEBUG, "    %s=", name);
+	ble_hs_log_flat_buf(buf, len);
+	BLE_HS_LOG(DEBUG, "\n");
 }
 
 /**
@@ -202,399 +194,443 @@ ble_sm_alg_log_buf(const char *name, const uint8_t *buf, int len)
  * @param len                   Length of the message in octets.
  * @param out                   Output; message authentication code.
  */
-static int
-ble_sm_alg_aes_cmac(const uint8_t *key, const uint8_t *in, size_t len,
-                    uint8_t *out)
+static int ble_sm_alg_aes_cmac(const uint8_t *key, const uint8_t *in, size_t len,
+                               uint8_t *out)
 {
-    struct tc_aes_key_sched_struct sched;
-    struct tc_cmac_struct state;
+	struct tc_aes_key_sched_struct sched;
+	struct tc_cmac_struct state;
 
-    if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
-        return BLE_HS_EUNKNOWN;
-    }
+	if (tc_cmac_setup(&state, key, &sched) == TC_CRYPTO_FAIL) {
+		return BLE_HS_EUNKNOWN;
+	}
 
-    if (tc_cmac_update(&state, in, len) == TC_CRYPTO_FAIL) {
-        return BLE_HS_EUNKNOWN;
-    }
+	if (tc_cmac_update(&state, in, len) == TC_CRYPTO_FAIL) {
+		return BLE_HS_EUNKNOWN;
+	}
 
-    if (tc_cmac_final(out, &state) == TC_CRYPTO_FAIL) {
-        return BLE_HS_EUNKNOWN;
-    }
+	if (tc_cmac_final(out, &state) == TC_CRYPTO_FAIL) {
+		return BLE_HS_EUNKNOWN;
+	}
 
-    return 0;
+	return 0;
 }
 
-int
-ble_sm_alg_f4(const uint8_t *u, const uint8_t *v, const uint8_t *x,
-              uint8_t z, uint8_t *out_enc_data)
+int ble_sm_alg_f4(const uint8_t *u, const uint8_t *v, const uint8_t *x, uint8_t z,
+                  uint8_t *out_enc_data)
 {
-    uint8_t xs[16];
-    uint8_t m[65];
-    int rc;
-
-    BLE_HS_LOG(DEBUG, "ble_sm_alg_f4()\n    u=");
-    ble_hs_log_flat_buf(u, 32);
-    BLE_HS_LOG(DEBUG, "\n    v=");
-    ble_hs_log_flat_buf(v, 32);
-    BLE_HS_LOG(DEBUG, "\n    x=");
-    ble_hs_log_flat_buf(x, 16);
-    BLE_HS_LOG(DEBUG, "\n    z=0x%02x\n", z);
-
-    /*
-     * U, V and Z are concatenated and used as input m to the function
-     * AES-CMAC and X is used as the key k.
-     *
-     * Core Spec 4.2 Vol 3 Part H 2.2.5
-     *
-     * note:
-     * ble_sm_alg_aes_cmac uses BE data; ble_sm_alg_f4 accepts LE so we swap.
-     */
-    swap_buf(m, u, 32);
-    swap_buf(m + 32, v, 32);
-    m[64] = z;
-
-    swap_buf(xs, x, 16);
-
-    rc = ble_sm_alg_aes_cmac(xs, m, sizeof(m), out_enc_data);
-    if (rc != 0) {
-        return BLE_HS_EUNKNOWN;
-    }
-
-    swap_in_place(out_enc_data, 16);
-
-    BLE_HS_LOG(DEBUG, "    out_enc_data=");
-    ble_hs_log_flat_buf(out_enc_data, 16);
-    BLE_HS_LOG(DEBUG, "\n");
-
-    return 0;
+	uint8_t xs[16];
+	uint8_t m[65];
+	int rc;
+
+	BLE_HS_LOG(DEBUG, "ble_sm_alg_f4()\n    u=");
+	ble_hs_log_flat_buf(u, 32);
+	BLE_HS_LOG(DEBUG, "\n    v=");
+	ble_hs_log_flat_buf(v, 32);
+	BLE_HS_LOG(DEBUG, "\n    x=");
+	ble_hs_log_flat_buf(x, 16);
+	BLE_HS_LOG(DEBUG, "\n    z=0x%02x\n", z);
+
+	/*
+	 * U, V and Z are concatenated and used as input m to the function
+	 * AES-CMAC and X is used as the key k.
+	 *
+	 * Core Spec 4.2 Vol 3 Part H 2.2.5
+	 *
+	 * note:
+	 * ble_sm_alg_aes_cmac uses BE data; ble_sm_alg_f4 accepts LE so we swap.
+	 */
+	swap_buf(m, u, 32);
+	swap_buf(m + 32, v, 32);
+	m[64] = z;
+
+	swap_buf(xs, x, 16);
+
+	rc = ble_sm_alg_aes_cmac(xs, m, sizeof(m), out_enc_data);
+	if (rc != 0) {
+		return BLE_HS_EUNKNOWN;
+	}
+
+	swap_in_place(out_enc_data, 16);
+
+	BLE_HS_LOG(DEBUG, "    out_enc_data=");
+	ble_hs_log_flat_buf(out_enc_data, 16);
+	BLE_HS_LOG(DEBUG, "\n");
+
+	return 0;
 }
 
-int
-ble_sm_alg_f5(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
-              uint8_t a1t, const uint8_t *a1, uint8_t a2t, const uint8_t *a2,
-              uint8_t *mackey, uint8_t *ltk)
+int ble_sm_alg_f5(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
+                  uint8_t a1t, const uint8_t *a1, uint8_t a2t, const uint8_t *a2,
+                  uint8_t *mackey, uint8_t *ltk)
 {
-    static const uint8_t salt[16] = { 0x6c, 0x88, 0x83, 0x91, 0xaa, 0xf5,
-                      0xa5, 0x38, 0x60, 0x37, 0x0b, 0xdb,
-                      0x5a, 0x60, 0x83, 0xbe };
-    uint8_t m[53] = {
-        0x00, /* counter */
-        0x62, 0x74, 0x6c, 0x65, /* keyID */
-        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*n1*/
-        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*2*/
-        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* a1 */
-        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* a2 */
-        0x01, 0x00 /* length */
-    };
-    uint8_t ws[32];
-    uint8_t t[16];
-    int rc;
-
-    BLE_HS_LOG(DEBUG, "ble_sm_alg_f5()\n");
-    ble_sm_alg_log_buf("w", w, 32);
-    ble_sm_alg_log_buf("n1", n1, 16);
-    ble_sm_alg_log_buf("n2", n2, 16);
-
-    swap_buf(ws, w, 32);
-
-    rc = ble_sm_alg_aes_cmac(salt, ws, 32, t);
-    if (rc != 0) {
-        return BLE_HS_EUNKNOWN;
-    }
-
-    ble_sm_alg_log_buf("t", t, 16);
-
-    swap_buf(m + 5, n1, 16);
-    swap_buf(m + 21, n2, 16);
-    m[37] = a1t;
-    swap_buf(m + 38, a1, 6);
-    m[44] = a2t;
-    swap_buf(m + 45, a2, 6);
-
-    rc = ble_sm_alg_aes_cmac(t, m, sizeof(m), mackey);
-    if (rc != 0) {
-        return BLE_HS_EUNKNOWN;
-    }
-
-    ble_sm_alg_log_buf("mackey", mackey, 16);
-
-    swap_in_place(mackey, 16);
-
-    /* Counter for ltk is 1. */
-    m[0] = 0x01;
-
-    rc = ble_sm_alg_aes_cmac(t, m, sizeof(m), ltk);
-    if (rc != 0) {
-        return BLE_HS_EUNKNOWN;
-    }
-
-    ble_sm_alg_log_buf("ltk", ltk, 16);
-
-    swap_in_place(ltk, 16);
-
-    return 0;
+	static const uint8_t salt[16] = {0x6c, 0x88, 0x83, 0x91, 0xaa, 0xf5, 0xa5, 0x38,
+	                                 0x60, 0x37, 0x0b, 0xdb, 0x5a, 0x60, 0x83, 0xbe};
+	uint8_t m[53] = {
+		0x00,                                           /* counter */
+		0x62, 0x74, 0x6c, 0x65,                         /* keyID */
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*n1*/
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*2*/
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* a1 */
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* a2 */
+		0x01, 0x00                                /* length */
+	};
+	uint8_t ws[32];
+	uint8_t t[16];
+	int rc;
+
+	BLE_HS_LOG(DEBUG, "ble_sm_alg_f5()\n");
+	ble_sm_alg_log_buf("w", w, 32);
+	ble_sm_alg_log_buf("n1", n1, 16);
+	ble_sm_alg_log_buf("n2", n2, 16);
+
+	swap_buf(ws, w, 32);
+
+	rc = ble_sm_alg_aes_cmac(salt, ws, 32, t);
+	if (rc != 0) {
+		return BLE_HS_EUNKNOWN;
+	}
+
+	ble_sm_alg_log_buf("t", t, 16);
+
+	swap_buf(m + 5, n1, 16);
+	swap_buf(m + 21, n2, 16);
+	m[37] = a1t;
+	swap_buf(m + 38, a1, 6);
+	m[44] = a2t;
+	swap_buf(m + 45, a2, 6);
+
+	rc = ble_sm_alg_aes_cmac(t, m, sizeof(m), mackey);
+	if (rc != 0) {
+		return BLE_HS_EUNKNOWN;
+	}
+
+	ble_sm_alg_log_buf("mackey", mackey, 16);
+
+	swap_in_place(mackey, 16);
+
+	/* Counter for ltk is 1. */
+	m[0] = 0x01;
+
+	rc = ble_sm_alg_aes_cmac(t, m, sizeof(m), ltk);
+	if (rc != 0) {
+		return BLE_HS_EUNKNOWN;
+	}
+
+	ble_sm_alg_log_buf("ltk", ltk, 16);
+
+	swap_in_place(ltk, 16);
+
+	return 0;
 }
 
-int
-ble_sm_alg_f6(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
-              const uint8_t *r, const uint8_t *iocap, uint8_t a1t,
-              const uint8_t *a1, uint8_t a2t, const uint8_t *a2,
-              uint8_t *check)
+int ble_sm_alg_f6(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
+                  const uint8_t *r, const uint8_t *iocap, uint8_t a1t,
+                  const uint8_t *a1, uint8_t a2t, const uint8_t *a2, uint8_t *check)
 {
-    uint8_t ws[16];
-    uint8_t m[65];
-    int rc;
-
-    BLE_HS_LOG(DEBUG, "ble_sm_alg_f6()\n");
-    ble_sm_alg_log_buf("w", w, 16);
-    ble_sm_alg_log_buf("n1", n1, 16);
-    ble_sm_alg_log_buf("n2", n2, 16);
-    ble_sm_alg_log_buf("r", r, 16);
-    ble_sm_alg_log_buf("iocap", iocap, 3);
-    ble_sm_alg_log_buf("a1t", &a1t, 1);
-    ble_sm_alg_log_buf("a1", a1, 6);
-    ble_sm_alg_log_buf("a2t", &a2t, 1);
-    ble_sm_alg_log_buf("a2", a2, 6);
-
-    swap_buf(m, n1, 16);
-    swap_buf(m + 16, n2, 16);
-    swap_buf(m + 32, r, 16);
-    swap_buf(m + 48, iocap, 3);
-
-    m[51] = a1t;
-    memcpy(m + 52, a1, 6);
-    swap_buf(m + 52, a1, 6);
-
-    m[58] = a2t;
-    memcpy(m + 59, a2, 6);
-    swap_buf(m + 59, a2, 6);
-
-    swap_buf(ws, w, 16);
-
-    rc = ble_sm_alg_aes_cmac(ws, m, sizeof(m), check);
-    if (rc != 0) {
-        return BLE_HS_EUNKNOWN;
-    }
-
-    ble_sm_alg_log_buf("res", check, 16);
-
-    swap_in_place(check, 16);
-
-    return 0;
+	uint8_t ws[16];
+	uint8_t m[65];
+	int rc;
+
+	BLE_HS_LOG(DEBUG, "ble_sm_alg_f6()\n");
+	ble_sm_alg_log_buf("w", w, 16);
+	ble_sm_alg_log_buf("n1", n1, 16);
+	ble_sm_alg_log_buf("n2", n2, 16);
+	ble_sm_alg_log_buf("r", r, 16);
+	ble_sm_alg_log_buf("iocap", iocap, 3);
+	ble_sm_alg_log_buf("a1t", &a1t, 1);
+	ble_sm_alg_log_buf("a1", a1, 6);
+	ble_sm_alg_log_buf("a2t", &a2t, 1);
+	ble_sm_alg_log_buf("a2", a2, 6);
+
+	swap_buf(m, n1, 16);
+	swap_buf(m + 16, n2, 16);
+	swap_buf(m + 32, r, 16);
+	swap_buf(m + 48, iocap, 3);
+
+	m[51] = a1t;
+	memcpy(m + 52, a1, 6);
+	swap_buf(m + 52, a1, 6);
+
+	m[58] = a2t;
+	memcpy(m + 59, a2, 6);
+	swap_buf(m + 59, a2, 6);
+
+	swap_buf(ws, w, 16);
+
+	rc = ble_sm_alg_aes_cmac(ws, m, sizeof(m), check);
+	if (rc != 0) {
+		return BLE_HS_EUNKNOWN;
+	}
+
+	ble_sm_alg_log_buf("res", check, 16);
+
+	swap_in_place(check, 16);
+
+	return 0;
 }
 
-int
-ble_sm_alg_g2(const uint8_t *u, const uint8_t *v, const uint8_t *x,
-              const uint8_t *y, uint32_t *passkey)
+int ble_sm_alg_g2(const uint8_t *u, const uint8_t *v, const uint8_t *x,
+                  const uint8_t *y, uint32_t *passkey)
 {
-    uint8_t m[80], xs[16];
-    int rc;
+	uint8_t m[80], xs[16];
+	int rc;
 
-    BLE_HS_LOG(DEBUG, "ble_sm_alg_g2()\n");
-    ble_sm_alg_log_buf("u", u, 32);
-    ble_sm_alg_log_buf("v", v, 32);
-    ble_sm_alg_log_buf("x", x, 16);
-    ble_sm_alg_log_buf("y", y, 16);
+	BLE_HS_LOG(DEBUG, "ble_sm_alg_g2()\n");
+	ble_sm_alg_log_buf("u", u, 32);
+	ble_sm_alg_log_buf("v", v, 32);
+	ble_sm_alg_log_buf("x", x, 16);
+	ble_sm_alg_log_buf("y", y, 16);
 
-    swap_buf(m, u, 32);
-    swap_buf(m + 32, v, 32);
-    swap_buf(m + 64, y, 16);
+	swap_buf(m, u, 32);
+	swap_buf(m + 32, v, 32);
+	swap_buf(m + 64, y, 16);
 
-    swap_buf(xs, x, 16);
+	swap_buf(xs, x, 16);
 
-    /* reuse xs (key) as buffer for result */
-    rc = ble_sm_alg_aes_cmac(xs, m, sizeof(m), xs);
-    if (rc != 0) {
-        return BLE_HS_EUNKNOWN;
-    }
+	/* reuse xs (key) as buffer for result */
+	rc = ble_sm_alg_aes_cmac(xs, m, sizeof(m), xs);
+	if (rc != 0) {
+		return BLE_HS_EUNKNOWN;
+	}
 
-    ble_sm_alg_log_buf("res", xs, 16);
+	ble_sm_alg_log_buf("res", xs, 16);
 
-    *passkey = get_be32(xs + 12) % 1000000;
-    BLE_HS_LOG(DEBUG, "    passkey=%u\n", *passkey);
+	*passkey = get_be32(xs + 12) % 1000000;
+	BLE_HS_LOG(DEBUG, "    passkey=%u\n", *passkey);
 
-    return 0;
+	return 0;
 }
 
-int
-ble_sm_alg_csis_k1(const uint8_t *n, size_t n_len, const uint8_t *salt,
-                   const uint8_t *p, size_t p_len, uint8_t *out)
+int ble_sm_alg_csis_k1(const uint8_t *n, size_t n_len, const uint8_t *salt,
+                       const uint8_t *p, size_t p_len, uint8_t *out)
 {
-    int rc;
-    uint8_t t[16] = {0};
-    uint8_t salt_be[16] = {0};
-    uint8_t n_be[16] = {0};
-
-    /* XXX: Spec does not specify the maximum N and P parameters length.
-     * We assume that 16 bytes is enough and return error if passed len value is greater
-     * than that */
-    if ((n_len > 16) || (p_len > 16)) {
-        return BLE_HS_EINVAL;
-    }
-
-    swap_buf(salt_be, salt, 16);
-    swap_buf(n_be, n, n_len);
-
-    /* T = AES-CMAC_SALT (N) */
-    rc = ble_sm_alg_aes_cmac(salt_be, n_be, n_len, t);
-    if (rc != 0) {
-        return rc;
-    }
-
-    /* AES-CMAC_T (P) */
-    rc = ble_sm_alg_aes_cmac(t, p, p_len, out);
-    if (rc != 0) {
-        return rc;
-    }
-
-    swap_in_place(out, 16);
-
-    return 0;
+	int rc;
+	uint8_t t[16] = {0};
+	uint8_t salt_be[16] = {0};
+	uint8_t n_be[16] = {0};
+
+	/* XXX: Spec does not specify the maximum N and P parameters length.
+	 * We assume that 16 bytes is enough and return error if passed len value is
+	 * greater than that */
+	if ((n_len > 16) || (p_len > 16)) {
+		return BLE_HS_EINVAL;
+	}
+
+	swap_buf(salt_be, salt, 16);
+	swap_buf(n_be, n, n_len);
+
+	/* T = AES-CMAC_SALT (N) */
+	rc = ble_sm_alg_aes_cmac(salt_be, n_be, n_len, t);
+	if (rc != 0) {
+		return rc;
+	}
+
+	/* AES-CMAC_T (P) */
+	rc = ble_sm_alg_aes_cmac(t, p, p_len, out);
+	if (rc != 0) {
+		return rc;
+	}
+
+	swap_in_place(out, 16);
+
+	return 0;
 }
 
-int
-ble_sm_alg_csis_s1(const uint8_t *m, size_t m_len, uint8_t *out)
+int ble_sm_alg_csis_s1(const uint8_t *m, size_t m_len, uint8_t *out)
 {
-    int rc;
-    uint8_t k_zero[16] = {0};
+	int rc;
+	uint8_t k_zero[16] = {0};
 
-    /* XXX: Spec does not specify the maximum M parameter length.
-     * We assume that 16 bytes is enough and return error if passed len value is greater
-     * than that */
-    if (m_len > 16) {
-        return BLE_HS_EINVAL;
-    }
+	/* XXX: Spec does not specify the maximum M parameter length.
+	 * We assume that 16 bytes is enough and return error if passed len value is
+	 * greater than that */
+	if (m_len > 16) {
+		return BLE_HS_EINVAL;
+	}
 
-    /* AES-CMAC_zero (M) */
-    rc = ble_sm_alg_aes_cmac(k_zero, m, m_len, out);
-    if (rc != 0) {
-        return rc;
-    }
+	/* AES-CMAC_zero (M) */
+	rc = ble_sm_alg_aes_cmac(k_zero, m, m_len, out);
+	if (rc != 0) {
+		return rc;
+	}
 
-    swap_in_place(out, 16);
+	swap_in_place(out, 16);
 
-    return 0;
+	return 0;
 }
 
-int
-ble_sm_alg_csis_sef(const uint8_t *k, const uint8_t *plaintext_sirk, uint8_t *out)
+int ble_sm_alg_csis_sef(const uint8_t *k, const uint8_t *plaintext_sirk, uint8_t *out)
 {
-    uint8_t salt[16];
-    int rc;
-    int i;
-
-    /* s1("SIRKenc") */
-    rc = ble_sm_alg_csis_s1((const uint8_t *) "SIRKenc", 7, salt);
-    if (rc != 0) {
-        return rc;
-    }
-
-    /* k1(K, s1("SIRKenc"), "csis") */
-    rc = ble_sm_alg_csis_k1(k, 16, salt, (const uint8_t *) "csis", 4, out);
-    if (rc != 0) {
-        return rc;
-    }
-
-    /* k1(K, s1("SIRKenc"), "csis") ^ SIRK */
-    for (i = 0; i < 16; i++) {
-        out[i] ^= plaintext_sirk[i];
-    }
-
-    return 0;
+	uint8_t salt[16];
+	int rc;
+	int i;
+
+	/* s1("SIRKenc") */
+	rc = ble_sm_alg_csis_s1((const uint8_t *) "SIRKenc", 7, salt);
+	if (rc != 0) {
+		return rc;
+	}
+
+	/* k1(K, s1("SIRKenc"), "csis") */
+	rc = ble_sm_alg_csis_k1(k, 16, salt, (const uint8_t *) "csis", 4, out);
+	if (rc != 0) {
+		return rc;
+	}
+
+	/* k1(K, s1("SIRKenc"), "csis") ^ SIRK */
+	for (i = 0; i < 16; i++) {
+		out[i] ^= plaintext_sirk[i];
+	}
+
+	return 0;
 }
 
-int
-ble_sm_alg_csis_sdf(const uint8_t *k, const uint8_t *enc_sirk, uint8_t *out)
+int ble_sm_alg_csis_sdf(const uint8_t *k, const uint8_t *enc_sirk, uint8_t *out)
 {
-    uint8_t salt[16];
-    int rc;
-    int i;
-
-    /* s1("SIRKenc") */
-    rc = ble_sm_alg_csis_s1((const uint8_t *) "SIRKenc", 7, salt);
-    if (rc != 0) {
-        return rc;
-    }
-
-    /* k1(K, s1("SIRKenc"), "csis") */
-    rc = ble_sm_alg_csis_k1(k, 16, salt, (const uint8_t *) "csis", 4, out);
-    if (rc != 0) {
-        return rc;
-    }
-
-    /* k1(K, s1("SIRKenc"), "csis") ^ EncSIRK */
-    for (i = 0; i < 16; i++) {
-        out[i] ^= enc_sirk[i];
-    }
-
-    return 0;
+	uint8_t salt[16];
+	int rc;
+	int i;
+
+	/* s1("SIRKenc") */
+	rc = ble_sm_alg_csis_s1((const uint8_t *) "SIRKenc", 7, salt);
+	if (rc != 0) {
+		return rc;
+	}
+
+	/* k1(K, s1("SIRKenc"), "csis") */
+	rc = ble_sm_alg_csis_k1(k, 16, salt, (const uint8_t *) "csis", 4, out);
+	if (rc != 0) {
+		return rc;
+	}
+
+	/* k1(K, s1("SIRKenc"), "csis") ^ EncSIRK */
+	for (i = 0; i < 16; i++) {
+		out[i] ^= enc_sirk[i];
+	}
+
+	return 0;
 }
 
-int
-ble_sm_alg_csis_sih(const uint8_t *k, const uint8_t *r, uint8_t *out)
+int ble_sm_alg_csis_sih(const uint8_t *k, const uint8_t *r, uint8_t *out)
 {
-    uint8_t r1[16];
-    int rc;
+	uint8_t r1[16];
+	int rc;
 
-    memcpy(r1, r, 3);
-    memset(r1 + 3, 0, 13);
+	memcpy(r1, r, 3);
+	memset(r1 + 3, 0, 13);
 
-    rc = ble_sm_alg_encrypt(k, r1, r1);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_alg_encrypt(k, r1, r1);
+	if (rc != 0) {
+		return rc;
+	}
 
-    memcpy(out, r1, 3);
+	memcpy(out, r1, 3);
 
-    return 0;
+	return 0;
 }
 
-int
-ble_sm_alg_gen_dhkey(const uint8_t *peer_pub_key_x, const uint8_t *peer_pub_key_y,
-                     const uint8_t *our_priv_key, uint8_t *out_dhkey)
+int ble_sm_alg_gen_dhkey(const uint8_t *peer_pub_key_x, const uint8_t *peer_pub_key_y,
+                         const uint8_t *our_priv_key, uint8_t *out_dhkey)
 {
-    uint8_t dh[32];
-    uint8_t pk[64];
-    uint8_t priv[32];
-    int rc;
+	uint8_t dh[32];
+	uint8_t pk[64];
+	uint8_t priv[32];
+	int rc;
 
-    swap_buf(pk, peer_pub_key_x, 32);
-    swap_buf(&pk[32], peer_pub_key_y, 32);
-    swap_buf(priv, our_priv_key, 32);
+	swap_buf(pk, peer_pub_key_x, 32);
+	swap_buf(&pk[32], peer_pub_key_y, 32);
+	swap_buf(priv, our_priv_key, 32);
 
-    if (uECC_valid_public_key(pk, &curve_secp256r1) < 0) {
-        return BLE_HS_EUNKNOWN;
-    }
+	if (uECC_valid_public_key(pk, &curve_secp256r1) < 0) {
+		return BLE_HS_EUNKNOWN;
+	}
 
-    rc = uECC_shared_secret(pk, priv, dh, &curve_secp256r1);
-    if (rc == TC_CRYPTO_FAIL) {
-        return BLE_HS_EUNKNOWN;
-    }
+	rc = uECC_shared_secret(pk, priv, dh, &curve_secp256r1);
+	if (rc == TC_CRYPTO_FAIL) {
+		return BLE_HS_EUNKNOWN;
+	}
 
-    swap_buf(out_dhkey, dh, 32);
+	swap_buf(out_dhkey, dh, 32);
 
-    return 0;
+	return 0;
 }
 
 /* based on Core Specification 4.2 Vol 3. Part H 2.3.5.6.1 */
 static const uint8_t ble_sm_alg_dbg_priv_key[32] = {
-    0x3f, 0x49, 0xf6, 0xd4, 0xa3, 0xc5, 0x5f, 0x38, 0x74, 0xc9, 0xb3, 0xe3,
-    0xd2, 0x10, 0x3f, 0x50, 0x4a, 0xff, 0x60, 0x7b, 0xeb, 0x40, 0xb7, 0x99,
-    0x58, 0x99, 0xb8, 0xa6, 0xcd, 0x3c, 0x1a, 0xbd
-};
+	0x3f, 0x49, 0xf6, 0xd4, 0xa3, 0xc5, 0x5f, 0x38, 0x74, 0xc9, 0xb3,
+	0xe3, 0xd2, 0x10, 0x3f, 0x50, 0x4a, 0xff, 0x60, 0x7b, 0xeb, 0x40,
+	0xb7, 0x99, 0x58, 0x99, 0xb8, 0xa6, 0xcd, 0x3c, 0x1a, 0xbd};
 
 #if MYNEWT_VAL(BLE_SM_SC_DEBUG_KEYS)
 static const uint8_t ble_sm_alg_dbg_pub_key[64] = {
-    /* X */
-    0x20, 0xb0, 0x03, 0xd2, 0xf2, 0x97, 0xbe, 0x2c, 0x5e, 0x2c, 0x83, 0xa7,
-    0xe9, 0xf9, 0xa5, 0xb9, 0xef, 0xf4, 0x91, 0x11, 0xac, 0xf4, 0xfd, 0xdb,
-    0xcc, 0x03, 0x01, 0x48, 0x0e, 0x35, 0x9d, 0xe6,
-    /* Y */
-    0xdc, 0x80, 0x9c, 0x49, 0x65, 0x2a, 0xeb, 0x6d, 0x63, 0x32, 0x9a, 0xbf,
-    0x5a, 0x52, 0x15, 0x5c, 0x76, 0x63, 0x45, 0xc2, 0x8f, 0xed, 0x30, 0x24,
-    0x74, 0x1c, 0x8e, 0xd0, 0x15, 0x89, 0xd2, 0x8b,
+	/* X */
+	0x20,
+	0xb0,
+	0x03,
+	0xd2,
+	0xf2,
+	0x97,
+	0xbe,
+	0x2c,
+	0x5e,
+	0x2c,
+	0x83,
+	0xa7,
+	0xe9,
+	0xf9,
+	0xa5,
+	0xb9,
+	0xef,
+	0xf4,
+	0x91,
+	0x11,
+	0xac,
+	0xf4,
+	0xfd,
+	0xdb,
+	0xcc,
+	0x03,
+	0x01,
+	0x48,
+	0x0e,
+	0x35,
+	0x9d,
+	0xe6,
+	/* Y */
+	0xdc,
+	0x80,
+	0x9c,
+	0x49,
+	0x65,
+	0x2a,
+	0xeb,
+	0x6d,
+	0x63,
+	0x32,
+	0x9a,
+	0xbf,
+	0x5a,
+	0x52,
+	0x15,
+	0x5c,
+	0x76,
+	0x63,
+	0x45,
+	0xc2,
+	0x8f,
+	0xed,
+	0x30,
+	0x24,
+	0x74,
+	0x1c,
+	0x8e,
+	0xd0,
+	0x15,
+	0x89,
+	0xd2,
+	0x8b,
 };
 #endif
 
@@ -602,30 +638,29 @@ static const uint8_t ble_sm_alg_dbg_pub_key[64] = {
  * pub: 64 bytes
  * priv: 32 bytes
  */
-int
-ble_sm_alg_gen_key_pair(uint8_t *pub, uint8_t *priv)
+int ble_sm_alg_gen_key_pair(uint8_t *pub, uint8_t *priv)
 {
 #if MYNEWT_VAL(BLE_SM_SC_DEBUG_KEYS)
-    swap_buf(pub, ble_sm_alg_dbg_pub_key, 32);
-    swap_buf(&pub[32], &ble_sm_alg_dbg_pub_key[32], 32);
-    swap_buf(priv, ble_sm_alg_dbg_priv_key, 32);
+	swap_buf(pub, ble_sm_alg_dbg_pub_key, 32);
+	swap_buf(&pub[32], &ble_sm_alg_dbg_pub_key[32], 32);
+	swap_buf(priv, ble_sm_alg_dbg_priv_key, 32);
 #else
-    uint8_t pk[64];
+	uint8_t pk[64];
 
-    do {
-        if (uECC_make_key(pk, priv, &curve_secp256r1) != TC_CRYPTO_SUCCESS) {
-            return BLE_HS_EUNKNOWN;
-        }
+	do {
+		if (uECC_make_key(pk, priv, &curve_secp256r1) != TC_CRYPTO_SUCCESS) {
+			return BLE_HS_EUNKNOWN;
+		}
 
-        /* Make sure generated key isn't debug key. */
-    } while (memcmp(priv, ble_sm_alg_dbg_priv_key, 32) == 0);
+		/* Make sure generated key isn't debug key. */
+	} while (memcmp(priv, ble_sm_alg_dbg_priv_key, 32) == 0);
 
-    swap_buf(pub, pk, 32);
-    swap_buf(&pub[32], &pk[32], 32);
-    swap_in_place(priv, 32);
+	swap_buf(pub, pk, 32);
+	swap_buf(&pub[32], &pk[32], 32);
+	swap_in_place(priv, 32);
 #endif
 
-    return 0;
+	return 0;
 }
 
 #if MYNEWT_VAL(SELFTEST)
@@ -633,36 +668,34 @@ ble_sm_alg_gen_key_pair(uint8_t *pub, uint8_t *priv)
 #define ble_sm_alg_rand NULL
 #else
 /* used by uECC to get random data */
-static int
-ble_sm_alg_rand(uint8_t *dst, unsigned int size)
+static int ble_sm_alg_rand(uint8_t *dst, unsigned int size)
 {
 #if MYNEWT_VAL(TRNG)
-    size_t num;
-
-    if (!g_trng) {
-        g_trng = (struct trng_dev *)os_dev_open("trng", OS_WAIT_FOREVER, NULL);
-        assert(g_trng);
-    }
-
-    while (size) {
-        num = trng_read(g_trng, dst, size);
-        dst += num;
-        size -= num;
-    }
+	size_t num;
+
+	if (!g_trng) {
+		g_trng = (struct trng_dev *) os_dev_open("trng", OS_WAIT_FOREVER, NULL);
+		assert(g_trng);
+	}
+
+	while (size) {
+		num = trng_read(g_trng, dst, size);
+		dst += num;
+		size -= num;
+	}
 #else
-    if (ble_hs_hci_rand(dst, size)) {
-        return 0;
-    }
+	if (ble_hs_hci_rand(dst, size)) {
+		return 0;
+	}
 #endif
 
-    return 1;
+	return 1;
 }
 #endif
 
-void
-ble_sm_alg_ecc_init(void)
+void ble_sm_alg_ecc_init(void)
 {
-    uECC_set_rng(ble_sm_alg_rand);
+	uECC_set_rng(ble_sm_alg_rand);
 }
 
 #endif
diff --git a/nimble/host/src/ble_sm_sc.c b/nimble/host/src/ble_sm_sc.c
index 0cd2b2ee..82a80b03 100644
--- a/nimble/host/src/ble_sm_sc.c
+++ b/nimble/host/src/ble_sm_sc.c
@@ -27,8 +27,8 @@
 #if NIMBLE_BLE_CONNECT
 #if MYNEWT_VAL(BLE_SM_SC)
 
-#define BLE_SM_SC_PASSKEY_BYTES     4
-#define BLE_SM_SC_PASSKEY_BITS      20
+#define BLE_SM_SC_PASSKEY_BYTES 4
+#define BLE_SM_SC_PASSKEY_BITS 20
 
 static uint8_t ble_sm_sc_pub_key[64];
 static uint8_t ble_sm_sc_priv_key[32];
@@ -43,25 +43,24 @@ static uint8_t ble_sm_sc_keys_generated;
  * Create some shortened names for the passkey actions so that the table is
  * easier to read.
  */
-#define IOACT_NONE      BLE_SM_IOACT_NONE
-#define IOACT_OOB       BLE_SM_IOACT_OOB
-#define IOACT_INPUT     BLE_SM_IOACT_INPUT
-#define IOACT_DISP      BLE_SM_IOACT_DISP
-#define IOACT_NUMCMP    BLE_SM_IOACT_NUMCMP
+#define IOACT_NONE BLE_SM_IOACT_NONE
+#define IOACT_OOB BLE_SM_IOACT_OOB
+#define IOACT_INPUT BLE_SM_IOACT_INPUT
+#define IOACT_DISP BLE_SM_IOACT_DISP
+#define IOACT_NUMCMP BLE_SM_IOACT_NUMCMP
 
 /**
  * This table expresses the required initiator IO action.  Inputs are:
  *     o Responder IO capabilities (from pair response).
  *     o Initiator IO capabilities (from pair request).
  */
-static const uint8_t ble_sm_sc_init_ioa[5 /*resp*/ ][5 /*init*/ ] =
-{
-      /* init */
-/*r*/ {IOACT_NONE,    IOACT_NONE,   IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
-/*e*/ {IOACT_NONE,    IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
-/*s*/ {IOACT_DISP,    IOACT_DISP,   IOACT_INPUT, IOACT_NONE, IOACT_DISP},
-/*p*/ {IOACT_NONE,    IOACT_NONE,   IOACT_NONE,  IOACT_NONE, IOACT_NONE},
-      {IOACT_DISP,    IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
+static const uint8_t ble_sm_sc_init_ioa[5 /*resp*/][5 /*init*/] = {
+	/* init */
+	/*r*/ {IOACT_NONE, IOACT_NONE, IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
+	/*e*/ {IOACT_NONE, IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
+	/*s*/ {IOACT_DISP, IOACT_DISP, IOACT_INPUT, IOACT_NONE, IOACT_DISP},
+	/*p*/ {IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE},
+	{IOACT_DISP, IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
 };
 
 /**
@@ -69,14 +68,13 @@ static const uint8_t ble_sm_sc_init_ioa[5 /*resp*/ ][5 /*init*/ ] =
  *     o Responder IO capabilities (from pair response).
  *     o Initiator IO capabilities (from pair request).
  */
-static const uint8_t ble_sm_sc_resp_ioa[5 /*resp*/ ][5 /*init*/ ] =
-{
-      /* init */
-/*r*/ {IOACT_NONE,    IOACT_NONE,   IOACT_DISP,  IOACT_NONE, IOACT_DISP},
-/*e*/ {IOACT_NONE,    IOACT_NUMCMP, IOACT_DISP,  IOACT_NONE, IOACT_NUMCMP},
-/*s*/ {IOACT_INPUT,   IOACT_INPUT,  IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
-/*p*/ {IOACT_NONE,    IOACT_NONE,   IOACT_NONE,  IOACT_NONE, IOACT_NONE},
-      {IOACT_INPUT,   IOACT_NUMCMP, IOACT_DISP,  IOACT_NONE, IOACT_NUMCMP},
+static const uint8_t ble_sm_sc_resp_ioa[5 /*resp*/][5 /*init*/] = {
+	/* init */
+	/*r*/ {IOACT_NONE, IOACT_NONE, IOACT_DISP, IOACT_NONE, IOACT_DISP},
+	/*e*/ {IOACT_NONE, IOACT_NUMCMP, IOACT_DISP, IOACT_NONE, IOACT_NUMCMP},
+	/*s*/ {IOACT_INPUT, IOACT_INPUT, IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
+	/*p*/ {IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE},
+	{IOACT_INPUT, IOACT_NUMCMP, IOACT_DISP, IOACT_NONE, IOACT_NUMCMP},
 };
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
@@ -85,115 +83,112 @@ static uint8_t ble_sm_dbg_sc_pub_key[64];
 static uint8_t ble_sm_dbg_sc_priv_key[32];
 static uint8_t ble_sm_dbg_sc_keys_set;
 
-void
-ble_sm_dbg_set_sc_keys(uint8_t *pubkey, uint8_t *privkey)
+void ble_sm_dbg_set_sc_keys(uint8_t *pubkey, uint8_t *privkey)
 {
-    memcpy(ble_sm_dbg_sc_pub_key, pubkey,
-           sizeof ble_sm_dbg_sc_pub_key);
-    memcpy(ble_sm_dbg_sc_priv_key, privkey,
-           sizeof ble_sm_dbg_sc_priv_key);
-    ble_sm_dbg_sc_keys_set = 1;
+	memcpy(ble_sm_dbg_sc_pub_key, pubkey, sizeof ble_sm_dbg_sc_pub_key);
+	memcpy(ble_sm_dbg_sc_priv_key, privkey, sizeof ble_sm_dbg_sc_priv_key);
+	ble_sm_dbg_sc_keys_set = 1;
 }
 
 #endif
 
-int
-ble_sm_sc_io_action(struct ble_sm_proc *proc, uint8_t *action)
+int ble_sm_sc_io_action(struct ble_sm_proc *proc, uint8_t *action)
 {
-    struct ble_sm_pair_cmd *pair_req, *pair_rsp;
-
-    pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
-
-    if (pair_req->oob_data_flag == BLE_SM_PAIR_OOB_YES ||
-        pair_rsp->oob_data_flag == BLE_SM_PAIR_OOB_YES) {
-        *action = BLE_SM_IOACT_OOB_SC;
-    } else if (!(pair_req->authreq & BLE_SM_PAIR_AUTHREQ_MITM) &&
-               !(pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_MITM)) {
-
-        *action = BLE_SM_IOACT_NONE;
-    } else if (pair_req->io_cap >= BLE_SM_IO_CAP_RESERVED ||
-               pair_rsp->io_cap >= BLE_SM_IO_CAP_RESERVED) {
-        *action = BLE_SM_IOACT_NONE;
-    } else if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        *action = ble_sm_sc_init_ioa[pair_rsp->io_cap][pair_req->io_cap];
-    } else {
-        *action = ble_sm_sc_resp_ioa[pair_rsp->io_cap][pair_req->io_cap];
-    }
-
-    switch (*action) {
-    case BLE_SM_IOACT_NONE:
-        proc->pair_alg = BLE_SM_PAIR_ALG_JW;
-        break;
-
-    case BLE_SM_IOACT_OOB_SC:
-        proc->pair_alg = BLE_SM_PAIR_ALG_OOB;
-        proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
-        break;
-
-    case BLE_SM_IOACT_INPUT:
-    case BLE_SM_IOACT_DISP:
-        proc->pair_alg = BLE_SM_PAIR_ALG_PASSKEY;
-        proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
-        break;
-
-    case BLE_SM_IOACT_NUMCMP:
-        proc->pair_alg = BLE_SM_PAIR_ALG_NUMCMP;
-        proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
-        break;
-
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        return BLE_HS_EINVAL;
-    }
-
-    return 0;
+	struct ble_sm_pair_cmd *pair_req, *pair_rsp;
+
+	pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+	pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+
+	if (pair_req->oob_data_flag == BLE_SM_PAIR_OOB_YES ||
+	    pair_rsp->oob_data_flag == BLE_SM_PAIR_OOB_YES) {
+		*action = BLE_SM_IOACT_OOB_SC;
+	}
+	else if (!(pair_req->authreq & BLE_SM_PAIR_AUTHREQ_MITM) &&
+	         !(pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_MITM)) {
+		*action = BLE_SM_IOACT_NONE;
+	}
+	else if (pair_req->io_cap >= BLE_SM_IO_CAP_RESERVED ||
+	         pair_rsp->io_cap >= BLE_SM_IO_CAP_RESERVED) {
+		*action = BLE_SM_IOACT_NONE;
+	}
+	else if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		*action = ble_sm_sc_init_ioa[pair_rsp->io_cap][pair_req->io_cap];
+	}
+	else {
+		*action = ble_sm_sc_resp_ioa[pair_rsp->io_cap][pair_req->io_cap];
+	}
+
+	switch (*action) {
+	case BLE_SM_IOACT_NONE:
+		proc->pair_alg = BLE_SM_PAIR_ALG_JW;
+		break;
+
+	case BLE_SM_IOACT_OOB_SC:
+		proc->pair_alg = BLE_SM_PAIR_ALG_OOB;
+		proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
+		break;
+
+	case BLE_SM_IOACT_INPUT:
+	case BLE_SM_IOACT_DISP:
+		proc->pair_alg = BLE_SM_PAIR_ALG_PASSKEY;
+		proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
+		break;
+
+	case BLE_SM_IOACT_NUMCMP:
+		proc->pair_alg = BLE_SM_PAIR_ALG_NUMCMP;
+		proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
+		break;
+
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		return BLE_HS_EINVAL;
+	}
+
+	return 0;
 }
 
-static int
-ble_sm_gen_pub_priv(uint8_t *pub, uint8_t *priv)
+static int ble_sm_gen_pub_priv(uint8_t *pub, uint8_t *priv)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_sc_keys_set) {
-        ble_sm_dbg_sc_keys_set = 0;
-        memcpy(pub, ble_sm_dbg_sc_pub_key, sizeof ble_sm_dbg_sc_pub_key);
-        memcpy(priv, ble_sm_dbg_sc_priv_key, sizeof ble_sm_dbg_sc_priv_key);
-        return 0;
-    }
+	if (ble_sm_dbg_sc_keys_set) {
+		ble_sm_dbg_sc_keys_set = 0;
+		memcpy(pub, ble_sm_dbg_sc_pub_key, sizeof ble_sm_dbg_sc_pub_key);
+		memcpy(priv, ble_sm_dbg_sc_priv_key, sizeof ble_sm_dbg_sc_priv_key);
+		return 0;
+	}
 #endif
 
-    rc = ble_sm_alg_gen_key_pair(pub, priv);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_alg_gen_key_pair(pub, priv);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_sc_ensure_keys_generated(void)
+static int ble_sm_sc_ensure_keys_generated(void)
 {
-    int rc;
+	int rc;
 
-    if (!ble_sm_sc_keys_generated) {
-        rc = ble_sm_gen_pub_priv(ble_sm_sc_pub_key, ble_sm_sc_priv_key);
-        if (rc != 0) {
-            return rc;
-        }
+	if (!ble_sm_sc_keys_generated) {
+		rc = ble_sm_gen_pub_priv(ble_sm_sc_pub_key, ble_sm_sc_priv_key);
+		if (rc != 0) {
+			return rc;
+		}
 
-        ble_sm_sc_keys_generated = 1;
-    }
+		ble_sm_sc_keys_generated = 1;
+	}
 
-    BLE_HS_LOG(DEBUG, "our pubkey=");
-    ble_hs_log_flat_buf(&ble_sm_sc_pub_key, 64);
-    BLE_HS_LOG(DEBUG, "\n");
-    BLE_HS_LOG(DEBUG, "our privkey=");
-    ble_hs_log_flat_buf(&ble_sm_sc_priv_key, 32);
-    BLE_HS_LOG(DEBUG, "\n");
+	BLE_HS_LOG(DEBUG, "our pubkey=");
+	ble_hs_log_flat_buf(&ble_sm_sc_pub_key, 64);
+	BLE_HS_LOG(DEBUG, "\n");
+	BLE_HS_LOG(DEBUG, "our privkey=");
+	ble_hs_log_flat_buf(&ble_sm_sc_priv_key, 32);
+	BLE_HS_LOG(DEBUG, "\n");
 
-    return 0;
+	return 0;
 }
 
 /* Initiator does not send a confirm when pairing algorithm is any of:
@@ -201,13 +196,12 @@ ble_sm_sc_ensure_keys_generated(void)
  *     o numeric comparison
  * (vol. 3, part H, 2.3.5.6.2)
  */
-static int
-ble_sm_sc_initiator_txes_confirm(struct ble_sm_proc *proc)
+static int ble_sm_sc_initiator_txes_confirm(struct ble_sm_proc *proc)
 {
-    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_SC);
+	BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_SC);
 
-    return proc->pair_alg != BLE_SM_PAIR_ALG_JW &&
-           proc->pair_alg != BLE_SM_PAIR_ALG_NUMCMP;
+	return proc->pair_alg != BLE_SM_PAIR_ALG_JW &&
+	       proc->pair_alg != BLE_SM_PAIR_ALG_NUMCMP;
 }
 
 /* Responder does not verify the initiator's random number when pairing
@@ -216,703 +210,689 @@ ble_sm_sc_initiator_txes_confirm(struct ble_sm_proc *proc)
  *     o numeric comparison
  * (vol. 3, part H, 2.3.5.6.2)
  */
-static int
-ble_sm_sc_responder_verifies_random(struct ble_sm_proc *proc)
+static int ble_sm_sc_responder_verifies_random(struct ble_sm_proc *proc)
 {
-    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_SC);
+	BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_SC);
 
-    return proc->pair_alg != BLE_SM_PAIR_ALG_JW &&
-           proc->pair_alg != BLE_SM_PAIR_ALG_NUMCMP;
+	return proc->pair_alg != BLE_SM_PAIR_ALG_JW &&
+	       proc->pair_alg != BLE_SM_PAIR_ALG_NUMCMP;
 }
 
 /**
  * Generates the Ri byte used in the confirm message.  On success, the byte is
  * written to the supplied procedure object.
  */
-static int
-ble_sm_sc_gen_ri(struct ble_sm_proc *proc)
+static int ble_sm_sc_gen_ri(struct ble_sm_proc *proc)
 {
-    int byte;
-    int bit;
+	int byte;
+	int bit;
 
-    switch (proc->pair_alg) {
-    case BLE_SM_PAIR_ALG_JW:
-    case BLE_SM_PAIR_ALG_NUMCMP:
-    case BLE_SM_PAIR_ALG_OOB:
-        proc->ri = 0;
-        return 0;
+	switch (proc->pair_alg) {
+	case BLE_SM_PAIR_ALG_JW:
+	case BLE_SM_PAIR_ALG_NUMCMP:
+	case BLE_SM_PAIR_ALG_OOB:
+		proc->ri = 0;
+		return 0;
 
-    case BLE_SM_PAIR_ALG_PASSKEY:
-        BLE_HS_DBG_ASSERT(proc->passkey_bits_exchanged <
-                          BLE_SM_SC_PASSKEY_BITS);
+	case BLE_SM_PAIR_ALG_PASSKEY:
+		BLE_HS_DBG_ASSERT(proc->passkey_bits_exchanged < BLE_SM_SC_PASSKEY_BITS);
 
-        byte = proc->passkey_bits_exchanged / 8;
-        bit = proc->passkey_bits_exchanged % 8;
-        proc->ri = 0x80 | !!(proc->tk[byte] & (1 << bit));
+		byte = proc->passkey_bits_exchanged / 8;
+		bit = proc->passkey_bits_exchanged % 8;
+		proc->ri = 0x80 | !!(proc->tk[byte] & (1 << bit));
 
-        proc->passkey_bits_exchanged++;
+		proc->passkey_bits_exchanged++;
 
-        return 0;
+		return 0;
 
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        return BLE_HS_EUNKNOWN;
-    }
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		return BLE_HS_EUNKNOWN;
+	}
 }
 
-void
-ble_sm_sc_oob_confirm(struct ble_sm_proc *proc, struct ble_sm_result *res)
+void ble_sm_sc_oob_confirm(struct ble_sm_proc *proc, struct ble_sm_result *res)
 {
-    int err;
-    bool match;
-    uint8_t c[16];
-
-    /* Authentication stage 1: Step 5 */
-    if (proc->oob_data_remote) {
-        err = ble_sm_alg_f4(proc->pub_key_peer.x, proc->pub_key_peer.x,
-                            proc->oob_data_remote->r, 0, c);
-        if (err) {
-            res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_UNSPECIFIED);
-            res->enc_cb = 1;
-            return;
-        }
-
-        match = (memcmp(c, proc->oob_data_remote->c, sizeof(c)) == 0);
-        if (!match) {
-            /* Random number mismatch. */
-            res->sm_err = BLE_SM_ERR_CONFIRM_MISMATCH;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CONFIRM_MISMATCH);
-            res->enc_cb = 1;
-            return;
-        }
-    }
-
-    if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
-        (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
-        /* If is initiator or was waiting on
-         * IO then execute step 6: send Random
-         */
-        res->execute = 1;
-    }
+	int err;
+	bool match;
+	uint8_t c[16];
+
+	/* Authentication stage 1: Step 5 */
+	if (proc->oob_data_remote) {
+		err = ble_sm_alg_f4(proc->pub_key_peer.x, proc->pub_key_peer.x,
+		                    proc->oob_data_remote->r, 0, c);
+		if (err) {
+			res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_UNSPECIFIED);
+			res->enc_cb = 1;
+			return;
+		}
+
+		match = (memcmp(c, proc->oob_data_remote->c, sizeof(c)) == 0);
+		if (!match) {
+			/* Random number mismatch. */
+			res->sm_err = BLE_SM_ERR_CONFIRM_MISMATCH;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CONFIRM_MISMATCH);
+			res->enc_cb = 1;
+			return;
+		}
+	}
+
+	if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
+	    (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
+		/* If is initiator or was waiting on
+		 * IO then execute step 6: send Random
+		 */
+		res->execute = 1;
+	}
 }
 
-void
-ble_sm_sc_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
+void ble_sm_sc_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
 {
-    struct ble_sm_pair_confirm *cmd;
-    struct os_mbuf *txom;
-    int rc;
-
-    rc = ble_sm_sc_gen_ri(proc);
-    if (rc != 0) {
-        res->app_status = rc;
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_CONFIRM, sizeof(*cmd), &txom);
-    if (cmd == NULL) {
-        rc = BLE_HS_ENOMEM;
-        res->app_status = rc;
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    rc = ble_sm_alg_f4(ble_sm_sc_pub_key, proc->pub_key_peer.x,
-                       ble_sm_our_pair_rand(proc), proc->ri, cmd->value);
-    if (rc != 0) {
-        os_mbuf_free_chain(txom);
-        res->app_status = rc;
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    rc = ble_sm_tx(proc->conn_handle, txom);
-    if (rc != 0) {
-        res->app_status = rc;
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
-        proc->state = BLE_SM_PROC_STATE_RANDOM;
-    }
+	struct ble_sm_pair_confirm *cmd;
+	struct os_mbuf *txom;
+	int rc;
+
+	rc = ble_sm_sc_gen_ri(proc);
+	if (rc != 0) {
+		res->app_status = rc;
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_CONFIRM, sizeof(*cmd), &txom);
+	if (cmd == NULL) {
+		rc = BLE_HS_ENOMEM;
+		res->app_status = rc;
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	rc = ble_sm_alg_f4(ble_sm_sc_pub_key, proc->pub_key_peer.x,
+	                   ble_sm_our_pair_rand(proc), proc->ri, cmd->value);
+	if (rc != 0) {
+		os_mbuf_free_chain(txom);
+		res->app_status = rc;
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	rc = ble_sm_tx(proc->conn_handle, txom);
+	if (rc != 0) {
+		res->app_status = rc;
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
+		proc->state = BLE_SM_PROC_STATE_RANDOM;
+	}
 }
 
-static void
-ble_sm_sc_gen_numcmp(struct ble_sm_proc *proc, struct ble_sm_result *res)
+static void ble_sm_sc_gen_numcmp(struct ble_sm_proc *proc, struct ble_sm_result *res)
 {
-    uint8_t *pka;
-    uint8_t *pkb;
-
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        pka = ble_sm_sc_pub_key;
-        pkb = proc->pub_key_peer.x;
-    } else {
-        pka = proc->pub_key_peer.x;
-        pkb = ble_sm_sc_pub_key;
-    }
-    res->app_status = ble_sm_alg_g2(pka, pkb, proc->randm, proc->rands,
-                                    &res->passkey_params.numcmp);
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-    }
+	uint8_t *pka;
+	uint8_t *pkb;
+
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		pka = ble_sm_sc_pub_key;
+		pkb = proc->pub_key_peer.x;
+	}
+	else {
+		pka = proc->pub_key_peer.x;
+		pkb = ble_sm_sc_pub_key;
+	}
+	res->app_status =
+		ble_sm_alg_g2(pka, pkb, proc->randm, proc->rands, &res->passkey_params.numcmp);
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+	}
 }
 
 /**
  * Advances the supplied procedure object to the next state after it has
  * completed the random state.
  */
-static int
-ble_sm_sc_random_advance(struct ble_sm_proc *proc)
+static int ble_sm_sc_random_advance(struct ble_sm_proc *proc)
 {
-    int rc;
-
-    if (proc->pair_alg != BLE_SM_PAIR_ALG_PASSKEY ||
-        proc->passkey_bits_exchanged >= BLE_SM_SC_PASSKEY_BITS) {
-
-        proc->state = BLE_SM_PROC_STATE_DHKEY_CHECK;
-    } else {
-        proc->state = BLE_SM_PROC_STATE_CONFIRM;
-        rc = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
-        if (rc != 0) {
-            return rc;
-        }
-    }
-
-    return 0;
+	int rc;
+
+	if (proc->pair_alg != BLE_SM_PAIR_ALG_PASSKEY ||
+	    proc->passkey_bits_exchanged >= BLE_SM_SC_PASSKEY_BITS) {
+		proc->state = BLE_SM_PROC_STATE_DHKEY_CHECK;
+	}
+	else {
+		proc->state = BLE_SM_PROC_STATE_CONFIRM;
+		rc = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
+		if (rc != 0) {
+			return rc;
+		}
+	}
+
+	return 0;
 }
 
-void
-ble_sm_sc_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
+void ble_sm_sc_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
 {
-    struct ble_sm_pair_random *cmd;
-    struct os_mbuf *txom;
-    uint8_t ioact;
-    int rc;
-
-    cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_RANDOM, sizeof(*cmd), &txom);
-    if (cmd == NULL) {
-        rc = BLE_HS_ENOMEM;
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    memcpy(cmd->value, ble_sm_our_pair_rand(proc), 16);
-
-    rc = ble_sm_tx(proc->conn_handle, txom);
-    if (rc != 0) {
-        res->app_status = rc;
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
-        rc = ble_sm_sc_random_advance(proc);
-        if (rc != 0) {
-            res->app_status = rc;
-            res->enc_cb = 1;
-            res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-            return;
-        }
-
-        rc = ble_sm_sc_io_action(proc, &ioact);
-        BLE_HS_DBG_ASSERT(rc == 0);
-
-        if (ble_sm_ioact_state(ioact) == proc->state &&
-            !(proc->flags & BLE_SM_PROC_F_IO_INJECTED)) {
-
-            res->passkey_params.action = ioact;
-            BLE_HS_DBG_ASSERT(ioact == BLE_SM_IOACT_NUMCMP);
-            ble_sm_sc_gen_numcmp(proc, res);
-        }
-    }
+	struct ble_sm_pair_random *cmd;
+	struct os_mbuf *txom;
+	uint8_t ioact;
+	int rc;
+
+	cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_RANDOM, sizeof(*cmd), &txom);
+	if (cmd == NULL) {
+		rc = BLE_HS_ENOMEM;
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	memcpy(cmd->value, ble_sm_our_pair_rand(proc), 16);
+
+	rc = ble_sm_tx(proc->conn_handle, txom);
+	if (rc != 0) {
+		res->app_status = rc;
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
+		rc = ble_sm_sc_random_advance(proc);
+		if (rc != 0) {
+			res->app_status = rc;
+			res->enc_cb = 1;
+			res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+			return;
+		}
+
+		rc = ble_sm_sc_io_action(proc, &ioact);
+		BLE_HS_DBG_ASSERT(rc == 0);
+
+		if (ble_sm_ioact_state(ioact) == proc->state &&
+		    !(proc->flags & BLE_SM_PROC_F_IO_INJECTED)) {
+			res->passkey_params.action = ioact;
+			BLE_HS_DBG_ASSERT(ioact == BLE_SM_IOACT_NUMCMP);
+			ble_sm_sc_gen_numcmp(proc, res);
+		}
+	}
 }
 
-void
-ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
+void ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
 {
-    uint8_t confirm_val[16];
-    uint8_t ia[6];
-    uint8_t ra[6];
-    uint8_t ioact;
-    uint8_t iat;
-    uint8_t rat;
-    int rc;
-
-    if (proc->pair_alg != BLE_SM_PAIR_ALG_OOB && (
-        proc->flags & BLE_SM_PROC_F_INITIATOR ||
-        ble_sm_sc_responder_verifies_random(proc))) {
-
-        BLE_HS_LOG(DEBUG, "tk=");
-        ble_hs_log_flat_buf(proc->tk, 16);
-        BLE_HS_LOG(DEBUG, "\n");
-
-        rc = ble_sm_alg_f4(proc->pub_key_peer.x, ble_sm_sc_pub_key,
-                           ble_sm_peer_pair_rand(proc), proc->ri,
-                           confirm_val);
-        if (rc != 0) {
-            res->app_status = rc;
-            res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-            res->enc_cb = 1;
-            return;
-        }
-
-        if (memcmp(proc->confirm_peer, confirm_val, 16) != 0) {
-            /* Random number mismatch. */
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CONFIRM_MISMATCH);
-            res->sm_err = BLE_SM_ERR_CONFIRM_MISMATCH;
-            res->enc_cb = 1;
-            return;
-        }
-    }
-
-    /* Calculate the mac key and ltk. */
-    ble_sm_ia_ra(proc, &iat, ia, &rat, ra);
-    rc = ble_sm_alg_f5(proc->dhkey, proc->randm, proc->rands,
-                       iat, ia, rat, ra, proc->mackey, proc->ltk);
-    if (rc != 0) {
-        res->app_status = rc;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
-
-    /* Ensure proper key size */
-    memset(proc->ltk + proc->key_size, 0, sizeof proc->ltk - proc->key_size);
-
-    /* Ensure the ltk gets persisted when the pairing procedure succeeds. */
-    memcpy(proc->our_keys.ltk, proc->ltk, sizeof proc->our_keys.ltk);
-    proc->our_keys.ltk_valid = 1;
-    proc->our_keys.ediv = 0;
-    proc->our_keys.rand_val = 0;
-    proc->our_keys.ediv_rand_valid = 1;
-    proc->our_keys.key_size = proc->key_size;
-
-    memcpy(proc->peer_keys.ltk, proc->ltk, sizeof proc->peer_keys.ltk);
-    proc->peer_keys.ltk_valid = 1;
-    proc->peer_keys.ediv = 0;
-    proc->peer_keys.rand_val = 0;
-    proc->peer_keys.ediv_rand_valid = 1;
-    proc->peer_keys.key_size = proc->key_size;
-
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        ble_sm_sc_random_advance(proc);
-
-        rc = ble_sm_sc_io_action(proc, &ioact);
-        if (rc != 0) {
-            BLE_HS_DBG_ASSERT(0);
-        }
-
-        if (ble_sm_ioact_state(ioact) == proc->state &&
-            !(proc->flags & BLE_SM_PROC_F_IO_INJECTED)) {
-
-            res->passkey_params.action = ioact;
-            BLE_HS_DBG_ASSERT(ioact == BLE_SM_IOACT_NUMCMP);
-            ble_sm_sc_gen_numcmp(proc, res);
-        } else {
-            res->execute = 1;
-        }
-    } else {
-        if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB &&
-            !(proc->flags & BLE_SM_PROC_F_IO_INJECTED)) {
-            proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
-        } else {
-            res->execute = 1;
-        }
-    }
+	uint8_t confirm_val[16];
+	uint8_t ia[6];
+	uint8_t ra[6];
+	uint8_t ioact;
+	uint8_t iat;
+	uint8_t rat;
+	int rc;
+
+	if (proc->pair_alg != BLE_SM_PAIR_ALG_OOB &&
+	    (proc->flags & BLE_SM_PROC_F_INITIATOR ||
+	     ble_sm_sc_responder_verifies_random(proc))) {
+		BLE_HS_LOG(DEBUG, "tk=");
+		ble_hs_log_flat_buf(proc->tk, 16);
+		BLE_HS_LOG(DEBUG, "\n");
+
+		rc = ble_sm_alg_f4(proc->pub_key_peer.x, ble_sm_sc_pub_key,
+		                   ble_sm_peer_pair_rand(proc), proc->ri, confirm_val);
+		if (rc != 0) {
+			res->app_status = rc;
+			res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+			res->enc_cb = 1;
+			return;
+		}
+
+		if (memcmp(proc->confirm_peer, confirm_val, 16) != 0) {
+			/* Random number mismatch. */
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CONFIRM_MISMATCH);
+			res->sm_err = BLE_SM_ERR_CONFIRM_MISMATCH;
+			res->enc_cb = 1;
+			return;
+		}
+	}
+
+	/* Calculate the mac key and ltk. */
+	ble_sm_ia_ra(proc, &iat, ia, &rat, ra);
+	rc = ble_sm_alg_f5(proc->dhkey, proc->randm, proc->rands, iat, ia, rat, ra,
+	                   proc->mackey, proc->ltk);
+	if (rc != 0) {
+		res->app_status = rc;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
+
+	/* Ensure proper key size */
+	memset(proc->ltk + proc->key_size, 0, sizeof proc->ltk - proc->key_size);
+
+	/* Ensure the ltk gets persisted when the pairing procedure succeeds. */
+	memcpy(proc->our_keys.ltk, proc->ltk, sizeof proc->our_keys.ltk);
+	proc->our_keys.ltk_valid = 1;
+	proc->our_keys.ediv = 0;
+	proc->our_keys.rand_val = 0;
+	proc->our_keys.ediv_rand_valid = 1;
+	proc->our_keys.key_size = proc->key_size;
+
+	memcpy(proc->peer_keys.ltk, proc->ltk, sizeof proc->peer_keys.ltk);
+	proc->peer_keys.ltk_valid = 1;
+	proc->peer_keys.ediv = 0;
+	proc->peer_keys.rand_val = 0;
+	proc->peer_keys.ediv_rand_valid = 1;
+	proc->peer_keys.key_size = proc->key_size;
+
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		ble_sm_sc_random_advance(proc);
+
+		rc = ble_sm_sc_io_action(proc, &ioact);
+		if (rc != 0) {
+			BLE_HS_DBG_ASSERT(0);
+		}
+
+		if (ble_sm_ioact_state(ioact) == proc->state &&
+		    !(proc->flags & BLE_SM_PROC_F_IO_INJECTED)) {
+			res->passkey_params.action = ioact;
+			BLE_HS_DBG_ASSERT(ioact == BLE_SM_IOACT_NUMCMP);
+			ble_sm_sc_gen_numcmp(proc, res);
+		}
+		else {
+			res->execute = 1;
+		}
+	}
+	else {
+		if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB &&
+		    !(proc->flags & BLE_SM_PROC_F_IO_INJECTED)) {
+			proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
+		}
+		else {
+			res->execute = 1;
+		}
+	}
 }
 
-void
-ble_sm_sc_public_key_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                          void *arg)
+void ble_sm_sc_public_key_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                               void *arg)
 {
-    struct ble_sm_public_key *cmd;
-    struct os_mbuf *txom;
-    uint8_t ioact;
-    int rc;
-
-    res->app_status = ble_sm_sc_ensure_keys_generated();
-    if (res->app_status != 0) {
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_PUBLIC_KEY, sizeof(*cmd), &txom);
-    if (!cmd) {
-        res->app_status = BLE_HS_ENOMEM;
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    memcpy(cmd->x, ble_sm_sc_pub_key + 0, 32);
-    memcpy(cmd->y, ble_sm_sc_pub_key + 32, 32);
-
-    res->app_status = ble_sm_tx(proc->conn_handle, txom);
-    if (res->app_status != 0) {
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
-        if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
-            proc->state = BLE_SM_PROC_STATE_RANDOM;
-        } else {
-            proc->state = BLE_SM_PROC_STATE_CONFIRM;
-        }
-
-        rc = ble_sm_sc_io_action(proc, &ioact);
-        if (rc != 0) {
-            BLE_HS_DBG_ASSERT(0);
-        }
-
-        if (ble_sm_ioact_state(ioact) == proc->state) {
-            res->passkey_params.action = ioact;
-        }
-
-        if (ble_sm_proc_can_advance(proc) &&
-            !ble_sm_sc_initiator_txes_confirm(proc)) {
-
-            res->execute = 1;
-        }
-    }
+	struct ble_sm_public_key *cmd;
+	struct os_mbuf *txom;
+	uint8_t ioact;
+	int rc;
+
+	res->app_status = ble_sm_sc_ensure_keys_generated();
+	if (res->app_status != 0) {
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_PUBLIC_KEY, sizeof(*cmd), &txom);
+	if (!cmd) {
+		res->app_status = BLE_HS_ENOMEM;
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	memcpy(cmd->x, ble_sm_sc_pub_key + 0, 32);
+	memcpy(cmd->y, ble_sm_sc_pub_key + 32, 32);
+
+	res->app_status = ble_sm_tx(proc->conn_handle, txom);
+	if (res->app_status != 0) {
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
+		if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
+			proc->state = BLE_SM_PROC_STATE_RANDOM;
+		}
+		else {
+			proc->state = BLE_SM_PROC_STATE_CONFIRM;
+		}
+
+		rc = ble_sm_sc_io_action(proc, &ioact);
+		if (rc != 0) {
+			BLE_HS_DBG_ASSERT(0);
+		}
+
+		if (ble_sm_ioact_state(ioact) == proc->state) {
+			res->passkey_params.action = ioact;
+		}
+
+		if (ble_sm_proc_can_advance(proc) && !ble_sm_sc_initiator_txes_confirm(proc)) {
+			res->execute = 1;
+		}
+	}
 }
 
-void
-ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **om,
-                        struct ble_sm_result *res)
+void ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **om,
+                             struct ble_sm_result *res)
 {
-    struct ble_sm_public_key *cmd;
-    struct ble_sm_proc *proc;
-    uint8_t ioact;
-    int rc;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->enc_cb = 1;
-        return;
-    }
-
-    res->app_status = ble_sm_sc_ensure_keys_generated();
-    if (res->app_status != 0) {
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    cmd = (struct ble_sm_public_key *)(*om)->om_data;
-    /* Check if the peer public key is same as our generated public key.
-     * Return fail if the public keys match. */
-    if (memcmp(cmd, ble_sm_sc_pub_key, 64) == 0) {
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_AUTHREQ;
-        return;
-    }
-
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PUBLIC_KEY, -1,
-                            NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        memcpy(&proc->pub_key_peer, cmd, sizeof(*cmd));
-        rc = ble_sm_alg_gen_dhkey(proc->pub_key_peer.x,
-                                  proc->pub_key_peer.y,
-                                  ble_sm_sc_priv_key,
-                                  proc->dhkey);
-        if (rc != 0) {
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_DHKEY);
-            res->sm_err = BLE_SM_ERR_DHKEY;
-            res->enc_cb = 1;
-        } else {
-            if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-                if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
-                    proc->state = BLE_SM_PROC_STATE_RANDOM;
-                } else {
-                    proc->state = BLE_SM_PROC_STATE_CONFIRM;
-                }
-
-                rc = ble_sm_sc_io_action(proc, &ioact);
-                if (rc != 0) {
-                        BLE_HS_DBG_ASSERT(0);
-                }
-
-                if (ble_sm_ioact_state(ioact) == proc->state) {
-                    res->passkey_params.action = ioact;
-                }
-
-                if (ble_sm_proc_can_advance(proc) &&
-                    ble_sm_sc_initiator_txes_confirm(proc)) {
-
-                    res->execute = 1;
-                }
-            } else {
-                res->execute = 1;
-            }
-        }
-    }
-    ble_hs_unlock();
+	struct ble_sm_public_key *cmd;
+	struct ble_sm_proc *proc;
+	uint8_t ioact;
+	int rc;
+
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->enc_cb = 1;
+		return;
+	}
+
+	res->app_status = ble_sm_sc_ensure_keys_generated();
+	if (res->app_status != 0) {
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	cmd = (struct ble_sm_public_key *) (*om)->om_data;
+	/* Check if the peer public key is same as our generated public key.
+	 * Return fail if the public keys match. */
+	if (memcmp(cmd, ble_sm_sc_pub_key, 64) == 0) {
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_AUTHREQ;
+		return;
+	}
+
+
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PUBLIC_KEY, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		memcpy(&proc->pub_key_peer, cmd, sizeof(*cmd));
+		rc = ble_sm_alg_gen_dhkey(proc->pub_key_peer.x, proc->pub_key_peer.y,
+		                          ble_sm_sc_priv_key, proc->dhkey);
+		if (rc != 0) {
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_DHKEY);
+			res->sm_err = BLE_SM_ERR_DHKEY;
+			res->enc_cb = 1;
+		}
+		else {
+			if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+				if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
+					proc->state = BLE_SM_PROC_STATE_RANDOM;
+				}
+				else {
+					proc->state = BLE_SM_PROC_STATE_CONFIRM;
+				}
+
+				rc = ble_sm_sc_io_action(proc, &ioact);
+				if (rc != 0) {
+					BLE_HS_DBG_ASSERT(0);
+				}
+
+				if (ble_sm_ioact_state(ioact) == proc->state) {
+					res->passkey_params.action = ioact;
+				}
+
+				if (ble_sm_proc_can_advance(proc) && ble_sm_sc_initiator_txes_confirm(proc)) {
+					res->execute = 1;
+				}
+			}
+			else {
+				res->execute = 1;
+			}
+		}
+	}
+	ble_hs_unlock();
 }
 
-static void
-ble_sm_sc_dhkey_addrs(struct ble_sm_proc *proc, ble_addr_t *our_addr,
-                      ble_addr_t *peer_addr)
+static void ble_sm_sc_dhkey_addrs(struct ble_sm_proc *proc, ble_addr_t *our_addr,
+                                  ble_addr_t *peer_addr)
 {
-    struct ble_hs_conn_addrs addrs;
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn_addrs addrs;
+	struct ble_hs_conn *conn;
 
-    conn = ble_hs_conn_find_assert(proc->conn_handle);
+	conn = ble_hs_conn_find_assert(proc->conn_handle);
 
-    ble_hs_conn_addrs(conn, &addrs);
+	ble_hs_conn_addrs(conn, &addrs);
 
-    *our_addr = addrs.our_ota_addr;
-    *peer_addr = addrs.peer_ota_addr;
+	*our_addr = addrs.our_ota_addr;
+	*peer_addr = addrs.peer_ota_addr;
 }
 
-void
-ble_sm_sc_dhkey_check_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                           void *arg)
+void ble_sm_sc_dhkey_check_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                                void *arg)
 {
-    struct ble_sm_dhkey_check *cmd;
-    ble_addr_t our_addr;
-    ble_addr_t peer_addr;
-    struct os_mbuf *txom;
-    uint8_t *iocap;
-    int rc;
-
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        struct ble_sm_pair_cmd *pair_req;
-
-        pair_req  = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-        iocap = &pair_req->io_cap;
-    } else {
-        struct ble_sm_pair_cmd *pair_rsp;
-
-        pair_rsp  = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
-        iocap = &pair_rsp->io_cap;
-    }
-
-    if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
-        if (proc->oob_data_remote) {
-            memcpy(proc->tk, proc->oob_data_remote->r, 16);
-        } else {
-            memset(proc->tk, 0, 16);
-        }
-    }
-
-    ble_sm_sc_dhkey_addrs(proc, &our_addr, &peer_addr);
-
-    cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_DHKEY_CHECK, sizeof(*cmd), &txom);
-    if (!cmd) {
-        rc = BLE_HS_ENOMEM;
-        goto err;
-    }
-
-    rc = ble_sm_alg_f6(proc->mackey, ble_sm_our_pair_rand(proc),
-                       ble_sm_peer_pair_rand(proc), proc->tk, iocap,
-                       our_addr.type, our_addr.val, peer_addr.type,
-                       peer_addr.val, cmd->value);
-    if (rc != 0) {
-        os_mbuf_free_chain(txom);
-        goto err;
-    }
-
-    rc = ble_sm_tx(proc->conn_handle, txom);
-    if (rc != 0) {
-        goto err;
-    }
-
-    if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
-        proc->state = BLE_SM_PROC_STATE_LTK_START;
-    }
-
-    return;
+	struct ble_sm_dhkey_check *cmd;
+	ble_addr_t our_addr;
+	ble_addr_t peer_addr;
+	struct os_mbuf *txom;
+	uint8_t *iocap;
+	int rc;
+
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		struct ble_sm_pair_cmd *pair_req;
+
+		pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+		iocap = &pair_req->io_cap;
+	}
+	else {
+		struct ble_sm_pair_cmd *pair_rsp;
+
+		pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+		iocap = &pair_rsp->io_cap;
+	}
+
+	if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
+		if (proc->oob_data_remote) {
+			memcpy(proc->tk, proc->oob_data_remote->r, 16);
+		}
+		else {
+			memset(proc->tk, 0, 16);
+		}
+	}
+
+	ble_sm_sc_dhkey_addrs(proc, &our_addr, &peer_addr);
+
+	cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_DHKEY_CHECK, sizeof(*cmd), &txom);
+	if (!cmd) {
+		rc = BLE_HS_ENOMEM;
+		goto err;
+	}
+
+
+
+	rc = ble_sm_alg_f6(proc->mackey, ble_sm_our_pair_rand(proc),
+	                   ble_sm_peer_pair_rand(proc), proc->tk, iocap, our_addr.type,
+	                   our_addr.val, peer_addr.type, peer_addr.val, cmd->value);
+	if (rc != 0) {
+		os_mbuf_free_chain(txom);
+		goto err;
+	}
+
+	rc = ble_sm_tx(proc->conn_handle, txom);
+	if (rc != 0) {
+		goto err;
+	}
+
+	if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
+		proc->state = BLE_SM_PROC_STATE_LTK_START;
+	}
+
+	return;
 
 err:
-    res->app_status = rc;
-    res->enc_cb = 1;
-    res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	res->app_status = rc;
+	res->enc_cb = 1;
+	res->sm_err = BLE_SM_ERR_UNSPECIFIED;
 }
 
-static void
-ble_sm_dhkey_check_process(struct ble_sm_proc *proc,
-                           struct ble_sm_dhkey_check *cmd,
-                           struct ble_sm_result *res)
+static void ble_sm_dhkey_check_process(struct ble_sm_proc *proc,
+                                       struct ble_sm_dhkey_check *cmd,
+                                       struct ble_sm_result *res)
 {
-    uint8_t exp_value[16];
-    ble_addr_t our_addr;
-    ble_addr_t peer_addr;
-    uint8_t *iocap;
-    uint8_t ioact;
-    int rc;
-
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        struct ble_sm_pair_cmd *pair_rsp;
-
-        pair_rsp  = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
-        iocap = &pair_rsp->io_cap;
-
-        if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
-            if (pair_rsp->oob_data_flag) {
-                memcpy(proc->tk, proc->oob_data_local->r, 16);
-            } else {
-                memset(proc->tk, 0, 16);
-            }
-        }
-    } else {
-        struct ble_sm_pair_cmd *pair_req;
-
-        pair_req  = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-        iocap = &pair_req->io_cap;
-
-        if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
-            if (pair_req->oob_data_flag) {
-                memcpy(proc->tk, proc->oob_data_local->r, 16);
-            } else {
-                memset(proc->tk, 0, 16);
-            }
-        }
-    }
-
-    ble_sm_sc_dhkey_addrs(proc, &our_addr, &peer_addr);
-    BLE_HS_LOG(DEBUG, "tk=");
-    ble_hs_log_flat_buf(proc->tk, 16);
-    BLE_HS_LOG(DEBUG, "\n");
-
-    res->app_status = ble_sm_alg_f6(proc->mackey,
-                                    ble_sm_peer_pair_rand(proc),
-                                    ble_sm_our_pair_rand(proc),
-                                    proc->tk, iocap,
-                                    peer_addr.type, peer_addr.val,
-                                    our_addr.type, our_addr.val,
-                                    exp_value);
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
-
-    if (memcmp(cmd->value, exp_value, 16) != 0) {
-        /* Random number mismatch. */
-        res->sm_err = BLE_SM_ERR_DHKEY;
-        res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_DHKEY);
-        res->enc_cb = 1;
-        return;
-    }
-
-    rc = ble_sm_sc_io_action(proc, &ioact);
-    if (rc != 0) {
-        BLE_HS_DBG_ASSERT(0);
-    }
-
-    if (ble_sm_ioact_state(ioact) == proc->state) {
-        proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
-    }
-
-    if (ble_sm_proc_can_advance(proc)) {
-        if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-            proc->state = BLE_SM_PROC_STATE_ENC_START;
-        }
-
-        res->execute = 1;
-    }
+	uint8_t exp_value[16];
+	ble_addr_t our_addr;
+	ble_addr_t peer_addr;
+	uint8_t *iocap;
+	uint8_t ioact;
+	int rc;
+
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		struct ble_sm_pair_cmd *pair_rsp;
+
+		pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+		iocap = &pair_rsp->io_cap;
+
+		if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
+			if (pair_rsp->oob_data_flag) {
+				memcpy(proc->tk, proc->oob_data_local->r, 16);
+			}
+			else {
+				memset(proc->tk, 0, 16);
+			}
+		}
+	}
+	else {
+		struct ble_sm_pair_cmd *pair_req;
+
+		pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+		iocap = &pair_req->io_cap;
+
+		if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
+			if (pair_req->oob_data_flag) {
+				memcpy(proc->tk, proc->oob_data_local->r, 16);
+			}
+			else {
+				memset(proc->tk, 0, 16);
+			}
+		}
+	}
+
+
+	ble_sm_sc_dhkey_addrs(proc, &our_addr, &peer_addr);
+
+	BLE_HS_LOG(DEBUG, "tk=");
+	ble_hs_log_flat_buf(proc->tk, 16);
+	BLE_HS_LOG(DEBUG, "\n");
+
+	res->app_status = ble_sm_alg_f6(
+		proc->mackey, ble_sm_peer_pair_rand(proc), ble_sm_our_pair_rand(proc), proc->tk,
+		iocap, peer_addr.type, peer_addr.val, our_addr.type, our_addr.val, exp_value);
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
+
+	if (memcmp(cmd->value, exp_value, 16) != 0) {
+		/* Random number mismatch. */
+		res->sm_err = BLE_SM_ERR_DHKEY;
+		res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_DHKEY);
+		res->enc_cb = 1;
+		return;
+	}
+
+	rc = ble_sm_sc_io_action(proc, &ioact);
+	if (rc != 0) {
+		BLE_HS_DBG_ASSERT(0);
+	}
+
+	if (ble_sm_ioact_state(ioact) == proc->state) {
+		proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
+	}
+
+	if (ble_sm_proc_can_advance(proc)) {
+		if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+			proc->state = BLE_SM_PROC_STATE_ENC_START;
+		}
+
+		res->execute = 1;
+	}
 }
 
-void
-ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf **om,
-                         struct ble_sm_result *res)
+void ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf **om,
+                              struct ble_sm_result *res)
 {
-    struct ble_sm_dhkey_check *cmd;
-    struct ble_sm_proc *proc;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
-
-    cmd = (struct ble_sm_dhkey_check *)(*om)->om_data;
-
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_DHKEY_CHECK, -1,
-                            NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-    } else {
-        ble_sm_dhkey_check_process(proc, cmd, res);
-    }
-    ble_hs_unlock();
+	struct ble_sm_dhkey_check *cmd;
+	struct ble_sm_proc *proc;
+
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->enc_cb = 1;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		return;
+	}
+
+	cmd = (struct ble_sm_dhkey_check *) (*om)->om_data;
+
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_DHKEY_CHECK, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+	}
+	else {
+		ble_sm_dhkey_check_process(proc, cmd, res);
+	}
+	ble_hs_unlock();
 }
 
-bool
-ble_sm_sc_oob_data_check(struct ble_sm_proc *proc,
-                         bool oob_data_local_present,
-                         bool oob_data_remote_present)
+bool ble_sm_sc_oob_data_check(struct ble_sm_proc *proc, bool oob_data_local_present,
+                              bool oob_data_remote_present)
 {
-    struct ble_sm_pair_cmd *pair_req;
-    struct ble_sm_pair_cmd *pair_rsp;
-    bool req_oob_present;
-    bool rsp_oob_present;
-
-    pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
-    req_oob_present = pair_req->oob_data_flag == BLE_SM_PAIR_OOB_YES;
-    rsp_oob_present = pair_rsp->oob_data_flag == BLE_SM_PAIR_OOB_YES;
-
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        return req_oob_present == oob_data_remote_present;
-    } else {
-        return rsp_oob_present == oob_data_remote_present;
-    }
+	struct ble_sm_pair_cmd *pair_req;
+	struct ble_sm_pair_cmd *pair_rsp;
+	bool req_oob_present;
+	bool rsp_oob_present;
+
+	pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+	pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+	req_oob_present = pair_req->oob_data_flag == BLE_SM_PAIR_OOB_YES;
+	rsp_oob_present = pair_rsp->oob_data_flag == BLE_SM_PAIR_OOB_YES;
+
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		return req_oob_present == oob_data_remote_present;
+	}
+	else {
+		return rsp_oob_present == oob_data_remote_present;
+	}
 }
 
-int
-ble_sm_sc_oob_generate_data(struct ble_sm_sc_oob_data *oob_data)
+int ble_sm_sc_oob_generate_data(struct ble_sm_sc_oob_data *oob_data)
 {
-    int rc;
+	int rc;
 
 #if !MYNEWT_VAL(BLE_SM_SC)
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 
-    rc = ble_sm_sc_ensure_keys_generated();
-    if (rc) {
-        return rc;
-    }
+	rc = ble_sm_sc_ensure_keys_generated();
+	if (rc) {
+		return rc;
+	}
 
-    rc = ble_hs_hci_rand(oob_data->r, 16);
-    if (rc) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(oob_data->r, 16);
+	if (rc) {
+		return rc;
+	}
 
-    rc = ble_sm_alg_f4(ble_sm_sc_pub_key, ble_sm_sc_pub_key, oob_data->r, 0,
-                       oob_data->c);
-    if (rc) {
-        return rc;
-    }
+	rc = ble_sm_alg_f4(ble_sm_sc_pub_key, ble_sm_sc_pub_key, oob_data->r, 0, oob_data->c);
+	if (rc) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-void
-ble_sm_sc_init(void)
+void ble_sm_sc_init(void)
 {
-    ble_sm_alg_ecc_init();
-    ble_sm_sc_keys_generated = 0;
+	ble_sm_alg_ecc_init();
+	ble_sm_sc_keys_generated = 0;
 }
 
-#endif  /* MYNEWT_VAL(BLE_SM_SC) */
+#endif /* MYNEWT_VAL(BLE_SM_SC) */
 #endif
diff --git a/nimble/include/nimble/hci_common.h b/nimble/include/nimble/hci_common.h
index fb74c24a..63faf446 100644
--- a/nimble/include/nimble/hci_common.h
+++ b/nimble/include/nimble/hci_common.h
@@ -27,1244 +27,1259 @@
 extern "C" {
 #endif
 
-#define BLE_HCI_MAX_DATA_LEN    (MYNEWT_VAL(BLE_TRANSPORT_EVT_SIZE) - \
-                                 sizeof(struct ble_hci_ev))
+#define BLE_HCI_MAX_DATA_LEN \
+	(MYNEWT_VAL(BLE_TRANSPORT_EVT_SIZE) - sizeof(struct ble_hci_ev))
 
 /* Generic command header */
 struct ble_hci_cmd {
-    uint16_t opcode;
-    uint8_t  length;
-    uint8_t  data[0];
+	uint16_t opcode;
+	uint8_t length;
+	uint8_t data[0];
 } __attribute__((packed));
 
 /* Generic event header */
 struct ble_hci_ev {
-    uint8_t opcode;
-    uint8_t length;
-    uint8_t  data[0];
+	uint8_t opcode;
+	uint8_t length;
+	uint8_t data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OPCODE_NOP                  (0)
+#define BLE_HCI_OPCODE_NOP (0)
 
 /* Set opcode based on OCF and OGF */
-#define BLE_HCI_OP(ogf, ocf)            ((ocf) | ((ogf) << 10))
+#define BLE_HCI_OP(ogf, ocf) ((ocf) | ((ogf) << 10))
 
 /* Get the OGF and OCF from the opcode in the command */
-#define BLE_HCI_OGF(opcode)                 (((opcode) >> 10) & 0x003F)
-#define BLE_HCI_OCF(opcode)                 ((opcode) & 0x03FF)
+#define BLE_HCI_OGF(opcode) (((opcode) >> 10) & 0x003F)
+#define BLE_HCI_OCF(opcode) ((opcode) & 0x03FF)
 
 /* Opcode Group definitions (note: 0x07 not defined in spec) */
-#define BLE_HCI_OGF_LINK_CTRL               (0x01)
-#define BLE_HCI_OGF_LINK_POLICY             (0x02)
-#define BLE_HCI_OGF_CTLR_BASEBAND           (0x03)
-#define BLE_HCI_OGF_INFO_PARAMS             (0x04)
-#define BLE_HCI_OGF_STATUS_PARAMS           (0x05)
-#define BLE_HCI_OGF_TESTING                 (0x06)
-#define BLE_HCI_OGF_LE                      (0x08)
-#define BLE_HCI_OGF_VENDOR                  (0x3F)
+#define BLE_HCI_OGF_LINK_CTRL (0x01)
+#define BLE_HCI_OGF_LINK_POLICY (0x02)
+#define BLE_HCI_OGF_CTLR_BASEBAND (0x03)
+#define BLE_HCI_OGF_INFO_PARAMS (0x04)
+#define BLE_HCI_OGF_STATUS_PARAMS (0x05)
+#define BLE_HCI_OGF_TESTING (0x06)
+#define BLE_HCI_OGF_LE (0x08)
+#define BLE_HCI_OGF_VENDOR (0x3F)
 
 /*
  * Number of LE commands. NOTE: this is really just used to size the array
  * containing the lengths of the LE commands.
  */
-#define BLE_HCI_NUM_LE_CMDS                 (79)
+#define BLE_HCI_NUM_LE_CMDS (79)
 
 /* List of OCF for Link Control commands (OGF=0x01) */
-#define BLE_HCI_OCF_DISCONNECT_CMD          (0x0006)
+#define BLE_HCI_OCF_DISCONNECT_CMD (0x0006)
 struct ble_hci_lc_disconnect_cp {
-    uint16_t conn_handle;
-    uint8_t  reason;
+	uint16_t conn_handle;
+	uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_RD_REM_VER_INFO         (0x001D)
+#define BLE_HCI_OCF_RD_REM_VER_INFO (0x001D)
 struct ble_hci_rd_rem_ver_info_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
 /* List of OCF for Controller and Baseband commands (OGF=0x03) */
-#define BLE_HCI_OCF_CB_SET_EVENT_MASK       (0x0001)
+#define BLE_HCI_OCF_CB_SET_EVENT_MASK (0x0001)
 struct ble_hci_cb_set_event_mask_cp {
-    uint64_t event_mask;
+	uint64_t event_mask;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_RESET                (0x0003)
+#define BLE_HCI_OCF_CB_RESET (0x0003)
 
-#define BLE_HCI_OCF_CB_READ_TX_PWR          (0x002D)
+#define BLE_HCI_OCF_CB_READ_TX_PWR (0x002D)
 struct ble_hci_cb_read_tx_pwr_cp {
-    uint16_t conn_handle;
-    uint8_t  type;
+	uint16_t conn_handle;
+	uint8_t type;
 } __attribute__((packed));
 
 struct ble_hci_cb_read_tx_pwr_rp {
-    uint16_t conn_handle;
-    int8_t   tx_level;
+	uint16_t conn_handle;
+	int8_t tx_level;
 } __attribute__((packed));
 
 
-#define BLE_HCI_OCF_CB_SET_CTLR_TO_HOST_FC  (0x0031)
+#define BLE_HCI_OCF_CB_SET_CTLR_TO_HOST_FC (0x0031)
 struct ble_hci_cb_ctlr_to_host_fc_cp {
-    uint8_t enable;
+	uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_HOST_BUF_SIZE        (0x0033)
+#define BLE_HCI_OCF_CB_HOST_BUF_SIZE (0x0033)
 struct ble_hci_cb_host_buf_size_cp {
-    uint16_t acl_data_len;
-    uint8_t  sco_data_len;
-    uint16_t acl_num;
-    uint16_t sco_num;
+	uint16_t acl_data_len;
+	uint8_t sco_data_len;
+	uint16_t acl_num;
+	uint16_t sco_num;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_HOST_NUM_COMP_PKTS   (0x0035)
-struct  ble_hci_cb_host_num_comp_pkts_entry {
-    uint16_t handle;
-    uint16_t count;
+#define BLE_HCI_OCF_CB_HOST_NUM_COMP_PKTS (0x0035)
+struct ble_hci_cb_host_num_comp_pkts_entry {
+	uint16_t handle;
+	uint16_t count;
 } __attribute__((packed));
 struct ble_hci_cb_host_num_comp_pkts_cp {
-    uint8_t handles;
-    struct ble_hci_cb_host_num_comp_pkts_entry h[0];
+	uint8_t handles;
+	struct ble_hci_cb_host_num_comp_pkts_entry h[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_SET_EVENT_MASK2      (0x0063)
+#define BLE_HCI_OCF_CB_SET_EVENT_MASK2 (0x0063)
 struct ble_hci_cb_set_event_mask2_cp {
-    uint64_t event_mask2;
+	uint64_t event_mask2;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_RD_AUTH_PYLD_TMO     (0x007B)
+#define BLE_HCI_OCF_CB_RD_AUTH_PYLD_TMO (0x007B)
 struct ble_hci_cb_rd_auth_pyld_tmo_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_cb_rd_auth_pyld_tmo_rp {
-    uint16_t conn_handle;
-    uint16_t tmo;
+	uint16_t conn_handle;
+	uint16_t tmo;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_WR_AUTH_PYLD_TMO     (0x007C)
+#define BLE_HCI_OCF_CB_WR_AUTH_PYLD_TMO (0x007C)
 struct ble_hci_cb_wr_auth_pyld_tmo_cp {
-    uint16_t conn_handle;
-    uint16_t tmo;
+	uint16_t conn_handle;
+	uint16_t tmo;
 } __attribute__((packed));
 struct ble_hci_cb_wr_auth_pyld_tmo_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
 /* List of OCF for Info Param commands (OGF=0x04) */
-#define BLE_HCI_OCF_IP_RD_LOCAL_VER         (0x0001)
+#define BLE_HCI_OCF_IP_RD_LOCAL_VER (0x0001)
 struct ble_hci_ip_rd_local_ver_rp {
-    uint8_t  hci_ver;
-    uint16_t hci_rev;
-    uint8_t  lmp_ver;
-    uint16_t manufacturer;
-    uint16_t lmp_subver;
+	uint8_t hci_ver;
+	uint16_t hci_rev;
+	uint8_t lmp_ver;
+	uint16_t manufacturer;
+	uint16_t lmp_subver;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD      (0x0002)
+#define BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD (0x0002)
 struct ble_hci_ip_rd_loc_supp_cmd_rp {
-    uint8_t commands[64];
+	uint8_t commands[64];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT     (0x0003)
+#define BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT (0x0003)
 struct ble_hci_ip_rd_loc_supp_feat_rp {
-    uint64_t features;
+	uint64_t features;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_IP_RD_BUF_SIZE          (0x0005)
+#define BLE_HCI_OCF_IP_RD_BUF_SIZE (0x0005)
 struct ble_hci_ip_rd_buf_size_rp {
-    uint16_t acl_data_len;
-    uint8_t  sco_data_len;
-    uint16_t acl_num;
-    uint16_t sco_num;
+	uint16_t acl_data_len;
+	uint8_t sco_data_len;
+	uint16_t acl_num;
+	uint16_t sco_num;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_IP_RD_BD_ADDR           (0x0009)
+#define BLE_HCI_OCF_IP_RD_BD_ADDR (0x0009)
 struct ble_hci_ip_rd_bd_addr_rp {
-    uint8_t addr[6];
+	uint8_t addr[6];
 } __attribute__((packed));
 
 /* List of OCF for Status parameters commands (OGF = 0x05) */
-#define BLE_HCI_OCF_RD_RSSI                 (0x0005)
+#define BLE_HCI_OCF_RD_RSSI (0x0005)
 struct ble_hci_rd_rssi_cp {
-    uint16_t handle;
+	uint16_t handle;
 } __attribute__((packed));
 struct ble_hci_rd_rssi_rp {
-    uint16_t handle;
-    int8_t   rssi;
+	uint16_t handle;
+	int8_t rssi;
 } __attribute__((packed));
 
 /* List of OCF for LE commands (OGF = 0x08) */
-#define BLE_HCI_OCF_LE_SET_EVENT_MASK               (0x0001)
+#define BLE_HCI_OCF_LE_SET_EVENT_MASK (0x0001)
 struct ble_hci_le_set_event_mask_cp {
-    uint64_t event_mask;
+	uint64_t event_mask;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_BUF_SIZE                  (0x0002)
+#define BLE_HCI_OCF_LE_RD_BUF_SIZE (0x0002)
 struct ble_hci_le_rd_buf_size_rp {
-    uint16_t data_len;
-    uint8_t  data_packets;
+	uint16_t data_len;
+	uint8_t data_packets;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_BUF_SIZE_V2                    (0x0060)
+#define BLE_HCI_OCF_LE_RD_BUF_SIZE_V2 (0x0060)
 struct ble_hci_le_rd_buf_size_v2_rp {
-    uint16_t data_len;
-    uint8_t  data_packets;
-    uint16_t iso_data_len;
-    uint8_t  iso_data_packets;
+	uint16_t data_len;
+	uint8_t data_packets;
+	uint16_t iso_data_len;
+	uint8_t iso_data_packets;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_LOC_SUPP_FEAT             (0x0003)
+#define BLE_HCI_OCF_LE_RD_LOC_SUPP_FEAT (0x0003)
 struct ble_hci_le_rd_loc_supp_feat_rp {
-    uint64_t features;
+	uint64_t features;
 } __attribute__((packed));
 
+// Custom address spoofing for controller
+#define BLE_HCI_OCF_LE_SET_PUB_ADDR (0x0004)
+struct ble_hci_le_set_pub_addr_cp {
+	uint8_t addr[6];
+} __attribute__((packed));
+
+
 /* NOTE: 0x0004 is intentionally left undefined */
-#define BLE_HCI_OCF_LE_SET_RAND_ADDR                (0x0005)
+#define BLE_HCI_OCF_LE_SET_RAND_ADDR (0x0005)
 struct ble_hci_le_set_rand_addr_cp {
-    uint8_t addr[6];
+	uint8_t addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_ADV_PARAMS               (0x0006)
+#define BLE_HCI_OCF_LE_SET_ADV_PARAMS (0x0006)
 struct ble_hci_le_set_adv_params_cp {
-    uint16_t min_interval;
-    uint16_t max_interval;
-    uint8_t type;
-    uint8_t own_addr_type;
-    uint8_t peer_addr_type;
-    uint8_t peer_addr[6];
-    uint8_t chan_map;
-    uint8_t filter_policy;
+	uint16_t min_interval;
+	uint16_t max_interval;
+	uint8_t type;
+	uint8_t own_addr_type;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint8_t chan_map;
+	uint8_t filter_policy;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR            (0x0007)
+#define BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR (0x0007)
 struct ble_hci_le_rd_adv_chan_txpwr_rp {
-    int8_t power_level;
+	int8_t power_level;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_ADV_DATA                 (0x0008)
-#define BLE_HCI_MAX_ADV_DATA_LEN                    (31)
+#define BLE_HCI_OCF_LE_SET_ADV_DATA (0x0008)
+#define BLE_HCI_MAX_ADV_DATA_LEN (31)
 struct ble_hci_le_set_adv_data_cp {
-    uint8_t adv_data_len;
-    uint8_t adv_data[BLE_HCI_MAX_ADV_DATA_LEN];
+	uint8_t adv_data_len;
+	uint8_t adv_data[BLE_HCI_MAX_ADV_DATA_LEN];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA            (0x0009)
-#define BLE_HCI_MAX_SCAN_RSP_DATA_LEN               (31)
+#define BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA (0x0009)
+#define BLE_HCI_MAX_SCAN_RSP_DATA_LEN (31)
 struct ble_hci_le_set_scan_rsp_data_cp {
-    uint8_t scan_rsp_len;
-    uint8_t scan_rsp[BLE_HCI_MAX_SCAN_RSP_DATA_LEN];
+	uint8_t scan_rsp_len;
+	uint8_t scan_rsp[BLE_HCI_MAX_SCAN_RSP_DATA_LEN];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_ADV_ENABLE               (0x000A)
+#define BLE_HCI_OCF_LE_SET_ADV_ENABLE (0x000A)
 struct ble_hci_le_set_adv_enable_cp {
-    uint8_t enable;
+	uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_SCAN_PARAMS              (0x000B)
+#define BLE_HCI_OCF_LE_SET_SCAN_PARAMS (0x000B)
 struct ble_hci_le_set_scan_params_cp {
-    uint8_t  scan_type;
-    uint16_t scan_itvl;
-    uint16_t scan_window;
-    uint8_t  own_addr_type;
-    uint8_t  filter_policy;
+	uint8_t scan_type;
+	uint16_t scan_itvl;
+	uint16_t scan_window;
+	uint8_t own_addr_type;
+	uint8_t filter_policy;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_SCAN_ENABLE              (0x000C)
+#define BLE_HCI_OCF_LE_SET_SCAN_ENABLE (0x000C)
 struct ble_hci_le_set_scan_enable_cp {
-    uint8_t enable;
-    uint8_t filter_duplicates;
+	uint8_t enable;
+	uint8_t filter_duplicates;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CREATE_CONN                  (0x000D)
+#define BLE_HCI_OCF_LE_CREATE_CONN (0x000D)
 struct ble_hci_le_create_conn_cp {
-    uint16_t scan_itvl;
-    uint16_t scan_window;
-    uint8_t  filter_policy;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint8_t  own_addr_type;
-    uint16_t min_conn_itvl;
-    uint16_t max_conn_itvl;
-    uint16_t conn_latency;
-    uint16_t tmo;
-    uint16_t min_ce;
-    uint16_t max_ce;
-} __attribute__((packed));
-
-#define BLE_HCI_OCF_LE_CREATE_CONN_CANCEL           (0x000E)
-
-#define BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE           (0x000F)
+	uint16_t scan_itvl;
+	uint16_t scan_window;
+	uint8_t filter_policy;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint8_t own_addr_type;
+	uint16_t min_conn_itvl;
+	uint16_t max_conn_itvl;
+	uint16_t conn_latency;
+	uint16_t tmo;
+	uint16_t min_ce;
+	uint16_t max_ce;
+} __attribute__((packed));
+
+#define BLE_HCI_OCF_LE_CREATE_CONN_CANCEL (0x000E)
+
+#define BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE (0x000F)
 struct ble_hci_le_rd_white_list_rp {
-    uint8_t size;
+	uint8_t size;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CLEAR_WHITE_LIST             (0x0010)
+#define BLE_HCI_OCF_LE_CLEAR_WHITE_LIST (0x0010)
 
-#define BLE_HCI_OCF_LE_ADD_WHITE_LIST               (0x0011)
+#define BLE_HCI_OCF_LE_ADD_WHITE_LIST (0x0011)
 struct ble_hci_le_add_whte_list_cp {
-    uint8_t addr_type;
-    uint8_t addr[6];
+	uint8_t addr_type;
+	uint8_t addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RMV_WHITE_LIST               (0x0012)
+#define BLE_HCI_OCF_LE_RMV_WHITE_LIST (0x0012)
 struct ble_hci_le_rmv_white_list_cp {
-    uint8_t addr_type;
-    uint8_t addr[6];
+	uint8_t addr_type;
+	uint8_t addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CONN_UPDATE                  (0x0013)
+#define BLE_HCI_OCF_LE_CONN_UPDATE (0x0013)
 struct ble_hci_le_conn_update_cp {
-    uint16_t conn_handle;
-    uint16_t conn_itvl_min;
-    uint16_t conn_itvl_max;
-    uint16_t conn_latency;
-    uint16_t supervision_timeout;
-    uint16_t min_ce_len;
-    uint16_t max_ce_len;
+	uint16_t conn_handle;
+	uint16_t conn_itvl_min;
+	uint16_t conn_itvl_max;
+	uint16_t conn_latency;
+	uint16_t supervision_timeout;
+	uint16_t min_ce_len;
+	uint16_t max_ce_len;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_HOST_CHAN_CLASS          (0x0014)
+#define BLE_HCI_OCF_LE_SET_HOST_CHAN_CLASS (0x0014)
 struct ble_hci_le_set_host_chan_class_cp {
-    uint8_t chan_map[5];
+	uint8_t chan_map[5];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_CHAN_MAP                  (0x0015)
+#define BLE_HCI_OCF_LE_RD_CHAN_MAP (0x0015)
 struct ble_hci_le_rd_chan_map_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_le_rd_chan_map_rp {
-    uint16_t conn_handle;
-    uint8_t chan_map[5];
+	uint16_t conn_handle;
+	uint8_t chan_map[5];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_REM_FEAT                  (0x0016)
+#define BLE_HCI_OCF_LE_RD_REM_FEAT (0x0016)
 struct ble_hci_le_rd_rem_feat_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ENCRYPT                      (0x0017)
+#define BLE_HCI_OCF_LE_ENCRYPT (0x0017)
 struct ble_hci_le_encrypt_cp {
-    uint8_t key[16];
-    uint8_t data[16];
+	uint8_t key[16];
+	uint8_t data[16];
 } __attribute__((packed));
 struct ble_hci_le_encrypt_rp {
-    uint8_t data[16];
+	uint8_t data[16];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RAND                         (0x0018)
+#define BLE_HCI_OCF_LE_RAND (0x0018)
 struct ble_hci_le_rand_rp {
-    uint64_t random_number;
+	uint64_t random_number;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_START_ENCRYPT                (0x0019)
+#define BLE_HCI_OCF_LE_START_ENCRYPT (0x0019)
 struct ble_hci_le_start_encrypt_cp {
-    uint16_t conn_handle;
-    uint64_t rand;
-    uint16_t div;
-    uint8_t  ltk[16];
+	uint16_t conn_handle;
+	uint64_t rand;
+	uint16_t div;
+	uint8_t ltk[16];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY             (0x001A)
+#define BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY (0x001A)
 struct ble_hci_le_lt_key_req_reply_cp {
-    uint16_t conn_handle;
-    uint8_t  ltk[16];
+	uint16_t conn_handle;
+	uint8_t ltk[16];
 } __attribute__((packed));
 struct ble_hci_le_lt_key_req_reply_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY         (0x001B)
+#define BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY (0x001B)
 struct ble_hci_le_lt_key_req_neg_reply_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_le_lt_key_req_neg_reply_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_SUPP_STATES               (0x001C)
+#define BLE_HCI_OCF_LE_RD_SUPP_STATES (0x001C)
 struct ble_hci_le_rd_supp_states_rp {
-    uint64_t states;
+	uint64_t states;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RX_TEST                      (0x001D)
+#define BLE_HCI_OCF_LE_RX_TEST (0x001D)
 struct ble_hci_le_rx_test_cp {
-    uint8_t rx_chan;
+	uint8_t rx_chan;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_TX_TEST                      (0x001E)
+#define BLE_HCI_OCF_LE_TX_TEST (0x001E)
 struct ble_hci_le_tx_test_cp {
-    uint8_t tx_chan;
-    uint8_t test_data_len;
-    uint8_t payload;
+	uint8_t tx_chan;
+	uint8_t test_data_len;
+	uint8_t payload;
 } __attribute__((packed));
 #if MYNEWT_VAL(BLE_LL_DTM_EXTENSIONS)
 struct ble_hci_le_tx_test_ext_cp {
-    uint8_t tx_chan;
-    uint8_t test_data_len;
-    uint8_t payload;
-    uint16_t interval;
-    uint16_t pkt_count;
+	uint8_t tx_chan;
+	uint8_t test_data_len;
+	uint8_t payload;
+	uint16_t interval;
+	uint16_t pkt_count;
 } __attribute__((packed));
 #endif
 
-#define BLE_HCI_OCF_LE_TEST_END                     (0x001F)
+#define BLE_HCI_OCF_LE_TEST_END (0x001F)
 struct ble_hci_le_test_end_rp {
-    uint16_t num_packets;
+	uint16_t num_packets;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REM_CONN_PARAM_RR            (0x0020)
+#define BLE_HCI_OCF_LE_REM_CONN_PARAM_RR (0x0020)
 struct ble_hci_le_rem_conn_param_rr_cp {
-    uint16_t conn_handle;
-    uint16_t conn_itvl_min;
-    uint16_t conn_itvl_max;
-    uint16_t conn_latency;
-    uint16_t supervision_timeout;
-    uint16_t min_ce;
-    uint16_t max_ce;
+	uint16_t conn_handle;
+	uint16_t conn_itvl_min;
+	uint16_t conn_itvl_max;
+	uint16_t conn_latency;
+	uint16_t supervision_timeout;
+	uint16_t min_ce;
+	uint16_t max_ce;
 } __attribute__((packed));
 struct ble_hci_le_rem_conn_param_rr_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR           (0x0021)
+#define BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR (0x0021)
 struct ble_hci_le_rem_conn_params_nrr_cp {
-    uint16_t conn_handle;
-    uint8_t  reason;
+	uint16_t conn_handle;
+	uint8_t reason;
 } __attribute__((packed));
 struct ble_hci_le_rem_conn_params_nrr_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_DATA_LEN                 (0x0022)
+#define BLE_HCI_OCF_LE_SET_DATA_LEN (0x0022)
 struct ble_hci_le_set_data_len_cp {
-    uint16_t conn_handle;
-    uint16_t tx_octets;
-    uint16_t tx_time;
+	uint16_t conn_handle;
+	uint16_t tx_octets;
+	uint16_t tx_time;
 } __attribute__((packed));
 struct ble_hci_le_set_data_len_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_SUGG_DEF_DATA_LEN         (0x0023)
+#define BLE_HCI_OCF_LE_RD_SUGG_DEF_DATA_LEN (0x0023)
 struct ble_hci_le_rd_sugg_def_data_len_rp {
-    uint16_t max_tx_octets;
-    uint16_t max_tx_time;
+	uint16_t max_tx_octets;
+	uint16_t max_tx_time;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_WR_SUGG_DEF_DATA_LEN         (0x0024)
+#define BLE_HCI_OCF_LE_WR_SUGG_DEF_DATA_LEN (0x0024)
 struct ble_hci_le_wr_sugg_def_data_len_cp {
-    uint16_t max_tx_octets;
-    uint16_t max_tx_time;
+	uint16_t max_tx_octets;
+	uint16_t max_tx_time;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_P256_PUBKEY               (0x0025)
+#define BLE_HCI_OCF_LE_RD_P256_PUBKEY (0x0025)
 
-#define BLE_HCI_OCF_LE_GEN_DHKEY                    (0x0026)
+#define BLE_HCI_OCF_LE_GEN_DHKEY (0x0026)
 struct ble_hci_le_gen_dhkey_cp {
-    uint8_t pkey[64];
+	uint8_t pkey[64];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ADD_RESOLV_LIST              (0x0027)
+#define BLE_HCI_OCF_LE_ADD_RESOLV_LIST (0x0027)
 struct ble_hci_le_add_resolv_list_cp {
-    uint8_t peer_addr_type;
-    uint8_t peer_id_addr[6];
-    uint8_t peer_irk[16];
-    uint8_t local_irk[16];
+	uint8_t peer_addr_type;
+	uint8_t peer_id_addr[6];
+	uint8_t peer_irk[16];
+	uint8_t local_irk[16];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RMV_RESOLV_LIST              (0x0028)
+#define BLE_HCI_OCF_LE_RMV_RESOLV_LIST (0x0028)
 struct ble_hci_le_rmv_resolve_list_cp {
-    uint8_t peer_addr_type;
-    uint8_t peer_id_addr[6];
+	uint8_t peer_addr_type;
+	uint8_t peer_id_addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CLR_RESOLV_LIST              (0x0029)
+#define BLE_HCI_OCF_LE_CLR_RESOLV_LIST (0x0029)
 
-#define BLE_HCI_OCF_LE_RD_RESOLV_LIST_SIZE          (0x002A)
+#define BLE_HCI_OCF_LE_RD_RESOLV_LIST_SIZE (0x002A)
 struct ble_hci_le_rd_resolv_list_size_rp {
-    uint8_t size;
+	uint8_t size;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_PEER_RESOLV_ADDR          (0x002B)
+#define BLE_HCI_OCF_LE_RD_PEER_RESOLV_ADDR (0x002B)
 struct ble_hci_le_rd_peer_resolv_addr_cp {
-    uint8_t peer_addr_type;
-    uint8_t peer_id_addr[6];
+	uint8_t peer_addr_type;
+	uint8_t peer_id_addr[6];
 } __attribute__((packed));
 struct ble_hci_le_rd_peer_resolv_addr_rp {
-    uint8_t rpa[6];
+	uint8_t rpa[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_LOCAL_RESOLV_ADDR         (0x002C)
+#define BLE_HCI_OCF_LE_RD_LOCAL_RESOLV_ADDR (0x002C)
 struct ble_hci_le_rd_local_resolv_addr_cp {
-    uint8_t peer_addr_type;
-    uint8_t peer_id_addr[6];
+	uint8_t peer_addr_type;
+	uint8_t peer_id_addr[6];
 } __attribute__((packed));
 struct ble_hci_le_rd_local_resolv_addr_rp {
-    uint8_t rpa[6];
+	uint8_t rpa[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_ADDR_RES_EN              (0x002D)
+#define BLE_HCI_OCF_LE_SET_ADDR_RES_EN (0x002D)
 struct ble_hci_le_set_addr_res_en_cp {
-    uint8_t enable;
+	uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_RPA_TMO                  (0x002E)
+#define BLE_HCI_OCF_LE_SET_RPA_TMO (0x002E)
 struct ble_hci_le_set_rpa_tmo_cp {
-    uint16_t rpa_timeout;
+	uint16_t rpa_timeout;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_MAX_DATA_LEN              (0x002F)
+#define BLE_HCI_OCF_LE_RD_MAX_DATA_LEN (0x002F)
 struct ble_hci_le_rd_max_data_len_rp {
-    uint16_t max_tx_octests;
-    uint16_t max_tx_time;
-    uint16_t max_rx_octests;
-    uint16_t max_rx_time;
+	uint16_t max_tx_octests;
+	uint16_t max_tx_time;
+	uint16_t max_rx_octests;
+	uint16_t max_rx_time;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_PHY                       (0x0030)
+#define BLE_HCI_OCF_LE_RD_PHY (0x0030)
 struct ble_hci_le_rd_phy_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_le_rd_phy_rp {
-    uint16_t conn_handle;
-    uint8_t tx_phy;
-    uint8_t rx_phy;
+	uint16_t conn_handle;
+	uint8_t tx_phy;
+	uint8_t rx_phy;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_DEFAULT_PHY              (0x0031)
+#define BLE_HCI_OCF_LE_SET_DEFAULT_PHY (0x0031)
 struct ble_hci_le_set_default_phy_cp {
-    uint8_t all_phys;
-    uint8_t tx_phys;
-    uint8_t rx_phys;
+	uint8_t all_phys;
+	uint8_t tx_phys;
+	uint8_t rx_phys;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PHY                      (0x0032)
+#define BLE_HCI_OCF_LE_SET_PHY (0x0032)
 struct ble_hci_le_set_phy_cp {
-    uint16_t conn_handle;
-    uint8_t all_phys;
-    uint8_t tx_phys;
-    uint8_t rx_phys;
-    uint16_t phy_options;
+	uint16_t conn_handle;
+	uint8_t all_phys;
+	uint8_t tx_phys;
+	uint8_t rx_phys;
+	uint16_t phy_options;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RX_TEST_V2                  (0x0033)
+#define BLE_HCI_OCF_LE_RX_TEST_V2 (0x0033)
 struct ble_hci_le_rx_test_v2_cp {
-    uint8_t rx_chan;
-    uint8_t phy;
-    uint8_t index;
+	uint8_t rx_chan;
+	uint8_t phy;
+	uint8_t index;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_TX_TEST_V2                  (0x0034)
+#define BLE_HCI_OCF_LE_TX_TEST_V2 (0x0034)
 struct ble_hci_le_tx_test_v2_cp {
-    uint8_t tx_chan;
-    uint8_t test_data_len;
-    uint8_t payload;
-    uint8_t phy;
+	uint8_t tx_chan;
+	uint8_t test_data_len;
+	uint8_t payload;
+	uint8_t phy;
 } __attribute__((packed));
 #if MYNEWT_VAL(BLE_LL_DTM_EXTENSIONS)
 struct ble_hci_le_tx_test_v2_ext_cp {
-    uint8_t tx_chan;
-    uint8_t test_data_len;
-    uint8_t payload;
-    uint8_t phy;
-    uint16_t interval;
-    uint16_t pkt_count;
+	uint8_t tx_chan;
+	uint8_t test_data_len;
+	uint8_t payload;
+	uint8_t phy;
+	uint16_t interval;
+	uint16_t pkt_count;
 } __attribute__((packed));
 #endif
 
-#define BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR         (0x0035)
+#define BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR (0x0035)
 struct ble_hci_le_set_adv_set_rnd_addr_cp {
-    uint8_t adv_handle;
-    uint8_t addr[6];
+	uint8_t adv_handle;
+	uint8_t addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM            (0x0036)
+#define BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM (0x0036)
 struct ble_hci_le_set_ext_adv_params_cp {
-    uint8_t  adv_handle;
-    uint16_t props;
-    uint8_t  pri_itvl_min[3];
-    uint8_t  pri_itvl_max[3];
-    uint8_t pri_chan_map;
-    uint8_t own_addr_type;
-    uint8_t peer_addr_type;
-    uint8_t peer_addr[6];
-    uint8_t filter_policy;
-    int8_t tx_power;
-    uint8_t pri_phy;
-    uint8_t sec_max_skip;
-    uint8_t sec_phy;
-    uint8_t sid;
-    uint8_t scan_req_notif;
+	uint8_t adv_handle;
+	uint16_t props;
+	uint8_t pri_itvl_min[3];
+	uint8_t pri_itvl_max[3];
+	uint8_t pri_chan_map;
+	uint8_t own_addr_type;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint8_t filter_policy;
+	int8_t tx_power;
+	uint8_t pri_phy;
+	uint8_t sec_max_skip;
+	uint8_t sec_phy;
+	uint8_t sid;
+	uint8_t scan_req_notif;
 } __attribute__((packed));
 struct ble_hci_le_set_ext_adv_params_rp {
-    int8_t  tx_power;
+	int8_t tx_power;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_ADV_DATA             (0x0037)
+#define BLE_HCI_OCF_LE_SET_EXT_ADV_DATA (0x0037)
 struct ble_hci_le_set_ext_adv_data_cp {
-    uint8_t adv_handle;
-    uint8_t operation;
-    uint8_t fragment_pref;
-    uint8_t adv_data_len;
-    uint8_t adv_data[0];
+	uint8_t adv_handle;
+	uint8_t operation;
+	uint8_t fragment_pref;
+	uint8_t adv_data_len;
+	uint8_t adv_data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA        (0x0038)
+#define BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA (0x0038)
 struct ble_hci_le_set_ext_scan_rsp_data_cp {
-    uint8_t adv_handle;
-    uint8_t operation;
-    uint8_t fragment_pref;
-    uint8_t scan_rsp_len;
-    uint8_t scan_rsp[0];
+	uint8_t adv_handle;
+	uint8_t operation;
+	uint8_t fragment_pref;
+	uint8_t scan_rsp_len;
+	uint8_t scan_rsp[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE           (0x0039)
+#define BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE (0x0039)
 struct adv_set {
-    uint8_t adv_handle;
-    uint16_t duration;
-    uint8_t max_events;
+	uint8_t adv_handle;
+	uint16_t duration;
+	uint8_t max_events;
 } __attribute__((packed));
 struct ble_hci_le_set_ext_adv_enable_cp {
-    uint8_t enable;
-    uint8_t num_sets;
-    struct adv_set sets[0];
+	uint8_t enable;
+	uint8_t num_sets;
+	struct adv_set sets[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN          (0x003A)
+#define BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN (0x003A)
 struct ble_hci_le_rd_max_adv_data_len_rp {
-    uint16_t max_adv_data_len;
+	uint16_t max_adv_data_len;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_NUM_OF_ADV_SETS           (0x003B)
+#define BLE_HCI_OCF_LE_RD_NUM_OF_ADV_SETS (0x003B)
 struct ble_hci_le_rd_num_of_adv_sets_rp {
-    uint8_t num_sets;
+	uint8_t num_sets;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REMOVE_ADV_SET               (0x003C)
+#define BLE_HCI_OCF_LE_REMOVE_ADV_SET (0x003C)
 struct ble_hci_le_remove_adv_set_cp {
-    uint8_t adv_handle;
+	uint8_t adv_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CLEAR_ADV_SETS               (0x003D)
+#define BLE_HCI_OCF_LE_CLEAR_ADV_SETS (0x003D)
 
-#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS      (0x003E)
+#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS (0x003E)
 struct ble_hci_le_set_periodic_adv_params_cp {
-    uint8_t adv_handle;
-    uint16_t min_itvl;
-    uint16_t max_itvl;
-    uint16_t props;
+	uint8_t adv_handle;
+	uint16_t min_itvl;
+	uint16_t max_itvl;
+	uint16_t props;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA        (0x003F)
+#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA (0x003F)
 struct ble_hci_le_set_periodic_adv_data_cp {
-    uint8_t adv_handle;
-    uint8_t operation;
-    uint8_t adv_data_len;
-    uint8_t adv_data[0];
+	uint8_t adv_handle;
+	uint8_t operation;
+	uint8_t adv_data_len;
+	uint8_t adv_data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE      (0x0040)
+#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE (0x0040)
 struct ble_hci_le_set_periodic_adv_enable_cp {
-    uint8_t enable;
-    uint8_t adv_handle;
+	uint8_t enable;
+	uint8_t adv_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM           (0x0041)
+#define BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM (0x0041)
 struct scan_params {
-    uint8_t  type;
-    uint16_t itvl;
-    uint16_t window;
+	uint8_t type;
+	uint16_t itvl;
+	uint16_t window;
 } __attribute__((packed));
 struct ble_hci_le_set_ext_scan_params_cp {
-    uint8_t own_addr_type;
-    uint8_t filter_policy;
-    uint8_t phys;
-    struct scan_params scans[0];
+	uint8_t own_addr_type;
+	uint8_t filter_policy;
+	uint8_t phys;
+	struct scan_params scans[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE          (0x0042)
+#define BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE (0x0042)
 struct ble_hci_le_set_ext_scan_enable_cp {
-    uint8_t  enable;
-    uint8_t  filter_dup;
-    uint16_t duration;
-    uint16_t period;
+	uint8_t enable;
+	uint8_t filter_dup;
+	uint16_t duration;
+	uint16_t period;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_EXT_CREATE_CONN              (0x0043)
+#define BLE_HCI_OCF_LE_EXT_CREATE_CONN (0x0043)
 struct conn_params {
-    uint16_t scan_itvl;
-    uint16_t scan_window;
-    uint16_t conn_min_itvl;
-    uint16_t conn_max_itvl;
-    uint16_t conn_latency;
-    uint16_t supervision_timeout;
-    uint16_t min_ce;
-    uint16_t max_ce;
+	uint16_t scan_itvl;
+	uint16_t scan_window;
+	uint16_t conn_min_itvl;
+	uint16_t conn_max_itvl;
+	uint16_t conn_latency;
+	uint16_t supervision_timeout;
+	uint16_t min_ce;
+	uint16_t max_ce;
 } __attribute__((packed));
 struct ble_hci_le_ext_create_conn_cp {
-    uint8_t filter_policy;
-    uint8_t own_addr_type;
-    uint8_t peer_addr_type;
-    uint8_t peer_addr[6];
-    uint8_t init_phy_mask;
-    struct conn_params conn_params[0];
+	uint8_t filter_policy;
+	uint8_t own_addr_type;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint8_t init_phy_mask;
+	struct conn_params conn_params[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_FILTER      0x01
-#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_DISABLED    0x02
-#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_DUPLICATES  0x04
+#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_FILTER 0x01
+#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_DISABLED 0x02
+#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_DUPLICATES 0x04
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC          (0x0044)
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC (0x0044)
 struct ble_hci_le_periodic_adv_create_sync_cp {
-    uint8_t  options;
-    uint8_t  sid;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint16_t skip;
-    uint16_t sync_timeout;
-    uint8_t  sync_cte_type;
+	uint8_t options;
+	uint8_t sid;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint16_t skip;
+	uint16_t sync_timeout;
+	uint8_t sync_cte_type;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL   (0x0045)
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL (0x0045)
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC            (0x0046)
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC (0x0046)
 struct ble_hci_le_periodic_adv_term_sync_cp {
-    uint16_t sync_handle;
+	uint16_t sync_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST      (0x0047)
+#define BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST (0x0047)
 struct ble_hci_le_add_dev_to_periodic_adv_list_cp {
-    uint8_t peer_addr_type;
-    uint8_t peer_addr[6];
-    uint8_t sid;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint8_t sid;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST    (0x0048)
+#define BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST (0x0048)
 struct ble_hci_le_rem_dev_from_periodic_adv_list_cp {
-    uint8_t peer_addr_type;
-    uint8_t peer_addr[6];
-    uint8_t sid;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint8_t sid;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST           (0x0049)
+#define BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST (0x0049)
 
-#define BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE         (0x004A)
+#define BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE (0x004A)
 struct ble_hci_le_rd_periodic_adv_list_size_rp {
-    uint8_t list_size;
+	uint8_t list_size;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_TRANSMIT_POWER            (0x004B)
+#define BLE_HCI_OCF_LE_RD_TRANSMIT_POWER (0x004B)
 struct ble_hci_le_rd_transmit_power_rp {
-    int8_t min_tx_power;
-    int8_t max_tx_power;
+	int8_t min_tx_power;
+	int8_t max_tx_power;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_RF_PATH_COMPENSATION      (0x004C)
+#define BLE_HCI_OCF_LE_RD_RF_PATH_COMPENSATION (0x004C)
 struct ble_hci_le_rd_rf_path_compensation_rp {
-    int16_t tx_path_compensation;
-    int16_t rx_path_compensation;
+	int16_t tx_path_compensation;
+	int16_t rx_path_compensation;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_WR_RF_PATH_COMPENSATION      (0x004D)
+#define BLE_HCI_OCF_LE_WR_RF_PATH_COMPENSATION (0x004D)
 struct ble_hci_le_wr_rf_path_compensation_cp {
-    int16_t tx_path_compensation;
-    int16_t rx_path_compensation;
+	int16_t tx_path_compensation;
+	int16_t rx_path_compensation;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PRIVACY_MODE             (0x004E)
+#define BLE_HCI_OCF_LE_SET_PRIVACY_MODE (0x004E)
 struct ble_hci_le_set_privacy_mode_cp {
-    uint8_t peer_id_addr_type;
-    uint8_t peer_id_addr[6];
-    uint8_t mode;
-} __attribute__((packed));
-
-#define BLE_HCI_OCF_LE_RX_TEST_V3                        (0x004F)
-#define BLE_HCI_OCF_LE_TX_TEST_V3                        (0x0050)
-#define BLE_HCI_OCF_LE_SET_CONNLESS_CTE_TX_PARAMS        (0x0051)
-#define BLE_HCI_OCF_LE_SET_CONNLESS_CTE_TX_ENABLE        (0x0052)
-#define BLE_HCI_OCF_LE_SET_CONNLESS_IQ_SAMPLING_ENABLE   (0x0053)
-#define BLE_HCI_OCF_LE_SET_CONN_CTE_RX_PARAMS            (0x0054)
-#define BLE_HCI_OCF_LE_SET_CONN_CTE_TX_PARAMS            (0x0055)
-#define BLE_HCI_OCF_LE_SET_CONN_CTE_REQ_ENABLE           (0x0056)
-#define BLE_HCI_OCF_LE_SET_CONN_CTE_RESP_ENABLE          (0x0057)
-#define BLE_HCI_OCF_LE_RD_ANTENNA_INFO                   (0x0058)
-
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE       (0x0059)
+	uint8_t peer_id_addr_type;
+	uint8_t peer_id_addr[6];
+	uint8_t mode;
+} __attribute__((packed));
+
+#define BLE_HCI_OCF_LE_RX_TEST_V3 (0x004F)
+#define BLE_HCI_OCF_LE_TX_TEST_V3 (0x0050)
+#define BLE_HCI_OCF_LE_SET_CONNLESS_CTE_TX_PARAMS (0x0051)
+#define BLE_HCI_OCF_LE_SET_CONNLESS_CTE_TX_ENABLE (0x0052)
+#define BLE_HCI_OCF_LE_SET_CONNLESS_IQ_SAMPLING_ENABLE (0x0053)
+#define BLE_HCI_OCF_LE_SET_CONN_CTE_RX_PARAMS (0x0054)
+#define BLE_HCI_OCF_LE_SET_CONN_CTE_TX_PARAMS (0x0055)
+#define BLE_HCI_OCF_LE_SET_CONN_CTE_REQ_ENABLE (0x0056)
+#define BLE_HCI_OCF_LE_SET_CONN_CTE_RESP_ENABLE (0x0057)
+#define BLE_HCI_OCF_LE_RD_ANTENNA_INFO (0x0058)
+
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE (0x0059)
 struct ble_hci_le_periodic_adv_receive_enable_cp {
-    uint16_t sync_handle;
-    uint8_t enable;
+	uint16_t sync_handle;
+	uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER        (0x005A)
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER (0x005A)
 struct ble_hci_le_periodic_adv_sync_transfer_cp {
-    uint16_t conn_handle;
-    uint16_t service_data;
-    uint16_t sync_handle;
+	uint16_t conn_handle;
+	uint16_t service_data;
+	uint16_t sync_handle;
 } __attribute__((packed));
 struct ble_hci_le_periodic_adv_sync_transfer_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER    (0x005B)
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER (0x005B)
 struct ble_hci_le_periodic_adv_set_info_transfer_cp {
-    uint16_t conn_handle;
-    uint16_t service_data;
-    uint8_t adv_handle;
+	uint16_t conn_handle;
+	uint16_t service_data;
+	uint8_t adv_handle;
 } __attribute__((packed));
 struct ble_hci_le_periodic_adv_set_info_transfer_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
 #define BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS (0x005C)
 struct ble_hci_le_periodic_adv_sync_transfer_params_cp {
-    uint16_t conn_handle;
-    uint8_t  mode;
-    uint16_t skip;
-    uint16_t sync_timeout;
-    uint8_t  sync_cte_type;
+	uint16_t conn_handle;
+	uint8_t mode;
+	uint16_t skip;
+	uint16_t sync_timeout;
+	uint8_t sync_cte_type;
 } __attribute__((packed));
 struct ble_hci_le_periodic_adv_sync_transfer_params_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS  (0x005D)
+#define BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS (0x005D)
 struct ble_hci_le_set_default_periodic_sync_transfer_params_cp {
-    uint8_t  mode;
-    uint16_t skip;
-    uint16_t sync_timeout;
-    uint8_t  sync_cte_type;
+	uint8_t mode;
+	uint16_t skip;
+	uint16_t sync_timeout;
+	uint8_t sync_cte_type;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_GENERATE_DHKEY_V2                 (0x005E)
-#define BLE_HCI_OCF_LE_MODIFY_SCA                        (0x005F)
+#define BLE_HCI_OCF_LE_GENERATE_DHKEY_V2 (0x005E)
+#define BLE_HCI_OCF_LE_MODIFY_SCA (0x005F)
 
-#define BLE_HCI_OCF_LE_READ_ISO_TX_SYNC                  (0x0061)
+#define BLE_HCI_OCF_LE_READ_ISO_TX_SYNC (0x0061)
 struct ble_hci_le_read_iso_tx_sync_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_le_read_iso_tx_sync_rp {
-    uint16_t conn_handle;
-    uint16_t packet_seq_num;
-    uint32_t tx_timestamp;
-    uint8_t time_offset[3];
+	uint16_t conn_handle;
+	uint16_t packet_seq_num;
+	uint32_t tx_timestamp;
+	uint8_t time_offset[3];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_CIG_PARAMS                    (0x0062)
+#define BLE_HCI_OCF_LE_SET_CIG_PARAMS (0x0062)
 struct ble_hci_le_cis_params {
-    uint8_t cis_id;
-    uint16_t max_sdu_c_to_p;
-    uint16_t max_sdu_p_to_c;
-    uint8_t phy_c_to_p;
-    uint8_t phy_p_to_c;
-    uint8_t rnt_c_to_p;
-    uint8_t rnt_p_to_c;
+	uint8_t cis_id;
+	uint16_t max_sdu_c_to_p;
+	uint16_t max_sdu_p_to_c;
+	uint8_t phy_c_to_p;
+	uint8_t phy_p_to_c;
+	uint8_t rnt_c_to_p;
+	uint8_t rnt_p_to_c;
 } __attribute__((packed));
 struct ble_hci_le_set_cig_params_cp {
-    uint8_t cig_id;
-    uint8_t sdu_interval_c_to_p[3];
-    uint8_t sdu_interval_p_to_c[3];
-    uint8_t worst_sca;
-    uint8_t packing;
-    uint8_t framing;
-    uint16_t max_latency_c_to_p;
-    uint16_t max_latency_p_to_c;
-    uint8_t cis_count;
-    struct ble_hci_le_cis_params cis[0];
+	uint8_t cig_id;
+	uint8_t sdu_interval_c_to_p[3];
+	uint8_t sdu_interval_p_to_c[3];
+	uint8_t worst_sca;
+	uint8_t packing;
+	uint8_t framing;
+	uint16_t max_latency_c_to_p;
+	uint16_t max_latency_p_to_c;
+	uint8_t cis_count;
+	struct ble_hci_le_cis_params cis[0];
 } __attribute__((packed));
 struct ble_hci_le_set_cig_params_rp {
-    uint8_t cig_id;
-    uint8_t cis_count;
-    uint16_t conn_handle[0];
+	uint8_t cig_id;
+	uint8_t cis_count;
+	uint16_t conn_handle[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_CIG_PARAMS_TEST               (0x0063)
+#define BLE_HCI_OCF_LE_SET_CIG_PARAMS_TEST (0x0063)
 struct ble_hci_le_cis_params_test {
-    uint8_t cis_id;
-    uint8_t nse;
-    uint16_t max_sdu_c_to_p;
-    uint16_t max_sdu_p_to_c;
-    uint16_t max_pdu_c_to_p;
-    uint16_t max_pdu_p_to_c;
-    uint8_t phy_c_to_p;
-    uint8_t phy_p_to_c;
-    uint8_t bn_c_to_p;
-    uint8_t bn_p_to_c;
+	uint8_t cis_id;
+	uint8_t nse;
+	uint16_t max_sdu_c_to_p;
+	uint16_t max_sdu_p_to_c;
+	uint16_t max_pdu_c_to_p;
+	uint16_t max_pdu_p_to_c;
+	uint8_t phy_c_to_p;
+	uint8_t phy_p_to_c;
+	uint8_t bn_c_to_p;
+	uint8_t bn_p_to_c;
 } __attribute__((packed));
 struct ble_hci_le_set_cig_params_test_cp {
-    uint8_t cig_id;
-    uint8_t sdu_interval_c_to_p[3];
-    uint8_t sdu_interval_p_to_c[3];
-    uint8_t ft_c_to_p;
-    uint8_t ft_p_to_c;
-    uint16_t iso_interval;
-    uint8_t worst_sca;
-    uint8_t packing;
-    uint8_t framing;
-    uint8_t cis_count;
-    struct ble_hci_le_cis_params_test cis[0];
+	uint8_t cig_id;
+	uint8_t sdu_interval_c_to_p[3];
+	uint8_t sdu_interval_p_to_c[3];
+	uint8_t ft_c_to_p;
+	uint8_t ft_p_to_c;
+	uint16_t iso_interval;
+	uint8_t worst_sca;
+	uint8_t packing;
+	uint8_t framing;
+	uint8_t cis_count;
+	struct ble_hci_le_cis_params_test cis[0];
 } __attribute__((packed));
 struct ble_hci_le_set_cig_params_test_rp {
-    uint8_t cig_id;
-    uint8_t cis_count;
-    uint16_t conn_handle[0];
+	uint8_t cig_id;
+	uint8_t cis_count;
+	uint16_t conn_handle[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CREATE_CIS                        (0x0064)
+#define BLE_HCI_OCF_LE_CREATE_CIS (0x0064)
 struct ble_hci_le_create_cis_params {
-    uint16_t cis_handle;
-    uint16_t conn_handle;
+	uint16_t cis_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_le_create_cis_cp {
-    uint8_t cis_count;
-    struct ble_hci_le_create_cis_params cis[0];
+	uint8_t cis_count;
+	struct ble_hci_le_create_cis_params cis[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REMOVE_CIG                        (0x0065)
+#define BLE_HCI_OCF_LE_REMOVE_CIG (0x0065)
 struct ble_hci_le_remove_cig_cp {
-    uint8_t cig_id;
+	uint8_t cig_id;
 } __attribute__((packed));
 struct ble_hci_le_remove_cig_rp {
-    uint8_t cig_id;
+	uint8_t cig_id;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ACCEPT_CIS_REQ                    (0x0066)
+#define BLE_HCI_OCF_LE_ACCEPT_CIS_REQ (0x0066)
 struct ble_hci_le_accept_cis_request_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REJECT_CIS_REQ                    (0x0067)
+#define BLE_HCI_OCF_LE_REJECT_CIS_REQ (0x0067)
 struct ble_hci_le_reject_cis_request_cp {
-    uint16_t conn_handle;
-    uint8_t reason;
+	uint16_t conn_handle;
+	uint8_t reason;
 } __attribute__((packed));
 struct ble_hci_le_reject_cis_request_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CREATE_BIG                        (0x0068)
+#define BLE_HCI_OCF_LE_CREATE_BIG (0x0068)
 struct ble_hci_le_create_big_cp {
-    uint8_t big_handle;
-    uint8_t adv_handle;
-    uint8_t num_bis;
-    uint8_t sdu_interval[3];
-    uint16_t max_sdu;
-    uint16_t max_transport_latency;
-    uint8_t rtn;
-    uint8_t phy;
-    uint8_t packing;
-    uint8_t framing;
-    uint8_t encryption;
-    uint8_t broadcast_code[16];
-} __attribute__((packed));
-
-#define BLE_HCI_OCF_LE_CREATE_BIG_TEST                   (0x0069)
+	uint8_t big_handle;
+	uint8_t adv_handle;
+	uint8_t num_bis;
+	uint8_t sdu_interval[3];
+	uint16_t max_sdu;
+	uint16_t max_transport_latency;
+	uint8_t rtn;
+	uint8_t phy;
+	uint8_t packing;
+	uint8_t framing;
+	uint8_t encryption;
+	uint8_t broadcast_code[16];
+} __attribute__((packed));
+
+#define BLE_HCI_OCF_LE_CREATE_BIG_TEST (0x0069)
 struct ble_hci_le_create_big_test_cp {
-    uint8_t big_handle;
-    uint8_t adv_handle;
-    uint8_t num_bis;
-    uint8_t sdu_interval[3];
-    uint16_t iso_interval;
-    uint8_t nse;
-    uint16_t max_sdu;
-    uint16_t max_pdu;
-    uint8_t phy;
-    uint8_t packing;
-    uint8_t framing;
-    uint8_t bn;
-    uint8_t irc;
-    uint8_t pto;
-    uint8_t encryption;
-    uint8_t broadcast_code[16];
-} __attribute__((packed));
-
-#define BLE_HCI_OCF_LE_TERMINATE_BIG                     (0x006a)
+	uint8_t big_handle;
+	uint8_t adv_handle;
+	uint8_t num_bis;
+	uint8_t sdu_interval[3];
+	uint16_t iso_interval;
+	uint8_t nse;
+	uint16_t max_sdu;
+	uint16_t max_pdu;
+	uint8_t phy;
+	uint8_t packing;
+	uint8_t framing;
+	uint8_t bn;
+	uint8_t irc;
+	uint8_t pto;
+	uint8_t encryption;
+	uint8_t broadcast_code[16];
+} __attribute__((packed));
+
+#define BLE_HCI_OCF_LE_TERMINATE_BIG (0x006a)
 struct ble_hci_le_terminate_big_cp {
-    uint8_t big_handle;
-    uint8_t reason;
+	uint8_t big_handle;
+	uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_BIG_CREATE_SYNC                   (0x006b)
+#define BLE_HCI_OCF_LE_BIG_CREATE_SYNC (0x006b)
 struct ble_hci_le_big_create_sync_cp {
-    uint8_t big_handle;
-    uint16_t sync_handle;
-    uint8_t encryption;
-    uint8_t broadcast_code[16];
-    uint8_t mse;
-    uint16_t sync_timeout;
-    uint8_t num_bis;
-    uint8_t bis[0];
+	uint8_t big_handle;
+	uint16_t sync_handle;
+	uint8_t encryption;
+	uint8_t broadcast_code[16];
+	uint8_t mse;
+	uint16_t sync_timeout;
+	uint8_t num_bis;
+	uint8_t bis[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_BIG_TERMINATE_SYNC                (0x006c)
+#define BLE_HCI_OCF_LE_BIG_TERMINATE_SYNC (0x006c)
 struct ble_hci_le_big_terminate_sync_cp {
-    uint8_t big_handle;
+	uint8_t big_handle;
 } __attribute__((packed));
 struct ble_hci_le_big_terminate_sync_rp {
-    uint8_t big_handle;
+	uint8_t big_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REQ_PEER_SCA                      (0x006d)
+#define BLE_HCI_OCF_LE_REQ_PEER_SCA (0x006d)
 struct ble_hci_le_request_peer_sca_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SETUP_ISO_DATA_PATH               (0x006e)
+#define BLE_HCI_OCF_LE_SETUP_ISO_DATA_PATH (0x006e)
 struct ble_hci_le_setup_iso_data_path_cp {
-    uint16_t conn_handle;
-    uint8_t data_path_dir;
-    uint8_t data_path_id;
-    uint8_t codec_id[5];
-    uint8_t controller_delay[3];
-    uint8_t codec_config_len;
-    uint8_t codec_config[0];
+	uint16_t conn_handle;
+	uint8_t data_path_dir;
+	uint8_t data_path_id;
+	uint8_t codec_id[5];
+	uint8_t controller_delay[3];
+	uint8_t codec_config_len;
+	uint8_t codec_config[0];
 } __attribute__((packed));
 struct ble_hci_le_setup_iso_data_path_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REMOVE_ISO_DATA_PATH              (0x006f)
+#define BLE_HCI_OCF_LE_REMOVE_ISO_DATA_PATH (0x006f)
 struct ble_hci_le_remove_iso_data_path_cp {
-    uint16_t conn_handle;
-    uint8_t data_path_dir;
+	uint16_t conn_handle;
+	uint8_t data_path_dir;
 } __attribute__((packed));
 struct ble_hci_le_remove_iso_data_path_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ISO_TRANSMIT_TEST                 (0x0070)
+#define BLE_HCI_OCF_LE_ISO_TRANSMIT_TEST (0x0070)
 struct ble_hci_le_iso_transmit_test_cp {
-    uint16_t conn_handle;
-    uint8_t payload_type;
+	uint16_t conn_handle;
+	uint8_t payload_type;
 } __attribute__((packed));
 struct ble_hci_le_iso_transmit_test_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ISO_RECEIVE_TEST                  (0x0071)
+#define BLE_HCI_OCF_LE_ISO_RECEIVE_TEST (0x0071)
 struct ble_hci_le_iso_receive_test_cp {
-    uint16_t conn_handle;
-    uint8_t payload_type;
+	uint16_t conn_handle;
+	uint8_t payload_type;
 } __attribute__((packed));
 struct ble_hci_le_iso_receive_test_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ISO_READ_TEST_COUNTERS            (0x0072)
+#define BLE_HCI_OCF_LE_ISO_READ_TEST_COUNTERS (0x0072)
 struct ble_hci_le_iso_read_test_counters_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_le_iso_read_test_counters_rp {
-    uint16_t conn_handle;
-    uint32_t received_sdu_count;
-    uint32_t missed_sdu_count;
-    uint32_t failed_sdu_count;
+	uint16_t conn_handle;
+	uint32_t received_sdu_count;
+	uint32_t missed_sdu_count;
+	uint32_t failed_sdu_count;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ISO_TEST_END                      (0x0073)
+#define BLE_HCI_OCF_LE_ISO_TEST_END (0x0073)
 struct ble_hci_le_iso_test_end_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_le_iso_test_end_rp {
-    uint16_t conn_handle;
-    uint32_t received_sdu_count;
-    uint32_t missed_sdu_count;
-    uint32_t failed_sdu_count;
+	uint16_t conn_handle;
+	uint32_t received_sdu_count;
+	uint32_t missed_sdu_count;
+	uint32_t failed_sdu_count;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_HOST_FEATURE                  (0x0074)
+#define BLE_HCI_OCF_LE_SET_HOST_FEATURE (0x0074)
 struct ble_hci_le_set_host_feature_cp {
-    uint8_t bit_num;
-    uint8_t bit_val;
+	uint8_t bit_num;
+	uint8_t bit_val;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_READ_ISO_LINK_QUALITY             (0x0075)
+#define BLE_HCI_OCF_LE_READ_ISO_LINK_QUALITY (0x0075)
 struct ble_hci_le_read_iso_link_quality_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_le_read_iso_link_quality_rp {
-    uint16_t conn_handle;
-    uint32_t tx_unacked_pkts;
-    uint32_t tx_flushed_pkts;
-    uint32_t tx_last_subevent_pkts;
-    uint32_t retransmitted_pkts;
-    uint32_t crc_error_pkts;
-    uint32_t rx_unreceived_pkts;
-    uint32_t duplicate_pkts;
+	uint16_t conn_handle;
+	uint32_t tx_unacked_pkts;
+	uint32_t tx_flushed_pkts;
+	uint32_t tx_last_subevent_pkts;
+	uint32_t retransmitted_pkts;
+	uint32_t crc_error_pkts;
+	uint32_t rx_unreceived_pkts;
+	uint32_t duplicate_pkts;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ENH_READ_TRANSMIT_POWER_LEVEL     (0x0076)
+#define BLE_HCI_OCF_LE_ENH_READ_TRANSMIT_POWER_LEVEL (0x0076)
 struct ble_hci_le_enh_read_transmit_power_level_cp {
-    uint16_t conn_handle;
-    uint8_t phy;
+	uint16_t conn_handle;
+	uint8_t phy;
 } __attribute__((packed));
 struct ble_hci_le_enh_read_transmit_power_level_rp {
-    uint16_t conn_handle;
-    uint8_t phy;
-    uint8_t curr_tx_power_level;
-    uint8_t max_tx_power_level;
+	uint16_t conn_handle;
+	uint8_t phy;
+	uint8_t curr_tx_power_level;
+	uint8_t max_tx_power_level;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL  (0x0077)
+#define BLE_HCI_OCF_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL (0x0077)
 struct ble_hci_le_read_remote_transmit_power_level_cp {
-    uint16_t conn_handle;
-    uint8_t phy;
+	uint16_t conn_handle;
+	uint8_t phy;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_PARAM        (0x0078)
+#define BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_PARAM (0x0078)
 struct ble_hci_le_set_path_loss_report_param_cp {
-    uint16_t conn_handle;
-    uint8_t high_threshold;
-    uint8_t high_hysteresis;
-    uint8_t low_threshold;
-    uint8_t low_hysteresis;
-    uint16_t min_time_spent;
+	uint16_t conn_handle;
+	uint8_t high_threshold;
+	uint8_t high_hysteresis;
+	uint8_t low_threshold;
+	uint8_t low_hysteresis;
+	uint16_t min_time_spent;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_ENABLE       (0x0079)
+#define BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_ENABLE (0x0079)
 struct ble_hci_le_set_path_loss_report_enable_cp {
-    uint16_t conn_handle;
-    uint8_t enable;
+	uint16_t conn_handle;
+	uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_TRANS_PWR_REPORT_ENABLE       (0x007A)
+#define BLE_HCI_OCF_LE_SET_TRANS_PWR_REPORT_ENABLE (0x007A)
 struct ble_hci_le_set_transmit_power_report_enable_cp {
-    uint16_t conn_handle;
-    uint8_t local_enable;
-    uint8_t remote_enable;
+	uint16_t conn_handle;
+	uint8_t local_enable;
+	uint8_t remote_enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_DEFAULT_SUBRATE               (0x007D)
+#define BLE_HCI_OCF_LE_SET_DEFAULT_SUBRATE (0x007D)
 struct ble_hci_le_set_default_subrate_cp {
-    uint16_t subrate_min;
-    uint16_t subrate_max;
-    uint16_t max_latency;
-    uint16_t cont_num;
-    uint16_t supervision_tmo;
+	uint16_t subrate_min;
+	uint16_t subrate_max;
+	uint16_t max_latency;
+	uint16_t cont_num;
+	uint16_t supervision_tmo;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SUBRATE_REQ                       (0x007E)
+#define BLE_HCI_OCF_LE_SUBRATE_REQ (0x007E)
 struct ble_hci_le_subrate_req_cp {
-    uint16_t conn_handle;
-    uint16_t subrate_min;
-    uint16_t subrate_max;
-    uint16_t max_latency;
-    uint16_t cont_num;
-    uint16_t supervision_tmo;
+	uint16_t conn_handle;
+	uint16_t subrate_min;
+	uint16_t subrate_max;
+	uint16_t max_latency;
+	uint16_t cont_num;
+	uint16_t supervision_tmo;
+} __attribute__((packed));
+
+#define BLE_HCI_OCF_LE_CUSTOM_CMD (0x009E)
+struct ble_hci_le_custom_cmd_cp {
+	uint16_t opcode;  // Opcodes for different commands
 } __attribute__((packed));
 
 /* --- Vendor specific commands (OGF 0x003F) */
 /* Read Random Static Address */
-#define BLE_HCI_OCF_VS_RD_STATIC_ADDR                   (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0001))
+#define BLE_HCI_OCF_VS_RD_STATIC_ADDR (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0001))
 struct ble_hci_vs_rd_static_addr_rp {
-    uint8_t addr[6];
+	uint8_t addr[6];
 } __attribute__((packed));
 
 /* Set default transmit power. Actual selected TX power is returned
  * in reply. Setting 0xff restores controller reset default.
  */
-#define BLE_HCI_OCF_VS_SET_TX_PWR                       (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0002))
+#define BLE_HCI_OCF_VS_SET_TX_PWR (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0002))
 struct ble_hci_vs_set_tx_pwr_cp {
-    int8_t tx_power;
+	int8_t tx_power;
 } __attribute__((packed));
 struct ble_hci_vs_set_tx_pwr_rp {
-    int8_t tx_power;
+	int8_t tx_power;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_VS_CSS_CONFIGURE                    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0003))
+#define BLE_HCI_OCF_VS_CSS_CONFIGURE (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0003))
 struct ble_hci_vs_css_configure_cp {
-    uint32_t slot_us;
-    uint32_t period_slots;
+	uint32_t slot_us;
+	uint32_t period_slots;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_CSS_ENABLE                       (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0004))
+#define BLE_HCI_OCF_VS_CSS_ENABLE (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0004))
 struct ble_hci_vs_css_enable_cp {
-    uint8_t enable;
+	uint8_t enable;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_CSS_SET_NEXT_SLOT                (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0005))
+#define BLE_HCI_OCF_VS_CSS_SET_NEXT_SLOT \
+	(MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0005))
 struct ble_hci_vs_css_set_next_slot_cp {
-    uint16_t slot_idx;
+	uint16_t slot_idx;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_CSS_SET_CONN_SLOT                (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0006))
+#define BLE_HCI_OCF_VS_CSS_SET_CONN_SLOT \
+	(MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0006))
 struct ble_hci_vs_css_set_conn_slot_cp {
-    uint16_t conn_handle;
-    uint16_t slot_idx;
+	uint16_t conn_handle;
+	uint16_t slot_idx;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_CSS_READ_CONN_SLOT               (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0007))
+#define BLE_HCI_OCF_VS_CSS_READ_CONN_SLOT \
+	(MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0007))
 struct ble_hci_vs_css_read_conn_slot_cp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 struct ble_hci_vs_css_read_conn_slot_rp {
-    uint16_t conn_handle;
-    uint16_t slot_idx;
+	uint16_t conn_handle;
+	uint16_t slot_idx;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_SET_DATA_LEN                     (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0008))
+#define BLE_HCI_OCF_VS_SET_DATA_LEN (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0008))
 struct ble_hci_vs_set_data_len_cp {
-    uint16_t conn_handle;
-    uint16_t tx_octets;
-    uint16_t tx_time;
-    uint16_t rx_octets;
-    uint16_t rx_time;
+	uint16_t conn_handle;
+	uint16_t tx_octets;
+	uint16_t tx_time;
+	uint16_t rx_octets;
+	uint16_t rx_time;
 } __attribute__((packed));
 struct ble_hci_vs_set_data_len_rp {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_SET_ANTENNA                     (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0009))
+#define BLE_HCI_OCF_VS_SET_ANTENNA (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0009))
 struct ble_hci_vs_set_antenna_cp {
-    uint8_t antenna;
+	uint8_t antenna;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_SET_LOCAL_IRK                   (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x000A))
+#define BLE_HCI_OCF_VS_SET_LOCAL_IRK (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x000A))
 struct ble_hci_vs_set_local_irk_cp {
-    uint8_t own_addr_type;
-    uint8_t irk[16];
+	uint8_t own_addr_type;
+	uint8_t irk[16];
 } __attribute__((packed));
 
 /* Command Specific Definitions */
 /* --- Set controller to host flow control (OGF 0x03, OCF 0x0031) --- */
-#define BLE_HCI_CTLR_TO_HOST_FC_OFF         (0)
-#define BLE_HCI_CTLR_TO_HOST_FC_ACL         (1)
-#define BLE_HCI_CTLR_TO_HOST_FC_SYNC        (2)
-#define BLE_HCI_CTLR_TO_HOST_FC_BOTH        (3)
+#define BLE_HCI_CTLR_TO_HOST_FC_OFF (0)
+#define BLE_HCI_CTLR_TO_HOST_FC_ACL (1)
+#define BLE_HCI_CTLR_TO_HOST_FC_SYNC (2)
+#define BLE_HCI_CTLR_TO_HOST_FC_BOTH (3)
 
 /* --- LE set advertising parameters (OCF 0x0006) */
 /* Advertising types */
-#define BLE_HCI_ADV_TYPE_ADV_IND            (0)
-#define BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD  (1)
-#define BLE_HCI_ADV_TYPE_ADV_SCAN_IND       (2)
-#define BLE_HCI_ADV_TYPE_ADV_NONCONN_IND    (3)
-#define BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD  (4)
-#define BLE_HCI_ADV_TYPE_MAX                (4)
-
-#define BLE_HCI_ADV_CONN_MASK               (0x0001)
-#define BLE_HCI_ADV_SCAN_MASK               (0x0002)
-#define BLE_HCI_ADV_DIRECT_MASK             (0x0004)
-#define BLE_HCI_ADV_SCAN_RSP_MASK           (0x0008)
-#define BLE_HCI_ADV_LEGACY_MASK             (0x0010)
-
-#define BLE_HCI_ADV_DATA_STATUS_COMPLETE    (0x0000)
-#define BLE_HCI_ADV_DATA_STATUS_INCOMPLETE  (0x0020)
-#define BLE_HCI_ADV_DATA_STATUS_TRUNCATED   (0x0040)
-#define BLE_HCI_ADV_DATA_STATUS_MASK        (0x0060)
+#define BLE_HCI_ADV_TYPE_ADV_IND (0)
+#define BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD (1)
+#define BLE_HCI_ADV_TYPE_ADV_SCAN_IND (2)
+#define BLE_HCI_ADV_TYPE_ADV_NONCONN_IND (3)
+#define BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD (4)
+#define BLE_HCI_ADV_TYPE_MAX (4)
+
+#define BLE_HCI_ADV_CONN_MASK (0x0001)
+#define BLE_HCI_ADV_SCAN_MASK (0x0002)
+#define BLE_HCI_ADV_DIRECT_MASK (0x0004)
+#define BLE_HCI_ADV_SCAN_RSP_MASK (0x0008)
+#define BLE_HCI_ADV_LEGACY_MASK (0x0010)
+
+#define BLE_HCI_ADV_DATA_STATUS_COMPLETE (0x0000)
+#define BLE_HCI_ADV_DATA_STATUS_INCOMPLETE (0x0020)
+#define BLE_HCI_ADV_DATA_STATUS_TRUNCATED (0x0040)
+#define BLE_HCI_ADV_DATA_STATUS_MASK (0x0060)
 
 /* Own address types */
-#define BLE_HCI_ADV_OWN_ADDR_PUBLIC         (0)
-#define BLE_HCI_ADV_OWN_ADDR_RANDOM         (1)
-#define BLE_HCI_ADV_OWN_ADDR_PRIV_PUB       (2)
-#define BLE_HCI_ADV_OWN_ADDR_PRIV_RAND      (3)
-#define BLE_HCI_ADV_OWN_ADDR_MAX            (3)
+#define BLE_HCI_ADV_OWN_ADDR_PUBLIC (0)
+#define BLE_HCI_ADV_OWN_ADDR_RANDOM (1)
+#define BLE_HCI_ADV_OWN_ADDR_PRIV_PUB (2)
+#define BLE_HCI_ADV_OWN_ADDR_PRIV_RAND (3)
+#define BLE_HCI_ADV_OWN_ADDR_MAX (3)
 
 /* Advertisement peer address Type */
-#define BLE_HCI_ADV_PEER_ADDR_PUBLIC        (0)
-#define BLE_HCI_ADV_PEER_ADDR_RANDOM        (1)
-#define BLE_HCI_ADV_PEER_ADDR_MAX           (1)
+#define BLE_HCI_ADV_PEER_ADDR_PUBLIC (0)
+#define BLE_HCI_ADV_PEER_ADDR_RANDOM (1)
+#define BLE_HCI_ADV_PEER_ADDR_MAX (1)
 
 /* --- LE advertising channel tx power (OCF 0x0007) */
-#define BLE_HCI_ADV_CHAN_TXPWR_MIN             (-20)
-#define BLE_HCI_ADV_CHAN_TXPWR_MAX             (10)
+#define BLE_HCI_ADV_CHAN_TXPWR_MIN (-20)
+#define BLE_HCI_ADV_CHAN_TXPWR_MAX (10)
 
 /* --- LE set scan enable (OCF 0x000c) */
 
 /* Connect peer address type */
-#define BLE_HCI_CONN_PEER_ADDR_PUBLIC        (0)
-#define BLE_HCI_CONN_PEER_ADDR_RANDOM        (1)
-#define BLE_HCI_CONN_PEER_ADDR_PUBLIC_IDENT  (2)
-#define BLE_HCI_CONN_PEER_ADDR_RANDOM_IDENT  (3)
-#define BLE_HCI_CONN_PEER_ADDR_MAX           (3)
+#define BLE_HCI_CONN_PEER_ADDR_PUBLIC (0)
+#define BLE_HCI_CONN_PEER_ADDR_RANDOM (1)
+#define BLE_HCI_CONN_PEER_ADDR_PUBLIC_IDENT (2)
+#define BLE_HCI_CONN_PEER_ADDR_RANDOM_IDENT (3)
+#define BLE_HCI_CONN_PEER_ADDR_MAX (3)
 
 /*
  * Advertising filter policy
@@ -1276,39 +1291,39 @@ struct ble_hci_vs_set_local_irk_cp {
  *  CONN: process all scan request but only connection requests from white list
  *  BOTH: ignore all scan and connection requests unless in white list.
  */
-#define BLE_HCI_ADV_FILT_NONE               (0)
-#define BLE_HCI_ADV_FILT_SCAN               (1)
-#define BLE_HCI_ADV_FILT_CONN               (2)
-#define BLE_HCI_ADV_FILT_BOTH               (3)
-#define BLE_HCI_ADV_FILT_MAX                (3)
+#define BLE_HCI_ADV_FILT_NONE (0)
+#define BLE_HCI_ADV_FILT_SCAN (1)
+#define BLE_HCI_ADV_FILT_CONN (2)
+#define BLE_HCI_ADV_FILT_BOTH (3)
+#define BLE_HCI_ADV_FILT_MAX (3)
 
-#define BLE_HCI_ADV_FILT_DEF                (BLE_HCI_ADV_FILT_NONE)
+#define BLE_HCI_ADV_FILT_DEF (BLE_HCI_ADV_FILT_NONE)
 
 /* Advertising interval */
-#define BLE_HCI_ADV_ITVL                    (625)           /* usecs */
-#define BLE_HCI_ADV_ITVL_MIN                (32)            /* units */
-#define BLE_HCI_ADV_ITVL_MAX                (16384)         /* units */
-#define BLE_HCI_ADV_ITVL_NONCONN_MIN        (160)           /* units */
+#define BLE_HCI_ADV_ITVL (625)             /* usecs */
+#define BLE_HCI_ADV_ITVL_MIN (32)          /* units */
+#define BLE_HCI_ADV_ITVL_MAX (16384)       /* units */
+#define BLE_HCI_ADV_ITVL_NONCONN_MIN (160) /* units */
 
-#define BLE_HCI_ADV_ITVL_DEF                (0x800)         /* 1.28 seconds */
-#define BLE_HCI_ADV_CHANMASK_DEF            (0x7)           /* all channels */
+#define BLE_HCI_ADV_ITVL_DEF (0x800)   /* 1.28 seconds */
+#define BLE_HCI_ADV_CHANMASK_DEF (0x7) /* all channels */
 
-#define BLE_HCI_PERIODIC_ADV_ITVL           (1250)          /* usecs */
+#define BLE_HCI_PERIODIC_ADV_ITVL (1250) /* usecs */
 
 /* Set scan parameters */
-#define BLE_HCI_SCAN_TYPE_PASSIVE           (0)
-#define BLE_HCI_SCAN_TYPE_ACTIVE            (1)
+#define BLE_HCI_SCAN_TYPE_PASSIVE (0)
+#define BLE_HCI_SCAN_TYPE_ACTIVE (1)
 
 /* Scan interval and scan window timing */
-#define BLE_HCI_SCAN_ITVL                   (625)           /* usecs */
-#define BLE_HCI_SCAN_ITVL_MIN               (0x0004)        /* units */
-#define BLE_HCI_SCAN_ITVL_MAX               (0x4000)        /* units */
-#define BLE_HCI_SCAN_ITVL_MAX_EXT           (0xffff)        /* units */
-#define BLE_HCI_SCAN_ITVL_DEF               (16)            /* units */
-#define BLE_HCI_SCAN_WINDOW_MIN             (0x0004)        /* units */
-#define BLE_HCI_SCAN_WINDOW_MAX             (0x4000)        /* units */
-#define BLE_HCI_SCAN_WINDOW_MAX_EXT         (0xffff)        /* units */
-#define BLE_HCI_SCAN_WINDOW_DEF             (16)            /* units */
+#define BLE_HCI_SCAN_ITVL (625)              /* usecs */
+#define BLE_HCI_SCAN_ITVL_MIN (0x0004)       /* units */
+#define BLE_HCI_SCAN_ITVL_MAX (0x4000)       /* units */
+#define BLE_HCI_SCAN_ITVL_MAX_EXT (0xffff)   /* units */
+#define BLE_HCI_SCAN_ITVL_DEF (16)           /* units */
+#define BLE_HCI_SCAN_WINDOW_MIN (0x0004)     /* units */
+#define BLE_HCI_SCAN_WINDOW_MAX (0x4000)     /* units */
+#define BLE_HCI_SCAN_WINDOW_MAX_EXT (0xffff) /* units */
+#define BLE_HCI_SCAN_WINDOW_DEF (16)         /* units */
 
 /*
  * Scanning filter policy
@@ -1327,731 +1342,732 @@ struct ble_hci_vs_set_local_irk_cp {
  *      directed advertisement shall not be ignored if the InitA is a
  *      resolvable private address.
  */
-#define BLE_HCI_SCAN_FILT_NO_WL             (0)
-#define BLE_HCI_SCAN_FILT_USE_WL            (1)
-#define BLE_HCI_SCAN_FILT_NO_WL_INITA       (2)
-#define BLE_HCI_SCAN_FILT_USE_WL_INITA      (3)
-#define BLE_HCI_SCAN_FILT_MAX               (3)
+#define BLE_HCI_SCAN_FILT_NO_WL (0)
+#define BLE_HCI_SCAN_FILT_USE_WL (1)
+#define BLE_HCI_SCAN_FILT_NO_WL_INITA (2)
+#define BLE_HCI_SCAN_FILT_USE_WL_INITA (3)
+#define BLE_HCI_SCAN_FILT_MAX (3)
 
 /* Whitelist commands */
-#define BLE_HCI_ADD_WHITE_LIST_LEN          (7)
-#define BLE_HCI_RMV_WHITE_LIST_LEN          (7)
+#define BLE_HCI_ADD_WHITE_LIST_LEN (7)
+#define BLE_HCI_RMV_WHITE_LIST_LEN (7)
 
 /* Create Connection */
-#define BLE_HCI_CREATE_CONN_LEN             (25)
-#define BLE_HCI_CONN_ITVL                   (1250)  /* usecs */
-#define BLE_HCI_CONN_FILT_NO_WL             (0)
-#define BLE_HCI_CONN_FILT_USE_WL            (1)
-#define BLE_HCI_CONN_FILT_MAX               (1)
-#define BLE_HCI_CONN_ITVL_MIN               (0x0006)
-#define BLE_HCI_CONN_ITVL_MAX               (0x0c80)
-#define BLE_HCI_CONN_LATENCY_MIN            (0x0000)
-#define BLE_HCI_CONN_LATENCY_MAX            (0x01f3)
-#define BLE_HCI_CONN_SPVN_TIMEOUT_MIN       (0x000a)
-#define BLE_HCI_CONN_SPVN_TIMEOUT_MAX       (0x0c80)
-#define BLE_HCI_CONN_SPVN_TMO_UNITS         (10)    /* msecs */
-#define BLE_HCI_INITIATOR_FILT_POLICY_MAX   (1)
+#define BLE_HCI_CREATE_CONN_LEN (25)
+#define BLE_HCI_CONN_ITVL (1250) /* usecs */
+#define BLE_HCI_CONN_FILT_NO_WL (0)
+#define BLE_HCI_CONN_FILT_USE_WL (1)
+#define BLE_HCI_CONN_FILT_MAX (1)
+#define BLE_HCI_CONN_ITVL_MIN (0x0006)
+#define BLE_HCI_CONN_ITVL_MAX (0x0c80)
+#define BLE_HCI_CONN_LATENCY_MIN (0x0000)
+#define BLE_HCI_CONN_LATENCY_MAX (0x01f3)
+#define BLE_HCI_CONN_SPVN_TIMEOUT_MIN (0x000a)
+#define BLE_HCI_CONN_SPVN_TIMEOUT_MAX (0x0c80)
+#define BLE_HCI_CONN_SPVN_TMO_UNITS (10) /* msecs */
+#define BLE_HCI_INITIATOR_FILT_POLICY_MAX (1)
 
 /* Peer Address Type */
-#define BLE_HCI_CONN_PEER_ADDR_PUBLIC       (0)
-#define BLE_HCI_CONN_PEER_ADDR_RANDOM       (1)
-#define BLE_HCI_CONN_PEER_ADDR_PUB_ID       (2)
-#define BLE_HCI_CONN_PEER_ADDR_RAND_ID      (3)
-#define BLE_HCI_CONN_PEER_ADDR_MAX          (3)
+#define BLE_HCI_CONN_PEER_ADDR_PUBLIC (0)
+#define BLE_HCI_CONN_PEER_ADDR_RANDOM (1)
+#define BLE_HCI_CONN_PEER_ADDR_PUB_ID (2)
+#define BLE_HCI_CONN_PEER_ADDR_RAND_ID (3)
+#define BLE_HCI_CONN_PEER_ADDR_MAX (3)
 
 
 /* --- LE set data length (OCF 0x0022) */
-#define BLE_HCI_SET_DATALEN_TX_OCTETS_MIN   (0x001b)
-#define BLE_HCI_SET_DATALEN_TX_OCTETS_MAX   (0x00fb)
-#define BLE_HCI_SET_DATALEN_TX_TIME_MIN     (0x0148)
-#define BLE_HCI_SET_DATALEN_TX_TIME_MAX     (0x4290)
+#define BLE_HCI_SET_DATALEN_TX_OCTETS_MIN (0x001b)
+#define BLE_HCI_SET_DATALEN_TX_OCTETS_MAX (0x00fb)
+#define BLE_HCI_SET_DATALEN_TX_TIME_MIN (0x0148)
+#define BLE_HCI_SET_DATALEN_TX_TIME_MAX (0x4290)
 
 /* --- LE read/write suggested default data length (OCF 0x0023 and 0x0024) */
-#define BLE_HCI_SUGG_DEF_DATALEN_TX_OCTETS_MIN      (0x001b)
-#define BLE_HCI_SUGG_DEF_DATALEN_TX_OCTETS_MAX      (0x00fb)
-#define BLE_HCI_SUGG_DEF_DATALEN_TX_TIME_MIN        (0x0148)
-#define BLE_HCI_SUGG_DEF_DATALEN_TX_TIME_MAX        (0x4290)
+#define BLE_HCI_SUGG_DEF_DATALEN_TX_OCTETS_MIN (0x001b)
+#define BLE_HCI_SUGG_DEF_DATALEN_TX_OCTETS_MAX (0x00fb)
+#define BLE_HCI_SUGG_DEF_DATALEN_TX_TIME_MIN (0x0148)
+#define BLE_HCI_SUGG_DEF_DATALEN_TX_TIME_MAX (0x4290)
 
 /* --- LE read maximum default PHY (OCF 0x0030) */
-#define BLE_HCI_LE_PHY_1M                   (1)
-#define BLE_HCI_LE_PHY_2M                   (2)
-#define BLE_HCI_LE_PHY_CODED                (3)
+#define BLE_HCI_LE_PHY_1M (1)
+#define BLE_HCI_LE_PHY_2M (2)
+#define BLE_HCI_LE_PHY_CODED (3)
 
 /* --- LE set default PHY (OCF 0x0031) */
-#define BLE_HCI_LE_PHY_NO_TX_PREF_MASK              (0x01)
-#define BLE_HCI_LE_PHY_NO_RX_PREF_MASK              (0x02)
-#define BLE_HCI_LE_PHY_1M_PREF_MASK                 (0x01)
-#define BLE_HCI_LE_PHY_2M_PREF_MASK                 (0x02)
-#define BLE_HCI_LE_PHY_CODED_PREF_MASK              (0x04)
+#define BLE_HCI_LE_PHY_NO_TX_PREF_MASK (0x01)
+#define BLE_HCI_LE_PHY_NO_RX_PREF_MASK (0x02)
+#define BLE_HCI_LE_PHY_1M_PREF_MASK (0x01)
+#define BLE_HCI_LE_PHY_2M_PREF_MASK (0x02)
+#define BLE_HCI_LE_PHY_CODED_PREF_MASK (0x04)
 
-#define BLE_HCI_LE_PHY_PREF_MASK_ALL                \
-    (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |  \
-     BLE_HCI_LE_PHY_CODED_PREF_MASK)
+#define BLE_HCI_LE_PHY_PREF_MASK_ALL                           \
+	(BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK | \
+	 BLE_HCI_LE_PHY_CODED_PREF_MASK)
 
 /* --- LE set PHY (OCF 0x0032) */
-#define BLE_HCI_LE_PHY_CODED_ANY                    (0x0000)
-#define BLE_HCI_LE_PHY_CODED_S2_PREF                (0x0001)
-#define BLE_HCI_LE_PHY_CODED_S8_PREF                (0x0002)
+#define BLE_HCI_LE_PHY_CODED_ANY (0x0000)
+#define BLE_HCI_LE_PHY_CODED_S2_PREF (0x0001)
+#define BLE_HCI_LE_PHY_CODED_S8_PREF (0x0002)
 
 /* --- LE enhanced receiver test (OCF 0x0033) */
-#define BLE_HCI_LE_PHY_1M                           (1)
-#define BLE_HCI_LE_PHY_2M                           (2)
-#define BLE_HCI_LE_PHY_CODED                        (3)
+#define BLE_HCI_LE_PHY_1M (1)
+#define BLE_HCI_LE_PHY_2M (2)
+#define BLE_HCI_LE_PHY_CODED (3)
 
 /* --- LE enhanced transmitter test (OCF 0x0034) */
-#define BLE_HCI_LE_PHY_CODED_S8                     (3)
-#define BLE_HCI_LE_PHY_CODED_S2                     (4)
+#define BLE_HCI_LE_PHY_CODED_S8 (3)
+#define BLE_HCI_LE_PHY_CODED_S2 (4)
 
 /* --- LE set extended advertising parameters (OCF 0x0036) */
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_CONNECTABLE     (0x0001)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_SCANNABLE       (0x0002)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_DIRECTED        (0x0004)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_HD_DIRECTED     (0x0008)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY          (0x0010)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_ANON_ADV        (0x0020)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_INC_TX_PWR      (0x0040)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_MASK            (0x7F)
-
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND      (0x0013)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR   (0x0015)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR   (0x001d)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN     (0x0012)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN  (0x0010)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_CONNECTABLE (0x0001)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_SCANNABLE (0x0002)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_DIRECTED (0x0004)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_HD_DIRECTED (0x0008)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY (0x0010)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_ANON_ADV (0x0020)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_INC_TX_PWR (0x0040)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_MASK (0x7F)
+
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND (0x0013)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR (0x0015)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR (0x001d)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN (0x0012)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN (0x0010)
 
 /* --- LE set extended advertising data (OCF 0x0037) */
-#define BLE_HCI_MAX_EXT_ADV_DATA_LEN                (251)
+#define BLE_HCI_MAX_EXT_ADV_DATA_LEN (251)
 
-#define BLE_HCI_LE_SET_DATA_OPER_INT        (0)
-#define BLE_HCI_LE_SET_DATA_OPER_FIRST      (1)
-#define BLE_HCI_LE_SET_DATA_OPER_LAST       (2)
-#define BLE_HCI_LE_SET_DATA_OPER_COMPLETE   (3)
-#define BLE_HCI_LE_SET_DATA_OPER_UNCHANGED  (4)
+#define BLE_HCI_LE_SET_DATA_OPER_INT (0)
+#define BLE_HCI_LE_SET_DATA_OPER_FIRST (1)
+#define BLE_HCI_LE_SET_DATA_OPER_LAST (2)
+#define BLE_HCI_LE_SET_DATA_OPER_COMPLETE (3)
+#define BLE_HCI_LE_SET_DATA_OPER_UNCHANGED (4)
 
 /* --- LE set extended scan response data (OCF 0x0038) */
-#define BLE_HCI_MAX_EXT_SCAN_RSP_DATA_LEN           (251)
+#define BLE_HCI_MAX_EXT_SCAN_RSP_DATA_LEN (251)
 
 /* --- LE set periodic advertising parameters (OCF 0x003E) */
 #define BLE_HCI_LE_SET_PERIODIC_ADV_PROP_INC_TX_PWR (0x0040)
-#define BLE_HCI_LE_SET_PERIODIC_ADV_PROP_MASK       (0x0040)
+#define BLE_HCI_LE_SET_PERIODIC_ADV_PROP_MASK (0x0040)
 
 /* --- LE set periodic advertising data (OCF 0x003F) */
-#define BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN                (252)
+#define BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN (252)
 
 /* --- LE remove device from periodic advertising list (OCF 0x0048) */
-#define BLE_HCI_PERIODIC_DATA_STATUS_COMPLETE   0x00
+#define BLE_HCI_PERIODIC_DATA_STATUS_COMPLETE 0x00
 #define BLE_HCI_PERIODIC_DATA_STATUS_INCOMPLETE 0x01
-#define BLE_HCI_PERIODIC_DATA_STATUS_TRUNCATED  0x02
+#define BLE_HCI_PERIODIC_DATA_STATUS_TRUNCATED 0x02
 
 /* --- LE set privacy mode (OCF 0x004E) */
-#define BLE_HCI_PRIVACY_NETWORK                     (0)
-#define BLE_HCI_PRIVACY_DEVICE                      (1)
+#define BLE_HCI_PRIVACY_NETWORK (0)
+#define BLE_HCI_PRIVACY_DEVICE (1)
 
 /* Event Codes */
-#define BLE_HCI_EVCODE_INQUIRY_CMP          (0x01)
-#define BLE_HCI_EVCODE_INQUIRY_RESULT       (0x02)
-#define BLE_HCI_EVCODE_CONN_DONE            (0x03)
-#define BLE_HCI_EVCODE_CONN_REQUEST         (0x04)
-#define BLE_HCI_EVCODE_DISCONN_CMP          (0x05)
+#define BLE_HCI_EVCODE_INQUIRY_CMP (0x01)
+#define BLE_HCI_EVCODE_INQUIRY_RESULT (0x02)
+#define BLE_HCI_EVCODE_CONN_DONE (0x03)
+#define BLE_HCI_EVCODE_CONN_REQUEST (0x04)
+#define BLE_HCI_EVCODE_DISCONN_CMP (0x05)
 struct ble_hci_ev_disconn_cmp {
-    uint8_t status;
-    uint16_t conn_handle;
-    uint8_t reason;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_AUTH_CMP             (0x06)
-#define BLE_HCI_EVCODE_REM_NAME_REQ_CMP     (0x07)
+#define BLE_HCI_EVCODE_AUTH_CMP (0x06)
+#define BLE_HCI_EVCODE_REM_NAME_REQ_CMP (0x07)
 
-#define BLE_HCI_EVCODE_ENCRYPT_CHG          (0x08)
+#define BLE_HCI_EVCODE_ENCRYPT_CHG (0x08)
 struct ble_hci_ev_enrypt_chg {
-    uint8_t status;
-    uint16_t connection_handle;
-    uint8_t enabled;
+	uint8_t status;
+	uint16_t connection_handle;
+	uint8_t enabled;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_CHG_LINK_KEY_CMP     (0x09)
-#define BLE_HCI_EVCODE_MASTER_LINK_KEY_CMP  (0x0A)
+#define BLE_HCI_EVCODE_CHG_LINK_KEY_CMP (0x09)
+#define BLE_HCI_EVCODE_MASTER_LINK_KEY_CMP (0x0A)
 #define BLE_HCI_EVCODE_RD_REM_SUPP_FEAT_CMP (0x0B)
-#define BLE_HCI_EVCODE_RD_REM_VER_INFO_CMP  (0x0C)
+#define BLE_HCI_EVCODE_RD_REM_VER_INFO_CMP (0x0C)
 struct ble_hci_ev_rd_rem_ver_info_cmp {
-    uint8_t  status;
-    uint16_t conn_handle;
-    uint8_t  version;
-    uint16_t manufacturer;
-    uint16_t subversion;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint8_t version;
+	uint16_t manufacturer;
+	uint16_t subversion;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_QOS_SETUP_CMP        (0x0D)
+#define BLE_HCI_EVCODE_QOS_SETUP_CMP (0x0D)
 
-#define BLE_HCI_EVCODE_COMMAND_COMPLETE     (0x0E)
+#define BLE_HCI_EVCODE_COMMAND_COMPLETE (0x0E)
 struct ble_hci_ev_command_complete {
-    uint8_t  num_packets;
-    uint16_t opcode;
-    uint8_t  status;
-    uint8_t  return_params[0];
+	uint8_t num_packets;
+	uint16_t opcode;
+	uint8_t status;
+	uint8_t return_params[0];
 } __attribute__((packed));
 /* NOP is exception and has no return parameters */
 struct ble_hci_ev_command_complete_nop {
-    uint8_t  num_packets;
-    uint16_t opcode;
+	uint8_t num_packets;
+	uint16_t opcode;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_COMMAND_STATUS       (0x0F)
+#define BLE_HCI_EVCODE_COMMAND_STATUS (0x0F)
 struct ble_hci_ev_command_status {
-    uint8_t status;
-    uint8_t  num_packets;
-    uint16_t opcode;
+	uint8_t status;
+	uint8_t num_packets;
+	uint16_t opcode;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_HW_ERROR             (0x10)
+#define BLE_HCI_EVCODE_HW_ERROR (0x10)
 struct ble_hci_ev_hw_error {
-    uint8_t hw_code;
+	uint8_t hw_code;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_NUM_COMP_PKTS        (0x13)
+#define BLE_HCI_EVCODE_NUM_COMP_PKTS (0x13)
 struct comp_pkt {
-    uint16_t handle;
-    uint16_t packets;
-} __attribute__((packed));;
+	uint16_t handle;
+	uint16_t packets;
+} __attribute__((packed));
+;
 struct ble_hci_ev_num_comp_pkts {
-    uint8_t count;
-    struct comp_pkt completed[0];
+	uint8_t count;
+	struct comp_pkt completed[0];
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_MODE_CHANGE          (0x14)
-#define BLE_HCI_EVCODE_RETURN_LINK_KEYS     (0x15)
-#define BLE_HCI_EVCODE_PIN_CODE_REQ         (0x16)
-#define BLE_HCI_EVCODE_LINK_KEY_REQ         (0x17)
-#define BLE_HCI_EVCODE_LINK_KEY_NOTIFY      (0x18)
-#define BLE_HCI_EVCODE_LOOPBACK_CMD         (0x19)
+#define BLE_HCI_EVCODE_MODE_CHANGE (0x14)
+#define BLE_HCI_EVCODE_RETURN_LINK_KEYS (0x15)
+#define BLE_HCI_EVCODE_PIN_CODE_REQ (0x16)
+#define BLE_HCI_EVCODE_LINK_KEY_REQ (0x17)
+#define BLE_HCI_EVCODE_LINK_KEY_NOTIFY (0x18)
+#define BLE_HCI_EVCODE_LOOPBACK_CMD (0x19)
 
-#define BLE_HCI_EVCODE_DATA_BUF_OVERFLOW    (0x1A)
+#define BLE_HCI_EVCODE_DATA_BUF_OVERFLOW (0x1A)
 struct ble_hci_ev_data_buf_overflow {
-    uint8_t link_type;
+	uint8_t link_type;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_MAX_SLOTS_CHG        (0x1B)
-#define BLE_HCI_EVCODE_READ_CLK_OFF_COMP    (0x1C)
-#define BLE_HCI_EVCODE_CONN_PKT_TYPE_CHG    (0x1D)
-#define BLE_HCI_EVCODE_QOS_VIOLATION        (0x1E)
+#define BLE_HCI_EVCODE_MAX_SLOTS_CHG (0x1B)
+#define BLE_HCI_EVCODE_READ_CLK_OFF_COMP (0x1C)
+#define BLE_HCI_EVCODE_CONN_PKT_TYPE_CHG (0x1D)
+#define BLE_HCI_EVCODE_QOS_VIOLATION (0x1E)
 /* NOTE: 0x1F not defined */
-#define BLE_HCI_EVCODE_PSR_MODE_CHG         (0x20)
-#define BLE_HCI_EVCODE_FLOW_SPEC_COMP       (0x21)
-#define BLE_HCI_EVCODE_INQ_RESULT_RSSI      (0x22)
-#define BLE_HCI_EVCODE_READ_REM_EXT_FEAT    (0x23)
+#define BLE_HCI_EVCODE_PSR_MODE_CHG (0x20)
+#define BLE_HCI_EVCODE_FLOW_SPEC_COMP (0x21)
+#define BLE_HCI_EVCODE_INQ_RESULT_RSSI (0x22)
+#define BLE_HCI_EVCODE_READ_REM_EXT_FEAT (0x23)
 /* NOTE: 0x24 - 0x2B not defined */
-#define BLE_HCI_EVCODE_SYNCH_CONN_COMP      (0x2C)
-#define BLE_HCI_EVCODE_SYNCH_CONN_CHG       (0x2D)
-#define BLE_HCI_EVCODE_SNIFF_SUBRATING      (0x2E)
-#define BLE_HCI_EVCODE_EXT_INQ_RESULT       (0x2F)
+#define BLE_HCI_EVCODE_SYNCH_CONN_COMP (0x2C)
+#define BLE_HCI_EVCODE_SYNCH_CONN_CHG (0x2D)
+#define BLE_HCI_EVCODE_SNIFF_SUBRATING (0x2E)
+#define BLE_HCI_EVCODE_EXT_INQ_RESULT (0x2F)
 
-#define BLE_HCI_EVCODE_ENC_KEY_REFRESH      (0x30)
+#define BLE_HCI_EVCODE_ENC_KEY_REFRESH (0x30)
 struct ble_hci_ev_enc_key_refresh {
-    uint8_t status;
-    uint16_t conn_handle;
+	uint8_t status;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_EVOCDE_IO_CAP_REQ           (0x31)
-#define BLE_HCI_EVCODE_IO_CAP_RSP           (0x32)
-#define BLE_HCI_EVCODE_USER_CONFIRM_REQ     (0x33)
-#define BLE_HCI_EVCODE_PASSKEY_REQ          (0x34)
-#define BLE_HCI_EVCODE_REM_OOB_DATA_REQ     (0x35)
-#define BLE_HCI_EVCODE_SIMPLE_PAIR_COMP     (0x36)
+#define BLE_HCI_EVOCDE_IO_CAP_REQ (0x31)
+#define BLE_HCI_EVCODE_IO_CAP_RSP (0x32)
+#define BLE_HCI_EVCODE_USER_CONFIRM_REQ (0x33)
+#define BLE_HCI_EVCODE_PASSKEY_REQ (0x34)
+#define BLE_HCI_EVCODE_REM_OOB_DATA_REQ (0x35)
+#define BLE_HCI_EVCODE_SIMPLE_PAIR_COMP (0x36)
 /* NOTE: 0x37 not defined */
-#define BLE_HCI_EVCODE_LNK_SPVN_TMO_CHG     (0x38)
-#define BLE_HCI_EVCODE_ENH_FLUSH_COMP       (0x39)
-#define BLE_HCI_EVCODE_USER_PASSKEY_NOTIFY  (0x3B)
-#define BLE_HCI_EVCODE_KEYPRESS_NOTIFY      (0x3C)
-#define BLE_HCI_EVCODE_REM_HOST_SUPP_FEAT   (0x3D)
+#define BLE_HCI_EVCODE_LNK_SPVN_TMO_CHG (0x38)
+#define BLE_HCI_EVCODE_ENH_FLUSH_COMP (0x39)
+#define BLE_HCI_EVCODE_USER_PASSKEY_NOTIFY (0x3B)
+#define BLE_HCI_EVCODE_KEYPRESS_NOTIFY (0x3C)
+#define BLE_HCI_EVCODE_REM_HOST_SUPP_FEAT (0x3D)
 
-#define BLE_HCI_EVCODE_LE_META              (0x3E)
+#define BLE_HCI_EVCODE_LE_META (0x3E)
 struct ble_hci_ev_le_meta {
-    uint8_t subevent;
-    uint8_t data[0];
+	uint8_t subevent;
+	uint8_t data[0];
 } __attribute__((packed));
 
 /* NOTE: 0x3F not defined */
-#define BLE_HCI_EVCODE_PHYS_LINK_COMP       (0x40)
-#define BLE_HCI_EVCODE_CHAN_SELECTED        (0x41)
-#define BLE_HCI_EVCODE_DISCONN_PHYS_LINK    (0x42)
+#define BLE_HCI_EVCODE_PHYS_LINK_COMP (0x40)
+#define BLE_HCI_EVCODE_CHAN_SELECTED (0x41)
+#define BLE_HCI_EVCODE_DISCONN_PHYS_LINK (0x42)
 #define BLE_HCI_EVCODE_PHYS_LINK_LOSS_EARLY (0x43)
-#define BLE_HCI_EVCODE_PHYS_LINK_RECOVERY   (0x44)
-#define BLE_HCI_EVCODE_LOGICAL_LINK_COMP    (0x45)
+#define BLE_HCI_EVCODE_PHYS_LINK_RECOVERY (0x44)
+#define BLE_HCI_EVCODE_LOGICAL_LINK_COMP (0x45)
 #define BLE_HCI_EVCODE_DISCONN_LOGICAL_LINK (0x46)
-#define BLE_HCI_EVCODE_FLOW_SPEC_MODE_COMP  (0x47)
-#define BLE_HCI_EVCODE_NUM_COMP_DATA_BLKS   (0x48)
-#define BLE_HCI_EVCODE_AMP_START_TEST       (0x49)
-#define BLE_HCI_EVOCDE_AMP_TEST_END         (0x4A)
-#define BLE_HCI_EVOCDE_AMP_RCVR_REPORT      (0x4B)
+#define BLE_HCI_EVCODE_FLOW_SPEC_MODE_COMP (0x47)
+#define BLE_HCI_EVCODE_NUM_COMP_DATA_BLKS (0x48)
+#define BLE_HCI_EVCODE_AMP_START_TEST (0x49)
+#define BLE_HCI_EVOCDE_AMP_TEST_END (0x4A)
+#define BLE_HCI_EVOCDE_AMP_RCVR_REPORT (0x4B)
 #define BLE_HCI_EVCODE_SHORT_RANGE_MODE_CHG (0x4C)
-#define BLE_HCI_EVCODE_AMP_STATUS_CHG       (0x4D)
-#define BLE_HCI_EVCODE_TRIG_CLK_CAPTURE     (0x4E)
-#define BLE_HCI_EVCODE_SYNCH_TRAIN_COMP     (0x4F)
-#define BLE_HCI_EVCODE_SYNCH_TRAIN_RCVD     (0x50)
-#define BLE_HCI_EVCODE_SLAVE_BCAST_RX       (0x51)
-#define BLE_HCI_EVCODE_SLAVE_BCAST_TMO      (0x52)
-#define BLE_HCI_EVCODE_TRUNC_PAGE_COMP      (0x53)
-#define BLE_HCI_EVCODE_SLAVE_PAGE_RSP_TMO   (0x54)
+#define BLE_HCI_EVCODE_AMP_STATUS_CHG (0x4D)
+#define BLE_HCI_EVCODE_TRIG_CLK_CAPTURE (0x4E)
+#define BLE_HCI_EVCODE_SYNCH_TRAIN_COMP (0x4F)
+#define BLE_HCI_EVCODE_SYNCH_TRAIN_RCVD (0x50)
+#define BLE_HCI_EVCODE_SLAVE_BCAST_RX (0x51)
+#define BLE_HCI_EVCODE_SLAVE_BCAST_TMO (0x52)
+#define BLE_HCI_EVCODE_TRUNC_PAGE_COMP (0x53)
+#define BLE_HCI_EVCODE_SLAVE_PAGE_RSP_TMO (0x54)
 #define BLE_HCI_EVCODE_SLAVE_BCAST_CHAN_MAP (0x55)
-#define BLE_HCI_EVCODE_INQ_RSP_NOTIFY       (0x56)
+#define BLE_HCI_EVCODE_INQ_RSP_NOTIFY (0x56)
 
-#define BLE_HCI_EVCODE_AUTH_PYLD_TMO        (0x57)
+#define BLE_HCI_EVCODE_AUTH_PYLD_TMO (0x57)
 struct ble_hci_ev_auth_pyld_tmo {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_SAM_STATUS_CHG       (0x58)
+#define BLE_HCI_EVCODE_SAM_STATUS_CHG (0x58)
 
-#define BLE_HCI_EVCODE_VS                   (0xff)
+#define BLE_HCI_EVCODE_VS (0xff)
 struct ble_hci_ev_vs {
-    uint8_t id;
-    uint8_t data[0];
+	uint8_t id;
+	uint8_t data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_VS_SUBEV_ID_ASSERT              (0x01)
-#define BLE_HCI_VS_SUBEV_ID_CSS_SLOT_CHANGED    (0x02)
+#define BLE_HCI_VS_SUBEV_ID_ASSERT (0x01)
+#define BLE_HCI_VS_SUBEV_ID_CSS_SLOT_CHANGED (0x02)
 struct ble_hci_ev_vs_css_slot_changed {
-    uint16_t conn_handle;
-    uint16_t slot_idx;
+	uint16_t conn_handle;
+	uint16_t slot_idx;
 };
 
-#define BLE_HCI_VS_SUBEV_ISO_HCI_FEEDBACK       (0x03)
+#define BLE_HCI_VS_SUBEV_ISO_HCI_FEEDBACK (0x03)
 struct feedback_pkt {
-    uint16_t handle;
-    uint8_t sdu_per_interval;
-    int8_t diff;
+	uint16_t handle;
+	uint8_t sdu_per_interval;
+	int8_t diff;
 } __attribute__((packed));
 struct ble_hci_vs_subev_iso_hci_feedback {
-    uint8_t big_handle;
-    uint8_t count;
-    struct feedback_pkt feedback[0];
+	uint8_t big_handle;
+	uint8_t count;
+	struct feedback_pkt feedback[0];
 } __attribute__((packed));
 
-#define BLE_HCI_VS_SUBEV_ID_LLCP_TRACE          (0x17)
+#define BLE_HCI_VS_SUBEV_ID_LLCP_TRACE (0x17)
 
 /* LE sub-event codes */
-#define BLE_HCI_LE_SUBEV_CONN_COMPLETE          (0x01)
+#define BLE_HCI_LE_SUBEV_CONN_COMPLETE (0x01)
 struct ble_hci_ev_le_subev_conn_complete {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint16_t conn_handle;
-    uint8_t  role;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint16_t conn_itvl;
-    uint16_t conn_latency;
-    uint16_t supervision_timeout;
-    uint8_t  mca;
-} __attribute__((packed));
-
-#define BLE_HCI_LE_SUBEV_ADV_RPT                (0x02)
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint8_t role;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint16_t conn_itvl;
+	uint16_t conn_latency;
+	uint16_t supervision_timeout;
+	uint8_t mca;
+} __attribute__((packed));
+
+#define BLE_HCI_LE_SUBEV_ADV_RPT (0x02)
 struct adv_report {
-    uint8_t type;
-    uint8_t addr_type;
-    uint8_t addr[6];
-    uint8_t data_len;
-    uint8_t data[0];
+	uint8_t type;
+	uint8_t addr_type;
+	uint8_t addr[6];
+	uint8_t data_len;
+	uint8_t data[0];
 } __attribute__((packed));
 struct ble_hci_ev_le_subev_adv_rpt {
-    uint8_t  subev_code;
-    uint8_t  num_reports;
-    struct adv_report reports[0];
+	uint8_t subev_code;
+	uint8_t num_reports;
+	struct adv_report reports[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE      (0x03)
+#define BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE (0x03)
 struct ble_hci_ev_le_subev_conn_upd_complete {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint16_t conn_handle;
-    uint16_t conn_itvl;
-    uint16_t conn_latency;
-    uint16_t supervision_timeout;
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint16_t conn_itvl;
+	uint16_t conn_latency;
+	uint16_t supervision_timeout;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT       (0x04)
+#define BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT (0x04)
 struct ble_hci_ev_le_subev_rd_rem_used_feat {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint16_t conn_handle;
-    uint8_t features[8];
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint8_t features[8];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_LT_KEY_REQ             (0x05)
+#define BLE_HCI_LE_SUBEV_LT_KEY_REQ (0x05)
 struct ble_hci_ev_le_subev_lt_key_req {
-    uint8_t  subev_code;
-    uint16_t conn_handle;
-    uint64_t rand;
-    uint16_t div;
+	uint8_t subev_code;
+	uint16_t conn_handle;
+	uint64_t rand;
+	uint16_t div;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ      (0x06)
+#define BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ (0x06)
 struct ble_hci_ev_le_subev_rem_conn_param_req {
-    uint8_t  subev_code;
-    uint16_t conn_handle;
-    uint16_t min_interval;
-    uint16_t max_interval;
-    uint16_t latency;
-    uint16_t timeout;
+	uint8_t subev_code;
+	uint16_t conn_handle;
+	uint16_t min_interval;
+	uint16_t max_interval;
+	uint16_t latency;
+	uint16_t timeout;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_DATA_LEN_CHG           (0x07)
+#define BLE_HCI_LE_SUBEV_DATA_LEN_CHG (0x07)
 struct ble_hci_ev_le_subev_data_len_chg {
-    uint8_t  subev_code;
-    uint16_t conn_handle;
-    uint16_t max_tx_octets;
-    uint16_t max_tx_time;
-    uint16_t max_rx_octets;
-    uint16_t max_rx_time;
+	uint8_t subev_code;
+	uint16_t conn_handle;
+	uint16_t max_tx_octets;
+	uint16_t max_tx_time;
+	uint16_t max_rx_octets;
+	uint16_t max_rx_time;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_RD_LOC_P256_PUBKEY     (0x08)
+#define BLE_HCI_LE_SUBEV_RD_LOC_P256_PUBKEY (0x08)
 struct ble_hci_ev_le_subev_rd_loc_p256_pubkey {
-    uint8_t subev_code;
-    uint8_t status;
-    uint8_t public_key[64];
+	uint8_t subev_code;
+	uint8_t status;
+	uint8_t public_key[64];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_GEN_DHKEY_COMPLETE     (0x09)
+#define BLE_HCI_LE_SUBEV_GEN_DHKEY_COMPLETE (0x09)
 struct ble_hci_ev_le_subev_gen_dhkey_complete {
-    uint8_t subev_code;
-    uint8_t status;
-    uint8_t dh_key[32];
+	uint8_t subev_code;
+	uint8_t status;
+	uint8_t dh_key[32];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE      (0x0A)
+#define BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE (0x0A)
 struct ble_hci_ev_le_subev_enh_conn_complete {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint16_t conn_handle;
-    uint8_t  role;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint8_t  local_rpa[6];
-    uint8_t  peer_rpa[6];
-    uint16_t conn_itvl;
-    uint16_t conn_latency;
-    uint16_t supervision_timeout;
-    uint8_t  mca;
-} __attribute__((packed));
-
-#define BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT         (0x0B)
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint8_t role;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint8_t local_rpa[6];
+	uint8_t peer_rpa[6];
+	uint16_t conn_itvl;
+	uint16_t conn_latency;
+	uint16_t supervision_timeout;
+	uint8_t mca;
+} __attribute__((packed));
+
+#define BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT (0x0B)
 struct dir_adv_report {
-    uint8_t type;
-    uint8_t addr_type;
-    uint8_t addr[6];
-    uint8_t dir_addr_type;
-    uint8_t dir_addr[6];
-    int8_t  rssi;
+	uint8_t type;
+	uint8_t addr_type;
+	uint8_t addr[6];
+	uint8_t dir_addr_type;
+	uint8_t dir_addr[6];
+	int8_t rssi;
 } __attribute__((packed));
 struct ble_hci_ev_le_subev_direct_adv_rpt {
-    uint8_t subev_code;
-    uint8_t num_reports;
-    struct dir_adv_report reports[0];
+	uint8_t subev_code;
+	uint8_t num_reports;
+	struct dir_adv_report reports[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_PHY_UPDATE_COMPLETE    (0x0C)
+#define BLE_HCI_LE_SUBEV_PHY_UPDATE_COMPLETE (0x0C)
 struct ble_hci_ev_le_subev_phy_update_complete {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint16_t conn_handle;
-    uint8_t  tx_phy;
-    uint8_t  rx_phy;
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint8_t tx_phy;
+	uint8_t rx_phy;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_EXT_ADV_RPT            (0x0D)
+#define BLE_HCI_LE_SUBEV_EXT_ADV_RPT (0x0D)
 struct ext_adv_report {
-    uint16_t  evt_type;
-    uint8_t  addr_type;
-    uint8_t  addr[6];
-    uint8_t  pri_phy;
-    uint8_t  sec_phy;
-    uint8_t  sid;
-    int8_t   tx_power;
-    int8_t   rssi;
-    uint16_t periodic_itvl;
-    uint8_t  dir_addr_type;
-    uint8_t  dir_addr[6];
-    uint8_t  data_len;
-    uint8_t  data[0];
+	uint16_t evt_type;
+	uint8_t addr_type;
+	uint8_t addr[6];
+	uint8_t pri_phy;
+	uint8_t sec_phy;
+	uint8_t sid;
+	int8_t tx_power;
+	int8_t rssi;
+	uint16_t periodic_itvl;
+	uint8_t dir_addr_type;
+	uint8_t dir_addr[6];
+	uint8_t data_len;
+	uint8_t data[0];
 } __attribute__((packed));
 struct ble_hci_ev_le_subev_ext_adv_rpt {
-    uint8_t subev_code;
-    uint8_t num_reports;
-    struct ext_adv_report reports[0];
+	uint8_t subev_code;
+	uint8_t num_reports;
+	struct ext_adv_report reports[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_ESTAB     (0x0E)
+#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_ESTAB (0x0E)
 struct ble_hci_ev_le_subev_periodic_adv_sync_estab {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint16_t sync_handle;
-    uint8_t  sid;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint8_t  phy;
-    uint16_t interval;
-    uint8_t  aca;
-} __attribute__((packed));
-
-#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_RPT            (0x0F)
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t sync_handle;
+	uint8_t sid;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint8_t phy;
+	uint16_t interval;
+	uint8_t aca;
+} __attribute__((packed));
+
+#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_RPT (0x0F)
 struct ble_hci_ev_le_subev_periodic_adv_rpt {
-    uint8_t  subev_code;
-    uint16_t sync_handle;
-    int8_t   tx_power;
-    int8_t   rssi;
-    uint8_t  cte_type;
-    uint8_t  data_status;
-    uint8_t  data_len;
-    uint8_t  data[0];
+	uint8_t subev_code;
+	uint16_t sync_handle;
+	int8_t tx_power;
+	int8_t rssi;
+	uint8_t cte_type;
+	uint8_t data_status;
+	uint8_t data_len;
+	uint8_t data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_LOST      (0x10)
+#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_LOST (0x10)
 struct ble_hci_ev_le_subev_periodic_adv_sync_lost {
-    uint8_t  subev_code;
-    uint16_t sync_handle;
+	uint8_t subev_code;
+	uint16_t sync_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_SCAN_TIMEOUT           (0x11)
+#define BLE_HCI_LE_SUBEV_SCAN_TIMEOUT (0x11)
 struct ble_hci_ev_le_subev_scan_timeout {
-    uint8_t  subev_code;
+	uint8_t subev_code;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_ADV_SET_TERMINATED     (0x12)
+#define BLE_HCI_LE_SUBEV_ADV_SET_TERMINATED (0x12)
 struct ble_hci_ev_le_subev_adv_set_terminated {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint8_t  adv_handle;
-    uint16_t conn_handle;
-    uint8_t  num_events;
+	uint8_t subev_code;
+	uint8_t status;
+	uint8_t adv_handle;
+	uint16_t conn_handle;
+	uint8_t num_events;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_SCAN_REQ_RCVD          (0x13)
+#define BLE_HCI_LE_SUBEV_SCAN_REQ_RCVD (0x13)
 struct ble_hci_ev_le_subev_scan_req_rcvd {
-    uint8_t subev_code;
-    uint8_t adv_handle;
-    uint8_t peer_addr_type;
-    uint8_t peer_addr[6];
+	uint8_t subev_code;
+	uint8_t adv_handle;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CHAN_SEL_ALG           (0x14)
+#define BLE_HCI_LE_SUBEV_CHAN_SEL_ALG (0x14)
 struct ble_hci_ev_le_subev_chan_sel_alg {
-    uint8_t  subev_code;
-    uint16_t conn_handle;
-    uint8_t  csa;
+	uint8_t subev_code;
+	uint16_t conn_handle;
+	uint8_t csa;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CONNLESS_IQ_RPT        (0x15)
-#define BLE_HCI_LE_SUBEV_CONN_IQ_RPT            (0x16)
-#define BLE_HCI_LE_SUBEV_CTE_REQ_FAILED         (0x17)
+#define BLE_HCI_LE_SUBEV_CONNLESS_IQ_RPT (0x15)
+#define BLE_HCI_LE_SUBEV_CONN_IQ_RPT (0x16)
+#define BLE_HCI_LE_SUBEV_CTE_REQ_FAILED (0x17)
 
-#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_TRANSFER   (0x18)
+#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_TRANSFER (0x18)
 struct ble_hci_ev_le_subev_periodic_adv_sync_transfer {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint16_t conn_handle;
-    uint16_t service_data;
-    uint16_t sync_handle;
-    uint8_t  sid;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint8_t  phy;
-    uint16_t interval;
-    uint8_t  aca;
-} __attribute__((packed));
-
-#define BLE_HCI_LE_SUBEV_CIS_ESTABLISHED        (0x19)
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint16_t service_data;
+	uint16_t sync_handle;
+	uint8_t sid;
+	uint8_t peer_addr_type;
+	uint8_t peer_addr[6];
+	uint8_t phy;
+	uint16_t interval;
+	uint8_t aca;
+} __attribute__((packed));
+
+#define BLE_HCI_LE_SUBEV_CIS_ESTABLISHED (0x19)
 struct ble_hci_ev_le_subev_cis_established {
-    uint8_t subev_code;
-    uint8_t status;
-    uint16_t conn_handle;
-    uint8_t cig_sync_delay[3];
-    uint8_t cis_sync_delay[3];
-    uint8_t transport_latency_c_to_p[3];
-    uint8_t transport_latency_p_to_c[3];
-    uint8_t phy_c_to_p;
-    uint8_t phy_p_to_c;
-    uint8_t nse;
-    uint8_t bn_c_to_p;
-    uint8_t bn_p_to_c;
-    uint8_t ft_c_to_p;
-    uint8_t ft_p_to_c;
-    uint16_t max_pdu_c_to_p;
-    uint16_t max_pdu_p_to_c;
-    uint16_t iso_interval;
-} __attribute__((packed));
-
-#define BLE_HCI_LE_SUBEV_CIS_REQUEST            (0x1A)
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint8_t cig_sync_delay[3];
+	uint8_t cis_sync_delay[3];
+	uint8_t transport_latency_c_to_p[3];
+	uint8_t transport_latency_p_to_c[3];
+	uint8_t phy_c_to_p;
+	uint8_t phy_p_to_c;
+	uint8_t nse;
+	uint8_t bn_c_to_p;
+	uint8_t bn_p_to_c;
+	uint8_t ft_c_to_p;
+	uint8_t ft_p_to_c;
+	uint16_t max_pdu_c_to_p;
+	uint16_t max_pdu_p_to_c;
+	uint16_t iso_interval;
+} __attribute__((packed));
+
+#define BLE_HCI_LE_SUBEV_CIS_REQUEST (0x1A)
 struct ble_hci_ev_le_subev_cis_request {
-    uint8_t subev_code;
-    uint16_t acl_conn_handle;
-    uint16_t cis_conn_handle;
-    uint8_t cig_id;
-    uint8_t cis_id;
+	uint8_t subev_code;
+	uint16_t acl_conn_handle;
+	uint16_t cis_conn_handle;
+	uint8_t cig_id;
+	uint8_t cis_id;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CREATE_BIG_COMPLETE    (0x1B)
+#define BLE_HCI_LE_SUBEV_CREATE_BIG_COMPLETE (0x1B)
 struct ble_hci_ev_le_subev_create_big_complete {
-    uint8_t subev_code;
-    uint8_t status;
-    uint8_t big_handle;
-    uint8_t big_sync_delay[3];
-    uint8_t transport_latency_big[3];
-    uint8_t phy;
-    uint8_t nse;
-    uint8_t bn;
-    uint8_t pto;
-    uint8_t irc;
-    uint16_t max_pdu;
-    uint16_t iso_interval;
-    uint8_t num_bis;
-    uint16_t conn_handle[0];
+	uint8_t subev_code;
+	uint8_t status;
+	uint8_t big_handle;
+	uint8_t big_sync_delay[3];
+	uint8_t transport_latency_big[3];
+	uint8_t phy;
+	uint8_t nse;
+	uint8_t bn;
+	uint8_t pto;
+	uint8_t irc;
+	uint16_t max_pdu;
+	uint16_t iso_interval;
+	uint8_t num_bis;
+	uint16_t conn_handle[0];
 } __attribute__((packed));
 
 #define BLE_HCI_LE_SUBEV_TERMINATE_BIG_COMPLETE (0x1C)
 struct ble_hci_ev_le_subev_terminate_big_complete {
-    uint8_t subev_code;
-    uint8_t big_handle;
-    uint8_t reason;
+	uint8_t subev_code;
+	uint8_t big_handle;
+	uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_BIG_SYNC_ESTABLISHED    (0x1D)
+#define BLE_HCI_LE_SUBEV_BIG_SYNC_ESTABLISHED (0x1D)
 struct ble_hci_ev_le_subev_big_sync_established {
-    uint8_t subev_code;
-    uint8_t status;
-    uint8_t big_handle;
-    uint8_t transport_latency_big[3];
-    uint8_t nse;
-    uint8_t bn;
-    uint8_t pto;
-    uint8_t irc;
-    uint16_t max_pdu;
-    uint16_t iso_interval;
-    uint8_t num_bis;
-    uint16_t conn_handle[0];
-} __attribute__((packed));
-
-#define BLE_HCI_LE_SUBEV_BIG_SYNC_LOST          (0x1E)
+	uint8_t subev_code;
+	uint8_t status;
+	uint8_t big_handle;
+	uint8_t transport_latency_big[3];
+	uint8_t nse;
+	uint8_t bn;
+	uint8_t pto;
+	uint8_t irc;
+	uint16_t max_pdu;
+	uint16_t iso_interval;
+	uint8_t num_bis;
+	uint16_t conn_handle[0];
+} __attribute__((packed));
+
+#define BLE_HCI_LE_SUBEV_BIG_SYNC_LOST (0x1E)
 struct ble_hci_ev_le_subev_big_sync_lost {
-    uint8_t subev_code;
-    uint8_t big_handle;
-    uint8_t reason;
+	uint8_t subev_code;
+	uint8_t big_handle;
+	uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_REQ_PEER_SCA_COMP      (0x1F)
+#define BLE_HCI_LE_SUBEV_REQ_PEER_SCA_COMP (0x1F)
 struct ble_hci_ev_le_subev_peer_sca_complete {
-    uint8_t subev_code;
-    uint8_t status;
-    uint16_t conn_handle;
-    uint8_t sca;
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint8_t sca;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_PATH_LOSS_THRESHOLD     (0x20)
+#define BLE_HCI_LE_SUBEV_PATH_LOSS_THRESHOLD (0x20)
 struct ble_hci_ev_le_subev_path_loss_threshold {
-    uint8_t subev_code;
-    uint16_t conn_handle;
-    uint8_t current_path_loss;
-    uint8_t zone_entered;
+	uint8_t subev_code;
+	uint16_t conn_handle;
+	uint8_t current_path_loss;
+	uint8_t zone_entered;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_TRANSMIT_POWER_REPORT   (0x21)
+#define BLE_HCI_LE_SUBEV_TRANSMIT_POWER_REPORT (0x21)
 struct ble_hci_ev_le_subev_transmit_power_report {
-    uint8_t subev_code;
-    uint8_t status;
-    uint16_t conn_handle;
-    uint8_t reason;
-    uint8_t phy;
-    int8_t transmit_power_level;
-    uint8_t transmit_power_level_flag;
-    int8_t delta;
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint8_t reason;
+	uint8_t phy;
+	int8_t transmit_power_level;
+	uint8_t transmit_power_level_flag;
+	int8_t delta;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_BIGINFO_ADV_REPORT         (0x22)
+#define BLE_HCI_LE_SUBEV_BIGINFO_ADV_REPORT (0x22)
 struct ble_hci_ev_le_subev_biginfo_adv_report {
-    uint8_t subev_code;
-    uint16_t sync_handle;
-    uint8_t bis_cnt;
-    uint8_t nse;
-    uint16_t iso_interval;
-    uint8_t bn;
-    uint8_t pto;
-    uint8_t irc;
-    uint16_t max_pdu;
-    uint8_t sdu_interval[3];
-    uint16_t max_sdu;
-    uint8_t phy;
-    uint8_t framing;
-    uint8_t encryption;
-} __attribute__((packed));
-
-#define BLE_HCI_LE_SUBEV_SUBRATE_CHANGE             (0x23)
+	uint8_t subev_code;
+	uint16_t sync_handle;
+	uint8_t bis_cnt;
+	uint8_t nse;
+	uint16_t iso_interval;
+	uint8_t bn;
+	uint8_t pto;
+	uint8_t irc;
+	uint16_t max_pdu;
+	uint8_t sdu_interval[3];
+	uint16_t max_sdu;
+	uint8_t phy;
+	uint8_t framing;
+	uint8_t encryption;
+} __attribute__((packed));
+
+#define BLE_HCI_LE_SUBEV_SUBRATE_CHANGE (0x23)
 struct ble_hci_ev_le_subev_subrate_change {
-    uint8_t subev_code;
-    uint8_t status;
-    uint16_t conn_handle;
-    uint16_t subrate_factor;
-    uint16_t periph_latency;
-    uint16_t cont_num;
-    uint16_t supervision_tmo;
+	uint8_t subev_code;
+	uint8_t status;
+	uint16_t conn_handle;
+	uint16_t subrate_factor;
+	uint16_t periph_latency;
+	uint16_t cont_num;
+	uint16_t supervision_tmo;
 } __attribute__((packed));
 
 /* Data buffer overflow event */
-#define BLE_HCI_EVENT_ACL_BUF_OVERFLOW      (0x01)
+#define BLE_HCI_EVENT_ACL_BUF_OVERFLOW (0x01)
 
 /* Advertising report */
-#define BLE_HCI_ADV_RPT_EVTYPE_ADV_IND      (0)
-#define BLE_HCI_ADV_RPT_EVTYPE_DIR_IND      (1)
-#define BLE_HCI_ADV_RPT_EVTYPE_SCAN_IND     (2)
-#define BLE_HCI_ADV_RPT_EVTYPE_NONCONN_IND  (3)
-#define BLE_HCI_ADV_RPT_EVTYPE_SCAN_RSP     (4)
+#define BLE_HCI_ADV_RPT_EVTYPE_ADV_IND (0)
+#define BLE_HCI_ADV_RPT_EVTYPE_DIR_IND (1)
+#define BLE_HCI_ADV_RPT_EVTYPE_SCAN_IND (2)
+#define BLE_HCI_ADV_RPT_EVTYPE_NONCONN_IND (3)
+#define BLE_HCI_ADV_RPT_EVTYPE_SCAN_RSP (4)
 
 /* Bluetooth 5, Vol 2, Part E, 7.7.65.13 */
-#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_IND                 (0x13)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_DIRECT_IND          (0x15)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_SCAN_IND            (0x12)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_NONCON_IND          (0x10)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_IND        (0x1b)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_SCAN_IND   (0x1a)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_IND (0x13)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_DIRECT_IND (0x15)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_SCAN_IND (0x12)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_NONCON_IND (0x10)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_IND (0x1b)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_SCAN_IND (0x1a)
 
 /* LE connection complete event (sub event 0x01) */
-#define BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER    (0x00)
-#define BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE     (0x01)
+#define BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER (0x00)
+#define BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE (0x01)
 
 /* Maximum valid connection handle value */
-#define BLE_HCI_LE_CONN_HANDLE_MAX              (0x0eff)
+#define BLE_HCI_LE_CONN_HANDLE_MAX (0x0eff)
 
 /* LE advertising report event. (sub event 0x02) */
-#define BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN     (1)
-#define BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX     (0x19)
+#define BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN (1)
+#define BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX (0x19)
 
 /* Bluetooth Assigned numbers for version information.*/
-#define BLE_HCI_VER_BCS_1_0b                (0)
-#define BLE_HCI_VER_BCS_1_1                 (1)
-#define BLE_HCI_VER_BCS_1_2                 (2)
-#define BLE_HCI_VER_BCS_2_0_EDR             (3)
-#define BLE_HCI_VER_BCS_2_1_EDR             (4)
-#define BLE_HCI_VER_BCS_3_0_HCS             (5)
-#define BLE_HCI_VER_BCS_4_0                 (6)
-#define BLE_HCI_VER_BCS_4_1                 (7)
-#define BLE_HCI_VER_BCS_4_2                 (8)
-#define BLE_HCI_VER_BCS_5_0                 (9)
-#define BLE_HCI_VER_BCS_5_1                 (10)
-#define BLE_HCI_VER_BCS_5_2                 (11)
-#define BLE_HCI_VER_BCS_5_3                 (12)
-#define BLE_HCI_VER_BCS_5_4                 (13)
-
-#define BLE_LMP_VER_BCS_1_0b                (0)
-#define BLE_LMP_VER_BCS_1_1                 (1)
-#define BLE_LMP_VER_BCS_1_2                 (2)
-#define BLE_LMP_VER_BCS_2_0_EDR             (3)
-#define BLE_LMP_VER_BCS_2_1_EDR             (4)
-#define BLE_LMP_VER_BCS_3_0_HCS             (5)
-#define BLE_LMP_VER_BCS_4_0                 (6)
-#define BLE_LMP_VER_BCS_4_1                 (7)
-#define BLE_LMP_VER_BCS_4_2                 (8)
-#define BLE_LMP_VER_BCS_5_0                 (9)
-#define BLE_LMP_VER_BCS_5_1                 (10)
-#define BLE_LMP_VER_BCS_5_2                 (11)
-#define BLE_LMP_VER_BCS_5_3                 (12)
-#define BLE_LMP_VER_BCS_5_4                 (13)
+#define BLE_HCI_VER_BCS_1_0b (0)
+#define BLE_HCI_VER_BCS_1_1 (1)
+#define BLE_HCI_VER_BCS_1_2 (2)
+#define BLE_HCI_VER_BCS_2_0_EDR (3)
+#define BLE_HCI_VER_BCS_2_1_EDR (4)
+#define BLE_HCI_VER_BCS_3_0_HCS (5)
+#define BLE_HCI_VER_BCS_4_0 (6)
+#define BLE_HCI_VER_BCS_4_1 (7)
+#define BLE_HCI_VER_BCS_4_2 (8)
+#define BLE_HCI_VER_BCS_5_0 (9)
+#define BLE_HCI_VER_BCS_5_1 (10)
+#define BLE_HCI_VER_BCS_5_2 (11)
+#define BLE_HCI_VER_BCS_5_3 (12)
+#define BLE_HCI_VER_BCS_5_4 (13)
+
+#define BLE_LMP_VER_BCS_1_0b (0)
+#define BLE_LMP_VER_BCS_1_1 (1)
+#define BLE_LMP_VER_BCS_1_2 (2)
+#define BLE_LMP_VER_BCS_2_0_EDR (3)
+#define BLE_LMP_VER_BCS_2_1_EDR (4)
+#define BLE_LMP_VER_BCS_3_0_HCS (5)
+#define BLE_LMP_VER_BCS_4_0 (6)
+#define BLE_LMP_VER_BCS_4_1 (7)
+#define BLE_LMP_VER_BCS_4_2 (8)
+#define BLE_LMP_VER_BCS_5_0 (9)
+#define BLE_LMP_VER_BCS_5_1 (10)
+#define BLE_LMP_VER_BCS_5_2 (11)
+#define BLE_LMP_VER_BCS_5_3 (12)
+#define BLE_LMP_VER_BCS_5_4 (13)
 
 /* selected HCI and LMP version */
 #if MYNEWT_VAL(BLE_VERSION) == 50
@@ -2071,68 +2087,68 @@ struct ble_hci_ev_le_subev_subrate_change {
 #define BLE_LMP_VER_BCS BLE_LMP_VER_BCS_5_4
 #endif
 
-#define BLE_HCI_DATA_HDR_SZ                 4
-#define BLE_HCI_DATA_HANDLE(handle_pb_bc)   (((handle_pb_bc) & 0x0fff) >> 0)
-#define BLE_HCI_DATA_PB(handle_pb_bc)       (((handle_pb_bc) & 0x3000) >> 12)
-#define BLE_HCI_DATA_BC(handle_pb_bc)       (((handle_pb_bc) & 0xc000) >> 14)
+#define BLE_HCI_DATA_HDR_SZ 4
+#define BLE_HCI_DATA_HANDLE(handle_pb_bc) (((handle_pb_bc) & 0x0fff) >> 0)
+#define BLE_HCI_DATA_PB(handle_pb_bc) (((handle_pb_bc) & 0x3000) >> 12)
+#define BLE_HCI_DATA_BC(handle_pb_bc) (((handle_pb_bc) & 0xc000) >> 14)
 
-struct hci_data_hdr
-{
-    uint16_t hdh_handle_pb_bc;
-    uint16_t hdh_len;
+struct hci_data_hdr {
+	uint16_t hdh_handle_pb_bc;
+	uint16_t hdh_len;
 };
 
-#define BLE_HCI_PB_FIRST_NON_FLUSH          0
-#define BLE_HCI_PB_MIDDLE                   1
-#define BLE_HCI_PB_FIRST_FLUSH              2
-#define BLE_HCI_PB_FULL                     3
+#define BLE_HCI_PB_FIRST_NON_FLUSH 0
+#define BLE_HCI_PB_MIDDLE 1
+#define BLE_HCI_PB_FIRST_FLUSH 2
+#define BLE_HCI_PB_FULL 3
 
-#define BLE_HCI_ISO_CONN_HANDLE_MASK        (0x07ff)
-#define BLE_HCI_ISO_PB_FLAG_MASK            (0x3000)
-#define BLE_HCI_ISO_TS_FLAG_MASK            (0x4000)
-#define BLE_HCI_ISO_LENGTH_MASK             (0x7fff)
-#define BLE_HCI_ISO_SDU_LENGTH_MASK         (0x0fff)
-#define BLE_HCI_ISO_PKT_STATUS_FLAG_MASK    (0xC000)
+#define BLE_HCI_ISO_CONN_HANDLE_MASK (0x07ff)
+#define BLE_HCI_ISO_PB_FLAG_MASK (0x3000)
+#define BLE_HCI_ISO_TS_FLAG_MASK (0x4000)
+#define BLE_HCI_ISO_LENGTH_MASK (0x7fff)
+#define BLE_HCI_ISO_SDU_LENGTH_MASK (0x0fff)
+#define BLE_HCI_ISO_PKT_STATUS_FLAG_MASK (0xC000)
 
-#define BLE_HCI_ISO_HANDLE(ch, pb, ts)  ((ch) | ((pb) << 12) | ((ts) << 14))
+#define BLE_HCI_ISO_HANDLE(ch, pb, ts) ((ch) | ((pb) << 12) | ((ts) << 14))
 
-#define BLE_HCI_ISO_CONN_HANDLE(h)      ((h) & BLE_HCI_ISO_CONN_HANDLE_MASK)
-#define BLE_HCI_ISO_PB_FLAG(h)          (((h) & BLE_HCI_ISO_PB_FLAG_MASK) >> 12)
-#define BLE_HCI_ISO_TS_FLAG(h)          (((h) & BLE_HCI_ISO_TS_FLAG_MASK) >> 14)
-#define BLE_HCI_ISO_LENGTH(l)           ((l) & BLE_HCI_ISO_LENGTH_MASK)
-#define BLE_HCI_ISO_SDU_LENGTH(l)       ((l) & BLE_HCI_ISO_SDU_LENGTH_MASK)
-#define BLE_HCI_ISO_PKT_STATUS_FLAG(l)  (((l) & BLE_HCI_ISO_PKT_STATUS_FLAG_MASK) >> 14)
+#define BLE_HCI_ISO_CONN_HANDLE(h) ((h) & BLE_HCI_ISO_CONN_HANDLE_MASK)
+#define BLE_HCI_ISO_PB_FLAG(h) (((h) & BLE_HCI_ISO_PB_FLAG_MASK) >> 12)
+#define BLE_HCI_ISO_TS_FLAG(h) (((h) & BLE_HCI_ISO_TS_FLAG_MASK) >> 14)
+#define BLE_HCI_ISO_LENGTH(l) ((l) & BLE_HCI_ISO_LENGTH_MASK)
+#define BLE_HCI_ISO_SDU_LENGTH(l) ((l) & BLE_HCI_ISO_SDU_LENGTH_MASK)
+#define BLE_HCI_ISO_PKT_STATUS_FLAG(l) \
+	(((l) & BLE_HCI_ISO_PKT_STATUS_FLAG_MASK) >> 14)
 
-#define BLE_HCI_ISO_PB_FIRST            (0)
-#define BLE_HCI_ISO_PB_CONTINUATION     (1)
-#define BLE_HCI_ISO_PB_COMPLETE         (2)
-#define BLE_HCI_ISO_PB_LAST             (3)
+#define BLE_HCI_ISO_PB_FIRST (0)
+#define BLE_HCI_ISO_PB_CONTINUATION (1)
+#define BLE_HCI_ISO_PB_COMPLETE (2)
+#define BLE_HCI_ISO_PB_LAST (3)
 
-#define BLE_HCI_ISO_PKT_STATUS_VALID    0x00
-#define BLE_HCI_ISO_PKT_STATUS_INVALID  0x01
-#define BLE_HCI_ISO_PKT_STATUS_LOST     0x10
+#define BLE_HCI_ISO_PKT_STATUS_VALID 0x00
+#define BLE_HCI_ISO_PKT_STATUS_INVALID 0x01
+#define BLE_HCI_ISO_PKT_STATUS_LOST 0x10
 
-#define BLE_HCI_ISO_BIG_HANDLE_MIN      0x00
-#define BLE_HCI_ISO_BIG_HANDLE_MAX      0xEF
+#define BLE_HCI_ISO_BIG_HANDLE_MIN 0x00
+#define BLE_HCI_ISO_BIG_HANDLE_MAX 0xEF
 
-#define BLE_HCI_ISO_BIG_ENCRYPTION_UNENCRYPTED  0x00
-#define BLE_HCI_ISO_BIG_ENCRYPTION_ENCRYPTED    0x01
+#define BLE_HCI_ISO_BIG_ENCRYPTION_UNENCRYPTED 0x00
+#define BLE_HCI_ISO_BIG_ENCRYPTION_ENCRYPTED 0x01
 
-#define BLE_HCI_ISO_DATA_PATH_DIR_INPUT         0x00
-#define BLE_HCI_ISO_DATA_PATH_DIR_OUTPUT        0x01
+#define BLE_HCI_ISO_DATA_PATH_DIR_INPUT 0x00
+#define BLE_HCI_ISO_DATA_PATH_DIR_OUTPUT 0x01
 
 struct ble_hci_iso {
-    uint16_t handle;
-    uint16_t length;
-    uint8_t data[0];
+	uint16_t handle;
+	uint16_t length;
+	uint8_t data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_ISO_HDR_SDU_LENGTH_MASK     (0x07ff)
+#define BLE_HCI_ISO_HDR_SDU_LENGTH_MASK (0x07ff)
 
 struct ble_hci_iso_data {
-    uint16_t packet_seq_num;
-    uint16_t sdu_len;
-    uint8_t data[0];
+	uint16_t packet_seq_num;
+	uint16_t sdu_len;
+	uint8_t data[0];
 } __attribute__((packed));
 
 #ifdef __cplusplus
diff --git a/repository.yml b/repository.yml
index b50dc7b9..50e4c59a 100644
--- a/repository.yml
+++ b/repository.yml
@@ -33,6 +33,7 @@ repo.versions:
     "1.5.0": "nimble_1_5_0_tag"
     "1.6.0": "nimble_1_6_0_tag"
     "1.7.0": "nimble_1_7_0_tag"
+    "1.7.1": "re-pairing"
 
     "1.0-latest": "1.0.0"
     "1.1-latest": "1.1.0"
@@ -62,3 +63,5 @@ repo.newt_compatibility:
         1.11.0: good
     1.7.0:
         1.12.0: good
+    1.7.1:
+        1.12.0: good
