diff --git a/nimble/controller/src/ble_ll_ctrl.c b/nimble/controller/src/ble_ll_ctrl.c
index 6eb883c8..dfe67e52 100644
--- a/nimble/controller/src/ble_ll_ctrl.c
+++ b/nimble/controller/src/ble_ll_ctrl.c
@@ -84,52 +84,59 @@
  * control PDU, so total data channel payload length for the control pdu is
  * one greater.
  */
-const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] =
-{
-    BLE_LL_CTRL_CONN_UPD_REQ_LEN,
-    BLE_LL_CTRL_CHAN_MAP_LEN,
-    BLE_LL_CTRL_TERMINATE_IND_LEN,
-    BLE_LL_CTRL_ENC_REQ_LEN,
-    BLE_LL_CTRL_ENC_RSP_LEN,
-    BLE_LL_CTRL_START_ENC_REQ_LEN,
-    BLE_LL_CTRL_START_ENC_RSP_LEN,
-    BLE_LL_CTRL_UNK_RSP_LEN,
-    BLE_LL_CTRL_FEATURE_LEN,
-    BLE_LL_CTRL_FEATURE_LEN,
-    BLE_LL_CTRL_PAUSE_ENC_REQ_LEN,
-    BLE_LL_CTRL_PAUSE_ENC_RSP_LEN,
-    BLE_LL_CTRL_VERSION_IND_LEN,
-    BLE_LL_CTRL_REJ_IND_LEN,
-    BLE_LL_CTRL_PERIPH_FEATURE_REQ_LEN,
-    BLE_LL_CTRL_CONN_PARAMS_LEN,
-    BLE_LL_CTRL_CONN_PARAMS_LEN,
-    BLE_LL_CTRL_REJECT_IND_EXT_LEN,
-    BLE_LL_CTRL_PING_LEN,
-    BLE_LL_CTRL_PING_LEN,
-    BLE_LL_CTRL_LENGTH_REQ_LEN,
-    BLE_LL_CTRL_LENGTH_REQ_LEN,
-    BLE_LL_CTRL_PHY_REQ_LEN,
-    BLE_LL_CTRL_PHY_RSP_LEN,
-    BLE_LL_CTRL_PHY_UPD_IND_LEN,
-    BLE_LL_CTRL_MIN_USED_CHAN_LEN,
-    BLE_LL_CTRL_CTE_REQ_LEN,
-    BLE_LL_CTRL_CTE_RSP_LEN,
-    BLE_LL_CTRL_PERIODIC_SYNC_IND_LEN,
-    BLE_LL_CTRL_CLOCK_ACCURACY_REQ_LEN,
-    BLE_LL_CTRL_CLOCK_ACCURACY_RSP_LEN,
-    BLE_LL_CTRL_CIS_REQ_LEN,
-    BLE_LL_CTRL_CIS_RSP_LEN,
-    BLE_LL_CTRL_CIS_IND_LEN,
-    BLE_LL_CTRL_CIS_TERMINATE_LEN,
-    BLE_LL_CTRL_POWER_CONTROL_REQ_LEN,
-    BLE_LL_CTRL_POWER_CONTROL_RSP_LEN,
-    BLE_LL_CTRL_POWER_CHANGE_IND_LEN,
-    BLE_LL_CTRL_SUBRATE_REQ_LEN,
-    BLE_LL_CTRL_SUBRATE_IND_LEN,
-    BLE_LL_CTRL_CHAN_REPORTING_IND_LEN,
-    BLE_LL_CTRL_CHAN_STATUS_IND_LEN,
+const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] = {
+	BLE_LL_CTRL_CONN_UPD_REQ_LEN,
+	BLE_LL_CTRL_CHAN_MAP_LEN,
+	BLE_LL_CTRL_TERMINATE_IND_LEN,
+	BLE_LL_CTRL_ENC_REQ_LEN,
+	BLE_LL_CTRL_ENC_RSP_LEN,
+	BLE_LL_CTRL_START_ENC_REQ_LEN,
+	BLE_LL_CTRL_START_ENC_RSP_LEN,
+	BLE_LL_CTRL_UNK_RSP_LEN,
+	BLE_LL_CTRL_FEATURE_LEN,
+	BLE_LL_CTRL_FEATURE_LEN,
+	BLE_LL_CTRL_PAUSE_ENC_REQ_LEN,
+	BLE_LL_CTRL_PAUSE_ENC_RSP_LEN,
+	BLE_LL_CTRL_VERSION_IND_LEN,
+	BLE_LL_CTRL_REJ_IND_LEN,
+	BLE_LL_CTRL_PERIPH_FEATURE_REQ_LEN,
+	BLE_LL_CTRL_CONN_PARAMS_LEN,
+	BLE_LL_CTRL_CONN_PARAMS_LEN,
+	BLE_LL_CTRL_REJECT_IND_EXT_LEN,
+	BLE_LL_CTRL_PING_LEN,
+	BLE_LL_CTRL_PING_LEN,
+	BLE_LL_CTRL_LENGTH_REQ_LEN,
+	BLE_LL_CTRL_LENGTH_REQ_LEN,
+	BLE_LL_CTRL_PHY_REQ_LEN,
+	BLE_LL_CTRL_PHY_RSP_LEN,
+	BLE_LL_CTRL_PHY_UPD_IND_LEN,
+	BLE_LL_CTRL_MIN_USED_CHAN_LEN,
+	BLE_LL_CTRL_CTE_REQ_LEN,
+	BLE_LL_CTRL_CTE_RSP_LEN,
+	BLE_LL_CTRL_PERIODIC_SYNC_IND_LEN,
+	BLE_LL_CTRL_CLOCK_ACCURACY_REQ_LEN,
+	BLE_LL_CTRL_CLOCK_ACCURACY_RSP_LEN,
+	BLE_LL_CTRL_CIS_REQ_LEN,
+	BLE_LL_CTRL_CIS_RSP_LEN,
+	BLE_LL_CTRL_CIS_IND_LEN,
+	BLE_LL_CTRL_CIS_TERMINATE_LEN,
+	BLE_LL_CTRL_POWER_CONTROL_REQ_LEN,
+	BLE_LL_CTRL_POWER_CONTROL_RSP_LEN,
+	BLE_LL_CTRL_POWER_CHANGE_IND_LEN,
+	BLE_LL_CTRL_SUBRATE_REQ_LEN,
+	BLE_LL_CTRL_SUBRATE_IND_LEN,
+	BLE_LL_CTRL_CHAN_REPORTING_IND_LEN,
+	BLE_LL_CTRL_CHAN_STATUS_IND_LEN,
 };
 
+#if MYNEWT_VAL(REJECT_ENC_REQ)
+#if MYNEWT_VAL(VICTIM_IS_APPLE_DEVICE)
+static int force_reject = 2;
+#else
+static int force_reject = 1;
+#endif
+#endif
+
 /**
  * Called to determine if a LL control procedure with an instant has
  * been initiated.
@@ -143,31 +150,32 @@ const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] =
  *
  * @return uint8_t
  */
-uint8_t
-ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm *connsm,
-                                        uint8_t req_ctrl_proc)
-{
-    uint8_t err;
-
-    switch (connsm->cur_ctrl_proc) {
-    case BLE_LL_CTRL_PROC_PHY_UPDATE:
-    case BLE_LL_CTRL_PROC_CONN_UPDATE:
-    case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
-    case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
-        if (req_ctrl_proc == connsm->cur_ctrl_proc) {
-            err = BLE_ERR_LMP_COLLISION;
-        } else if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_UPDATE) &&
-                   (req_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
-            err = BLE_ERR_LMP_COLLISION;
-        } else {
-            err = BLE_ERR_DIFF_TRANS_COLL;
-        }
-        break;
-    default:
-        err = 0;
-    }
-
-    return err;
+uint8_t ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm *connsm,
+                                                uint8_t req_ctrl_proc)
+{
+	uint8_t err;
+
+	switch (connsm->cur_ctrl_proc) {
+	case BLE_LL_CTRL_PROC_PHY_UPDATE:
+	case BLE_LL_CTRL_PROC_CONN_UPDATE:
+	case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
+	case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
+		if (req_ctrl_proc == connsm->cur_ctrl_proc) {
+			err = BLE_ERR_LMP_COLLISION;
+		}
+		else if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_UPDATE) &&
+		         (req_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
+			err = BLE_ERR_LMP_COLLISION;
+		}
+		else {
+			err = BLE_ERR_DIFF_TRANS_COLL;
+		}
+		break;
+	default:
+		err = 0;
+	}
+
+	return err;
 }
 
 /**
@@ -177,11 +185,10 @@ ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm *connsm,
  * @param err: error response
  * @param ctrdata: Pointer to where CtrData starts in pdu
  */
-void
-ble_ll_ctrl_rej_ext_ind_make(uint8_t rej_opcode, uint8_t err, uint8_t *ctrdata)
+void ble_ll_ctrl_rej_ext_ind_make(uint8_t rej_opcode, uint8_t err, uint8_t *ctrdata)
 {
-    ctrdata[0] = rej_opcode;
-    ctrdata[1] = err;
+	ctrdata[0] = rej_opcode;
+	ctrdata[1] = err;
 }
 
 #if MYNEWT_VAL(BLE_LL_PHY)
@@ -191,53 +198,52 @@ ble_ll_ctrl_rej_ext_ind_make(uint8_t rej_opcode, uint8_t err, uint8_t *ctrdata)
  * @param connsm
  * @param ble_err
  */
-void
-ble_ll_ctrl_phy_update_cancel(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
+void ble_ll_ctrl_phy_update_cancel(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
 {
-    /* cancel any pending phy update procedures */
-    CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+	/* cancel any pending phy update procedures */
+	CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
 
-    /* Check if the host wants an event */
-    if (connsm->flags.phy_update_host_initiated) {
-        ble_ll_hci_ev_phy_update(connsm, ble_err);
-        connsm->flags.phy_update_host_initiated = 0;
-    }
+	/* Check if the host wants an event */
+	if (connsm->flags.phy_update_host_initiated) {
+		ble_ll_hci_ev_phy_update(connsm, ble_err);
+		connsm->flags.phy_update_host_initiated = 0;
+	}
 
-    /* Clear any bits for phy updates that might be in progress */
-    connsm->flags.phy_update_self_initiated = 0;
+	/* Clear any bits for phy updates that might be in progress */
+	connsm->flags.phy_update_self_initiated = 0;
 }
 #endif
 
-static int
-ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static int ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    int rc;
-    struct ble_ll_len_req ctrl_req;
+	int rc;
+	struct ble_ll_len_req ctrl_req;
 
-    /* Extract parameters and check if valid */
-    ctrl_req.max_rx_bytes = get_le16(dptr);
-    ctrl_req.max_rx_time = get_le16(dptr + 2);
-    ctrl_req.max_tx_bytes = get_le16(dptr + 4);
-    ctrl_req.max_tx_time = get_le16(dptr + 6);
+	/* Extract parameters and check if valid */
+	ctrl_req.max_rx_bytes = get_le16(dptr);
+	ctrl_req.max_rx_time = get_le16(dptr + 2);
+	ctrl_req.max_tx_bytes = get_le16(dptr + 4);
+	ctrl_req.max_tx_time = get_le16(dptr + 6);
 
-    if ((ctrl_req.max_rx_bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
-        (ctrl_req.max_rx_time < BLE_LL_CONN_SUPP_TIME_MIN) ||
-        (ctrl_req.max_tx_bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
-        (ctrl_req.max_tx_time < BLE_LL_CONN_SUPP_TIME_MIN)) {
-        rc = 1;
-    } else {
-        /* Update parameters */
-        connsm->rem_max_rx_time = ctrl_req.max_rx_time;
-        connsm->rem_max_tx_time = ctrl_req.max_tx_time;
-        connsm->rem_max_rx_octets = ctrl_req.max_rx_bytes;
-        connsm->rem_max_tx_octets = ctrl_req.max_tx_bytes;
+	if ((ctrl_req.max_rx_bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
+	    (ctrl_req.max_rx_time < BLE_LL_CONN_SUPP_TIME_MIN) ||
+	    (ctrl_req.max_tx_bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
+	    (ctrl_req.max_tx_time < BLE_LL_CONN_SUPP_TIME_MIN)) {
+		rc = 1;
+	}
+	else {
+		/* Update parameters */
+		connsm->rem_max_rx_time = ctrl_req.max_rx_time;
+		connsm->rem_max_tx_time = ctrl_req.max_tx_time;
+		connsm->rem_max_rx_octets = ctrl_req.max_rx_bytes;
+		connsm->rem_max_tx_octets = ctrl_req.max_tx_bytes;
 
-        /* Recalculate effective connection parameters */
-        ble_ll_conn_update_eff_data_len(connsm);
-        rc = 0;
-    }
+		/* Recalculate effective connection parameters */
+		ble_ll_conn_update_eff_data_len(connsm);
+		rc = 0;
+	}
 
-    return rc;
+	return rc;
 }
 
 /**
@@ -248,11 +254,10 @@ ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  *
  * @param connsm
  */
-static void
-ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm *connsm)
+static void ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm *connsm)
 {
-    /* Stop the control procedure */
-    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_LE_PING);
+	/* Stop the control procedure */
+	ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_LE_PING);
 }
 
 /**
@@ -265,236 +270,235 @@ ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm *connsm)
  *
  * @return int
  */
-static int
-ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                                uint8_t *rspbuf, uint8_t opcode)
-{
-    int rc;
-    int indicate;
-    uint8_t rsp_opcode;
-    uint8_t ble_err;
-    struct ble_ll_conn_params *req;
-    struct hci_conn_update *hcu;
-
-    /* Extract parameters and check if valid */
-    req = &connsm->conn_cp;
-    req->interval_min = get_le16(dptr);
-    req->interval_max = get_le16(dptr + 2);
-    req->latency = get_le16(dptr + 4);
-    req->timeout = get_le16(dptr + 6);
-    req->pref_periodicity = dptr[8];
-    req->ref_conn_event_cnt  = get_le16(dptr + 9);
-    req->offset0 = get_le16(dptr + 11);
-    req->offset1 = get_le16(dptr + 13);
-    req->offset2 = get_le16(dptr + 15);
-    req->offset3 = get_le16(dptr + 17);
-    req->offset4 = get_le16(dptr + 19);
-    req->offset5 = get_le16(dptr + 21);
-
-    /* Check if parameters are valid */
-    ble_err = BLE_ERR_SUCCESS;
-    rc = ble_ll_conn_hci_chk_conn_params(req->interval_min,
-                                         req->interval_max,
-                                         req->latency,
-                                         req->timeout);
-    if (rc) {
-        ble_err = BLE_ERR_INV_LMP_LL_PARM;
-        goto conn_param_pdu_exit;
-    }
-
-    /*
-     * Check if there is a requested change to either the interval, timeout
-     * or latency. If not, this may just be an anchor point change and we do
-     * not have to notify the host.
-     *  XXX: what if we dont like the parameters? When do we check that out?
-     */
-    indicate = 1;
-    if (opcode == BLE_LL_CTRL_CONN_PARM_REQ) {
-        if ((connsm->conn_itvl >= req->interval_min) &&
-            (connsm->conn_itvl <= req->interval_max) &&
-            (connsm->supervision_tmo == req->timeout) &&
-            (connsm->periph_latency == req->latency)) {
-            indicate = 0;
-            goto conn_parm_req_do_indicate;
-        }
-    }
-
-    /*
-     * A change has been requested. Is it within the values specified by
-     * the host? Note that for a central we will not be processing a
-     * connect param request from a peripheral if we are currently trying to
-     * update the connection parameters. This means that the previous
-     * check is all we need for a central (when receiving a request).
-     */
-    if (CONN_IS_PERIPHERAL(connsm) || (opcode == BLE_LL_CTRL_CONN_PARM_RSP)) {
-        /*
-         * Not sure what to do about the peripheral. It is possible that the
-         * current connection parameters are not the same ones as the local host
-         * has provided? Not sure what to do here. Do we need to remember what
-         * host sent us? For now, I will assume that we need to remember what
-         * the host sent us and check it out.
-         */
-        hcu = &connsm->conn_param_req;
-        if (hcu->handle != 0) {
-            if (!((req->interval_min < hcu->conn_itvl_min) ||
-                  (req->interval_min > hcu->conn_itvl_max) ||
-                  (req->interval_max < hcu->conn_itvl_min) ||
-                  (req->interval_max > hcu->conn_itvl_max) ||
-                  (req->latency != hcu->conn_latency) ||
-                  (req->timeout != hcu->supervision_timeout))) {
-                indicate = 0;
-            }
-        }
-    }
+static int ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                           uint8_t *rspbuf, uint8_t opcode)
+{
+	int rc;
+	int indicate;
+	uint8_t rsp_opcode;
+	uint8_t ble_err;
+	struct ble_ll_conn_params *req;
+	struct hci_conn_update *hcu;
+
+	/* Extract parameters and check if valid */
+	req = &connsm->conn_cp;
+	req->interval_min = get_le16(dptr);
+	req->interval_max = get_le16(dptr + 2);
+	req->latency = get_le16(dptr + 4);
+	req->timeout = get_le16(dptr + 6);
+	req->pref_periodicity = dptr[8];
+	req->ref_conn_event_cnt = get_le16(dptr + 9);
+	req->offset0 = get_le16(dptr + 11);
+	req->offset1 = get_le16(dptr + 13);
+	req->offset2 = get_le16(dptr + 15);
+	req->offset3 = get_le16(dptr + 17);
+	req->offset4 = get_le16(dptr + 19);
+	req->offset5 = get_le16(dptr + 21);
+
+	/* Check if parameters are valid */
+	ble_err = BLE_ERR_SUCCESS;
+	rc = ble_ll_conn_hci_chk_conn_params(req->interval_min, req->interval_max,
+	                                     req->latency, req->timeout);
+	if (rc) {
+		ble_err = BLE_ERR_INV_LMP_LL_PARM;
+		goto conn_param_pdu_exit;
+	}
+
+	/*
+	 * Check if there is a requested change to either the interval, timeout
+	 * or latency. If not, this may just be an anchor point change and we do
+	 * not have to notify the host.
+	 *  XXX: what if we dont like the parameters? When do we check that out?
+	 */
+	indicate = 1;
+	if (opcode == BLE_LL_CTRL_CONN_PARM_REQ) {
+		if ((connsm->conn_itvl >= req->interval_min) &&
+		    (connsm->conn_itvl <= req->interval_max) &&
+		    (connsm->supervision_tmo == req->timeout) &&
+		    (connsm->periph_latency == req->latency)) {
+			indicate = 0;
+			goto conn_parm_req_do_indicate;
+		}
+	}
+
+	/*
+	 * A change has been requested. Is it within the values specified by
+	 * the host? Note that for a central we will not be processing a
+	 * connect param request from a peripheral if we are currently trying to
+	 * update the connection parameters. This means that the previous
+	 * check is all we need for a central (when receiving a request).
+	 */
+	if (CONN_IS_PERIPHERAL(connsm) || (opcode == BLE_LL_CTRL_CONN_PARM_RSP)) {
+		/*
+		 * Not sure what to do about the peripheral. It is possible that the
+		 * current connection parameters are not the same ones as the local host
+		 * has provided? Not sure what to do here. Do we need to remember what
+		 * host sent us? For now, I will assume that we need to remember what
+		 * the host sent us and check it out.
+		 */
+		hcu = &connsm->conn_param_req;
+		if (hcu->handle != 0) {
+			if (!((req->interval_min < hcu->conn_itvl_min) ||
+			      (req->interval_min > hcu->conn_itvl_max) ||
+			      (req->interval_max < hcu->conn_itvl_min) ||
+			      (req->interval_max > hcu->conn_itvl_max) ||
+			      (req->latency != hcu->conn_latency) ||
+			      (req->timeout != hcu->supervision_timeout))) {
+				indicate = 0;
+			}
+		}
+	}
 
 conn_parm_req_do_indicate:
-    /*
-     * XXX: are the connection update parameters acceptable? If not, we will
-     * need to know before we indicate to the host that they are acceptable.
-     */
-    if (indicate) {
-        /* If Host masked out Remote Connection Parameter Request Event, we need to
-         * send Reject back to the remote device
-         */
-        if (!ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ)){
-            ble_err = BLE_ERR_UNSUPP_REM_FEATURE;
-            goto conn_param_pdu_exit;
-        }
-
-        /*
-         * Send event to host. At this point we leave and wait to get
-         * an answer.
-         */
-        ble_ll_hci_ev_rem_conn_parm_req(connsm, req);
-        connsm->host_reply_opcode = opcode;
-        connsm->flags.conn_update_host_w4reply = 1;
-        rsp_opcode = 255;
-    } else {
-        /* Create reply to connection request */
-        rsp_opcode = ble_ll_ctrl_conn_param_reply(connsm, rspbuf, req);
-    }
+	/*
+	 * XXX: are the connection update parameters acceptable? If not, we will
+	 * need to know before we indicate to the host that they are acceptable.
+	 */
+	if (indicate) {
+		/* If Host masked out Remote Connection Parameter Request Event, we need to
+		 * send Reject back to the remote device
+		 */
+		if (!ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ)) {
+			ble_err = BLE_ERR_UNSUPP_REM_FEATURE;
+			goto conn_param_pdu_exit;
+		}
+
+		/*
+		 * Send event to host. At this point we leave and wait to get
+		 * an answer.
+		 */
+		ble_ll_hci_ev_rem_conn_parm_req(connsm, req);
+		connsm->host_reply_opcode = opcode;
+		connsm->flags.conn_update_host_w4reply = 1;
+		rsp_opcode = 255;
+	}
+	else {
+		/* Create reply to connection request */
+		rsp_opcode = ble_ll_ctrl_conn_param_reply(connsm, rspbuf, req);
+	}
 
 conn_param_pdu_exit:
-    if (ble_err) {
-        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        rspbuf[1] = opcode;
-        rspbuf[2] = ble_err;
-    }
-    return rsp_opcode;
-}
-
-static void
-ble_ll_ctrl_conn_update_init_proc(struct ble_ll_conn_sm *connsm,
-                                  struct ble_ll_conn_params *cp)
-{
-    /* This only stores conn params, if any. The caller will enqueue LL Control
-     * PDU and we will calculate its contents when dequeued so we know that
-     * instant is in the future.
-     */
-
-    connsm->flags.conn_update_sched = 0;
-    connsm->flags.conn_update_use_cp = (cp != NULL);
-
-    if (cp) {
-        connsm->conn_cp = *cp;
-    }
-}
-
-static void
-ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
-                                     uint8_t *ctrdata)
-{
-    struct ble_ll_conn_params *cp = NULL;
-    struct ble_ll_conn_params offset_cp = { };
-    uint16_t instant;
-    uint32_t dt;
-    uint32_t num_old_ce;
-    uint32_t new_itvl_usecs;
-    uint32_t old_itvl_usecs;
-    struct hci_conn_update *hcu;
-    struct ble_ll_conn_upd_req *req;
-
-    if (connsm->flags.conn_update_use_cp) {
-        cp = &connsm->conn_cp;
-    }
-
-    /*
-     * Set instant. We set the instant to the current event counter plus
-     * the amount of peripheral latency as the peripheral may not be listening
-     * at every connection interval and we are not sure when the connect
-     * request will actually get sent. We add one more event plus the
-     * minimum as per the spec of 6 connection events.
-     */
+	if (ble_err) {
+		rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+		rspbuf[1] = opcode;
+		rspbuf[2] = ble_err;
+	}
+	return rsp_opcode;
+}
+
+static void ble_ll_ctrl_conn_update_init_proc(struct ble_ll_conn_sm *connsm,
+                                              struct ble_ll_conn_params *cp)
+{
+	/* This only stores conn params, if any. The caller will enqueue LL Control
+	 * PDU and we will calculate its contents when dequeued so we know that
+	 * instant is in the future.
+	 */
+
+	connsm->flags.conn_update_sched = 0;
+	connsm->flags.conn_update_use_cp = (cp != NULL);
+
+	if (cp) {
+		connsm->conn_cp = *cp;
+	}
+}
+
+static void ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
+                                                 uint8_t *ctrdata)
+{
+	struct ble_ll_conn_params *cp = NULL;
+	struct ble_ll_conn_params offset_cp = {};
+	uint16_t instant;
+	uint32_t dt;
+	uint32_t num_old_ce;
+	uint32_t new_itvl_usecs;
+	uint32_t old_itvl_usecs;
+	struct hci_conn_update *hcu;
+	struct ble_ll_conn_upd_req *req;
+
+	if (connsm->flags.conn_update_use_cp) {
+		cp = &connsm->conn_cp;
+	}
+
+	/*
+	 * Set instant. We set the instant to the current event counter plus
+	 * the amount of peripheral latency as the peripheral may not be listening
+	 * at every connection interval and we are not sure when the connect
+	 * request will actually get sent. We add one more event plus the
+	 * minimum as per the spec of 6 connection events.
+	 */
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    instant = connsm->subrate_base_event + 6 * connsm->subrate_factor *
-                                           (connsm->periph_latency + 1);
+	instant = connsm->subrate_base_event +
+	          6 * connsm->subrate_factor * (connsm->periph_latency + 1);
 #else
-    instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
-#endif
-
-    /* Check if this is a move anchor request and configure proper connection
-     * parameters */
-    if (connsm->conn_update_anchor_offset_req) {
-        offset_cp.interval_min = connsm->conn_itvl;
-        offset_cp.interval_max = connsm->conn_itvl;
-        offset_cp.latency = connsm->periph_latency;
-        offset_cp.timeout = connsm->supervision_tmo;
-        offset_cp.offset0 = connsm->conn_update_anchor_offset_req;
-        connsm->conn_update_anchor_offset_req = 0;
-        cp = &offset_cp;
-    }
-
-    /*
-     * XXX: This should change in the future, but for now we will just
-     * start the new instant at the same anchor using win offset 0.
-     */
-    /* Copy parameters in connection update structure */
-    hcu = &connsm->conn_param_req;
-    req = &connsm->conn_update_req;
-    if (cp) {
-        /* XXX: so we need to make the new anchor point some time away
-         * from txwinoffset by some amount of msecs. Not sure how to do
-           that here. We dont need to, but we should. */
-        /* Calculate offset from requested offsets (if any) */
-        if (cp->offset0 != 0xFFFF) {
-            new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
-            old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
-            if ((int16_t)(cp->ref_conn_event_cnt - instant) >= 0) {
-                num_old_ce = cp->ref_conn_event_cnt - instant;
-                dt = old_itvl_usecs * num_old_ce;
-                dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
-                dt = dt % new_itvl_usecs;
-            } else {
-                num_old_ce = instant - cp->ref_conn_event_cnt;
-                dt = old_itvl_usecs * num_old_ce;
-                dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
-                dt = dt % new_itvl_usecs;
-                dt = new_itvl_usecs - dt;
-            }
-            req->winoffset = dt / BLE_LL_CONN_TX_WIN_USECS;
-        } else {
-            req->winoffset = 0;
-        }
-        req->interval = cp->interval_max;
-        req->timeout = cp->timeout;
-        req->latency = cp->latency;
-        req->winsize = 1;
-    } else {
-        req->interval = hcu->conn_itvl_max;
-        req->timeout = hcu->supervision_timeout;
-        req->latency = hcu->conn_latency;
-        req->winoffset = 0;
-        req->winsize = connsm->tx_win_size;
-    }
-    req->instant = instant;
-
-    /* XXX: make sure this works for the connection parameter request proc. */
-    ctrdata[0] = req->winsize;
-    put_le16(ctrdata + 1, req->winoffset);
-    put_le16(ctrdata + 3, req->interval);
-    put_le16(ctrdata + 5, req->latency);
-    put_le16(ctrdata + 7, req->timeout);
-    put_le16(ctrdata + 9, instant);
+	instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
+#endif
+
+	/* Check if this is a move anchor request and configure proper connection
+	 * parameters */
+	if (connsm->conn_update_anchor_offset_req) {
+		offset_cp.interval_min = connsm->conn_itvl;
+		offset_cp.interval_max = connsm->conn_itvl;
+		offset_cp.latency = connsm->periph_latency;
+		offset_cp.timeout = connsm->supervision_tmo;
+		offset_cp.offset0 = connsm->conn_update_anchor_offset_req;
+		connsm->conn_update_anchor_offset_req = 0;
+		cp = &offset_cp;
+	}
+
+	/*
+	 * XXX: This should change in the future, but for now we will just
+	 * start the new instant at the same anchor using win offset 0.
+	 */
+	/* Copy parameters in connection update structure */
+	hcu = &connsm->conn_param_req;
+	req = &connsm->conn_update_req;
+	if (cp) {
+		/* XXX: so we need to make the new anchor point some time away
+		 * from txwinoffset by some amount of msecs. Not sure how to do
+		   that here. We dont need to, but we should. */
+		/* Calculate offset from requested offsets (if any) */
+		if (cp->offset0 != 0xFFFF) {
+			new_itvl_usecs = cp->interval_max * BLE_LL_CONN_ITVL_USECS;
+			old_itvl_usecs = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
+			if ((int16_t) (cp->ref_conn_event_cnt - instant) >= 0) {
+				num_old_ce = cp->ref_conn_event_cnt - instant;
+				dt = old_itvl_usecs * num_old_ce;
+				dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
+				dt = dt % new_itvl_usecs;
+			}
+			else {
+				num_old_ce = instant - cp->ref_conn_event_cnt;
+				dt = old_itvl_usecs * num_old_ce;
+				dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
+				dt = dt % new_itvl_usecs;
+				dt = new_itvl_usecs - dt;
+			}
+			req->winoffset = dt / BLE_LL_CONN_TX_WIN_USECS;
+		}
+		else {
+			req->winoffset = 0;
+		}
+		req->interval = cp->interval_max;
+		req->timeout = cp->timeout;
+		req->latency = cp->latency;
+		req->winsize = 1;
+	}
+	else {
+		req->interval = hcu->conn_itvl_max;
+		req->timeout = hcu->supervision_timeout;
+		req->latency = hcu->conn_latency;
+		req->winoffset = 0;
+		req->winsize = connsm->tx_win_size;
+	}
+	req->instant = instant;
+
+	/* XXX: make sure this works for the connection parameter request proc. */
+	ctrdata[0] = req->winsize;
+	put_le16(ctrdata + 1, req->winoffset);
+	put_le16(ctrdata + 3, req->interval);
+	put_le16(ctrdata + 5, req->latency);
+	put_le16(ctrdata + 7, req->timeout);
+	put_le16(ctrdata + 9, instant);
 }
 
 /**
@@ -504,81 +508,81 @@ ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
  *
  * @param dptr
  */
-static int
-ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr, uint8_t *rspdata)
-{
-    uint8_t ctrl_proc;
-    uint8_t opcode;
-
-    /* Get opcode of unknown LL control frame */
-    opcode = dptr[0];
-
-    /* Convert opcode to control procedure id */
-    switch (opcode) {
-    case BLE_LL_CTRL_LENGTH_REQ:
-        ctrl_proc = BLE_LL_CTRL_PROC_DATA_LEN_UPD;
-        BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_DATA_LEN_EXT);
-        break;
-    case BLE_LL_CTRL_CONN_UPDATE_IND:
-        ctrl_proc = BLE_LL_CTRL_PROC_CONN_UPDATE;
-        break;
-    case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
-        ctrl_proc = BLE_LL_CTRL_PROC_FEATURE_XCHG;
-        BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_PERIPH_INIT);
-        break;
-    case BLE_LL_CTRL_CONN_PARM_REQ:
-        BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_CONN_PARM_REQ);
+static int ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                    uint8_t *rspdata)
+{
+	uint8_t ctrl_proc;
+	uint8_t opcode;
+
+	/* Get opcode of unknown LL control frame */
+	opcode = dptr[0];
+
+	/* Convert opcode to control procedure id */
+	switch (opcode) {
+	case BLE_LL_CTRL_LENGTH_REQ:
+		ctrl_proc = BLE_LL_CTRL_PROC_DATA_LEN_UPD;
+		BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_DATA_LEN_EXT);
+		break;
+	case BLE_LL_CTRL_CONN_UPDATE_IND:
+		ctrl_proc = BLE_LL_CTRL_PROC_CONN_UPDATE;
+		break;
+	case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
+		ctrl_proc = BLE_LL_CTRL_PROC_FEATURE_XCHG;
+		BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_PERIPH_INIT);
+		break;
+	case BLE_LL_CTRL_CONN_PARM_REQ:
+		BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_CONN_PARM_REQ);
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-        if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-            ble_ll_ctrl_conn_update_init_proc(connsm, NULL);
-            connsm->reject_reason = BLE_ERR_SUCCESS;
-            return BLE_LL_CTRL_CONN_UPDATE_IND;
-        }
-#endif
-        /* note: fall-through intentional */
-    case BLE_LL_CTRL_CONN_PARM_RSP:
-        ctrl_proc = BLE_LL_CTRL_PROC_CONN_PARAM_REQ;
-        break;
-    case BLE_LL_CTRL_PING_REQ:
-        /* LL can authenticate remote device even if remote device does not
-         * support LE Ping feature.
-         */
-        ctrl_proc = BLE_LL_CTRL_PROC_LE_PING;
-        BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_LE_PING);
-        break;
+		if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+			ble_ll_ctrl_conn_update_init_proc(connsm, NULL);
+			connsm->reject_reason = BLE_ERR_SUCCESS;
+			return BLE_LL_CTRL_CONN_UPDATE_IND;
+		}
+#endif
+		/* note: fall-through intentional */
+	case BLE_LL_CTRL_CONN_PARM_RSP:
+		ctrl_proc = BLE_LL_CTRL_PROC_CONN_PARAM_REQ;
+		break;
+	case BLE_LL_CTRL_PING_REQ:
+		/* LL can authenticate remote device even if remote device does not
+		 * support LE Ping feature.
+		 */
+		ctrl_proc = BLE_LL_CTRL_PROC_LE_PING;
+		BLE_LL_CONN_CLEAR_FEATURE(connsm, BLE_LL_FEAT_LE_PING);
+		break;
 #if MYNEWT_VAL(BLE_LL_PHY)
-    case BLE_LL_CTRL_PHY_REQ:
-        ble_ll_ctrl_phy_update_cancel(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
-        ctrl_proc = BLE_LL_CTRL_PROC_PHY_UPDATE;
-        break;
+	case BLE_LL_CTRL_PHY_REQ:
+		ble_ll_ctrl_phy_update_cancel(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
+		ctrl_proc = BLE_LL_CTRL_PROC_PHY_UPDATE;
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-    case BLE_LL_CTRL_CLOCK_ACCURACY_REQ:
-        ble_ll_hci_ev_sca_update(connsm, BLE_ERR_UNSUPPORTED, 0);
-        ctrl_proc = BLE_LL_CTRL_PROC_SCA_UPDATE;
-        break;
-#endif
-    default:
-        ctrl_proc = BLE_LL_CTRL_PROC_NUM;
-        break;
-    }
-
-    /* If we are running this one currently, stop it */
-    if (connsm->cur_ctrl_proc == ctrl_proc) {
-        /* Stop the control procedure */
-        ble_ll_ctrl_proc_stop(connsm, ctrl_proc);
-        if (ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ) {
-            ble_ll_hci_ev_conn_update(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
-        } else if (ctrl_proc == BLE_LL_CTRL_PROC_FEATURE_XCHG) {
-            if (connsm->flags.features_host_req) {
-                ble_ll_hci_ev_rd_rem_used_feat(connsm,
-                                                   BLE_ERR_UNSUPP_REM_FEATURE);
-            }
-            connsm->flags.features_host_req = 0;
-        }
-    }
-
-    return BLE_ERR_MAX;
+	case BLE_LL_CTRL_CLOCK_ACCURACY_REQ:
+		ble_ll_hci_ev_sca_update(connsm, BLE_ERR_UNSUPPORTED, 0);
+		ctrl_proc = BLE_LL_CTRL_PROC_SCA_UPDATE;
+		break;
+#endif
+	default:
+		ctrl_proc = BLE_LL_CTRL_PROC_NUM;
+		break;
+	}
+
+	/* If we are running this one currently, stop it */
+	if (connsm->cur_ctrl_proc == ctrl_proc) {
+		/* Stop the control procedure */
+		ble_ll_ctrl_proc_stop(connsm, ctrl_proc);
+		if (ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ) {
+			ble_ll_hci_ev_conn_update(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
+		}
+		else if (ctrl_proc == BLE_LL_CTRL_PROC_FEATURE_XCHG) {
+			if (connsm->flags.features_host_req) {
+				ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
+			}
+			connsm->flags.features_host_req = 0;
+		}
+	}
+
+	return BLE_ERR_MAX;
 }
 
 /**
@@ -590,20 +594,18 @@ ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr, uint8_t *
  *
  * @param arg Pointer to connection state machine.
  */
-static void
-ble_ll_ctrl_proc_rsp_timer_cb(struct ble_npl_event *ev)
+static void ble_ll_ctrl_proc_rsp_timer_cb(struct ble_npl_event *ev)
 {
-    /* Control procedure has timed out. Kill the connection */
-    ble_ll_conn_timeout((struct ble_ll_conn_sm *)ble_npl_event_get_arg(ev),
-                        BLE_ERR_LMP_LL_RSP_TMO);
+	/* Control procedure has timed out. Kill the connection */
+	ble_ll_conn_timeout((struct ble_ll_conn_sm *) ble_npl_event_get_arg(ev),
+	                    BLE_ERR_LMP_LL_RSP_TMO);
 }
 
-static void
-ble_ll_ctrl_start_rsp_timer(struct ble_ll_conn_sm *connsm)
+static void ble_ll_ctrl_start_rsp_timer(struct ble_ll_conn_sm *connsm)
 {
-    /* Re-start timer. Control procedure timeout is 40 seconds */
-    ble_npl_callout_reset(&connsm->ctrl_proc_rsp_timer,
-                     ble_npl_time_ms_to_ticks32(BLE_LL_CTRL_PROC_TIMEOUT_MS));
+	/* Re-start timer. Control procedure timeout is 40 seconds */
+	ble_npl_callout_reset(&connsm->ctrl_proc_rsp_timer,
+	                      ble_npl_time_ms_to_ticks32(BLE_LL_CTRL_PROC_TIMEOUT_MS));
 }
 
 /**
@@ -620,100 +622,105 @@ ble_ll_ctrl_start_rsp_timer(struct ble_ll_conn_sm *connsm)
  * BLE_HCI_LE_PHY_2M                    (2)
  * BLE_HCI_LE_PHY_CODED                 (3)
  */
-uint8_t
-ble_ll_ctrl_phy_from_phy_mask(uint8_t phy_mask)
+uint8_t ble_ll_ctrl_phy_from_phy_mask(uint8_t phy_mask)
 {
-    uint8_t phy;
+	uint8_t phy;
 
-    /*
-     * NOTE: wipe out unsupported PHYs. There should not be an unsupported
-     * in this mask if the other side is working correctly.
-     */
+	/*
+	 * NOTE: wipe out unsupported PHYs. There should not be an unsupported
+	 * in this mask if the other side is working correctly.
+	 */
 #if !MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_2M_PHY)
-    phy_mask &= ~BLE_HCI_LE_PHY_2M_PREF_MASK;
+	phy_mask &= ~BLE_HCI_LE_PHY_2M_PREF_MASK;
 #endif
 #if !MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-    phy_mask &= ~BLE_HCI_LE_PHY_CODED_PREF_MASK;
+	phy_mask &= ~BLE_HCI_LE_PHY_CODED_PREF_MASK;
 #endif
 
-    if (phy_mask & BLE_PHY_MASK_1M) {
-        phy = BLE_PHY_1M;
-        phy_mask &= ~BLE_PHY_MASK_1M;
-    } else if (phy_mask & BLE_PHY_MASK_2M) {
-        phy = BLE_PHY_2M;
-        phy_mask &= ~BLE_PHY_MASK_2M;
-    } else if (phy_mask & BLE_PHY_MASK_CODED) {
-        phy = BLE_PHY_CODED;
-        phy_mask &= ~BLE_PHY_MASK_CODED;
-    } else {
-        phy = 0;
-    }
+	if (phy_mask & BLE_PHY_MASK_1M) {
+		phy = BLE_PHY_1M;
+		phy_mask &= ~BLE_PHY_MASK_1M;
+	}
+	else if (phy_mask & BLE_PHY_MASK_2M) {
+		phy = BLE_PHY_2M;
+		phy_mask &= ~BLE_PHY_MASK_2M;
+	}
+	else if (phy_mask & BLE_PHY_MASK_CODED) {
+		phy = BLE_PHY_CODED;
+		phy_mask &= ~BLE_PHY_MASK_CODED;
+	}
+	else {
+		phy = 0;
+	}
 
-    if (phy_mask != 0) {
-        phy = 0;
-    }
+	if (phy_mask != 0) {
+		phy = 0;
+	}
 
-    return phy;
+	return phy;
 }
 
 #if MYNEWT_VAL(BLE_LL_PHY)
-uint8_t
-ble_ll_ctrl_phy_tx_transition_get(uint8_t phy_mask)
-{
-    /*
-     * Evaluate PHYs in transition starting from the one with longest TX time
-     * so we select the one that allows shortest payload to be sent. This is
-     * to make sure we do not violate timing restriction on new PHY.
-     */
-    if (phy_mask & BLE_PHY_MASK_CODED) {
-        return BLE_PHY_CODED;
-    } else if (phy_mask & BLE_PHY_MASK_1M) {
-        return BLE_PHY_1M;
-    } else if (phy_mask & BLE_PHY_MASK_2M) {
-        return BLE_PHY_2M;
-    }
-
-    return 0;
-}
-
-void
-ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm)
-{
-    int chk_proc_stop;
-    int chk_host_phy;
-
-    chk_proc_stop = 1;
-    chk_host_phy = 1;
-
-    connsm->phy_tx_transition = 0;
-
-    if (connsm->flags.phy_update_peer_initiated) {
-        connsm->flags.phy_update_peer_initiated = 0;
-    } else if (connsm->flags.phy_update_self_initiated) {
-        connsm->flags.phy_update_self_initiated = 0;
-    } else {
-        /* Must be a host-initiated update */
-        connsm->flags.phy_update_host_initiated = 0;
-        chk_host_phy = 0;
-        if (connsm->flags.phy_update_host_w4event == 0) {
-            ble_ll_hci_ev_phy_update(connsm, BLE_ERR_SUCCESS);
-        }
-    }
-
-    /* Must check if we need to start host procedure */
-    if (chk_host_phy) {
-        if (connsm->flags.phy_update_host_initiated) {
-            if (ble_ll_conn_phy_update_if_needed(connsm)) {
-                connsm->flags.phy_update_host_initiated = 0;
-            } else {
-                chk_proc_stop = 0;
-            }
-        }
-    }
-
-    if (chk_proc_stop) {
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
-    }
+uint8_t ble_ll_ctrl_phy_tx_transition_get(uint8_t phy_mask)
+{
+	/*
+	 * Evaluate PHYs in transition starting from the one with longest TX time
+	 * so we select the one that allows shortest payload to be sent. This is
+	 * to make sure we do not violate timing restriction on new PHY.
+	 */
+	if (phy_mask & BLE_PHY_MASK_CODED) {
+		return BLE_PHY_CODED;
+	}
+	else if (phy_mask & BLE_PHY_MASK_1M) {
+		return BLE_PHY_1M;
+	}
+	else if (phy_mask & BLE_PHY_MASK_2M) {
+		return BLE_PHY_2M;
+	}
+
+	return 0;
+}
+
+void ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm)
+{
+	int chk_proc_stop;
+	int chk_host_phy;
+
+	chk_proc_stop = 1;
+	chk_host_phy = 1;
+
+	connsm->phy_tx_transition = 0;
+
+	if (connsm->flags.phy_update_peer_initiated) {
+		connsm->flags.phy_update_peer_initiated = 0;
+	}
+	else if (connsm->flags.phy_update_self_initiated) {
+		connsm->flags.phy_update_self_initiated = 0;
+	}
+	else {
+		/* Must be a host-initiated update */
+		connsm->flags.phy_update_host_initiated = 0;
+		chk_host_phy = 0;
+		if (connsm->flags.phy_update_host_w4event == 0) {
+			ble_ll_hci_ev_phy_update(connsm, BLE_ERR_SUCCESS);
+		}
+	}
+
+	/* Must check if we need to start host procedure */
+	if (chk_host_phy) {
+		if (connsm->flags.phy_update_host_initiated) {
+			if (ble_ll_conn_phy_update_if_needed(connsm)) {
+				connsm->flags.phy_update_host_initiated = 0;
+			}
+			else {
+				chk_proc_stop = 0;
+			}
+		}
+	}
+
+	if (chk_proc_stop) {
+		ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+	}
 }
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
@@ -729,23 +736,24 @@ ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm)
  * @param prefs The mask of preferred phys
  * @return uint8_t The phy to use (not a mask)
  */
-static uint8_t
-ble_ll_ctrl_find_new_phy(uint8_t phy_mask_prefs)
+static uint8_t ble_ll_ctrl_find_new_phy(uint8_t phy_mask_prefs)
 {
-    uint8_t new_phy;
+	uint8_t new_phy;
 
-    new_phy = phy_mask_prefs;
-    if (new_phy) {
-        if (new_phy & BLE_PHY_MASK_2M) {
-            new_phy = BLE_PHY_2M;
-        } else if (new_phy & BLE_PHY_MASK_1M) {
-            new_phy = BLE_PHY_1M;
-        } else {
-            new_phy = BLE_PHY_CODED;
-        }
-    }
+	new_phy = phy_mask_prefs;
+	if (new_phy) {
+		if (new_phy & BLE_PHY_MASK_2M) {
+			new_phy = BLE_PHY_2M;
+		}
+		else if (new_phy & BLE_PHY_MASK_1M) {
+			new_phy = BLE_PHY_1M;
+		}
+		else {
+			new_phy = BLE_PHY_CODED;
+		}
+	}
 
-    return new_phy;
+	return new_phy;
 }
 
 /**
@@ -757,129 +765,134 @@ ble_ll_ctrl_find_new_phy(uint8_t phy_mask_prefs)
  * @param periph_req flag denoting if peripheral requested this. 0: no 1:yes
  */
 
-static void
-ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                                uint8_t *ctrdata, int periph_req)
+static void ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                            uint8_t *ctrdata, int periph_req)
 {
-    uint8_t m_to_s;
-    uint8_t s_to_m;
-    uint8_t tx_phys;
-    uint8_t rx_phys;
-    uint8_t is_periph_sym = 0;
+	uint8_t m_to_s;
+	uint8_t s_to_m;
+	uint8_t tx_phys;
+	uint8_t rx_phys;
+	uint8_t is_periph_sym = 0;
 
-    /* Get preferences from PDU */
-    tx_phys = dptr[0];
-    rx_phys = dptr[1];
+	/* Get preferences from PDU */
+	tx_phys = dptr[0];
+	rx_phys = dptr[1];
 
-    /* If we are central, check if peripheral requested symmetric PHY */
+	/* If we are central, check if peripheral requested symmetric PHY */
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        is_periph_sym = tx_phys == rx_phys;
-        is_periph_sym &= __builtin_popcount(tx_phys) == 1;
-    }
-#endif
-
-    /* Get m_to_s and s_to_m masks */
-    if (periph_req) {
-        m_to_s = connsm->phy_data.pref_mask_tx & rx_phys;
-        s_to_m = connsm->phy_data.pref_mask_rx & tx_phys;
-    } else {
-        m_to_s = connsm->phy_data.pref_mask_tx_req & rx_phys;
-        s_to_m = connsm->phy_data.pref_mask_rx_req & tx_phys;
-    }
-
-    if (is_periph_sym) {
-        /*
-         * If either s_to_m or m_to_s is 0, it means for at least one direction
-         * requested PHY is not our preferred one so make sure we keep current
-         * PHY in both directions
-         *
-         * Core 5.2, Vol 6, PartB, 5.1.10
-         *     If the peripheral specified a single PHY in both the TX_PHYS and
-         *     RX_PHYS fields and both fields are the same, the central shall
-         *     either select the PHY specified by the peripheral for both directions
-         *     or shall leave both directions unchanged.
-         */
-        if ((s_to_m == 0) || (m_to_s == 0)) {
-            s_to_m = 0;
-            m_to_s = 0;
-        } else {
-            BLE_LL_ASSERT(s_to_m == m_to_s);
-        }
-    }
-
-    /* Calculate new PHYs to use */
-    m_to_s = ble_ll_ctrl_find_new_phy(m_to_s);
-    s_to_m = ble_ll_ctrl_find_new_phy(s_to_m);
-
-    /* Make sure we do not indicate PHY change if the same as current one */
-    if (m_to_s == connsm->phy_data.cur_tx_phy) {
-        m_to_s = 0;
-    }
-    if (s_to_m == connsm->phy_data.cur_rx_phy) {
-        s_to_m = 0;
-    }
-
-    /* At this point, m_to_s and s_to_m are not masks; they are numeric */
-
-    /*
-     * If not changing we still send update ind. Check if hosts expects
-     * the event and if so send it. Stop control procedure if it is the
-     * one running.
-     */
-    if ((m_to_s == 0) && (s_to_m == 0)) {
-        if (connsm->flags.phy_update_peer_initiated) {
-            connsm->flags.phy_update_peer_initiated = 0;
-        } else if (connsm->flags.phy_update_self_initiated) {
-            connsm->flags.phy_update_self_initiated = 0;
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
-        } else {
-            ble_ll_hci_ev_phy_update(connsm, BLE_ERR_SUCCESS);
-            connsm->flags.phy_update_host_initiated = 0;
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
-        }
-    } else {
-        /* Set new phys to use when instant occurs */
-        connsm->phy_data.new_tx_phy = m_to_s;
-        connsm->phy_data.new_rx_phy = s_to_m;
-
-        /* Convert m_to_s and s_to_m to masks */
-        if (m_to_s) {
-            m_to_s = 1 << (m_to_s - 1);
-        }
-
-        if (s_to_m) {
-            s_to_m = 1 << (s_to_m - 1);
-        }
-    }
-
-    ctrdata[0] = m_to_s;
-    ctrdata[1] = s_to_m;
-}
-
-static bool
-ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
-{
-    uint16_t instant;
-    uint8_t m_to_s;
-    uint8_t s_to_m;
-    bool schedule = false;
-
-    m_to_s = ctrdata[0];
-    s_to_m = ctrdata[1];
-
-    if ((m_to_s == 0) && (s_to_m == 0)) {
-        instant = 0;
-    } else {
-        /* Determine instant we will use. 6 more is minimum */
-        instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
-        connsm->phy_instant = instant;
-        schedule = true;
-    }
-
-    put_le16(ctrdata + 2, instant);
-
-    return schedule;
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+		is_periph_sym = tx_phys == rx_phys;
+		is_periph_sym &= __builtin_popcount(tx_phys) == 1;
+	}
+#endif
+
+	/* Get m_to_s and s_to_m masks */
+	if (periph_req) {
+		m_to_s = connsm->phy_data.pref_mask_tx & rx_phys;
+		s_to_m = connsm->phy_data.pref_mask_rx & tx_phys;
+	}
+	else {
+		m_to_s = connsm->phy_data.pref_mask_tx_req & rx_phys;
+		s_to_m = connsm->phy_data.pref_mask_rx_req & tx_phys;
+	}
+
+	if (is_periph_sym) {
+		/*
+		 * If either s_to_m or m_to_s is 0, it means for at least one direction
+		 * requested PHY is not our preferred one so make sure we keep current
+		 * PHY in both directions
+		 *
+		 * Core 5.2, Vol 6, PartB, 5.1.10
+		 *     If the peripheral specified a single PHY in both the TX_PHYS and
+		 *     RX_PHYS fields and both fields are the same, the central shall
+		 *     either select the PHY specified by the peripheral for both directions
+		 *     or shall leave both directions unchanged.
+		 */
+		if ((s_to_m == 0) || (m_to_s == 0)) {
+			s_to_m = 0;
+			m_to_s = 0;
+		}
+		else {
+			BLE_LL_ASSERT(s_to_m == m_to_s);
+		}
+	}
+
+	/* Calculate new PHYs to use */
+	m_to_s = ble_ll_ctrl_find_new_phy(m_to_s);
+	s_to_m = ble_ll_ctrl_find_new_phy(s_to_m);
+
+	/* Make sure we do not indicate PHY change if the same as current one */
+	if (m_to_s == connsm->phy_data.cur_tx_phy) {
+		m_to_s = 0;
+	}
+	if (s_to_m == connsm->phy_data.cur_rx_phy) {
+		s_to_m = 0;
+	}
+
+	/* At this point, m_to_s and s_to_m are not masks; they are numeric */
+
+	/*
+	 * If not changing we still send update ind. Check if hosts expects
+	 * the event and if so send it. Stop control procedure if it is the
+	 * one running.
+	 */
+	if ((m_to_s == 0) && (s_to_m == 0)) {
+		if (connsm->flags.phy_update_peer_initiated) {
+			connsm->flags.phy_update_peer_initiated = 0;
+		}
+		else if (connsm->flags.phy_update_self_initiated) {
+			connsm->flags.phy_update_self_initiated = 0;
+			ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+		}
+		else {
+			ble_ll_hci_ev_phy_update(connsm, BLE_ERR_SUCCESS);
+			connsm->flags.phy_update_host_initiated = 0;
+			ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+		}
+	}
+	else {
+		/* Set new phys to use when instant occurs */
+		connsm->phy_data.new_tx_phy = m_to_s;
+		connsm->phy_data.new_rx_phy = s_to_m;
+
+		/* Convert m_to_s and s_to_m to masks */
+		if (m_to_s) {
+			m_to_s = 1 << (m_to_s - 1);
+		}
+
+		if (s_to_m) {
+			s_to_m = 1 << (s_to_m - 1);
+		}
+	}
+
+	ctrdata[0] = m_to_s;
+	ctrdata[1] = s_to_m;
+}
+
+static bool ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm *connsm,
+                                               uint8_t *ctrdata)
+{
+	uint16_t instant;
+	uint8_t m_to_s;
+	uint8_t s_to_m;
+	bool schedule = false;
+
+	m_to_s = ctrdata[0];
+	s_to_m = ctrdata[1];
+
+	if ((m_to_s == 0) && (s_to_m == 0)) {
+		instant = 0;
+	}
+	else {
+		/* Determine instant we will use. 6 more is minimum */
+		instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
+		connsm->phy_instant = instant;
+		schedule = true;
+	}
+
+	put_le16(ctrdata + 2, instant);
+
+	return schedule;
 }
 #endif
 
@@ -889,11 +902,10 @@ ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm *connsm, uint8_t *ctrda
  * @param connsm Pointer to connection state machine
  * @param ctrdata: Pointer to where CtrData starts in pdu
  */
-static void
-ble_ll_ctrl_phy_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
+static void ble_ll_ctrl_phy_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
 {
-    ctrdata[0] = connsm->phy_data.pref_mask_tx;
-    ctrdata[1] = connsm->phy_data.pref_mask_rx;
+	ctrdata[0] = connsm->phy_data.pref_mask_tx;
+	ctrdata[1] = connsm->phy_data.pref_mask_rx;
 }
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
@@ -903,84 +915,82 @@ ble_ll_ctrl_phy_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
  * @param connsm Pointer to connection state machine
  * @param ctrdata: Pointer to where CtrData starts in pdu
  */
-static void
-ble_ll_ctrl_sca_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
+static void ble_ll_ctrl_sca_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
 {
-    ctrdata[0] = BLE_LL_SCA_ENUM;
+	ctrdata[0] = BLE_LL_SCA_ENUM;
 }
 #endif
 
-static uint8_t
-ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
-                       uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
+                                      uint8_t *rsp)
 {
-    uint8_t rsp_opcode;
-    uint8_t err;
+	uint8_t rsp_opcode;
+	uint8_t err;
 
-    /*
-     * XXX: TODO if we have an instant in progress we should end connection.
-     * At least it seems that is the case. Need to figure out more from
-     * the spec here.
-     */
+	/*
+	 * XXX: TODO if we have an instant in progress we should end connection.
+	 * At least it seems that is the case. Need to figure out more from
+	 * the spec here.
+	 */
 
-    /* Check if we have already initiated a procedure with an instant */
-    err = ble_ll_ctrl_proc_with_instant_initiated(connsm,
-                                                  BLE_LL_CTRL_PROC_PHY_UPDATE);
+	/* Check if we have already initiated a procedure with an instant */
+	err = ble_ll_ctrl_proc_with_instant_initiated(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
 
-    switch (connsm->conn_role) {
+	switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        if (err) {
-            ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_PHY_REQ, err, rsp);
-            rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        } else {
-            /*
-             * NOTE: do not change order of these two lines as the call to
-             * make the LL_PHY_UPDATE_IND pdu might clear the flag.
-             */
-            connsm->flags.phy_update_peer_initiated = 1;
-            ble_ll_ctrl_phy_update_ind_make(connsm, req, rsp, 1);
-            rsp_opcode = BLE_LL_CTRL_PHY_UPDATE_IND;
-        }
-        break;
+	case BLE_LL_CONN_ROLE_CENTRAL:
+		if (err) {
+			ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_PHY_REQ, err, rsp);
+			rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+		}
+		else {
+			/*
+			 * NOTE: do not change order of these two lines as the call to
+			 * make the LL_PHY_UPDATE_IND pdu might clear the flag.
+			 */
+			connsm->flags.phy_update_peer_initiated = 1;
+			ble_ll_ctrl_phy_update_ind_make(connsm, req, rsp, 1);
+			rsp_opcode = BLE_LL_CTRL_PHY_UPDATE_IND;
+		}
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        /* XXX: deal with other control procedures that we need to stop */
-        if (err) {
-            if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE) {
-                ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
-                connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
-            }
+	case BLE_LL_CONN_ROLE_PERIPHERAL:
+		/* XXX: deal with other control procedures that we need to stop */
+		if (err) {
+			if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE) {
+				ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
+				connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
+			}
 
-            /* If there is a PHY update procedure pending cancel it */
-            ble_ll_ctrl_phy_update_cancel(connsm, err);
+			/* If there is a PHY update procedure pending cancel it */
+			ble_ll_ctrl_phy_update_cancel(connsm, err);
 
-            /* XXX: ? Should not be any phy update events */
-            connsm->flags.phy_update_host_w4event = 0;
-        }
+			/* XXX: ? Should not be any phy update events */
+			connsm->flags.phy_update_host_w4event = 0;
+		}
 
-        /* XXX: TODO: if we started another procedure with an instant
-         * why are we doing this? Need to look into this.*/
+		/* XXX: TODO: if we started another procedure with an instant
+		 * why are we doing this? Need to look into this.*/
 
-        /* Respond to central's phy update procedure */
-        connsm->flags.phy_update_peer_initiated = 1;
-        ble_ll_ctrl_phy_req_rsp_make(connsm, rsp);
-        rsp_opcode = BLE_LL_CTRL_PHY_RSP;
+		/* Respond to central's phy update procedure */
+		connsm->flags.phy_update_peer_initiated = 1;
+		ble_ll_ctrl_phy_req_rsp_make(connsm, rsp);
+		rsp_opcode = BLE_LL_CTRL_PHY_RSP;
 
-        connsm->phy_tx_transition = ble_ll_ctrl_phy_tx_transition_get(req[1] | rsp[0]);
+		connsm->phy_tx_transition = ble_ll_ctrl_phy_tx_transition_get(req[1] | rsp[0]);
 
-        /* Start response timer */
-        connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_PHY_UPDATE;
-        ble_ll_ctrl_start_rsp_timer(connsm);
-        break;
+		/* Start response timer */
+		connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_PHY_UPDATE;
+		ble_ll_ctrl_start_rsp_timer(connsm);
+		break;
 #endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
+	default:
+		BLE_LL_ASSERT(0);
+		break;
+	}
 
-    return rsp_opcode;
+	return rsp_opcode;
 }
 
 /**
@@ -992,44 +1002,43 @@ ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_phy_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                       uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_phy_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                      uint8_t *rsp)
 {
-    uint8_t rsp_opcode;
+	uint8_t rsp_opcode;
 
-    rsp_opcode = BLE_ERR_MAX;
+	rsp_opcode = BLE_ERR_MAX;
 
-    switch (connsm->conn_role) {
+	switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE) {
-            ble_ll_ctrl_phy_update_ind_make(connsm, dptr, rsp, 0);
-            ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
-            rsp_opcode = BLE_LL_CTRL_PHY_UPDATE_IND;
-        }
-
-        /*
-         * If not in the process of doing this control procedure something
-         * is wrong. End connection? Assert?
-         *
-         * XXX: TODO count some stat?
-         */
-        break;
+	case BLE_LL_CONN_ROLE_CENTRAL:
+		if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE) {
+			ble_ll_ctrl_phy_update_ind_make(connsm, dptr, rsp, 0);
+			ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
+			rsp_opcode = BLE_LL_CTRL_PHY_UPDATE_IND;
+		}
+
+		/*
+		 * If not in the process of doing this control procedure something
+		 * is wrong. End connection? Assert?
+		 *
+		 * XXX: TODO count some stat?
+		 */
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-        break;
+	case BLE_LL_CONN_ROLE_PERIPHERAL:
+		rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
+		break;
 #endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
+	default:
+		BLE_LL_ASSERT(0);
+		break;
+	}
 
-    /* NOTE: peripheral should never receive one of these */
+	/* NOTE: peripheral should never receive one of these */
 
-    return rsp_opcode;
+	return rsp_opcode;
 }
 
 /**
@@ -1042,82 +1051,83 @@ ble_ll_ctrl_rx_phy_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static uint8_t ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    int no_change;
-    uint8_t new_m_to_s_mask;
-    uint8_t new_s_to_m_mask;
-    uint8_t new_tx_phy;
-    uint8_t new_rx_phy;
-    uint16_t instant;
-    uint16_t delta;
+	int no_change;
+	uint8_t new_m_to_s_mask;
+	uint8_t new_s_to_m_mask;
+	uint8_t new_tx_phy;
+	uint8_t new_rx_phy;
+	uint16_t instant;
+	uint16_t delta;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
-#endif
-
-    /*
-     * Reception stops the procedure response timer but does not
-     * complete the procedure
-     */
-    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE) {
-        ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
-    }
-
-    /*
-     * XXX: Should we check to see if we are expecting to receive one
-     * of these, and if not, kill connection? Meaning we better be
-     * doing either a PEER, CTRLR, or HOST phy update.
-     */
-    /* get the new phy masks and see if we need to change */
-    new_m_to_s_mask = dptr[0];
-    new_s_to_m_mask = dptr[1];
-    instant = get_le16(dptr + 2);
-
-    if ((new_m_to_s_mask == 0) && (new_s_to_m_mask == 0)) {
-        /* No change in phy */
-        no_change = 1;
-    } else {
-        no_change = 0;
-        /*
-         * NOTE: from the peripherals perspective, the m to s phy is the one
-         * that the peripheral will receive on; s to m is the one it will
-         * transmit on
-         */
-        new_rx_phy = ble_ll_ctrl_phy_from_phy_mask(new_m_to_s_mask);
-        new_tx_phy = ble_ll_ctrl_phy_from_phy_mask(new_s_to_m_mask);
-
-        if ((new_tx_phy == 0) && (new_rx_phy == 0)) {
-            /* XXX: this is an error! What to do??? */
-            no_change = 1;
-        }
-
-        if ((new_tx_phy == connsm->phy_data.cur_tx_phy) &&
-            (new_rx_phy == connsm->phy_data.cur_rx_phy)) {
-            no_change = 1;
-        }
-    }
-
-    if (!no_change) {
-        /* If instant is in the past, we have to end the connection */
-        delta = (instant - connsm->event_cntr) & 0xFFFF;
-        if (delta >= 32767) {
-            ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
-        } else {
-            connsm->phy_data.new_tx_phy = new_tx_phy;
-            connsm->phy_data.new_rx_phy = new_rx_phy;
-            connsm->phy_instant = instant;
-            connsm->flags.phy_update_sched = 1;
-        }
-        return BLE_ERR_MAX;
-    }
-
-    ble_ll_ctrl_phy_update_proc_complete(connsm);
-
-    return BLE_ERR_MAX;
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+		return BLE_LL_CTRL_UNKNOWN_RSP;
+	}
+#endif
+
+	/*
+	 * Reception stops the procedure response timer but does not
+	 * complete the procedure
+	 */
+	if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_PHY_UPDATE) {
+		ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
+	}
+
+	/*
+	 * XXX: Should we check to see if we are expecting to receive one
+	 * of these, and if not, kill connection? Meaning we better be
+	 * doing either a PEER, CTRLR, or HOST phy update.
+	 */
+	/* get the new phy masks and see if we need to change */
+	new_m_to_s_mask = dptr[0];
+	new_s_to_m_mask = dptr[1];
+	instant = get_le16(dptr + 2);
+
+	if ((new_m_to_s_mask == 0) && (new_s_to_m_mask == 0)) {
+		/* No change in phy */
+		no_change = 1;
+	}
+	else {
+		no_change = 0;
+		/*
+		 * NOTE: from the peripherals perspective, the m to s phy is the one
+		 * that the peripheral will receive on; s to m is the one it will
+		 * transmit on
+		 */
+		new_rx_phy = ble_ll_ctrl_phy_from_phy_mask(new_m_to_s_mask);
+		new_tx_phy = ble_ll_ctrl_phy_from_phy_mask(new_s_to_m_mask);
+
+		if ((new_tx_phy == 0) && (new_rx_phy == 0)) {
+			/* XXX: this is an error! What to do??? */
+			no_change = 1;
+		}
+
+		if ((new_tx_phy == connsm->phy_data.cur_tx_phy) &&
+		    (new_rx_phy == connsm->phy_data.cur_rx_phy)) {
+			no_change = 1;
+		}
+	}
+
+	if (!no_change) {
+		/* If instant is in the past, we have to end the connection */
+		delta = (instant - connsm->event_cntr) & 0xFFFF;
+		if (delta >= 32767) {
+			ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
+		}
+		else {
+			connsm->phy_data.new_tx_phy = new_tx_phy;
+			connsm->phy_data.new_rx_phy = new_rx_phy;
+			connsm->phy_instant = instant;
+			connsm->flags.phy_update_sched = 1;
+		}
+		return BLE_ERR_MAX;
+	}
+
+	ble_ll_ctrl_phy_update_proc_complete(connsm);
+
+	return BLE_ERR_MAX;
 }
 #endif
 
@@ -1130,15 +1140,15 @@ ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_periodic_sync_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static uint8_t ble_ll_ctrl_rx_periodic_sync_ind(struct ble_ll_conn_sm *connsm,
+                                                uint8_t *dptr)
 {
-    if (connsm->sync_transfer_mode) {
-        ble_ll_sync_periodic_ind(connsm, dptr, connsm->sync_transfer_mode == 1,
-                                 connsm->sync_transfer_skip,
-                                 connsm->sync_transfer_sync_timeout);
-    }
-    return BLE_ERR_MAX;
+	if (connsm->sync_transfer_mode) {
+		ble_ll_sync_periodic_ind(connsm, dptr, connsm->sync_transfer_mode == 1,
+		                         connsm->sync_transfer_skip,
+		                         connsm->sync_transfer_sync_timeout);
+	}
+	return BLE_ERR_MAX;
 }
 #endif
 
@@ -1152,17 +1162,16 @@ ble_ll_ctrl_rx_periodic_sync_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_sca_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                       uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_sca_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                      uint8_t *rsp)
 {
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-        connsm->central_sca = dptr[0];
-    }
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
+		connsm->central_sca = dptr[0];
+	}
 
-    ble_ll_ctrl_sca_req_rsp_make(connsm, rsp);
+	ble_ll_ctrl_sca_req_rsp_make(connsm, rsp);
 
-    return BLE_LL_CTRL_CLOCK_ACCURACY_RSP;
+	return BLE_LL_CTRL_CLOCK_ACCURACY_RSP;
 }
 
 /**
@@ -1173,143 +1182,140 @@ ble_ll_ctrl_rx_sca_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_sca_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static uint8_t ble_ll_ctrl_rx_sca_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    if (connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_SCA_UPDATE) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+	if (connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_SCA_UPDATE) {
+		return BLE_LL_CTRL_UNKNOWN_RSP;
+	}
 
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-        connsm->central_sca = dptr[0];
-    }
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
+		connsm->central_sca = dptr[0];
+	}
 
-    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SCA_UPDATE);
-    ble_ll_hci_ev_sca_update(connsm, BLE_ERR_SUCCESS, dptr[0]);
+	ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SCA_UPDATE);
+	ble_ll_hci_ev_sca_update(connsm, BLE_ERR_SUCCESS, dptr[0]);
 
-    return BLE_ERR_MAX;
+	return BLE_ERR_MAX;
 }
 
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-static void
-ble_ll_ctrl_subrate_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
-                             struct ble_ll_conn_subrate_req_params *srp)
+static void ble_ll_ctrl_subrate_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
+                                         struct ble_ll_conn_subrate_req_params *srp)
 {
-    put_le16(pyld + 0, srp->subrate_min);
-    put_le16(pyld + 2, srp->subrate_max);
-    put_le16(pyld + 4, srp->max_latency);
-    put_le16(pyld + 6, srp->cont_num);
-    put_le16(pyld + 8, srp->supervision_tmo);
+	put_le16(pyld + 0, srp->subrate_min);
+	put_le16(pyld + 2, srp->subrate_max);
+	put_le16(pyld + 4, srp->max_latency);
+	put_le16(pyld + 6, srp->cont_num);
+	put_le16(pyld + 8, srp->supervision_tmo);
 }
 
-static void
-ble_ll_ctrl_subrate_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
-                             struct ble_ll_conn_subrate_params *sp)
+static void ble_ll_ctrl_subrate_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
+                                         struct ble_ll_conn_subrate_params *sp)
 {
-    put_le16(pyld + 0, sp->subrate_factor);
-    put_le16(pyld + 2, sp->subrate_base_event);
-    put_le16(pyld + 4, sp->periph_latency);
-    put_le16(pyld + 6, sp->cont_num);
-    put_le16(pyld + 8, sp->supervision_tmo);
+	put_le16(pyld + 0, sp->subrate_factor);
+	put_le16(pyld + 2, sp->subrate_base_event);
+	put_le16(pyld + 4, sp->periph_latency);
+	put_le16(pyld + 6, sp->cont_num);
+	put_le16(pyld + 8, sp->supervision_tmo);
 }
 
-static uint8_t
-ble_ll_ctrl_rx_subrate_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
-                           uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_subrate_req(struct ble_ll_conn_sm *connsm,
+                                          uint8_t *req, uint8_t *rsp)
 {
-    struct ble_ll_conn_subrate_req_params params;
-    struct ble_ll_conn_subrate_req_params *srp = &params;
-    uint8_t err;
-    int rc;
+	struct ble_ll_conn_subrate_req_params params;
+	struct ble_ll_conn_subrate_req_params *srp = &params;
+	uint8_t err;
+	int rc;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
+		return BLE_LL_CTRL_UNKNOWN_RSP;
+	}
 #endif
 
-    if ((ble_ll_read_supp_features() & BLE_LL_FEAT_CONN_SUBRATING_HOST) == 0) {
-        ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_SUBRATE_REQ,
-                                     BLE_ERR_UNSUPP_REM_FEATURE, rsp);
-        return BLE_LL_CTRL_REJECT_IND_EXT;
-    }
+	if ((ble_ll_read_supp_features() & BLE_LL_FEAT_CONN_SUBRATING_HOST) == 0) {
+		ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_SUBRATE_REQ, BLE_ERR_UNSUPP_REM_FEATURE,
+		                             rsp);
+		return BLE_LL_CTRL_REJECT_IND_EXT;
+	}
 
-    srp->subrate_min = get_le16(req + 0);
-    srp->subrate_max = get_le16(req + 2);
-    srp->max_latency = get_le16(req + 4);
-    srp->cont_num = get_le16(req + 6);
-    srp->supervision_tmo = get_le16(req + 8);
+	srp->subrate_min = get_le16(req + 0);
+	srp->subrate_max = get_le16(req + 2);
+	srp->max_latency = get_le16(req + 4);
+	srp->cont_num = get_le16(req + 6);
+	srp->supervision_tmo = get_le16(req + 8);
 
-    rc = ble_ll_conn_subrate_req_llcp(connsm, srp);
-    if (rc < 0) {
-        if (rc == -EINVAL) {
-            err = BLE_ERR_INV_LMP_LL_PARM;
-        } else if (rc == -ENOTSUP) {
-            err = BLE_ERR_UNSUPP_REM_FEATURE;
-        } else if (rc == -EBUSY) {
-            err = BLE_ERR_DIFF_TRANS_COLL;
-        } else {
-            err = BLE_ERR_UNSPECIFIED;
-        }
+	rc = ble_ll_conn_subrate_req_llcp(connsm, srp);
+	if (rc < 0) {
+		if (rc == -EINVAL) {
+			err = BLE_ERR_INV_LMP_LL_PARM;
+		}
+		else if (rc == -ENOTSUP) {
+			err = BLE_ERR_UNSUPP_REM_FEATURE;
+		}
+		else if (rc == -EBUSY) {
+			err = BLE_ERR_DIFF_TRANS_COLL;
+		}
+		else {
+			err = BLE_ERR_UNSPECIFIED;
+		}
 
-        ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_SUBRATE_REQ, err, rsp);
+		ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_SUBRATE_REQ, err, rsp);
 
-        return BLE_LL_CTRL_REJECT_IND_EXT;
-    }
+		return BLE_LL_CTRL_REJECT_IND_EXT;
+	}
 
-    return BLE_ERR_MAX;
+	return BLE_ERR_MAX;
 }
 
-static uint8_t
-ble_ll_ctrl_rx_subrate_ind(struct ble_ll_conn_sm *connsm, uint8_t *req,
-                           uint8_t *rsp)
+static uint8_t ble_ll_ctrl_rx_subrate_ind(struct ble_ll_conn_sm *connsm,
+                                          uint8_t *req, uint8_t *rsp)
 {
-    struct ble_ll_conn_subrate_params params;
-    struct ble_ll_conn_subrate_params *sp = &params;
-    uint32_t t1, t2;
+	struct ble_ll_conn_subrate_params params;
+	struct ble_ll_conn_subrate_params *sp = &params;
+	uint32_t t1, t2;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
-#endif
-
-    sp->subrate_factor = get_le16(req + 0);
-    sp->subrate_base_event = get_le16(req + 2);
-    sp->periph_latency = get_le16(req + 4);
-    sp->cont_num = get_le16(req + 6);
-    sp->supervision_tmo = get_le16(req + 8);
-
-    /* This is probably not really useful since we shall apply new parameters
-     * immediately after receiving LL_SUBRATE_IND and central shall apply those
-     * parameters after receiving ack which it already did, so it's too late
-     * here to do anything useful. Let's just send LL_REJECT_EXT_IND anyway just
-     * for debugging purposes and reset to subrate factor of 1 and no latency,
-     * perhaps we can find some connection event from central and send our PDU.
-     */
-    t1 = connsm->conn_itvl * sp->subrate_factor * (sp->periph_latency + 1) *
-         BLE_LL_CONN_ITVL_USECS;
-    t2 = sp->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000 / 2;
-    if ((sp->subrate_factor < 1) || (sp->subrate_factor > 500) ||
-        (sp->cont_num > sp->subrate_factor - 1) ||
-        (sp->subrate_factor * (sp->periph_latency + 1) > 500) || (t1 >= t2)) {
-
-        sp->subrate_factor = 1;
-        sp->subrate_base_event = connsm->event_cntr;
-        sp->periph_latency = 0;
-        sp->cont_num = 0;
-        sp->supervision_tmo = connsm->supervision_tmo;
-
-        return BLE_ERR_MAX;
-    }
-
-    ble_ll_conn_subrate_set(connsm, sp);
-    ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SUBRATE_REQ);
-    connsm->flags.subrate_host_req = 0;
-
-    return BLE_ERR_MAX;
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+		return BLE_LL_CTRL_UNKNOWN_RSP;
+	}
+#endif
+
+	sp->subrate_factor = get_le16(req + 0);
+	sp->subrate_base_event = get_le16(req + 2);
+	sp->periph_latency = get_le16(req + 4);
+	sp->cont_num = get_le16(req + 6);
+	sp->supervision_tmo = get_le16(req + 8);
+
+	/* This is probably not really useful since we shall apply new parameters
+	 * immediately after receiving LL_SUBRATE_IND and central shall apply those
+	 * parameters after receiving ack which it already did, so it's too late
+	 * here to do anything useful. Let's just send LL_REJECT_EXT_IND anyway just
+	 * for debugging purposes and reset to subrate factor of 1 and no latency,
+	 * perhaps we can find some connection event from central and send our PDU.
+	 */
+	t1 = connsm->conn_itvl * sp->subrate_factor * (sp->periph_latency + 1) *
+	     BLE_LL_CONN_ITVL_USECS;
+	t2 = sp->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000 / 2;
+	if ((sp->subrate_factor < 1) || (sp->subrate_factor > 500) ||
+	    (sp->cont_num > sp->subrate_factor - 1) ||
+	    (sp->subrate_factor * (sp->periph_latency + 1) > 500) || (t1 >= t2)) {
+		sp->subrate_factor = 1;
+		sp->subrate_base_event = connsm->event_cntr;
+		sp->periph_latency = 0;
+		sp->cont_num = 0;
+		sp->supervision_tmo = connsm->supervision_tmo;
+
+		return BLE_ERR_MAX;
+	}
+
+	ble_ll_conn_subrate_set(connsm, sp);
+	ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SUBRATE_REQ);
+	connsm->flags.subrate_host_req = 0;
+
+	return BLE_ERR_MAX;
 }
 #endif
 
@@ -1322,51 +1328,56 @@ ble_ll_ctrl_rx_subrate_ind(struct ble_ll_conn_sm *connsm, uint8_t *req,
  * @param connsm
  * @param dptr: Pointer to where control pdu payload starts
  */
-static void
-ble_ll_ctrl_datalen_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static void ble_ll_ctrl_datalen_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    put_le16(dptr + 1, connsm->max_rx_octets);
-    put_le16(dptr + 3, connsm->max_rx_time);
-    put_le16(dptr + 5, connsm->max_tx_octets);
-    put_le16(dptr + 7, connsm->max_tx_time);
+	put_le16(dptr + 1, connsm->max_rx_octets);
+	put_le16(dptr + 3, connsm->max_rx_time);
+	put_le16(dptr + 5, connsm->max_tx_octets);
+	put_le16(dptr + 7, connsm->max_tx_time);
 }
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-void
-ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm)
+void ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm)
 {
 #ifdef BLE_LL_ENCRYPT_DEBUG
-    int cnt;
-#endif
-
-    /* XXX: possibly have some way out of this if this locks up */
-    while (1) {
-        if (!ble_hw_encrypt_block(&connsm->enc_data.enc_block)) {
-            break;
-        }
-    }
+	int cnt;
+#endif
+	int cnt;
+	/* XXX: possibly have some way out of this if this locks up */
+	while (1) {
+		if (!ble_hw_encrypt_block(&connsm->enc_data.enc_block)) {
+			break;
+		}
+	}
+	printf("\nLTK:");
+	for (cnt = 0; cnt < 16; ++cnt) {
+		printf("%02x", connsm->enc_data.enc_block.key[cnt]);
+	}
+	printf("\nSession Key:");
+	for (cnt = 0; cnt < 16; ++cnt) {
+		printf("%02x", connsm->enc_data.enc_block.cipher_text[cnt]);
+	}
 
 #ifdef BLE_LL_ENCRYPT_DEBUG
-    console_printf("Calculating Session Key for handle=%u",
-                   connsm->conn_handle);
-
-    console_printf("\nLTK:");
-    for (cnt = 0; cnt < 16; ++cnt) {
-        console_printf("%02x", connsm->enc_data.enc_block.key[cnt]);
-    }
-    console_printf("\nSKD:");
-    for (cnt = 0; cnt < 16; ++cnt) {
-        console_printf("%02x", connsm->enc_data.enc_block.plain_text[cnt]);
-    }
-    console_printf("\nSession Key:");
-    for (cnt = 0; cnt < 16; ++cnt) {
-        console_printf("%02x", connsm->enc_data.enc_block.cipher_text[cnt]);
-    }
-    console_printf("\nIV:");
-    for (cnt = 0; cnt < 8; ++ cnt) {
-        console_printf("%02x", connsm->enc_data.iv[cnt]);
-    }
-    console_printf("\n");
+	console_printf("Calculating Session Key for handle=%u", connsm->conn_handle);
+
+	console_printf("\nLTK:");
+	for (cnt = 0; cnt < 16; ++cnt) {
+		console_printf("%02x", connsm->enc_data.enc_block.key[cnt]);
+	}
+	console_printf("\nSKD:");
+	for (cnt = 0; cnt < 16; ++cnt) {
+		console_printf("%02x", connsm->enc_data.enc_block.plain_text[cnt]);
+	}
+	console_printf("\nSession Key:");
+	for (cnt = 0; cnt < 16; ++cnt) {
+		console_printf("%02x", connsm->enc_data.enc_block.cipher_text[cnt]);
+	}
+	console_printf("\nIV:");
+	for (cnt = 0; cnt < 8; ++cnt) {
+		console_printf("%02x", connsm->enc_data.iv[cnt]);
+	}
+	console_printf("\n");
 #endif
 }
 
@@ -1386,101 +1397,99 @@ ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm)
  *
  * @return int
  */
-static int
-ble_ll_ctrl_enc_allowed_pdu(uint8_t llid, uint8_t len, uint8_t opcode)
-{
-    int allowed;
-
-    allowed = 0;
-
-    switch (llid) {
-    case BLE_LL_LLID_CTRL:
-        switch (opcode) {
-        case BLE_LL_CTRL_REJECT_IND:
-        case BLE_LL_CTRL_REJECT_IND_EXT:
-        case BLE_LL_CTRL_START_ENC_RSP:
-        case BLE_LL_CTRL_START_ENC_REQ:
-        case BLE_LL_CTRL_ENC_REQ:
-        case BLE_LL_CTRL_ENC_RSP:
-        case BLE_LL_CTRL_PAUSE_ENC_REQ:
-        case BLE_LL_CTRL_PAUSE_ENC_RSP:
-        case BLE_LL_CTRL_TERMINATE_IND:
-            allowed = 1;
-            break;
-        }
-        break;
-    case BLE_LL_LLID_DATA_FRAG:
-        if (len == 0) {
-            /* Empty PDUs are allowed */
-            allowed = 1;
-        }
-        break;
-    }
-
-    return allowed;
-}
-
-int
-ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf *rxpdu)
-{
-    uint8_t llid;
-    uint8_t len;
-    uint8_t opcode;
-
-    llid = rxpdu->om_data[0] & BLE_LL_DATA_HDR_LLID_MASK;
-    len = rxpdu->om_data[1];
-    if (llid == BLE_LL_LLID_CTRL) {
-        opcode = rxpdu->om_data[2];
-    } else {
-        opcode = 0;
-    }
-
-    return ble_ll_ctrl_enc_allowed_pdu(llid, len, opcode);
-}
-
-int
-ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr *pkthdr)
-{
-    struct os_mbuf *m;
-    struct ble_mbuf_hdr *ble_hdr;
-    uint8_t llid;
-    uint8_t len;
-    uint8_t opcode;
-
-    m = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
-    ble_hdr = BLE_MBUF_HDR_PTR(m);
-
-    llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
-    len = ble_hdr->txinfo.pyld_len;
-    if (llid == BLE_LL_LLID_CTRL) {
-        opcode = m->om_data[0];
-    } else {
-        opcode = 0;
-    }
-
-    return ble_ll_ctrl_enc_allowed_pdu(llid, len, opcode);
-}
-
-int
-ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf *txpdu)
-{
-    int is_start_enc_rsp;
-    uint8_t opcode;
-    uint8_t llid;
-    struct ble_mbuf_hdr *ble_hdr;
-
-    is_start_enc_rsp = 0;
-    ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
-
-    llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
-    if (llid == BLE_LL_LLID_CTRL) {
-        opcode = txpdu->om_data[0];
-        if (opcode == BLE_LL_CTRL_START_ENC_RSP) {
-            is_start_enc_rsp = 1;
-        }
-    }
-
-    return is_start_enc_rsp;
+static int ble_ll_ctrl_enc_allowed_pdu(uint8_t llid, uint8_t len, uint8_t opcode)
+{
+	int allowed;
+
+	allowed = 0;
+
+	switch (llid) {
+	case BLE_LL_LLID_CTRL:
+		switch (opcode) {
+		case BLE_LL_CTRL_REJECT_IND:
+		case BLE_LL_CTRL_REJECT_IND_EXT:
+		case BLE_LL_CTRL_START_ENC_RSP:
+		case BLE_LL_CTRL_START_ENC_REQ:
+		case BLE_LL_CTRL_ENC_REQ:
+		case BLE_LL_CTRL_ENC_RSP:
+		case BLE_LL_CTRL_PAUSE_ENC_REQ:
+		case BLE_LL_CTRL_PAUSE_ENC_RSP:
+		case BLE_LL_CTRL_TERMINATE_IND:
+			allowed = 1;
+			break;
+		}
+		break;
+	case BLE_LL_LLID_DATA_FRAG:
+		if (len == 0) {
+			/* Empty PDUs are allowed */
+			allowed = 1;
+		}
+		break;
+	}
+
+	return allowed;
+}
+
+int ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf *rxpdu)
+{
+	uint8_t llid;
+	uint8_t len;
+	uint8_t opcode;
+
+	llid = rxpdu->om_data[0] & BLE_LL_DATA_HDR_LLID_MASK;
+	len = rxpdu->om_data[1];
+	if (llid == BLE_LL_LLID_CTRL) {
+		opcode = rxpdu->om_data[2];
+	}
+	else {
+		opcode = 0;
+	}
+
+	return ble_ll_ctrl_enc_allowed_pdu(llid, len, opcode);
+}
+
+int ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr *pkthdr)
+{
+	struct os_mbuf *m;
+	struct ble_mbuf_hdr *ble_hdr;
+	uint8_t llid;
+	uint8_t len;
+	uint8_t opcode;
+
+	m = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
+	ble_hdr = BLE_MBUF_HDR_PTR(m);
+
+	llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
+	len = ble_hdr->txinfo.pyld_len;
+	if (llid == BLE_LL_LLID_CTRL) {
+		opcode = m->om_data[0];
+	}
+	else {
+		opcode = 0;
+	}
+
+	return ble_ll_ctrl_enc_allowed_pdu(llid, len, opcode);
+}
+
+int ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf *txpdu)
+{
+	int is_start_enc_rsp;
+	uint8_t opcode;
+	uint8_t llid;
+	struct ble_mbuf_hdr *ble_hdr;
+
+	is_start_enc_rsp = 0;
+	ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
+
+	llid = ble_hdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK;
+	if (llid == BLE_LL_LLID_CTRL) {
+		opcode = txpdu->om_data[0];
+		if (opcode == BLE_LL_CTRL_START_ENC_RSP) {
+			is_start_enc_rsp = 1;
+		}
+	}
+
+	return is_start_enc_rsp;
 }
 
 /**
@@ -1491,31 +1500,30 @@ ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf *txpdu)
  *
  * @return int
  */
-int
-ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm)
+int ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm)
 {
-    int rc;
-    struct os_mbuf *om;
+	int rc;
+	struct os_mbuf *om;
 
-    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
-                            sizeof(struct ble_mbuf_hdr));
-    if (om) {
-        om->om_data[0] = BLE_LL_CTRL_START_ENC_REQ;
-        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, 1);
+	om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN, sizeof(struct ble_mbuf_hdr));
+	if (om) {
+		om->om_data[0] = BLE_LL_CTRL_START_ENC_REQ;
+		ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, 1);
 
-        /* Wait for LL_START_ENC_RSP. If there is already procedure in progress,
-         * LL response timer is already running.
-         */
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) {
-            connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_ENCRYPT;
-            ble_ll_ctrl_start_rsp_timer(connsm);
-        }
+		/* Wait for LL_START_ENC_RSP. If there is already procedure in progress,
+		 * LL response timer is already running.
+		 */
+		if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) {
+			connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_ENCRYPT;
+			ble_ll_ctrl_start_rsp_timer(connsm);
+		}
 
-        rc = 0;
-    } else {
-        rc = -1;
-    }
-    return rc;
+		rc = 0;
+	}
+	else {
+		rc = -1;
+	}
+	return rc;
 }
 
 /**
@@ -1536,25 +1544,24 @@ ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm)
  * @param connsm
  * @param dptr: Pointer to where control pdu payload starts
  */
-static void
-ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static void ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    put_le64(dptr, connsm->enc_data.host_rand_num);
-    put_le16(dptr + 8, connsm->enc_data.enc_div);
+	put_le64(dptr, connsm->enc_data.host_rand_num);
+	put_le16(dptr + 8, connsm->enc_data.enc_div);
 
 #ifdef BLE_LL_ENCRYPT_USE_TEST_DATA
-    /* IV stored LSB to MSB, IVm is LSB, IVs is MSB */
-    put_le64(dptr + 10, g_bletest_SKDm);
-    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
-    put_le32(dptr + 18, g_bletest_IVm);
-    memcpy(connsm->enc_data.iv, dptr + 18, 4);
-    return;
+	/* IV stored LSB to MSB, IVm is LSB, IVs is MSB */
+	put_le64(dptr + 10, g_bletest_SKDm);
+	swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
+	put_le32(dptr + 18, g_bletest_IVm);
+	memcpy(connsm->enc_data.iv, dptr + 18, 4);
+	return;
 #endif
 
-    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text + 8, 8);
-    swap_buf(dptr + 10, connsm->enc_data.enc_block.plain_text + 8, 8);
-    ble_ll_rand_data_get(connsm->enc_data.iv, 4);
-    memcpy(dptr + 18, connsm->enc_data.iv, 4);
+	ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text + 8, 8);
+	swap_buf(dptr + 10, connsm->enc_data.enc_block.plain_text + 8, 8);
+	ble_ll_rand_data_get(connsm->enc_data.iv, 4);
+	memcpy(dptr + 18, connsm->enc_data.iv, 4);
 }
 
 /**
@@ -1573,21 +1580,20 @@ ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @param connsm
  * @param dptr
  */
-static void
-ble_ll_ctrl_rx_enc_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static void ble_ll_ctrl_rx_enc_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    /* Calculate session key now that we have received the ENC_RSP */
-    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
-        /* In case we were already encrypted we need to reset packet counters */
-        connsm->enc_data.rx_pkt_cntr = 0;
-        connsm->enc_data.tx_pkt_cntr = 0;
-        connsm->enc_data.tx_encrypted = 0;
+	/* Calculate session key now that we have received the ENC_RSP */
+	if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
+		/* In case we were already encrypted we need to reset packet counters */
+		connsm->enc_data.rx_pkt_cntr = 0;
+		connsm->enc_data.tx_pkt_cntr = 0;
+		connsm->enc_data.tx_encrypted = 0;
 
-        swap_buf(connsm->enc_data.enc_block.plain_text, dptr, 8);
-        memcpy(connsm->enc_data.iv + 4, dptr + 8, 4);
-        ble_ll_calc_session_key(connsm);
-        connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_REQ_WAIT;
-    }
+		swap_buf(connsm->enc_data.enc_block.plain_text, dptr, 8);
+		memcpy(connsm->enc_data.iv + 4, dptr + 8, 4);
+		ble_ll_calc_session_key(connsm);
+		connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_REQ_WAIT;
+	}
 }
 
 /**
@@ -1611,100 +1617,98 @@ ble_ll_ctrl_rx_enc_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @param dptr      Pointer to start of encrypt request data.
  * @param rspbuf
  */
-static uint8_t
-ble_ll_ctrl_rx_enc_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                       uint8_t *rspdata)
+static uint8_t ble_ll_ctrl_rx_enc_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                      uint8_t *rspdata)
 {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+		return BLE_LL_CTRL_UNKNOWN_RSP;
+	}
 #endif
 
-    connsm->enc_data.enc_state = CONN_ENC_S_ENC_RSP_TO_BE_SENT;
+	connsm->enc_data.enc_state = CONN_ENC_S_ENC_RSP_TO_BE_SENT;
 
-    /* In case we were already encrypted we need to reset packet counters */
-    connsm->enc_data.rx_pkt_cntr = 0;
-    connsm->enc_data.tx_pkt_cntr = 0;
-    connsm->enc_data.tx_encrypted = 0;
+	/* In case we were already encrypted we need to reset packet counters */
+	connsm->enc_data.rx_pkt_cntr = 0;
+	connsm->enc_data.tx_pkt_cntr = 0;
+	connsm->enc_data.tx_encrypted = 0;
 
-    /* Extract information from request */
-    connsm->enc_data.host_rand_num = get_le64(dptr);
-    connsm->enc_data.enc_div = get_le16(dptr + 8);
+	/* Extract information from request */
+	connsm->enc_data.host_rand_num = get_le64(dptr);
+	connsm->enc_data.enc_div = get_le16(dptr + 8);
 
 #if BLE_LL_ENCRYPT_USE_TEST_DATA
-    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
-    memcpy(connsm->enc_data.iv, dptr + 18, 4);
+	swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
+	memcpy(connsm->enc_data.iv, dptr + 18, 4);
 
-    put_le64(rspdata, g_bletest_SKDs);
-    swap_buf(connsm->enc_data.enc_block.plain_text, rspdata, 8);
-    put_le32(rspdata + 8, g_bletest_IVs);
-    memcpy(connsm->enc_data.iv + 4, rspdata + 8, 4);
-    return BLE_LL_CTRL_ENC_RSP;
+	put_le64(rspdata, g_bletest_SKDs);
+	swap_buf(connsm->enc_data.enc_block.plain_text, rspdata, 8);
+	put_le32(rspdata + 8, g_bletest_IVs);
+	memcpy(connsm->enc_data.iv + 4, rspdata + 8, 4);
+	return BLE_LL_CTRL_ENC_RSP;
 #endif
 
-    swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
-    memcpy(connsm->enc_data.iv, dptr + 18, 4);
+	swap_buf(connsm->enc_data.enc_block.plain_text + 8, dptr + 10, 8);
+	memcpy(connsm->enc_data.iv, dptr + 18, 4);
 
-    /* Create the ENC_RSP. Concatenate our SKD and IV */
-    ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text, 8);
-    swap_buf(rspdata, connsm->enc_data.enc_block.plain_text, 8);
-    ble_ll_rand_data_get(connsm->enc_data.iv + 4, 4);
-    memcpy(rspdata + 8, connsm->enc_data.iv + 4, 4);
+	/* Create the ENC_RSP. Concatenate our SKD and IV */
+	ble_ll_rand_data_get(connsm->enc_data.enc_block.plain_text, 8);
+	swap_buf(rspdata, connsm->enc_data.enc_block.plain_text, 8);
+	ble_ll_rand_data_get(connsm->enc_data.iv + 4, 4);
+	memcpy(rspdata + 8, connsm->enc_data.iv + 4, 4);
 
-    return BLE_LL_CTRL_ENC_RSP;
+	return BLE_LL_CTRL_ENC_RSP;
 }
 
-static uint8_t
-ble_ll_ctrl_rx_start_enc_req(struct ble_ll_conn_sm *connsm)
+static uint8_t ble_ll_ctrl_rx_start_enc_req(struct ble_ll_conn_sm *connsm)
 {
-    int rc;
+	int rc;
 
-    /* Only central should receive start enc request */
-    rc = BLE_ERR_MAX;
+	/* Only central should receive start enc request */
+	rc = BLE_ERR_MAX;
 
-    switch (connsm->conn_role) {
+	switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        /* We only want to send a START_ENC_RSP if we havent yet */
-        if (connsm->enc_data.enc_state == CONN_ENC_S_START_ENC_REQ_WAIT) {
-            connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_RSP_WAIT;
-            rc = BLE_LL_CTRL_START_ENC_RSP;
-        }
-        break;
+	case BLE_LL_CONN_ROLE_CENTRAL:
+		/* We only want to send a START_ENC_RSP if we havent yet */
+		if (connsm->enc_data.enc_state == CONN_ENC_S_START_ENC_REQ_WAIT) {
+			connsm->enc_data.enc_state = CONN_ENC_S_START_ENC_RSP_WAIT;
+			rc = BLE_LL_CTRL_START_ENC_RSP;
+		}
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        rc = BLE_LL_CTRL_UNKNOWN_RSP;
-        break;
+	case BLE_LL_CONN_ROLE_PERIPHERAL:
+		rc = BLE_LL_CTRL_UNKNOWN_RSP;
+		break;
 #endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
+	default:
+		BLE_LL_ASSERT(0);
+		break;
+	}
 
-    return rc;
+	return rc;
 }
 
-static uint8_t
-ble_ll_ctrl_rx_pause_enc_req(struct ble_ll_conn_sm *connsm)
+static uint8_t ble_ll_ctrl_rx_pause_enc_req(struct ble_ll_conn_sm *connsm)
 {
-    int rc;
+	int rc;
 
-    /*
-     * The spec does not say what to do here, but if we receive a pause
-     * encryption request and we are not encrypted, what do we do? We
-     * ignore it...
-     */
-    rc = BLE_ERR_MAX;
-    if (CONN_IS_PERIPHERAL(connsm) &&
-        (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED)) {
-        rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
-    } else {
-        rc = BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+	/*
+	 * The spec does not say what to do here, but if we receive a pause
+	 * encryption request and we are not encrypted, what do we do? We
+	 * ignore it...
+	 */
+	rc = BLE_ERR_MAX;
+	if (CONN_IS_PERIPHERAL(connsm) &&
+	    (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED)) {
+		rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
+	}
+	else {
+		rc = BLE_LL_CTRL_UNKNOWN_RSP;
+	}
 
-    return rc;
+	return rc;
 }
 
 /**
@@ -1715,36 +1719,36 @@ ble_ll_ctrl_rx_pause_enc_req(struct ble_ll_conn_sm *connsm)
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
+static uint8_t ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
 {
-    int rc = 0;
+	int rc = 0;
 
-    switch (connsm->conn_role) {
+	switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
-        break;
+	case BLE_LL_CONN_ROLE_CENTRAL:
+		rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        if (connsm->enc_data.enc_state == CONN_ENC_S_PAUSE_ENC_RSP_WAIT) {
-                /* Master sends back unencrypted LL_PAUSE_ENC_RSP.
-                 * From this moment encryption is paused.
-                 */
-                rc = BLE_ERR_MAX;
-                connsm->enc_data.enc_state = CONN_ENC_S_PAUSED;
-            } else {
-                rc = BLE_LL_CTRL_UNKNOWN_RSP;
-            }
-        break;
-#endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
-
-    return rc;
+	case BLE_LL_CONN_ROLE_PERIPHERAL:
+		if (connsm->enc_data.enc_state == CONN_ENC_S_PAUSE_ENC_RSP_WAIT) {
+			/* Master sends back unencrypted LL_PAUSE_ENC_RSP.
+			 * From this moment encryption is paused.
+			 */
+			rc = BLE_ERR_MAX;
+			connsm->enc_data.enc_state = CONN_ENC_S_PAUSED;
+		}
+		else {
+			rc = BLE_LL_CTRL_UNKNOWN_RSP;
+		}
+		break;
+#endif
+	default:
+		BLE_LL_ASSERT(0);
+		break;
+	}
+
+	return rc;
 }
 
 /**
@@ -1756,53 +1760,52 @@ ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
  *
  * @return uint8_t
  */
-static uint8_t
-ble_ll_ctrl_rx_start_enc_rsp(struct ble_ll_conn_sm *connsm)
+static uint8_t ble_ll_ctrl_rx_start_enc_rsp(struct ble_ll_conn_sm *connsm)
 {
-    int rc = 0;
+	int rc = 0;
 
-    /* Not in proper state. Discard */
-    if (connsm->enc_data.enc_state != CONN_ENC_S_START_ENC_RSP_WAIT) {
-        return BLE_ERR_MAX;
-    }
+	/* Not in proper state. Discard */
+	if (connsm->enc_data.enc_state != CONN_ENC_S_START_ENC_RSP_WAIT) {
+		return BLE_ERR_MAX;
+	}
 
-    switch (connsm->conn_role) {
+	switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
+	case BLE_LL_CONN_ROLE_CENTRAL:
+		ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
 
-        /* We are encrypted */
-        connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
+		/* We are encrypted */
+		connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
-        ble_ll_conn_auth_pyld_timer_start(connsm);
+		ble_ll_conn_auth_pyld_timer_start(connsm);
 #endif
-        rc = BLE_ERR_MAX;
-        break;
+		rc = BLE_ERR_MAX;
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        /* Procedure has completed but peripheral needs to send START_ENC_RSP */
-        rc = BLE_LL_CTRL_START_ENC_RSP;
+	case BLE_LL_CONN_ROLE_PERIPHERAL:
+		/* Procedure has completed but peripheral needs to send START_ENC_RSP */
+		rc = BLE_LL_CTRL_START_ENC_RSP;
 
-        /* Stop timer if it was started when sending START_ENC_REQ */
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
-        }
-        break;
+		/* Stop timer if it was started when sending START_ENC_REQ */
+		if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
+			ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
+		}
+		break;
 #endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
+	default:
+		BLE_LL_ASSERT(0);
+		break;
+	}
 
-    /*
-     * XXX: for now, a Slave sends this event when it receivest the
-     * START_ENC_RSP from the central. It might be technically incorrect
-     * to send it before we transmit our own START_ENC_RSP.
-     */
-    ble_ll_hci_ev_encrypt_chg(connsm, BLE_ERR_SUCCESS);
+	/*
+	 * XXX: for now, a Slave sends this event when it receivest the
+	 * START_ENC_RSP from the central. It might be technically incorrect
+	 * to send it before we transmit our own START_ENC_RSP.
+	 */
+	ble_ll_hci_ev_encrypt_chg(connsm, BLE_ERR_SUCCESS);
 
-    return rc;
+	return rc;
 }
 
 #endif
@@ -1814,60 +1817,59 @@ ble_ll_ctrl_rx_start_enc_rsp(struct ble_ll_conn_sm *connsm)
  * @param dptr Pointer to start of data. NOTE: the opcode is not part
  *             of the data.
  */
-static void
-ble_ll_ctrl_conn_param_pdu_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                                struct ble_ll_conn_params *req)
-{
-    uint16_t offset;
-    struct hci_conn_update *hcu;
-
-    /* If we were passed in a request, we use the parameters from the request */
-    if (req) {
-        put_le16(dptr, req->interval_min);
-        put_le16(dptr + 2, req->interval_max);
-        put_le16(dptr + 4, req->latency);
-        put_le16(dptr + 6, req->timeout);
-    } else {
-        hcu = &connsm->conn_param_req;
-        /* The host should have provided the parameters! */
-        BLE_LL_ASSERT(hcu->handle != 0);
-        put_le16(dptr, hcu->conn_itvl_min);
-        put_le16(dptr + 2, hcu->conn_itvl_max);
-        put_le16(dptr + 4, hcu->conn_latency);
-        put_le16(dptr + 6, hcu->supervision_timeout);
-    }
-
-    /* XXX: NOTE: if interval min and interval max are != to each
-     * other this value should be set to non-zero. I think this
-     * applies only when an offset field is set. See section 5.1.7.1 pg 103
-     * Vol 6 Part B.
-     */
-    /* XXX: for now, set periodicity to 0 */
-    dptr[8] = 0;
-
-    /* XXX: deal with reference event count. what to put here? */
-    put_le16(dptr + 9, connsm->event_cntr);
-
-    /* XXX: For now, dont use offsets */
-    offset = 0xFFFF;
-    put_le16(dptr + 11, offset);
-    put_le16(dptr + 13, offset);
-    put_le16(dptr + 15, offset);
-    put_le16(dptr + 17, offset);
-    put_le16(dptr + 19, offset);
-    put_le16(dptr + 21, offset);
-}
-
-static void
-ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
-{
-    /* Set flag to denote we have sent/received this */
-    connsm->flags.version_ind_txd = 1;
-
-    /* Fill out response */
-    pyld[0] = BLE_HCI_VER_BCS;
-    put_le16(pyld + 1, MYNEWT_VAL(BLE_LL_MANUFACTURER_ID));
-    put_le16(pyld + 3, BLE_LL_SUB_VERS_NR);
+static void ble_ll_ctrl_conn_param_pdu_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                            struct ble_ll_conn_params *req)
+{
+	uint16_t offset;
+	struct hci_conn_update *hcu;
+
+	/* If we were passed in a request, we use the parameters from the request */
+	if (req) {
+		put_le16(dptr, req->interval_min);
+		put_le16(dptr + 2, req->interval_max);
+		put_le16(dptr + 4, req->latency);
+		put_le16(dptr + 6, req->timeout);
+	}
+	else {
+		hcu = &connsm->conn_param_req;
+		/* The host should have provided the parameters! */
+		BLE_LL_ASSERT(hcu->handle != 0);
+		put_le16(dptr, hcu->conn_itvl_min);
+		put_le16(dptr + 2, hcu->conn_itvl_max);
+		put_le16(dptr + 4, hcu->conn_latency);
+		put_le16(dptr + 6, hcu->supervision_timeout);
+	}
+
+	/* XXX: NOTE: if interval min and interval max are != to each
+	 * other this value should be set to non-zero. I think this
+	 * applies only when an offset field is set. See section 5.1.7.1 pg 103
+	 * Vol 6 Part B.
+	 */
+	/* XXX: for now, set periodicity to 0 */
+	dptr[8] = 0;
+
+	/* XXX: deal with reference event count. what to put here? */
+	put_le16(dptr + 9, connsm->event_cntr);
+
+	/* XXX: For now, dont use offsets */
+	offset = 0xFFFF;
+	put_le16(dptr + 11, offset);
+	put_le16(dptr + 13, offset);
+	put_le16(dptr + 15, offset);
+	put_le16(dptr + 17, offset);
+	put_le16(dptr + 19, offset);
+	put_le16(dptr + 21, offset);
+}
+
+static void ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
+{
+	/* Set flag to denote we have sent/received this */
+	connsm->flags.version_ind_txd = 1;
+
+	/* Fill out response */
+	pyld[0] = BLE_HCI_VER_BCS;
+	put_le16(pyld + 1, MYNEWT_VAL(BLE_LL_MANUFACTURER_ID));
+	put_le16(pyld + 3, BLE_LL_SUB_VERS_NR);
 }
 
 /**
@@ -1876,22 +1878,20 @@ ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
  * @param connsm    Pointer to connection state machine
  * @param pyld      Pointer to payload of LL control PDU
  */
-static void
-ble_ll_ctrl_chanmap_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
+static void ble_ll_ctrl_chanmap_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
 {
-    /* Copy channel map that host desires into request */
-    memcpy(pyld, g_ble_ll_data.chan_map, BLE_LL_CHAN_MAP_LEN);
-    memcpy(connsm->req_chanmap, pyld, BLE_LL_CHAN_MAP_LEN);
+	/* Copy channel map that host desires into request */
+	memcpy(pyld, g_ble_ll_data.chan_map, BLE_LL_CHAN_MAP_LEN);
+	memcpy(connsm->req_chanmap, pyld, BLE_LL_CHAN_MAP_LEN);
 
-    /* Instant is placed in ble_ll_ctrl_chanmap_req_instant()*/
+	/* Instant is placed in ble_ll_ctrl_chanmap_req_instant()*/
 }
 
-static void
-ble_ll_ctrl_chanmap_req_instant(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
+static void ble_ll_ctrl_chanmap_req_instant(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
 {
-    /* Place instant into request */
-    connsm->chanmap_instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
-    put_le16(pyld + BLE_LL_CHAN_MAP_LEN, connsm->chanmap_instant);
+	/* Place instant into request */
+	connsm->chanmap_instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
+	put_le16(pyld + BLE_LL_CHAN_MAP_LEN, connsm->chanmap_instant);
 }
 
 /**
@@ -1904,32 +1904,31 @@ ble_ll_ctrl_chanmap_req_instant(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
  *
  * @return uint8_t
  */
-uint8_t
-ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm, uint8_t *rsp,
-                             struct ble_ll_conn_params *req)
+uint8_t ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm, uint8_t *rsp,
+                                     struct ble_ll_conn_params *req)
 {
-    uint8_t rsp_opcode = 0;
+	uint8_t rsp_opcode = 0;
 
-    switch (connsm->conn_role) {
+	switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CONN_ROLE_CENTRAL:
-        ble_ll_ctrl_conn_update_init_proc(connsm, req);
-        rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
-        break;
+	case BLE_LL_CONN_ROLE_CENTRAL:
+		ble_ll_ctrl_conn_update_init_proc(connsm, req);
+		rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CONN_ROLE_PERIPHERAL:
-        /* Create a connection parameter response */
-        ble_ll_ctrl_conn_param_pdu_make(connsm, rsp + 1, req);
-        rsp_opcode = BLE_LL_CTRL_CONN_PARM_RSP;
-        break;
+	case BLE_LL_CONN_ROLE_PERIPHERAL:
+		/* Create a connection parameter response */
+		ble_ll_ctrl_conn_param_pdu_make(connsm, rsp + 1, req);
+		rsp_opcode = BLE_LL_CTRL_CONN_PARM_RSP;
+		break;
 #endif
-    default:
-        BLE_LL_ASSERT(0);
-        break;
-    }
+	default:
+		BLE_LL_ASSERT(0);
+		break;
+	}
 
-    return rsp_opcode;
+	return rsp_opcode;
 }
 
 /**
@@ -1940,87 +1939,88 @@ ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm, uint8_t *rsp,
  * @param dptr
  * @param opcode
  */
-static int
-ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                          uint8_t opcode, uint8_t *rspdata)
-{
-    uint8_t ble_error;
-    uint8_t rsp_opcode = BLE_ERR_MAX;
-
-    /* Get error out of received PDU */
-    if (opcode == BLE_LL_CTRL_REJECT_IND) {
-        ble_error = dptr[0];
-    } else {
-        ble_error = dptr[1];
-    }
-
-    /* Suppress unused-but-set if not used by following code (due to syscfg) */
-    (void)ble_error;
-
-    /* XXX: should I check to make sure the rejected opcode is sane
-       if we receive ind ext? */
-    switch (connsm->cur_ctrl_proc) {
-    case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
-        if (opcode == BLE_LL_CTRL_REJECT_IND_EXT) {
-            switch (connsm->conn_role) {
-        #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-            case BLE_LL_CONN_ROLE_CENTRAL:
-                /* As a central we should send connection update indication in this point */
-                rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
-                ble_ll_ctrl_conn_update_init_proc(connsm, NULL);
-                connsm->reject_reason = BLE_ERR_SUCCESS;
-                break;
-        #endif
-        #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-            case BLE_LL_CONN_ROLE_PERIPHERAL:
-                ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
-                ble_ll_hci_ev_conn_update(connsm, ble_error);
-                break;
-        #endif
-            default:
-                BLE_LL_ASSERT(0);
-                break;
-            }
-        }
-        break;
+static int ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                     uint8_t opcode, uint8_t *rspdata)
+{
+	uint8_t ble_error;
+	uint8_t rsp_opcode = BLE_ERR_MAX;
+
+	/* Get error out of received PDU */
+	if (opcode == BLE_LL_CTRL_REJECT_IND) {
+		ble_error = dptr[0];
+	}
+	else {
+		ble_error = dptr[1];
+	}
+
+	/* Suppress unused-but-set if not used by following code (due to syscfg) */
+	(void) ble_error;
+
+	/* XXX: should I check to make sure the rejected opcode is sane
+	   if we receive ind ext? */
+	switch (connsm->cur_ctrl_proc) {
+	case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
+		if (opcode == BLE_LL_CTRL_REJECT_IND_EXT) {
+			switch (connsm->conn_role) {
+#if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
+			case BLE_LL_CONN_ROLE_CENTRAL:
+				/* As a central we should send connection update indication in this point */
+				rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
+				ble_ll_ctrl_conn_update_init_proc(connsm, NULL);
+				connsm->reject_reason = BLE_ERR_SUCCESS;
+				break;
+#endif
+#if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
+			case BLE_LL_CONN_ROLE_PERIPHERAL:
+				ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
+				ble_ll_hci_ev_conn_update(connsm, ble_error);
+				break;
+#endif
+			default:
+				BLE_LL_ASSERT(0);
+				break;
+			}
+		}
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    case BLE_LL_CTRL_PROC_ENCRYPT:
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
-        ble_ll_hci_ev_encrypt_chg(connsm, ble_error);
-        connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
-        break;
+	// TODO: here implement logic for handling the re-pairing?
+	case BLE_LL_CTRL_PROC_ENCRYPT:
+		ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_ENCRYPT);
+		ble_ll_hci_ev_encrypt_chg(connsm, ble_error);
+		connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_PHY)
-    case BLE_LL_CTRL_PROC_PHY_UPDATE:
-        ble_ll_ctrl_phy_update_cancel(connsm, ble_error);
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
-        break;
-#endif
-    case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
-        /* That should not happen according to Bluetooth 5.0 Vol6 Part B, 5.1.9
-         * However we need this workaround as there are devices on the market
-         * which do send LL_REJECT on LL_LENGTH_REQ when collision happens
-         */
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
-        break;
+	case BLE_LL_CTRL_PROC_PHY_UPDATE:
+		ble_ll_ctrl_phy_update_cancel(connsm, ble_error);
+		ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
+		break;
+#endif
+	case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
+		/* That should not happen according to Bluetooth 5.0 Vol6 Part B, 5.1.9
+		 * However we need this workaround as there are devices on the market
+		 * which do send LL_REJECT on LL_LENGTH_REQ when collision happens
+		 */
+		ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-    case BLE_LL_CTRL_PROC_SCA_UPDATE:
-        ble_ll_hci_ev_sca_update(connsm, ble_error, 0);
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SCA_UPDATE);
-        break;
+	case BLE_LL_CTRL_PROC_SCA_UPDATE:
+		ble_ll_hci_ev_sca_update(connsm, ble_error, 0);
+		ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SCA_UPDATE);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    case BLE_LL_CTRL_PROC_SUBRATE_REQ:
-        ble_ll_hci_ev_subrate_change(connsm, ble_error);
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SUBRATE_UPDATE);
-        break;
+	case BLE_LL_CTRL_PROC_SUBRATE_REQ:
+		ble_ll_hci_ev_subrate_change(connsm, ble_error);
+		ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_SUBRATE_UPDATE);
+		break;
 #endif
 
-    default:
-        break;
-    }
+	default:
+		break;
+	}
 
-    return rsp_opcode;
+	return rsp_opcode;
 }
 
 /**
@@ -2031,121 +2031,119 @@ ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  *
  * @return int
  */
-static int
-ble_ll_ctrl_rx_conn_update(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static int ble_ll_ctrl_rx_conn_update(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    uint8_t rsp_opcode;
-    uint16_t conn_events;
-    struct ble_ll_conn_upd_req *reqdata;
+	uint8_t rsp_opcode;
+	uint16_t conn_events;
+	struct ble_ll_conn_upd_req *reqdata;
 
-    /* Only a peripheral should receive this */
+	/* Only a peripheral should receive this */
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
-#endif
-
-    /* Retrieve parameters */
-    reqdata = &connsm->conn_update_req;
-    reqdata->winsize = dptr[0];
-    reqdata->winoffset = get_le16(dptr + 1);
-    reqdata->interval = get_le16(dptr + 3);
-    reqdata->latency = get_le16(dptr + 5);
-    reqdata->timeout = get_le16(dptr + 7);
-    reqdata->instant = get_le16(dptr + 9);
-
-    /* XXX: validate them at some point. If they dont check out, we
-       return the unknown response */
-    rsp_opcode = BLE_ERR_MAX;
-
-    /* If instant is in the past, we have to end the connection */
-    conn_events = (reqdata->instant - connsm->event_cntr) & 0xFFFF;
-    if (conn_events >= 32767) {
-        ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
-    } else {
-        connsm->flags.conn_update_sched = 1;
-
-        /*
-         * Errata says that receiving a connection update when the event
-         * counter is equal to the instant means wesimply ignore the window
-         * offset and window size. Anchor point has already been set based on
-         * first packet received in connection event. Given that we increment
-         * the event counter BEFORE checking to see if the instant is equal to
-         * the event counter what we do here is increment the instant and set
-         * the window offset and size to 0.
-         */
-        if (conn_events == 0) {
-            reqdata->winoffset = 0;
-            reqdata->winsize = 0;
-            reqdata->instant += 1;
-        }
-    }
-
-    return rsp_opcode;
-}
-
-void
-ble_ll_ctrl_initiate_dle(struct ble_ll_conn_sm *connsm, bool initial)
-{
-    if (!(connsm->conn_features & BLE_LL_FEAT_DATA_LEN_EXT)) {
-        return;
-    }
-
-    /*
-     * Section 4.5.10 Vol 6 PART B. If the max tx/rx time or octets
-     * exceeds the minimum, data length procedure needs to occur
-     * "at the earliest practical opportunity".
-     */
-    if (initial) {
-        if ((connsm->max_tx_octets <= BLE_LL_CONN_SUPP_BYTES_MIN) &&
-            (connsm->max_rx_octets <= BLE_LL_CONN_SUPP_BYTES_MIN) &&
-            (connsm->max_tx_time <= BLE_LL_CONN_SUPP_TIME_MIN) &&
-            (connsm->max_rx_time <= BLE_LL_CONN_SUPP_TIME_MIN)) {
-            return;
-        }
-    }
-
-    ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD, NULL);
-}
-
-static void
-ble_ll_ctrl_update_features(struct ble_ll_conn_sm *connsm, uint8_t *feat)
-{
-    connsm->conn_features = feat[0];
-    memcpy(connsm->remote_features, feat + 1, 7);
-
-    /* If we received peer's features for the 1st time, we should try DLE */
-    if (!connsm->flags.features_rxd) {
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+		return BLE_LL_CTRL_UNKNOWN_RSP;
+	}
+#endif
+
+	/* Retrieve parameters */
+	reqdata = &connsm->conn_update_req;
+	reqdata->winsize = dptr[0];
+	reqdata->winoffset = get_le16(dptr + 1);
+	reqdata->interval = get_le16(dptr + 3);
+	reqdata->latency = get_le16(dptr + 5);
+	reqdata->timeout = get_le16(dptr + 7);
+	reqdata->instant = get_le16(dptr + 9);
+
+	/* XXX: validate them at some point. If they dont check out, we
+	   return the unknown response */
+	rsp_opcode = BLE_ERR_MAX;
+
+	/* If instant is in the past, we have to end the connection */
+	conn_events = (reqdata->instant - connsm->event_cntr) & 0xFFFF;
+	if (conn_events >= 32767) {
+		ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
+	}
+	else {
+		connsm->flags.conn_update_sched = 1;
+
+		/*
+		 * Errata says that receiving a connection update when the event
+		 * counter is equal to the instant means wesimply ignore the window
+		 * offset and window size. Anchor point has already been set based on
+		 * first packet received in connection event. Given that we increment
+		 * the event counter BEFORE checking to see if the instant is equal to
+		 * the event counter what we do here is increment the instant and set
+		 * the window offset and size to 0.
+		 */
+		if (conn_events == 0) {
+			reqdata->winoffset = 0;
+			reqdata->winsize = 0;
+			reqdata->instant += 1;
+		}
+	}
+
+	return rsp_opcode;
+}
+
+void ble_ll_ctrl_initiate_dle(struct ble_ll_conn_sm *connsm, bool initial)
+{
+	if (!(connsm->conn_features & BLE_LL_FEAT_DATA_LEN_EXT)) {
+		return;
+	}
+
+	/*
+	 * Section 4.5.10 Vol 6 PART B. If the max tx/rx time or octets
+	 * exceeds the minimum, data length procedure needs to occur
+	 * "at the earliest practical opportunity".
+	 */
+	if (initial) {
+		if ((connsm->max_tx_octets <= BLE_LL_CONN_SUPP_BYTES_MIN) &&
+		    (connsm->max_rx_octets <= BLE_LL_CONN_SUPP_BYTES_MIN) &&
+		    (connsm->max_tx_time <= BLE_LL_CONN_SUPP_TIME_MIN) &&
+		    (connsm->max_rx_time <= BLE_LL_CONN_SUPP_TIME_MIN)) {
+			return;
+		}
+	}
+
+	ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD, NULL);
+}
+
+static void ble_ll_ctrl_update_features(struct ble_ll_conn_sm *connsm, uint8_t *feat)
+{
+	connsm->conn_features = feat[0];
+	memcpy(connsm->remote_features, feat + 1, 7);
+
+	/* If we received peer's features for the 1st time, we should try DLE */
+	if (!connsm->flags.features_rxd) {
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-        /*
-         * If connection was established on uncoded PHY, by default we use
-         * MaxTxTime and MaxRxTime applicable for that PHY since we are not
-         * allowed to indicate longer supported time if peer does not support
-         * LE Coded PHY. However, once we know that peer does support it we can
-         * update those values to ones applicable for coded PHY.
-         */
-        if (ble_ll_conn_rem_feature_check(connsm, BLE_LL_FEAT_LE_CODED_PHY)) {
-            if (connsm->host_req_max_tx_time) {
-                connsm->max_tx_time = MAX(connsm->max_tx_time,
-                                          connsm->host_req_max_tx_time);
-            } else {
-                connsm->max_tx_time = g_ble_ll_conn_params.conn_init_max_tx_time_coded;
-            }
-            if (connsm->host_req_max_rx_time) {
-                connsm->max_rx_time = MAX(connsm->max_rx_time,
-                                          connsm->host_req_max_rx_time);
-            } else {
-                connsm->max_rx_time = BLE_LL_CONN_SUPP_TIME_MAX_CODED;
-            }
-        }
+		/*
+		 * If connection was established on uncoded PHY, by default we use
+		 * MaxTxTime and MaxRxTime applicable for that PHY since we are not
+		 * allowed to indicate longer supported time if peer does not support
+		 * LE Coded PHY. However, once we know that peer does support it we can
+		 * update those values to ones applicable for coded PHY.
+		 */
+		if (ble_ll_conn_rem_feature_check(connsm, BLE_LL_FEAT_LE_CODED_PHY)) {
+			if (connsm->host_req_max_tx_time) {
+				connsm->max_tx_time = MAX(connsm->max_tx_time, connsm->host_req_max_tx_time);
+			}
+			else {
+				connsm->max_tx_time = g_ble_ll_conn_params.conn_init_max_tx_time_coded;
+			}
+			if (connsm->host_req_max_rx_time) {
+				connsm->max_rx_time = MAX(connsm->max_rx_time, connsm->host_req_max_rx_time);
+			}
+			else {
+				connsm->max_rx_time = BLE_LL_CONN_SUPP_TIME_MAX_CODED;
+			}
+		}
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CONN_INIT_AUTO_DLE)
-        connsm->flags.pending_initiate_dle = 1;
+		connsm->flags.pending_initiate_dle = 1;
 #endif
 
-        connsm->flags.features_rxd = 1;
-    }
+		connsm->flags.features_rxd = 1;
+	}
 }
 
 /**
@@ -2161,48 +2159,48 @@ ble_ll_ctrl_update_features(struct ble_ll_conn_sm *connsm, uint8_t *feat)
  *
  * @return int
  */
-static int
-ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                           uint8_t *rspbuf, uint8_t opcode)
-{
-    uint8_t rsp_opcode;
-    uint64_t our_feat;
-
-    /*
-     * Only accept peripheral feature requests if we are a central and feature
-     * requests if we are a peripheral.
-     */
-    if (opcode == BLE_LL_CTRL_PERIPH_FEATURE_REQ) {
-        if (!CONN_IS_CENTRAL(connsm)) {
-            return BLE_LL_CTRL_UNKNOWN_RSP;
-        }
-    } else {
-        /* XXX: not sure this is correct but do it anyway */
-        if (!CONN_IS_PERIPHERAL(connsm)) {
-            return BLE_LL_CTRL_UNKNOWN_RSP;
-        }
-    }
-
-    our_feat = ble_ll_read_supp_features();
-
-    rsp_opcode = BLE_LL_CTRL_FEATURE_RSP;
-
-    ble_ll_ctrl_update_features(connsm, dptr);
-
-    /*
-     * 1st octet of features should be common features of local and remote
-     * controller - we call this 'connection features'
-     * remaining octets are features of controller which sends PDU, in this case
-     * it's our controller
-     *
-     * See: Vol 6, Part B, section 2.4.2.10
-     */
-    connsm->conn_features &= our_feat;
-
-    put_le64(rspbuf + 1, our_feat);
-    rspbuf[1] = connsm->conn_features;
-
-    return rsp_opcode;
+static int ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                      uint8_t *rspbuf, uint8_t opcode)
+{
+	uint8_t rsp_opcode;
+	uint64_t our_feat;
+
+	/*
+	 * Only accept peripheral feature requests if we are a central and feature
+	 * requests if we are a peripheral.
+	 */
+	if (opcode == BLE_LL_CTRL_PERIPH_FEATURE_REQ) {
+		if (!CONN_IS_CENTRAL(connsm)) {
+			return BLE_LL_CTRL_UNKNOWN_RSP;
+		}
+	}
+	else {
+		/* XXX: not sure this is correct but do it anyway */
+		if (!CONN_IS_PERIPHERAL(connsm)) {
+			return BLE_LL_CTRL_UNKNOWN_RSP;
+		}
+	}
+
+	our_feat = ble_ll_read_supp_features();
+
+	rsp_opcode = BLE_LL_CTRL_FEATURE_RSP;
+
+	ble_ll_ctrl_update_features(connsm, dptr);
+
+	/*
+	 * 1st octet of features should be common features of local and remote
+	 * controller - we call this 'connection features'
+	 * remaining octets are features of controller which sends PDU, in this case
+	 * it's our controller
+	 *
+	 * See: Vol 6, Part B, section 2.4.2.10
+	 */
+	connsm->conn_features &= our_feat;
+
+	put_le64(rspbuf + 1, our_feat);
+	rspbuf[1] = connsm->conn_features;
+
+	return rsp_opcode;
 }
 
 /**
@@ -2213,21 +2211,20 @@ ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  * @param new_features
  *
  */
-static void
-ble_ll_ctrl_rx_feature_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static void ble_ll_ctrl_rx_feature_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    ble_ll_ctrl_update_features(connsm, dptr);
+	ble_ll_ctrl_update_features(connsm, dptr);
 
-    /* Stop the control procedure */
-    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG)) {
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG);
-    }
+	/* Stop the control procedure */
+	if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG)) {
+		ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG);
+	}
 
-    /* Send event to host if pending features read */
-    if (connsm->flags.features_host_req) {
-        ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_SUCCESS);
-        connsm->flags.features_host_req = 0;
-    }
+	/* Send event to host if pending features read */
+	if (connsm->flags.features_host_req) {
+		ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_SUCCESS);
+		connsm->flags.features_host_req = 0;
+	}
 }
 
 /**
@@ -2241,127 +2238,124 @@ ble_ll_ctrl_rx_feature_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  *
  * @return int
  */
-static int
-ble_ll_ctrl_rx_conn_param_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                              uint8_t *rspbuf)
-{
-    uint8_t rsp_opcode;
-
-    /*
-     * This is not in the specification per se but it simplifies the
-     * implementation. If we get a connection parameter request and we
-     * are awaiting a reply from the host, simply ignore the request. This
-     * might not be a good idea if the parameters are different, but oh
-     * well. This is not expected to happen anyway. A return of BLE_ERR_MAX
-     * means that we will simply discard the connection parameter request
-     */
-    if (connsm->flags.conn_update_host_w4reply) {
-        return BLE_ERR_MAX;
-    }
+static int ble_ll_ctrl_rx_conn_param_req(struct ble_ll_conn_sm *connsm,
+                                         uint8_t *dptr, uint8_t *rspbuf)
+{
+	uint8_t rsp_opcode;
+
+	/*
+	 * This is not in the specification per se but it simplifies the
+	 * implementation. If we get a connection parameter request and we
+	 * are awaiting a reply from the host, simply ignore the request. This
+	 * might not be a good idea if the parameters are different, but oh
+	 * well. This is not expected to happen anyway. A return of BLE_ERR_MAX
+	 * means that we will simply discard the connection parameter request
+	 */
+	if (connsm->flags.conn_update_host_w4reply) {
+		return BLE_ERR_MAX;
+	}
 
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
-    /* Reject any attempts to change connection parameters by peripheral */
-    if (ble_ll_sched_css_is_enabled() &&
-        connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
-        rspbuf[2] = BLE_ERR_UNSUPPORTED;
-        return rsp_opcode;
-    }
-#endif
-
-    /* XXX: remember to deal with this on the central: if the peripheral has
-     * initiated a procedure we may have received its connection parameter
-     * update request and have signaled the host with an event. If that
-     * is the case, we will need to drop the host command when we get it
-       and also clear any applicable states. */
-
-    /* XXX: Read 5.3 again. There are multiple control procedures that might
-     * be pending (a connection update) that will cause collisions and the
-       behavior below. */
-    /*
-     * Check for procedure collision (Vol 6 PartB 5.3). If we are a peripheral
-     * and we receive a request we "consider the peripheral initiated
-     * procedure as complete". This means send a connection update complete
-     * event (with error).
-     *
-     * If a central, we send reject with a
-     * transaction collision error code.
-     */
-    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
-        switch (connsm->conn_role) {
+	/* Reject any attempts to change connection parameters by peripheral */
+	if (ble_ll_sched_css_is_enabled() && connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+		rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+		rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
+		rspbuf[2] = BLE_ERR_UNSUPPORTED;
+		return rsp_opcode;
+	}
+#endif
+
+	/* XXX: remember to deal with this on the central: if the peripheral has
+	 * initiated a procedure we may have received its connection parameter
+	 * update request and have signaled the host with an event. If that
+	 * is the case, we will need to drop the host command when we get it
+	   and also clear any applicable states. */
+
+	/* XXX: Read 5.3 again. There are multiple control procedures that might
+	 * be pending (a connection update) that will cause collisions and the
+	   behavior below. */
+	/*
+	 * Check for procedure collision (Vol 6 PartB 5.3). If we are a peripheral
+	 * and we receive a request we "consider the peripheral initiated
+	 * procedure as complete". This means send a connection update complete
+	 * event (with error).
+	 *
+	 * If a central, we send reject with a
+	 * transaction collision error code.
+	 */
+	if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
+		switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-        case BLE_LL_CONN_ROLE_CENTRAL:
-            /* The central sends reject ind ext w/error code 0x23 */
-            rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-            rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
-            rspbuf[2] = BLE_ERR_LMP_COLLISION;
-            return rsp_opcode;
+		case BLE_LL_CONN_ROLE_CENTRAL:
+			/* The central sends reject ind ext w/error code 0x23 */
+			rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+			rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
+			rspbuf[2] = BLE_ERR_LMP_COLLISION;
+			return rsp_opcode;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-        case BLE_LL_CONN_ROLE_PERIPHERAL:
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
-            ble_ll_hci_ev_conn_update(connsm, BLE_ERR_LMP_COLLISION);
-            break;
-#endif
-        default:
-            BLE_LL_ASSERT(0);
-            break;
-        }
-    }
-
-    /*
-     * If we are a central and we currently performing a channel map
-     * update procedure we need to return an error
-     */
+		case BLE_LL_CONN_ROLE_PERIPHERAL:
+			ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
+			ble_ll_hci_ev_conn_update(connsm, BLE_ERR_LMP_COLLISION);
+			break;
+#endif
+		default:
+			BLE_LL_ASSERT(0);
+			break;
+		}
+	}
+
+	/*
+	 * If we are a central and we currently performing a channel map
+	 * update procedure we need to return an error
+	 */
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if ((connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) &&
-        (connsm->flags.chanmap_update_sched)) {
-        rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
-        rspbuf[2] = BLE_ERR_DIFF_TRANS_COLL;
-        return rsp_opcode;
-    }
+	if ((connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) &&
+	    (connsm->flags.chanmap_update_sched)) {
+		rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+		rspbuf[1] = BLE_LL_CTRL_CONN_PARM_REQ;
+		rspbuf[2] = BLE_ERR_DIFF_TRANS_COLL;
+		return rsp_opcode;
+	}
 #endif
 
-    /* Process the received connection parameter request */
-    rsp_opcode = ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf,
-                                                 BLE_LL_CTRL_CONN_PARM_REQ);
-    return rsp_opcode;
+	/* Process the received connection parameter request */
+	rsp_opcode =
+		ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf, BLE_LL_CTRL_CONN_PARM_REQ);
+	return rsp_opcode;
 }
 
-static int
-ble_ll_ctrl_rx_conn_param_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                              uint8_t *rspbuf)
+static int ble_ll_ctrl_rx_conn_param_rsp(struct ble_ll_conn_sm *connsm,
+                                         uint8_t *dptr, uint8_t *rspbuf)
 {
-    uint8_t rsp_opcode;
+	uint8_t rsp_opcode;
 
-    /* A peripheral should never receive this response */
+	/* A peripheral should never receive this response */
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
+		return BLE_LL_CTRL_UNKNOWN_RSP;
+	}
 #endif
 
-    /*
-     * This case should never happen! It means that the peripheral initiated a
-     * procedure and the central initiated one as well. If we do get in this
-     * state just clear the awaiting reply. The peripheral will hopefully stop its
-     * procedure when we reply.
-     */
-    if (connsm->flags.conn_update_host_w4reply) {
-        connsm->flags.conn_update_host_w4reply = 0;
-    }
+	/*
+	 * This case should never happen! It means that the peripheral initiated a
+	 * procedure and the central initiated one as well. If we do get in this
+	 * state just clear the awaiting reply. The peripheral will hopefully stop its
+	 * procedure when we reply.
+	 */
+	if (connsm->flags.conn_update_host_w4reply) {
+		connsm->flags.conn_update_host_w4reply = 0;
+	}
 
-    /* If we receive a response and no procedure is pending, just leave */
-    if (!IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
-        return BLE_ERR_MAX;
-    }
+	/* If we receive a response and no procedure is pending, just leave */
+	if (!IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
+		return BLE_ERR_MAX;
+	}
 
-    /* Process the received connection parameter response */
-    rsp_opcode = ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf,
-                                                 BLE_LL_CTRL_CONN_PARM_RSP);
-    return rsp_opcode;
+	/* Process the received connection parameter response */
+	rsp_opcode =
+		ble_ll_ctrl_conn_param_pdu_proc(connsm, dptr, rspbuf, BLE_LL_CTRL_CONN_PARM_RSP);
+	return rsp_opcode;
 }
 
 /**
@@ -2375,30 +2369,29 @@ ble_ll_ctrl_rx_conn_param_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  *
  * @return int
  */
-static int
-ble_ll_ctrl_rx_version_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                           uint8_t *rspbuf)
+static int ble_ll_ctrl_rx_version_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
+                                      uint8_t *rspbuf)
 {
-    uint8_t rsp_opcode;
+	uint8_t rsp_opcode;
 
-    /* Process the packet */
-    connsm->vers_nr = dptr[0];
-    connsm->comp_id = get_le16(dptr + 1);
-    connsm->sub_vers_nr = get_le16(dptr + 3);
-    connsm->flags.version_ind_rxd = 1;
+	/* Process the packet */
+	connsm->vers_nr = dptr[0];
+	connsm->comp_id = get_le16(dptr + 1);
+	connsm->sub_vers_nr = get_le16(dptr + 3);
+	connsm->flags.version_ind_rxd = 1;
 
-    rsp_opcode = BLE_ERR_MAX;
-    if (!connsm->flags.version_ind_txd) {
-        rsp_opcode = BLE_LL_CTRL_VERSION_IND;
-        ble_ll_ctrl_version_ind_make(connsm, rspbuf);
-    }
+	rsp_opcode = BLE_ERR_MAX;
+	if (!connsm->flags.version_ind_txd) {
+		rsp_opcode = BLE_LL_CTRL_VERSION_IND;
+		ble_ll_ctrl_version_ind_make(connsm, rspbuf);
+	}
 
-    /* Stop the control procedure */
-    if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG)) {
-        ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
-        ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG);
-    }
-    return rsp_opcode;
+	/* Stop the control procedure */
+	if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG)) {
+		ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
+		ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG);
+	}
+	return rsp_opcode;
 }
 
 /**
@@ -2409,30 +2402,30 @@ ble_ll_ctrl_rx_version_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  * @param connsm
  * @param dptr
  */
-static int
-ble_ll_ctrl_rx_chanmap_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+static int ble_ll_ctrl_rx_chanmap_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 {
-    uint16_t instant;
-    uint16_t conn_events;
+	uint16_t instant;
+	uint16_t conn_events;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
-        return BLE_LL_CTRL_UNKNOWN_RSP;
-    }
+	if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+		return BLE_LL_CTRL_UNKNOWN_RSP;
+	}
 #endif
 
-    /* If instant is in the past, we have to end the connection */
-    instant = get_le16(dptr + BLE_LL_CHAN_MAP_LEN);
-    conn_events = (instant - connsm->event_cntr) & 0xFFFF;
-    if (conn_events >= 32767) {
-        ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
-    } else {
-        connsm->chanmap_instant = instant;
-        memcpy(connsm->req_chanmap, dptr, BLE_LL_CHAN_MAP_LEN);
-        connsm->flags.chanmap_update_sched = 1;
-    }
+	/* If instant is in the past, we have to end the connection */
+	instant = get_le16(dptr + BLE_LL_CHAN_MAP_LEN);
+	conn_events = (instant - connsm->event_cntr) & 0xFFFF;
+	if (conn_events >= 32767) {
+		ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
+	}
+	else {
+		connsm->chanmap_instant = instant;
+		memcpy(connsm->req_chanmap, dptr, BLE_LL_CHAN_MAP_LEN);
+		connsm->flags.chanmap_update_sched = 1;
+	}
 
-    return BLE_ERR_MAX;
+	return BLE_ERR_MAX;
 }
 
 /**
@@ -2447,122 +2440,122 @@ ble_ll_ctrl_rx_chanmap_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @param connsm
  * @param ctrl_proc
  */
-static struct os_mbuf *
-ble_ll_ctrl_proc_init(struct ble_ll_conn_sm *connsm, int ctrl_proc, void *data)
-{
-    uint8_t len;
-    uint8_t opcode = 0;
-    uint8_t *dptr;
-    uint8_t *ctrdata;
-    struct os_mbuf *om;
-
-    /* Get an mbuf for the control pdu */
-    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN, sizeof(struct ble_mbuf_hdr));
-
-    if (om) {
-        /* The control data starts after the opcode (1 byte) */
-        dptr = om->om_data;
-        ctrdata = dptr + 1;
-
-        switch (ctrl_proc) {
-        case BLE_LL_CTRL_PROC_CONN_UPDATE:
-            opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
-            ble_ll_ctrl_conn_update_init_proc(connsm, data);
-            break;
-        case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
-            opcode = BLE_LL_CTRL_CHANNEL_MAP_REQ;
-            ble_ll_ctrl_chanmap_req_make(connsm, ctrdata);
-            break;
-        case BLE_LL_CTRL_PROC_FEATURE_XCHG:
-            switch (connsm->conn_role) {
+static struct os_mbuf *ble_ll_ctrl_proc_init(struct ble_ll_conn_sm *connsm,
+                                             int ctrl_proc, void *data)
+{
+	uint8_t len;
+	uint8_t opcode = 0;
+	uint8_t *dptr;
+	uint8_t *ctrdata;
+	struct os_mbuf *om;
+
+	/* Get an mbuf for the control pdu */
+	om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN, sizeof(struct ble_mbuf_hdr));
+
+	if (om) {
+		/* The control data starts after the opcode (1 byte) */
+		dptr = om->om_data;
+		ctrdata = dptr + 1;
+
+		switch (ctrl_proc) {
+		case BLE_LL_CTRL_PROC_CONN_UPDATE:
+			opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
+			ble_ll_ctrl_conn_update_init_proc(connsm, data);
+			break;
+		case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
+			opcode = BLE_LL_CTRL_CHANNEL_MAP_REQ;
+			ble_ll_ctrl_chanmap_req_make(connsm, ctrdata);
+			break;
+		case BLE_LL_CTRL_PROC_FEATURE_XCHG:
+			switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-            case BLE_LL_CONN_ROLE_CENTRAL:
-                opcode = BLE_LL_CTRL_FEATURE_REQ;
-                break;
+			case BLE_LL_CONN_ROLE_CENTRAL:
+				opcode = BLE_LL_CTRL_FEATURE_REQ;
+				break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-            case BLE_LL_CONN_ROLE_PERIPHERAL:
-                opcode = BLE_LL_CTRL_PERIPH_FEATURE_REQ;
-                break;
-#endif
-            default:
-                BLE_LL_ASSERT(0);
-                break;
-            }
-            put_le64(ctrdata, ble_ll_read_supp_features());
-            break;
-        case BLE_LL_CTRL_PROC_VERSION_XCHG:
-            opcode = BLE_LL_CTRL_VERSION_IND;
-            ble_ll_ctrl_version_ind_make(connsm, ctrdata);
-            break;
-        case BLE_LL_CTRL_PROC_TERMINATE:
-            opcode = BLE_LL_CTRL_TERMINATE_IND;
-            ctrdata[0] = connsm->disconnect_reason;
-            break;
-        case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
-            opcode = BLE_LL_CTRL_CONN_PARM_REQ;
-            ble_ll_ctrl_conn_param_pdu_make(connsm, ctrdata, NULL);
-            break;
-        case BLE_LL_CTRL_PROC_LE_PING:
-            opcode = BLE_LL_CTRL_PING_REQ;
-            break;
-        case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
-            opcode = BLE_LL_CTRL_LENGTH_REQ;
-            ble_ll_ctrl_datalen_upd_make(connsm, dptr);
-            break;
+			case BLE_LL_CONN_ROLE_PERIPHERAL:
+				opcode = BLE_LL_CTRL_PERIPH_FEATURE_REQ;
+				break;
+#endif
+			default:
+				BLE_LL_ASSERT(0);
+				break;
+			}
+			put_le64(ctrdata, ble_ll_read_supp_features());
+			break;
+		case BLE_LL_CTRL_PROC_VERSION_XCHG:
+			opcode = BLE_LL_CTRL_VERSION_IND;
+			ble_ll_ctrl_version_ind_make(connsm, ctrdata);
+			break;
+		case BLE_LL_CTRL_PROC_TERMINATE:
+			opcode = BLE_LL_CTRL_TERMINATE_IND;
+			ctrdata[0] = connsm->disconnect_reason;
+			break;
+		case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
+			opcode = BLE_LL_CTRL_CONN_PARM_REQ;
+			ble_ll_ctrl_conn_param_pdu_make(connsm, ctrdata, NULL);
+			break;
+		case BLE_LL_CTRL_PROC_LE_PING:
+			opcode = BLE_LL_CTRL_PING_REQ;
+			break;
+		case BLE_LL_CTRL_PROC_DATA_LEN_UPD:
+			opcode = BLE_LL_CTRL_LENGTH_REQ;
+			ble_ll_ctrl_datalen_upd_make(connsm, dptr);
+			break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-        /* XXX: deal with already encrypted connection.*/
-        case BLE_LL_CTRL_PROC_ENCRYPT:
-            /* If we are already encrypted we do pause procedure */
-            if (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED) {
-                opcode = BLE_LL_CTRL_PAUSE_ENC_REQ;
-            } else {
-                opcode = BLE_LL_CTRL_ENC_REQ;
-                ble_ll_ctrl_enc_req_make(connsm, ctrdata);
-            }
-            break;
+		/* XXX: deal with already encrypted connection.*/
+		case BLE_LL_CTRL_PROC_ENCRYPT:
+			/* If we are already encrypted we do pause procedure */
+			if (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED) {
+				opcode = BLE_LL_CTRL_PAUSE_ENC_REQ;
+			}
+			else {
+				opcode = BLE_LL_CTRL_ENC_REQ;
+				ble_ll_ctrl_enc_req_make(connsm, ctrdata);
+			}
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_PHY)
-        case BLE_LL_CTRL_PROC_PHY_UPDATE:
-            opcode = BLE_LL_CTRL_PHY_REQ;
-            ble_ll_ctrl_phy_req_rsp_make(connsm, ctrdata);
-            break;
+		case BLE_LL_CTRL_PROC_PHY_UPDATE:
+			opcode = BLE_LL_CTRL_PHY_REQ;
+			ble_ll_ctrl_phy_req_rsp_make(connsm, ctrdata);
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-        case BLE_LL_CTRL_PROC_SCA_UPDATE:
-            opcode = BLE_LL_CTRL_CLOCK_ACCURACY_REQ;
-            ble_ll_ctrl_sca_req_rsp_make(connsm, ctrdata);
-            break;
+		case BLE_LL_CTRL_PROC_SCA_UPDATE:
+			opcode = BLE_LL_CTRL_CLOCK_ACCURACY_REQ;
+			ble_ll_ctrl_sca_req_rsp_make(connsm, ctrdata);
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-        case BLE_LL_CTRL_PROC_SUBRATE_REQ:
-            opcode = BLE_LL_CTRL_SUBRATE_REQ;
-            ble_ll_ctrl_subrate_req_make(connsm, ctrdata, &connsm->subrate_req);
-            break;
+		case BLE_LL_CTRL_PROC_SUBRATE_REQ:
+			opcode = BLE_LL_CTRL_SUBRATE_REQ;
+			ble_ll_ctrl_subrate_req_make(connsm, ctrdata, &connsm->subrate_req);
+			break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-        case BLE_LL_CTRL_PROC_SUBRATE_UPDATE:
-            opcode = BLE_LL_CTRL_SUBRATE_IND;
-            ble_ll_ctrl_subrate_ind_make(connsm, ctrdata,
-                                         &connsm->subrate_trans);
-            break;
+		case BLE_LL_CTRL_PROC_SUBRATE_UPDATE:
+			opcode = BLE_LL_CTRL_SUBRATE_IND;
+			ble_ll_ctrl_subrate_ind_make(connsm, ctrdata, &connsm->subrate_trans);
+			break;
 #endif
 #endif
-        default:
-            BLE_LL_ASSERT(0);
-            break;
-        }
+		default:
+			BLE_LL_ASSERT(0);
+			break;
+		}
 
-        /* Set llid, length and opcode */
-        dptr[0] = opcode;
-        len = g_ble_ll_ctrl_pkt_lengths[opcode] + 1;
+		/* Set llid, length and opcode */
+		dptr[0] = opcode;
+		len = g_ble_ll_ctrl_pkt_lengths[opcode] + 1;
 
-        /* Add packet to transmit queue of connection */
-        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
-    }
+		/* Add packet to transmit queue of connection */
+		ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
+	}
 
-    return om;
+	return om;
 }
 
 /**
@@ -2573,18 +2566,17 @@ ble_ll_ctrl_proc_init(struct ble_ll_conn_sm *connsm, int ctrl_proc, void *data)
  *
  * @return int
  */
-int
-ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode)
+int ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode)
 {
-    int rc;
+	int rc;
 
-    rc = 0;
-    if ((hdr & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
-        if (opcode == BLE_LL_CTRL_TERMINATE_IND) {
-            rc = 1;
-        }
-    }
-    return rc;
+	rc = 0;
+	if ((hdr & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
+		if (opcode == BLE_LL_CTRL_TERMINATE_IND) {
+			rc = 1;
+		}
+	}
+	return rc;
 }
 
 /**
@@ -2595,17 +2587,16 @@ ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode)
  * @param connsm
  * @param ctrl_proc
  */
-void
-ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
+void ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
 {
-    if (connsm->cur_ctrl_proc == ctrl_proc) {
-        ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
-        connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
-    }
-    CLR_PENDING_CTRL_PROC(connsm, ctrl_proc);
+	if (connsm->cur_ctrl_proc == ctrl_proc) {
+		ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
+		connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_IDLE;
+	}
+	CLR_PENDING_CTRL_PROC(connsm, ctrl_proc);
 
-    /* If there are others, start them */
-    ble_ll_ctrl_chk_proc_start(connsm);
+	/* If there are others, start them */
+	ble_ll_ctrl_chk_proc_start(connsm);
 }
 
 /**
@@ -2615,24 +2606,23 @@ ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
  *
  * @param connsm
  */
-void
-ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm)
+void ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm)
 {
-    int ctrl_proc;
-    uint32_t usecs;
-    struct os_mbuf *om;
+	int ctrl_proc;
+	uint32_t usecs;
+	struct os_mbuf *om;
 
-    BLE_LL_ASSERT(connsm->disconnect_reason != 0);
+	BLE_LL_ASSERT(connsm->disconnect_reason != 0);
 
-    ctrl_proc = BLE_LL_CTRL_PROC_TERMINATE;
-    om = ble_ll_ctrl_proc_init(connsm, ctrl_proc, NULL);
-    if (om) {
-        connsm->flags.terminate_started = 1;
+	ctrl_proc = BLE_LL_CTRL_PROC_TERMINATE;
+	om = ble_ll_ctrl_proc_init(connsm, ctrl_proc, NULL);
+	if (om) {
+		connsm->flags.terminate_started = 1;
 
-        /* Set terminate "timeout" */
-        usecs = connsm->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000;
-        connsm->terminate_timeout = ble_ll_tmr_get() + ble_ll_tmr_u2t(usecs);
-    }
+		/* Set terminate "timeout" */
+		usecs = connsm->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000;
+		connsm->terminate_timeout = ble_ll_tmr_get() + ble_ll_tmr_u2t(usecs);
+	}
 }
 
 /**
@@ -2644,31 +2634,29 @@ ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm)
  *
  * @param connsm Pointer to connection state machine.
  */
-void
-ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc,
-                       void *data)
+void ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc, void *data)
 {
-    struct os_mbuf *om;
+	struct os_mbuf *om;
 
-    BLE_LL_ASSERT(ctrl_proc != BLE_LL_CTRL_PROC_TERMINATE);
+	BLE_LL_ASSERT(ctrl_proc != BLE_LL_CTRL_PROC_TERMINATE);
 
-    om = NULL;
-    if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) {
-        /* Initiate the control procedure. */
-        om = ble_ll_ctrl_proc_init(connsm, ctrl_proc, data);
-        if (om) {
-            /* Set the current control procedure */
-            connsm->cur_ctrl_proc = ctrl_proc;
+	om = NULL;
+	if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) {
+		/* Initiate the control procedure. */
+		om = ble_ll_ctrl_proc_init(connsm, ctrl_proc, data);
+		if (om) {
+			/* Set the current control procedure */
+			connsm->cur_ctrl_proc = ctrl_proc;
 
-            /* Initialize the procedure response timeout */
-            if (ctrl_proc != BLE_LL_CTRL_PROC_CHAN_MAP_UPD) {
-                ble_ll_ctrl_start_rsp_timer(connsm);
-            }
-        }
-    }
+			/* Initialize the procedure response timeout */
+			if (ctrl_proc != BLE_LL_CTRL_PROC_CHAN_MAP_UPD) {
+				ble_ll_ctrl_start_rsp_timer(connsm);
+			}
+		}
+	}
 
-    /* Set bitmask denoting control procedure is pending */
-    connsm->pending_ctrl_procs |= (1 << ctrl_proc);
+	/* Set bitmask denoting control procedure is pending */
+	connsm->pending_ctrl_procs |= (1 << ctrl_proc);
 }
 
 /**
@@ -2679,55 +2667,54 @@ ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc,
  *
  * @param connsm Pointer to connection state machine.
  */
-void
-ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
-{
-    int i;
-
-    /* XXX: TODO new rules! Cannot start certain control procedures if other
-     * ones are peer initiated. We need to wait. Deal with this.
-     */
-
-    /*
-     * If we are terminating, dont start any new procedures but start
-     * terminate if needed
-     */
-    if (connsm->disconnect_reason) {
-        if (!connsm->flags.terminate_started) {
-            /*
-             * If the terminate procedure has not started it means we were not
-             * able to start it right away (no control pdu was available).
-             * Start it now. No need to start any other procedures.
-             */
-            ble_ll_ctrl_terminate_start(connsm);
-        }
-        return;
-    }
-
-    /* If there is a running procedure or no pending, do nothing */
-    if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) &&
-        (connsm->pending_ctrl_procs != 0)) {
-        /*
-         * The specification says there is no priority to control procedures
-         * so just start from the first one for now.
-         */
-        for (i = 0; i < BLE_LL_CTRL_PROC_NUM; ++i) {
-            if (IS_PENDING_CTRL_PROC(connsm, i)) {
-                /*
-                 * The version exchange is a special case. If we have already
-                 * received the information dont start it.
-                 */
-                if ((i == BLE_LL_CTRL_PROC_VERSION_XCHG) &&
-                    (connsm->flags.version_ind_rxd)) {
-                    ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
-                    CLR_PENDING_CTRL_PROC(connsm, i);
-                } else {
-                    ble_ll_ctrl_proc_start(connsm, i, NULL);
-                    break;
-                }
-            }
-        }
-    }
+void ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
+{
+	int i;
+
+	/* XXX: TODO new rules! Cannot start certain control procedures if other
+	 * ones are peer initiated. We need to wait. Deal with this.
+	 */
+
+	/*
+	 * If we are terminating, dont start any new procedures but start
+	 * terminate if needed
+	 */
+	if (connsm->disconnect_reason) {
+		if (!connsm->flags.terminate_started) {
+			/*
+			 * If the terminate procedure has not started it means we were not
+			 * able to start it right away (no control pdu was available).
+			 * Start it now. No need to start any other procedures.
+			 */
+			ble_ll_ctrl_terminate_start(connsm);
+		}
+		return;
+	}
+
+	/* If there is a running procedure or no pending, do nothing */
+	if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_IDLE) &&
+	    (connsm->pending_ctrl_procs != 0)) {
+		/*
+		 * The specification says there is no priority to control procedures
+		 * so just start from the first one for now.
+		 */
+		for (i = 0; i < BLE_LL_CTRL_PROC_NUM; ++i) {
+			if (IS_PENDING_CTRL_PROC(connsm, i)) {
+				/*
+				 * The version exchange is a special case. If we have already
+				 * received the information dont start it.
+				 */
+				if ((i == BLE_LL_CTRL_PROC_VERSION_XCHG) && (connsm->flags.version_ind_rxd)) {
+					ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
+					CLR_PENDING_CTRL_PROC(connsm, i);
+				}
+				else {
+					ble_ll_ctrl_proc_start(connsm, i, NULL);
+					break;
+				}
+			}
+		}
+	}
 }
 
 /**
@@ -2743,310 +2730,332 @@ ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
  * @param om
  * @param connsm
  */
-int
-ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
-{
-    uint64_t features;
-    uint64_t feature;
-    uint8_t len;
-    uint8_t opcode;
-    uint8_t *dptr;
-    uint8_t *rspbuf;
-    uint8_t *rspdata;
+int ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
+{
+	uint64_t features;
+	uint64_t feature;
+	uint8_t len;
+	uint8_t opcode;
+	uint8_t *dptr;
+	uint8_t *rspbuf;
+	uint8_t *rspdata;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    int restart_encryption;
+	int restart_encryption;
 #endif
-    int rc = 0;
-    uint8_t rsp_opcode = 0;
+	int rc = 0;
+	uint8_t rsp_opcode = 0;
 
-    /* XXX: where do we validate length received and packet header length?
-     * do this in LL task when received. Someplace!!! What I mean
-     * is we should validate the over the air length with the mbuf length.
-       Should the PHY do that???? */
+	/* XXX: where do we validate length received and packet header length?
+	 * do this in LL task when received. Someplace!!! What I mean
+	 * is we should validate the over the air length with the mbuf length.
+	   Should the PHY do that???? */
 
-    /*
-     * dptr points to om_data pointer. The first byte of om_data is the
-     * first byte of the Data Channel PDU header. Get length from header and
-     * opcode from LL control PDU.
-     */
-    dptr = om->om_data;
-    len = dptr[1];
-    opcode = dptr[2];
+	/*
+	 * dptr points to om_data pointer. The first byte of om_data is the
+	 * first byte of the Data Channel PDU header. Get length from header and
+	 * opcode from LL control PDU.
+	 */
+	dptr = om->om_data;
+	len = dptr[1];
+	opcode = dptr[2];
 
 #if MYNEWT_VAL(BLE_LL_HCI_LLCP_TRACE)
-    ble_ll_hci_ev_send_vs_llcp_trace(0x03, connsm->conn_handle,
-                                     connsm->event_cntr,
-                                     &dptr[2], len);
+	ble_ll_hci_ev_send_vs_llcp_trace(0x03, connsm->conn_handle, connsm->event_cntr,
+	                                 &dptr[2], len);
 #endif
 
-    /*
-     * rspbuf points to first byte of response. The response buffer does not
-     * contain the Data Channel PDU. Thus, the first byte of rspbuf is the
-     * LL control PDU payload (the opcode of the control PDU). rspdata
-     * points to CtrData in the control PDU.
-     */
-    rspbuf = dptr;
-    rspdata = rspbuf + 1;
+	/*
+	 * rspbuf points to first byte of response. The response buffer does not
+	 * contain the Data Channel PDU. Thus, the first byte of rspbuf is the
+	 * LL control PDU payload (the opcode of the control PDU). rspdata
+	 * points to CtrData in the control PDU.
+	 */
+	rspbuf = dptr;
+	rspdata = rspbuf + 1;
 
-    /* Move data pointer to start of control data (2 byte PDU hdr + opcode) */
-    dptr += (BLE_LL_PDU_HDR_LEN + 1);
+	/* Move data pointer to start of control data (2 byte PDU hdr + opcode) */
+	dptr += (BLE_LL_PDU_HDR_LEN + 1);
 
-    /*
-     * Subtract the opcode from the length. Note that if the length was zero,
-     * which would be an error, we will fail the check against the length
-     * of the control packet.
-     */
-    --len;
+	/*
+	 * Subtract the opcode from the length. Note that if the length was zero,
+	 * which would be an error, we will fail the check against the length
+	 * of the control packet.
+	 */
+	--len;
 
-    ble_ll_trace_u32x2(BLE_LL_TRACE_ID_CTRL_RX, opcode, len);
+	ble_ll_trace_u32x2(BLE_LL_TRACE_ID_CTRL_RX, opcode, len);
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    restart_encryption = 0;
-#endif
-
-    /* If opcode comes from reserved value or CtrlData fields is invalid
-     * we shall respond with LL_UNKNOWN_RSP
-     */
-    if ((opcode >= BLE_LL_CTRL_OPCODES) ||
-        (len != g_ble_ll_ctrl_pkt_lengths[opcode])) {
-        rc = -1;
-        rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-        goto ll_ctrl_send_rsp;
-    }
-
-    /* Check if the feature is supported. */
-    switch (opcode) {
-    case BLE_LL_CTRL_LENGTH_REQ:
-        feature = BLE_LL_FEAT_DATA_LEN_EXT;
-        break;
-    case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
-        feature = BLE_LL_FEAT_PERIPH_INIT;
-        break;
-    case BLE_LL_CTRL_CONN_PARM_REQ:
-    case BLE_LL_CTRL_CONN_PARM_RSP:
-        feature = BLE_LL_FEAT_CONN_PARM_REQ;
-        break;
-    case BLE_LL_CTRL_ENC_REQ:
-    case BLE_LL_CTRL_START_ENC_REQ:
-    case BLE_LL_CTRL_PAUSE_ENC_REQ:
-        feature = BLE_LL_FEAT_LE_ENCRYPTION;
-        break;
-    case BLE_LL_CTRL_PING_REQ:
-        feature = BLE_LL_FEAT_LE_PING;
-        break;
-    case BLE_LL_CTRL_PHY_REQ:
-        feature = BLE_LL_FEAT_LE_2M_PHY | BLE_LL_FEAT_LE_CODED_PHY;
-        break;
-    case BLE_LL_CTRL_MIN_USED_CHAN_IND:
-        feature = BLE_LL_FEAT_MIN_USED_CHAN;
-        break;
-    case BLE_LL_CTRL_PERIODIC_SYNC_IND:
-        feature = BLE_LL_FEAT_SYNC_TRANS_RECV;
-        break;
-    case BLE_LL_CTRL_SUBRATE_REQ:
-    case BLE_LL_CTRL_SUBRATE_IND:
-        feature = BLE_LL_FEAT_CONN_SUBRATING;
-        break;
-    default:
-        feature = 0;
-        break;
-    }
-
-    if (feature) {
-        features = ble_ll_read_supp_features();
-        if ((features & feature) == 0) {
-            if (opcode == BLE_LL_CTRL_ENC_REQ) {
-                if (connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ) {
-                    rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-                    rspbuf[1] = opcode;
-                    rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;
-
-                } else {
-                    rsp_opcode = BLE_LL_CTRL_REJECT_IND;
-                    rspbuf[1] = BLE_ERR_UNSUPP_REM_FEATURE;
-                }
-            } else {
-                /* Construct unknown rsp pdu */
-                rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-            }
-            goto ll_ctrl_send_rsp;
-        }
-    }
-
-    /* Process opcode */
-    rsp_opcode = BLE_ERR_MAX;
-    switch (opcode) {
-    case BLE_LL_CTRL_CONN_UPDATE_IND:
-        rsp_opcode = ble_ll_ctrl_rx_conn_update(connsm, dptr);
-        break;
-    case BLE_LL_CTRL_CHANNEL_MAP_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_chanmap_req(connsm, dptr);
-        break;
-    case BLE_LL_CTRL_LENGTH_REQ:
-        /* Extract parameters and check if valid */
-        if (ble_ll_ctrl_len_proc(connsm, dptr)) {
-            rc  = -1;
-            rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-            goto ll_ctrl_send_rsp;
-        }
-
-        /*
-         * If we have not started this procedure ourselves and it is
-         * pending, no need to perform it.
-         */
-        if ((connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_DATA_LEN_UPD) &&
-            IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD)) {
-            CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
-        }
-
-        /* Send a response */
-        rsp_opcode = BLE_LL_CTRL_LENGTH_RSP;
-        ble_ll_ctrl_datalen_upd_make(connsm, rspbuf);
-        break;
-    case BLE_LL_CTRL_LENGTH_RSP:
-        /* According to specification, process this only if we asked for it. */
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_DATA_LEN_UPD) {
-            /*
-             * Process the received data. If received data is invalid, we'll
-             * reply with LL_UNKNOWN_RSP as per spec, but we still need to stop
-             * control procedure to avoid timeout.
-             */
-            if (ble_ll_ctrl_len_proc(connsm, dptr)) {
-                rc = -1;
-                rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
-            }
-
-            /* Stop the control procedure */
-            ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
-        }
-        break;
-    case BLE_LL_CTRL_UNKNOWN_RSP:
-        rsp_opcode = ble_ll_ctrl_proc_unk_rsp(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_FEATURE_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
-        break;
-    /* XXX: check to see if ctrl procedure was running? Do we care? */
-    case BLE_LL_CTRL_FEATURE_RSP:
-        ble_ll_ctrl_rx_feature_rsp(connsm, dptr);
-        break;
-    case BLE_LL_CTRL_VERSION_IND:
-        rsp_opcode = ble_ll_ctrl_rx_version_ind(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
-        break;
+	restart_encryption = 0;
+#endif
+
+	/* If opcode comes from reserved value or CtrlData fields is invalid
+	 * we shall respond with LL_UNKNOWN_RSP
+	 */
+	if ((opcode >= BLE_LL_CTRL_OPCODES) || (len != g_ble_ll_ctrl_pkt_lengths[opcode])) {
+		rc = -1;
+		rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
+		goto ll_ctrl_send_rsp;
+	}
+
+	/* Check if the feature is supported. */
+	switch (opcode) {
+	case BLE_LL_CTRL_LENGTH_REQ:
+		feature = BLE_LL_FEAT_DATA_LEN_EXT;
+		break;
+	case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
+		feature = BLE_LL_FEAT_PERIPH_INIT;
+		break;
+	case BLE_LL_CTRL_CONN_PARM_REQ:
+	case BLE_LL_CTRL_CONN_PARM_RSP:
+		feature = BLE_LL_FEAT_CONN_PARM_REQ;
+		break;
+	case BLE_LL_CTRL_ENC_REQ:
+#if MYNEWT_VAL(REJECT_ENC_REQ)
+		if (force_reject) {
+			if (connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ) {
+				rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+				rspbuf[1] = opcode;
+				rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;
+				// BLE_ERR_CTLR_BUSY
+				// ERR MAX
+			}
+			else {
+				rsp_opcode = BLE_LL_CTRL_REJECT_IND;
+				// rspbuf[1] = BLE_ERR_UNSUPP_REM_FEATURE;
+				rspbuf[1] = BLE_ERR_CMD_DISALLOWED;
+			}
+			printf("Rejecting LL_ENC_REQ\n");
+			force_reject--;
+			if (force_reject == 0) {
+				ble_ll_hci_ev_conn_update(connsm, BLE_ERR_MAX);
+			}
+
+			goto ll_ctrl_send_rsp;
+		}
+#endif
+	case BLE_LL_CTRL_START_ENC_REQ:
+	case BLE_LL_CTRL_PAUSE_ENC_REQ:
+		feature = BLE_LL_FEAT_LE_ENCRYPTION;
+		break;
+	case BLE_LL_CTRL_PING_REQ:
+		feature = BLE_LL_FEAT_LE_PING;
+		break;
+	case BLE_LL_CTRL_PHY_REQ:
+		feature = BLE_LL_FEAT_LE_2M_PHY | BLE_LL_FEAT_LE_CODED_PHY;
+		break;
+	case BLE_LL_CTRL_MIN_USED_CHAN_IND:
+		feature = BLE_LL_FEAT_MIN_USED_CHAN;
+		break;
+	case BLE_LL_CTRL_PERIODIC_SYNC_IND:
+		feature = BLE_LL_FEAT_SYNC_TRANS_RECV;
+		break;
+	case BLE_LL_CTRL_SUBRATE_REQ:
+	case BLE_LL_CTRL_SUBRATE_IND:
+		feature = BLE_LL_FEAT_CONN_SUBRATING;
+		break;
+	default:
+		feature = 0;
+		break;
+	}
+
+	if (feature) {
+		features = ble_ll_read_supp_features();
+		if ((features & feature) == 0) {
+			if (opcode == BLE_LL_CTRL_ENC_REQ) {
+				if (connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ) {
+					rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+					rspbuf[1] = opcode;
+					rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;
+				}
+				else {
+					rsp_opcode = BLE_LL_CTRL_REJECT_IND;
+					rspbuf[1] = BLE_ERR_UNSUPP_REM_FEATURE;
+				}
+			}
+			else {
+				/* Construct unknown rsp pdu */
+				rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
+			}
+			goto ll_ctrl_send_rsp;
+		}
+	}
+
+	/* Process opcode */
+	rsp_opcode = BLE_ERR_MAX;
+	switch (opcode) {
+	case BLE_LL_CTRL_CONN_UPDATE_IND:
+		rsp_opcode = ble_ll_ctrl_rx_conn_update(connsm, dptr);
+		break;
+	case BLE_LL_CTRL_CHANNEL_MAP_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_chanmap_req(connsm, dptr);
+		break;
+	case BLE_LL_CTRL_LENGTH_REQ:
+		/* Extract parameters and check if valid */
+		if (ble_ll_ctrl_len_proc(connsm, dptr)) {
+			rc = -1;
+			rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
+			goto ll_ctrl_send_rsp;
+		}
+
+		/*
+		 * If we have not started this procedure ourselves and it is
+		 * pending, no need to perform it.
+		 */
+		if ((connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_DATA_LEN_UPD) &&
+		    IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD)) {
+			CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
+		}
+
+		/* Send a response */
+		rsp_opcode = BLE_LL_CTRL_LENGTH_RSP;
+		ble_ll_ctrl_datalen_upd_make(connsm, rspbuf);
+		break;
+	case BLE_LL_CTRL_LENGTH_RSP:
+		/* According to specification, process this only if we asked for it. */
+		if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_DATA_LEN_UPD) {
+			/*
+			 * Process the received data. If received data is invalid, we'll
+			 * reply with LL_UNKNOWN_RSP as per spec, but we still need to stop
+			 * control procedure to avoid timeout.
+			 */
+			if (ble_ll_ctrl_len_proc(connsm, dptr)) {
+				rc = -1;
+				rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
+			}
+
+			/* Stop the control procedure */
+			ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_DATA_LEN_UPD);
+		}
+		break;
+	case BLE_LL_CTRL_UNKNOWN_RSP:
+		rsp_opcode = ble_ll_ctrl_proc_unk_rsp(connsm, dptr, rspdata);
+		break;
+	case BLE_LL_CTRL_FEATURE_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
+		break;
+	/* XXX: check to see if ctrl procedure was running? Do we care? */
+	case BLE_LL_CTRL_FEATURE_RSP:
+		ble_ll_ctrl_rx_feature_rsp(connsm, dptr);
+		break;
+	case BLE_LL_CTRL_VERSION_IND:
+		rsp_opcode = ble_ll_ctrl_rx_version_ind(connsm, dptr, rspdata);
+		break;
+	case BLE_LL_CTRL_PERIPH_FEATURE_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_feature_req(connsm, dptr, rspbuf, opcode);
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    case BLE_LL_CTRL_ENC_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_enc_req(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_ENC_RSP:
-        ble_ll_ctrl_rx_enc_rsp(connsm, dptr);
-        break;
-    case BLE_LL_CTRL_START_ENC_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_start_enc_req(connsm);
-        break;
-    case BLE_LL_CTRL_START_ENC_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_start_enc_rsp(connsm);
-        break;
-    case BLE_LL_CTRL_PAUSE_ENC_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_pause_enc_req(connsm);
-        break;
-    case BLE_LL_CTRL_PAUSE_ENC_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_pause_enc_rsp(connsm);
-        if (rsp_opcode == BLE_LL_CTRL_PAUSE_ENC_RSP) {
-            restart_encryption = 1;
-        }
-        break;
-#endif
-    case BLE_LL_CTRL_PING_REQ:
-        rsp_opcode = BLE_LL_CTRL_PING_RSP;
-        break;
-    case BLE_LL_CTRL_PING_RSP:
-        ble_ll_ctrl_rx_ping_rsp(connsm);
-        break;
-    case BLE_LL_CTRL_CONN_PARM_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_conn_param_req(connsm, dptr, rspbuf);
-        break;
-    case BLE_LL_CTRL_CONN_PARM_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_conn_param_rsp(connsm, dptr, rspbuf);
-        break;
-    /* Fall-through intentional... */
-    case BLE_LL_CTRL_REJECT_IND:
-    case BLE_LL_CTRL_REJECT_IND_EXT:
-        /* Sometimes reject triggers sending other LL CTRL msg */
-        rsp_opcode = ble_ll_ctrl_rx_reject_ind(connsm, dptr, opcode, rspdata);
-        break;
+	case BLE_LL_CTRL_ENC_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_enc_req(connsm, dptr, rspdata);
+		break;
+	case BLE_LL_CTRL_ENC_RSP:
+		ble_ll_ctrl_rx_enc_rsp(connsm, dptr);
+		break;
+	case BLE_LL_CTRL_START_ENC_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_start_enc_req(connsm);
+		break;
+	case BLE_LL_CTRL_START_ENC_RSP:
+		rsp_opcode = ble_ll_ctrl_rx_start_enc_rsp(connsm);
+		break;
+	case BLE_LL_CTRL_PAUSE_ENC_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_pause_enc_req(connsm);
+		break;
+	case BLE_LL_CTRL_PAUSE_ENC_RSP:
+		rsp_opcode = ble_ll_ctrl_rx_pause_enc_rsp(connsm);
+		if (rsp_opcode == BLE_LL_CTRL_PAUSE_ENC_RSP) {
+			restart_encryption = 1;
+		}
+		break;
+#endif
+	case BLE_LL_CTRL_PING_REQ:
+		rsp_opcode = BLE_LL_CTRL_PING_RSP;
+		break;
+	case BLE_LL_CTRL_PING_RSP:
+		ble_ll_ctrl_rx_ping_rsp(connsm);
+		break;
+	case BLE_LL_CTRL_CONN_PARM_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_conn_param_req(connsm, dptr, rspbuf);
+		break;
+	case BLE_LL_CTRL_CONN_PARM_RSP:
+		rsp_opcode = ble_ll_ctrl_rx_conn_param_rsp(connsm, dptr, rspbuf);
+		break;
+	/* Fall-through intentional... */
+	case BLE_LL_CTRL_REJECT_IND:
+	case BLE_LL_CTRL_REJECT_IND_EXT:
+		/* Sometimes reject triggers sending other LL CTRL msg */
+		rsp_opcode = ble_ll_ctrl_rx_reject_ind(connsm, dptr, opcode, rspdata);
+		break;
 #if MYNEWT_VAL(BLE_LL_PHY)
-    case BLE_LL_CTRL_PHY_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_phy_req(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_PHY_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_phy_rsp(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_PHY_UPDATE_IND:
-        rsp_opcode = ble_ll_ctrl_rx_phy_update_ind(connsm, dptr);
-        break;
+	case BLE_LL_CTRL_PHY_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_phy_req(connsm, dptr, rspdata);
+		break;
+	case BLE_LL_CTRL_PHY_RSP:
+		rsp_opcode = ble_ll_ctrl_rx_phy_rsp(connsm, dptr, rspdata);
+		break;
+	case BLE_LL_CTRL_PHY_UPDATE_IND:
+		rsp_opcode = ble_ll_ctrl_rx_phy_update_ind(connsm, dptr);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-    case BLE_LL_CTRL_CLOCK_ACCURACY_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_sca_req(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_CLOCK_ACCURACY_RSP:
-        rsp_opcode = ble_ll_ctrl_rx_sca_rsp(connsm, dptr);
-        break;
+	case BLE_LL_CTRL_CLOCK_ACCURACY_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_sca_req(connsm, dptr, rspdata);
+		break;
+	case BLE_LL_CTRL_CLOCK_ACCURACY_RSP:
+		rsp_opcode = ble_ll_ctrl_rx_sca_rsp(connsm, dptr);
+		break;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
-    case BLE_LL_CTRL_PERIODIC_SYNC_IND:
-        rsp_opcode = ble_ll_ctrl_rx_periodic_sync_ind(connsm, dptr);
-        break;
+	case BLE_LL_CTRL_PERIODIC_SYNC_IND:
+		rsp_opcode = ble_ll_ctrl_rx_periodic_sync_ind(connsm, dptr);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    case BLE_LL_CTRL_SUBRATE_REQ:
-        rsp_opcode = ble_ll_ctrl_rx_subrate_req(connsm, dptr, rspdata);
-        break;
-    case BLE_LL_CTRL_SUBRATE_IND:
-        rsp_opcode = ble_ll_ctrl_rx_subrate_ind(connsm, dptr, rspdata);
-        break;
-#endif
-    default:
-        /* Nothing to do here */
-        break;
-    }
-
-    /* Free mbuf or send response */
+	case BLE_LL_CTRL_SUBRATE_REQ:
+		rsp_opcode = ble_ll_ctrl_rx_subrate_req(connsm, dptr, rspdata);
+		break;
+	case BLE_LL_CTRL_SUBRATE_IND:
+		rsp_opcode = ble_ll_ctrl_rx_subrate_ind(connsm, dptr, rspdata);
+		break;
+#endif
+	default:
+		/* Nothing to do here */
+		break;
+	}
+
+	/* Free mbuf or send response */
 ll_ctrl_send_rsp:
-    if (rsp_opcode == BLE_ERR_MAX) {
-        os_mbuf_free_chain(om);
-    } else {
-        /*
-         * Write the response opcode into the buffer. If this is an unknown
-         * response, put opcode of unknown pdu into buffer.
-         */
-        rspbuf[0] = rsp_opcode;
-        if (rsp_opcode == BLE_LL_CTRL_UNKNOWN_RSP) {
-            rspbuf[1] = opcode;
-        }
-        len = g_ble_ll_ctrl_pkt_lengths[rsp_opcode] + 1;
-        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
+	if (rsp_opcode == BLE_ERR_MAX) {
+		os_mbuf_free_chain(om);
+	}
+	else {
+		/*
+		 * Write the response opcode into the buffer. If this is an unknown
+		 * response, put opcode of unknown pdu into buffer.
+		 */
+		rspbuf[0] = rsp_opcode;
+		if (rsp_opcode == BLE_LL_CTRL_UNKNOWN_RSP) {
+			rspbuf[1] = opcode;
+		}
+		len = g_ble_ll_ctrl_pkt_lengths[rsp_opcode] + 1;
+		ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-        if (restart_encryption) {
-            /* XXX: what happens if this fails? Meaning we cant allocate
-               mbuf? */
-            ble_ll_ctrl_proc_init(connsm, BLE_LL_CTRL_PROC_ENCRYPT, NULL);
-        }
+		if (restart_encryption) {
+			/* XXX: what happens if this fails? Meaning we cant allocate
+			   mbuf? */
+			ble_ll_ctrl_proc_init(connsm, BLE_LL_CTRL_PROC_ENCRYPT, NULL);
+		}
 #endif
-    }
+	}
 
 #if MYNEWT_VAL(BLE_LL_CONN_INIT_AUTO_DLE)
-    if (connsm->flags.pending_initiate_dle) {
-        connsm->flags.pending_initiate_dle = 0;
-        ble_ll_ctrl_initiate_dle(connsm, true);
-    }
+	if (connsm->flags.pending_initiate_dle) {
+		connsm->flags.pending_initiate_dle = 0;
+		ble_ll_ctrl_initiate_dle(connsm, true);
+	}
 #endif
 
-    return rc;
+	return rc;
 }
 
 /**
@@ -3058,76 +3067,75 @@ ll_ctrl_send_rsp:
  *
  * @return int
  */
-int
-ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm, uint8_t rej_opcode,
-                            uint8_t err)
-{
-    int rc;
-    uint8_t len;
-    uint8_t opcode;
-    uint8_t *rspbuf;
-    struct os_mbuf *om;
-
-    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
-                            sizeof(struct ble_mbuf_hdr));
-    if (om) {
-        rspbuf = om->om_data;
-        opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        if (rej_opcode == BLE_LL_CTRL_ENC_REQ) {
-            if ((connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ) == 0) {
-                opcode = BLE_LL_CTRL_REJECT_IND;
-            }
-        }
-        rspbuf[0] = opcode;
-        if (opcode == BLE_LL_CTRL_REJECT_IND) {
-            rspbuf[1] = err;
-            len = BLE_LL_CTRL_REJ_IND_LEN + 1;
-        } else {
-            rspbuf[1] = rej_opcode;
-            rspbuf[2] = err;
-            len = BLE_LL_CTRL_REJECT_IND_EXT_LEN + 1;
-        }
-        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
-        rc = 0;
-    } else {
-        rc = 1;
-    }
-    return rc;
-}
-
-int
-ble_ll_ctrl_tx_start(struct ble_ll_conn_sm *connsm, struct os_mbuf *txpdu)
-{
-    uint8_t opcode;
-    uint8_t *ctrdata;
-
-    opcode = txpdu->om_data[0];
-    ctrdata = &txpdu->om_data[1];
-
-    switch (opcode) {
-    case BLE_LL_CTRL_CONN_UPDATE_IND:
-        ble_ll_ctrl_conn_update_make_ind_pdu(connsm, ctrdata);
-        connsm->flags.conn_update_sched = 1;
-        break;
-    case BLE_LL_CTRL_CHANNEL_MAP_REQ:
-        ble_ll_ctrl_chanmap_req_instant(connsm, ctrdata);
-        connsm->flags.chanmap_update_sched = 1;
-        break;
+int ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm, uint8_t rej_opcode,
+                                uint8_t err)
+{
+	int rc;
+	uint8_t len;
+	uint8_t opcode;
+	uint8_t *rspbuf;
+	struct os_mbuf *om;
+
+	om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN, sizeof(struct ble_mbuf_hdr));
+	if (om) {
+		rspbuf = om->om_data;
+		opcode = BLE_LL_CTRL_REJECT_IND_EXT;
+		if (rej_opcode == BLE_LL_CTRL_ENC_REQ) {
+			if ((connsm->conn_features & BLE_LL_FEAT_EXTENDED_REJ) == 0) {
+				opcode = BLE_LL_CTRL_REJECT_IND;
+			}
+		}
+		rspbuf[0] = opcode;
+		if (opcode == BLE_LL_CTRL_REJECT_IND) {
+			rspbuf[1] = err;
+			len = BLE_LL_CTRL_REJ_IND_LEN + 1;
+		}
+		else {
+			rspbuf[1] = rej_opcode;
+			rspbuf[2] = err;
+			len = BLE_LL_CTRL_REJECT_IND_EXT_LEN + 1;
+		}
+		ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
+		rc = 0;
+	}
+	else {
+		rc = 1;
+	}
+	return rc;
+}
+
+int ble_ll_ctrl_tx_start(struct ble_ll_conn_sm *connsm, struct os_mbuf *txpdu)
+{
+	uint8_t opcode;
+	uint8_t *ctrdata;
+
+	opcode = txpdu->om_data[0];
+	ctrdata = &txpdu->om_data[1];
+
+	switch (opcode) {
+	case BLE_LL_CTRL_CONN_UPDATE_IND:
+		ble_ll_ctrl_conn_update_make_ind_pdu(connsm, ctrdata);
+		connsm->flags.conn_update_sched = 1;
+		break;
+	case BLE_LL_CTRL_CHANNEL_MAP_REQ:
+		ble_ll_ctrl_chanmap_req_instant(connsm, ctrdata);
+		connsm->flags.chanmap_update_sched = 1;
+		break;
 #if MYNEWT_VAL(BLE_LL_PHY)
-    case BLE_LL_CTRL_PHY_UPDATE_IND:
-        if (ble_ll_ctrl_phy_update_ind_instant(connsm, ctrdata)) {
-            connsm->flags.phy_update_sched = 1;
-        }
-        break;
+	case BLE_LL_CTRL_PHY_UPDATE_IND:
+		if (ble_ll_ctrl_phy_update_ind_instant(connsm, ctrdata)) {
+			connsm->flags.phy_update_sched = 1;
+		}
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    case BLE_LL_CTRL_SUBRATE_IND:
-        connsm->flags.subrate_trans = 1;
-        break;
+	case BLE_LL_CTRL_SUBRATE_IND:
+		connsm->flags.subrate_trans = 1;
+		break;
 #endif
-    }
+	}
 
-    return 0;
+	return 0;
 }
 
 /**
@@ -3140,114 +3148,109 @@ ble_ll_ctrl_tx_start(struct ble_ll_conn_sm *connsm, struct os_mbuf *txpdu)
  *
  * @return int
  */
-int
-ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
+int ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
 {
-    int rc;
-    uint8_t opcode;
+	int rc;
+	uint8_t opcode;
 
 #if MYNEWT_VAL(BLE_LL_HCI_LLCP_TRACE)
-    ble_ll_hci_ev_send_vs_llcp_trace(0x04, connsm->conn_handle,
-                                     connsm->event_cntr,
-                                     txpdu->om_data, txpdu->om_len);
-#endif
-
-    rc = 0;
-    opcode = txpdu->om_data[0];
-    switch (opcode) {
-    case BLE_LL_CTRL_TERMINATE_IND:
-        connsm->flags.terminate_ind_txd = 1;
-        rc = -1;
-        break;
-    case BLE_LL_CTRL_REJECT_IND_EXT:
-        if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ) {
-            /* If rejecting opcode is BLE_LL_CTRL_PROC_CONN_PARAM_REQ and
-             * reason is LMP collision that means we are central on the link and
-             * peer wanted to start procedure which we already started.
-             * Let's wait for response and do not close procedure. */
-            if (txpdu->om_data[1] == BLE_LL_CTRL_CONN_PARM_REQ &&
-                            txpdu->om_data[2] != BLE_ERR_LMP_COLLISION) {
-                connsm->reject_reason = txpdu->om_data[2];
-                connsm->flags.conn_update_host_w4event = 1;
-            }
-        }
+	ble_ll_hci_ev_send_vs_llcp_trace(0x04, connsm->conn_handle, connsm->event_cntr,
+	                                 txpdu->om_data, txpdu->om_len);
+#endif
+
+	rc = 0;
+	opcode = txpdu->om_data[0];
+	switch (opcode) {
+	case BLE_LL_CTRL_TERMINATE_IND:
+		connsm->flags.terminate_ind_txd = 1;
+		rc = -1;
+		break;
+	case BLE_LL_CTRL_REJECT_IND_EXT:
+		if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ) {
+			/* If rejecting opcode is BLE_LL_CTRL_PROC_CONN_PARAM_REQ and
+			 * reason is LMP collision that means we are central on the link and
+			 * peer wanted to start procedure which we already started.
+			 * Let's wait for response and do not close procedure. */
+			if (txpdu->om_data[1] == BLE_LL_CTRL_CONN_PARM_REQ &&
+			    txpdu->om_data[2] != BLE_ERR_LMP_COLLISION) {
+				connsm->reject_reason = txpdu->om_data[2];
+				connsm->flags.conn_update_host_w4event = 1;
+			}
+		}
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-        if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
-            connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
-        }
+		if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
+			connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
+		}
 #endif
-        break;
-    case BLE_LL_CTRL_REJECT_IND:
+		break;
+	case BLE_LL_CTRL_REJECT_IND:
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-        connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
+		connsm->enc_data.enc_state = CONN_ENC_S_UNENCRYPTED;
 #endif
-        break;
+		break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    case BLE_LL_CTRL_PAUSE_ENC_REQ:
-        /* note: fall-through intentional */
-    case BLE_LL_CTRL_ENC_REQ:
-        connsm->enc_data.enc_state = CONN_ENC_S_ENC_RSP_WAIT;
-        break;
-    case BLE_LL_CTRL_ENC_RSP:
-        connsm->enc_data.enc_state = CONN_ENC_S_LTK_REQ_WAIT;
-        connsm->flags.encrypt_ltk_req = 1;
-        break;
+	case BLE_LL_CTRL_PAUSE_ENC_REQ:
+		/* note: fall-through intentional */
+	case BLE_LL_CTRL_ENC_REQ:
+		connsm->enc_data.enc_state = CONN_ENC_S_ENC_RSP_WAIT;
+		break;
+	case BLE_LL_CTRL_ENC_RSP:
+		connsm->enc_data.enc_state = CONN_ENC_S_LTK_REQ_WAIT;
+		connsm->flags.encrypt_ltk_req = 1;
+		break;
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CTRL_START_ENC_RSP:
-        if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-            connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
-            if (connsm->flags.le_ping_supp) {
-                ble_ll_conn_auth_pyld_timer_start(connsm);
-            }
-        }
-        break;
-    case BLE_LL_CTRL_PAUSE_ENC_RSP:
-        if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-            connsm->enc_data.enc_state = CONN_ENC_S_PAUSE_ENC_RSP_WAIT;
-        }
-        break;
+	case BLE_LL_CTRL_START_ENC_RSP:
+		if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
+			connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
+			if (connsm->flags.le_ping_supp) {
+				ble_ll_conn_auth_pyld_timer_start(connsm);
+			}
+		}
+		break;
+	case BLE_LL_CTRL_PAUSE_ENC_RSP:
+		if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
+			connsm->enc_data.enc_state = CONN_ENC_S_PAUSE_ENC_RSP_WAIT;
+		}
+		break;
 #endif
 #endif
 #if MYNEWT_VAL(BLE_LL_PHY)
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    case BLE_LL_CTRL_PHY_REQ:
-        if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-            connsm->phy_tx_transition =
-                    ble_ll_ctrl_phy_tx_transition_get(
-                            connsm->phy_data.pref_mask_tx_req);
-        }
-        break;
-#endif
-    case BLE_LL_CTRL_PHY_UPDATE_IND:
-        connsm->phy_tx_transition =
-                    ble_ll_ctrl_phy_tx_transition_get(txpdu->om_data[2]);
-        break;
+	case BLE_LL_CTRL_PHY_REQ:
+		if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
+			connsm->phy_tx_transition =
+				ble_ll_ctrl_phy_tx_transition_get(connsm->phy_data.pref_mask_tx_req);
+		}
+		break;
+#endif
+	case BLE_LL_CTRL_PHY_UPDATE_IND:
+		connsm->phy_tx_transition = ble_ll_ctrl_phy_tx_transition_get(txpdu->om_data[2]);
+		break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    case BLE_LL_CTRL_SUBRATE_IND:
-        connsm->flags.subrate_trans = 0;
-        connsm->flags.subrate_ind_txd = 1;
-        break;
+	case BLE_LL_CTRL_SUBRATE_IND:
+		connsm->flags.subrate_trans = 0;
+		connsm->flags.subrate_ind_txd = 1;
+		break;
 #endif /* BLE_LL_CTRL_SUBRATE_IND */
 #endif /* BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE */
-    default:
-        break;
-    }
+	default:
+		break;
+	}
 
-    os_mbuf_free_chain(txpdu);
-    return rc;
+	os_mbuf_free_chain(txpdu);
+	return rc;
 }
 
-void
-ble_ll_ctrl_init_conn_sm(struct ble_ll_conn_sm *connsm)
+void ble_ll_ctrl_init_conn_sm(struct ble_ll_conn_sm *connsm)
 {
-    ble_npl_callout_init(&connsm->ctrl_proc_rsp_timer, &g_ble_ll_data.ll_evq,
-                         ble_ll_ctrl_proc_rsp_timer_cb, connsm);
+	ble_npl_callout_init(&connsm->ctrl_proc_rsp_timer, &g_ble_ll_data.ll_evq,
+	                     ble_ll_ctrl_proc_rsp_timer_cb, connsm);
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
-    ble_npl_callout_init(&connsm->auth_pyld_timer, &g_ble_ll_data.ll_evq,
-                         ble_ll_conn_auth_pyld_timer_cb, connsm);
+	ble_npl_callout_init(&connsm->auth_pyld_timer, &g_ble_ll_data.ll_evq,
+	                     ble_ll_conn_auth_pyld_timer_cb, connsm);
 #endif
 }
 #endif
diff --git a/nimble/host/include/host/ble_store.h b/nimble/host/include/host/ble_store.h
index 83b1c4f1..82625eea 100644
--- a/nimble/host/include/host/ble_store.h
+++ b/nimble/host/include/host/ble_store.h
@@ -40,13 +40,13 @@ extern "C" {
  * @{
  */
 /** Object type: Our security material. */
-#define BLE_STORE_OBJ_TYPE_OUR_SEC      1
+#define BLE_STORE_OBJ_TYPE_OUR_SEC 1
 
 /** Object type: Peer security material. */
-#define BLE_STORE_OBJ_TYPE_PEER_SEC     2
+#define BLE_STORE_OBJ_TYPE_PEER_SEC 2
 
 /** Object type: Client Characteristic Configuration Descriptor. */
-#define BLE_STORE_OBJ_TYPE_CCCD         3
+#define BLE_STORE_OBJ_TYPE_CCCD 3
 
 /** @} */
 
@@ -56,10 +56,10 @@ extern "C" {
  * @{
  */
 /** Failed to persist record; insufficient storage capacity. */
-#define BLE_STORE_EVENT_OVERFLOW        1
+#define BLE_STORE_EVENT_OVERFLOW 1
 
 /** About to execute a procedure that may fail due to overflow. */
-#define BLE_STORE_EVENT_FULL            2
+#define BLE_STORE_EVENT_FULL 2
 
 /** @} */
 
@@ -70,14 +70,14 @@ extern "C" {
  *     o BLE_STORE_OBJ_TYPE_PEER_SEC
  */
 struct ble_store_key_sec {
-    /**
-     * Key by peer identity address;
-     * peer_addr=BLE_ADDR_NONE means don't key off peer.
-     */
-    ble_addr_t peer_addr;
-
-    /** Number of results to skip; 0 means retrieve the first match. */
-    uint8_t idx;
+	/**
+	 * Key by peer identity address;
+	 * peer_addr=BLE_ADDR_NONE means don't key off peer.
+	 */
+	ble_addr_t peer_addr;
+
+	/** Number of results to skip; 0 means retrieve the first match. */
+	uint8_t idx;
 };
 
 /**
@@ -87,34 +87,38 @@ struct ble_store_key_sec {
  *     o BLE_STORE_OBJ_TYPE_PEER_SEC
  */
 struct ble_store_value_sec {
-    /** Peer address for which the security material is stored. */
-    ble_addr_t peer_addr;
-
-    /** Encryption key size. */
-    uint8_t key_size;
-    /** Encrypted Diversifier used for encryption key generation. */
-    uint16_t ediv;
-    /** Random number used for encryption key generation. */
-    uint64_t rand_num;
-    /** Long Term Key. */
-    uint8_t ltk[16];
-    /** Flag indicating whether Long Term Key is present. */
-    uint8_t ltk_present:1;
-
-    /** Identity Resolving Key. */
-    uint8_t irk[16];
-    /** Flag indicating whether Identity Resolving Key is present. */
-    uint8_t irk_present:1;
-
-    /** Connection Signature Resolving Key. */
-    uint8_t csrk[16];
-    /** Flag indicating if Connection Signature Resolving Key is present. */
-    uint8_t csrk_present:1;
-
-    /** Flag indicating whether the connection is authenticated. */
-    unsigned authenticated:1;
-    /** Flag indicating Secure Connections support. */
-    uint8_t sc:1;
+	/** Peer address for which the security material is stored. */
+	ble_addr_t peer_addr;
+
+	/** Encryption key size. */
+	uint8_t key_size;
+	/** Encrypted Diversifier used for encryption key generation. */
+	uint16_t ediv;
+	/** Random number used for encryption key generation. */
+	uint64_t rand_num;
+	/** Long Term Key. */
+	uint8_t ltk[16];
+	/** Flag indicating whether Long Term Key is present. */
+	uint8_t ltk_present : 1;
+
+	/** Identity Resolving Key. */
+	uint8_t irk[16];
+	/** Flag indicating whether Identity Resolving Key is present. */
+	uint8_t irk_present : 1;
+
+	/** Connection Signature Resolving Key. */
+	uint8_t csrk[16];
+	/** Flag indicating if Connection Signature Resolving Key is present. */
+	uint8_t csrk_present : 1;
+
+	/** Flag indicating whether the connection is authenticated. */
+	unsigned authenticated : 1;
+	/** Flag indicating Secure Connections support. */
+	uint8_t sc : 1;
+
+	uint8_t authreq : 1;
+
+	uint8_t rep : 1;
 };
 
 /**
@@ -123,20 +127,20 @@ struct ble_store_value_sec {
  * store object type.
  */
 struct ble_store_key_cccd {
-    /**
-     * Key by peer identity address;
-     * peer_addr=BLE_ADDR_NONE means don't key off peer.
-     */
-    ble_addr_t peer_addr;
-
-    /**
-     * Key by characteristic value handle;
-     * chr_val_handle=0 means don't key off characteristic handle.
-     */
-    uint16_t chr_val_handle;
-
-    /** Number of results to skip; 0 means retrieve the first match. */
-    uint8_t idx;
+	/**
+	 * Key by peer identity address;
+	 * peer_addr=BLE_ADDR_NONE means don't key off peer.
+	 */
+	ble_addr_t peer_addr;
+
+	/**
+	 * Key by characteristic value handle;
+	 * chr_val_handle=0 means don't key off characteristic handle.
+	 */
+	uint16_t chr_val_handle;
+
+	/** Number of results to skip; 0 means retrieve the first match. */
+	uint8_t idx;
 };
 
 /**
@@ -144,14 +148,14 @@ struct ble_store_key_cccd {
  * This struct corresponds to the BLE_STORE_OBJ_TYPE_CCCD store object type.
  */
 struct ble_store_value_cccd {
-    /** The peer address associated with the stored CCCD. */
-    ble_addr_t peer_addr;
-    /** The handle of the characteristic value. */
-    uint16_t chr_val_handle;
-    /** Flags associated with the CCCD. */
-    uint16_t flags;
-    /** Flag indicating whether the value has changed. */
-    unsigned value_changed:1;
+	/** The peer address associated with the stored CCCD. */
+	ble_addr_t peer_addr;
+	/** The handle of the characteristic value. */
+	uint16_t chr_val_handle;
+	/** Flags associated with the CCCD. */
+	uint16_t flags;
+	/** Flag indicating whether the value has changed. */
+	unsigned value_changed : 1;
 };
 
 /**
@@ -159,10 +163,10 @@ struct ble_store_value_cccd {
  * object type code to indicate which field is valid.
  */
 union ble_store_key {
-    /** Key for security material store lookups. */
-    struct ble_store_key_sec sec;
-    /** Key for Client Characteristic Configuration Descriptor store lookups. */
-    struct ble_store_key_cccd cccd;
+	/** Key for security material store lookups. */
+	struct ble_store_key_sec sec;
+	/** Key for Client Characteristic Configuration Descriptor store lookups. */
+	struct ble_store_key_cccd cccd;
 };
 
 /**
@@ -170,74 +174,74 @@ union ble_store_key {
  * code to indicate which field is valid.
  */
 union ble_store_value {
-    /** Stored security material. */
-    struct ble_store_value_sec sec;
-    /** Stored Client Characteristic Configuration Descriptor. */
-    struct ble_store_value_cccd cccd;
+	/** Stored security material. */
+	struct ble_store_value_sec sec;
+	/** Stored Client Characteristic Configuration Descriptor. */
+	struct ble_store_value_cccd cccd;
 };
 
 /** Represents an event associated with the BLE Store. */
 struct ble_store_status_event {
-    /**
-     * The type of event being reported; one of the BLE_STORE_EVENT_TYPE_[...]
-     * codes.
-     */
-    int event_code;
-
-    /**
-     * Additional data related to the event; the valid field is inferred from
-     * the obj_type,event_code pair.
-     */
-    union {
-        /**
-         * Represents a write that failed due to storage exhaustion.  Valid for
-         * the following event types:
-         *     o BLE_STORE_EVENT_OVERFLOW
-         */
-        struct {
-            /** The type of object that failed to be written. */
-            int obj_type;
-
-            /** The object that failed to be written. */
-            const union ble_store_value *value;
-        } overflow;
-
-        /**
-         * Represents the possibility that a scheduled write will fail due to
-         * storage exhaustion.  Valid for the following event types:
-         *     o BLE_STORE_EVENT_FULL
-         */
-        struct {
-            /** The type of object that may fail to be written. */
-            int obj_type;
-
-            /** The handle of the connection which prompted the write. */
-            uint16_t conn_handle;
-        } full;
-    };
+	/**
+	 * The type of event being reported; one of the BLE_STORE_EVENT_TYPE_[...]
+	 * codes.
+	 */
+	int event_code;
+
+	/**
+	 * Additional data related to the event; the valid field is inferred from
+	 * the obj_type,event_code pair.
+	 */
+	union {
+		/**
+		 * Represents a write that failed due to storage exhaustion.  Valid for
+		 * the following event types:
+		 *     o BLE_STORE_EVENT_OVERFLOW
+		 */
+		struct {
+			/** The type of object that failed to be written. */
+			int obj_type;
+
+			/** The object that failed to be written. */
+			const union ble_store_value *value;
+		} overflow;
+
+		/**
+		 * Represents the possibility that a scheduled write will fail due to
+		 * storage exhaustion.  Valid for the following event types:
+		 *     o BLE_STORE_EVENT_FULL
+		 */
+		struct {
+			/** The type of object that may fail to be written. */
+			int obj_type;
+
+			/** The handle of the connection which prompted the write. */
+			uint16_t conn_handle;
+		} full;
+	};
 };
 
 /** Generate LTK, EDIT and Rand. */
-#define BLE_STORE_GEN_KEY_LTK       0x01
+#define BLE_STORE_GEN_KEY_LTK 0x01
 /** Generate IRK. */
-#define BLE_STORE_GEN_KEY_IRK       0x02
+#define BLE_STORE_GEN_KEY_IRK 0x02
 /** Generate CSRK. */
-#define BLE_STORE_GEN_KEY_CSRK      0x03
+#define BLE_STORE_GEN_KEY_CSRK 0x03
 
 /** Represents a storage for generated key. */
 struct ble_store_gen_key {
-    union {
-        /** Long Term Key (LTK) for peripheral role. */
-        uint8_t ltk_periph[16];
-        /** Identity Resolving Key (IRK). */
-        uint8_t irk[16];
-        /** Connection Signature Resolving Key (CSRK). */
-        uint8_t csrk[16];
-    };
-    /** Encrypted Diversifier (EDIV). */
-    uint16_t ediv;
-    /** Random Number for key generation. */
-    uint64_t rand;
+	union {
+		/** Long Term Key (LTK) for peripheral role. */
+		uint8_t ltk_periph[16];
+		/** Identity Resolving Key (IRK). */
+		uint8_t irk[16];
+		/** Connection Signature Resolving Key (CSRK). */
+		uint8_t csrk[16];
+	};
+	/** Encrypted Diversifier (EDIV). */
+	uint16_t ediv;
+	/** Random Number for key generation. */
+	uint64_t rand;
 };
 
 /**
@@ -255,8 +259,7 @@ struct ble_store_gen_key {
  * @return                      0 if keys were generated successfully
  *                              Other nonzero on error.
  */
-typedef int ble_store_gen_key_fn(uint8_t key,
-                                 struct ble_store_gen_key *gen_key,
+typedef int ble_store_gen_key_fn(uint8_t key, struct ble_store_gen_key *gen_key,
                                  uint16_t conn_handle);
 
 /**
@@ -323,8 +326,7 @@ typedef int ble_store_delete_fn(int obj_type, const union ble_store_key *key);
  *                              nonzero if the store operation should be
  *                                  aborted.
  */
-typedef int ble_store_status_fn(struct ble_store_status_event *event,
-                                void *arg);
+typedef int ble_store_status_fn(struct ble_store_status_event *event, void *arg);
 
 /**
  * Reads data from a storage.
@@ -602,8 +604,7 @@ void ble_store_key_from_value_cccd(struct ble_store_key_cccd *out_key,
  *                                  containing the value from which the key will
  *                                  be generated.
  */
-void ble_store_key_from_value(int obj_type,
-                              union ble_store_key *out_key,
+void ble_store_key_from_value(int obj_type, union ble_store_key *out_key,
                               const union ble_store_value *value);
 
 
@@ -620,8 +621,7 @@ void ble_store_key_from_value(int obj_type,
  * @return                      0 to continue iterating;
  *                              Non-zero value to stop the iteration.
  */
-typedef int ble_store_iterator_fn(int obj_type,
-                                  union ble_store_value *val,
+typedef int ble_store_iterator_fn(int obj_type, union ble_store_value *val,
                                   void *cookie);
 
 
@@ -640,9 +640,7 @@ typedef int ble_store_iterator_fn(int obj_type,
  * @return                      0 on success;
  *                              Non-zero on error.
  */
-int ble_store_iterate(int obj_type,
-                      ble_store_iterator_fn *callback,
-                      void *cookie);
+int ble_store_iterate(int obj_type, ble_store_iterator_fn *callback, void *cookie);
 
 
 /**
@@ -673,8 +671,7 @@ int ble_store_clear(void);
  *                                  small;
  *                              Other non-zero on error.
  */
-int ble_store_util_bonded_peers(ble_addr_t *out_peer_id_addrs,
-                                int *out_num_peers,
+int ble_store_util_bonded_peers(ble_addr_t *out_peer_id_addrs, int *out_num_peers,
                                 int max_peers);
 
 /**
diff --git a/nimble/host/services/gap/include/services/gap/ble_svc_gap.h b/nimble/host/services/gap/include/services/gap/ble_svc_gap.h
index 707a3bd0..da6552ea 100644
--- a/nimble/host/services/gap/include/services/gap/ble_svc_gap.h
+++ b/nimble/host/services/gap/include/services/gap/ble_svc_gap.h
@@ -23,30 +23,34 @@
 #include <inttypes.h>
 
 #ifdef __cplusplus
-extern "C" {
+extern "C"
+{
 #endif
 
-#define BLE_SVC_GAP_UUID16                                  0x1800
-#define BLE_SVC_GAP_CHR_UUID16_DEVICE_NAME                  0x2a00
-#define BLE_SVC_GAP_CHR_UUID16_APPEARANCE                   0x2a01
-#define BLE_SVC_GAP_CHR_UUID16_PERIPH_PREF_CONN_PARAMS      0x2a04
-#define BLE_SVC_GAP_CHR_UUID16_CENTRAL_ADDRESS_RESOLUTION   0x2aa6
+#define BLE_SVC_GAP_UUID16 0x1800
+#define BLE_SVC_GAP_CHR_UUID16_DEVICE_NAME 0x2a00
+#define BLE_SVC_GAP_CHR_UUID16_APPEARANCE 0x2a01
+#define BLE_SVC_GAP_CHR_UUID16_PERIPH_PREF_CONN_PARAMS 0x2a04
+#define BLE_SVC_GAP_CHR_UUID16_CENTRAL_ADDRESS_RESOLUTION 0x2aa6
 
-#define BLE_SVC_GAP_APPEARANCE_GEN_UNKNOWN                         0
-#define BLE_SVC_GAP_APPEARANCE_GEN_COMPUTER                        128
-#define BLE_SVC_GAP_APPEARANCE_GEN_HID                             960
-#define BLE_SVC_GAP_APPEARANCE_CYC_SPEED_AND_CADENCE_SENSOR        1157
+#define BLE_SVC_GAP_APPEARANCE_GEN_UNKNOWN 0
+#define BLE_SVC_GAP_APPEARANCE_GEN_COMPUTER 128
+#define BLE_SVC_GAP_APPEARANCE_GEN_HID 960
+#define BLE_SVC_GAP_APPEARANCE_KEYBOARD 961
+#define BLE_SVC_GAP_APPEARANCE_MOUSE 962
+#define BLE_SVC_GAP_APPEARANCE_CYC_SPEED_AND_CADENCE_SENSOR 1157
+    // #define BLE_SVC_GAP_APPEARANCE_RUNNING_SPEED_AND_CADENCE_SENSOR 0x1814
 
-typedef void (ble_svc_gap_chr_changed_fn) (uint16_t uuid);
+    typedef void(ble_svc_gap_chr_changed_fn)(uint16_t uuid);
 
-void ble_svc_gap_set_chr_changed_cb(ble_svc_gap_chr_changed_fn *cb);
+    void ble_svc_gap_set_chr_changed_cb(ble_svc_gap_chr_changed_fn *cb);
 
-const char *ble_svc_gap_device_name(void);
-int ble_svc_gap_device_name_set(const char *name);
-uint16_t ble_svc_gap_device_appearance(void);
-int ble_svc_gap_device_appearance_set(uint16_t appearance);
+    const char *ble_svc_gap_device_name(void);
+    int ble_svc_gap_device_name_set(const char *name);
+    uint16_t ble_svc_gap_device_appearance(void);
+    int ble_svc_gap_device_appearance_set(uint16_t appearance);
 
-void ble_svc_gap_init(void);
+    void ble_svc_gap_init(void);
 
 #ifdef __cplusplus
 }
diff --git a/nimble/host/src/ble_gap.c b/nimble/host/src/ble_gap.c
index b935efac..cedfa03a 100644
--- a/nimble/host/src/ble_gap.c
+++ b/nimble/host/src/ble_gap.c
@@ -41,7 +41,7 @@
 #define bssnz_t
 #endif
 
-#define SET_BIT(t, n)  (t |= 1UL << (n))
+#define SET_BIT(t, n) (t |= 1UL << (n))
 
 /**
  * GAP - Generic Access Profile.
@@ -86,31 +86,31 @@
  */
 
 /** GAP procedure op codes. */
-#define BLE_GAP_OP_NULL             0
-#define BLE_GAP_OP_M_DISC           1
-#define BLE_GAP_OP_M_CONN           2
-#define BLE_GAP_OP_S_ADV            1
-#define BLE_GAP_OP_S_PERIODIC_ADV   2
-#define BLE_GAP_OP_SYNC             1
+#define BLE_GAP_OP_NULL 0
+#define BLE_GAP_OP_M_DISC 1
+#define BLE_GAP_OP_M_CONN 2
+#define BLE_GAP_OP_S_ADV 1
+#define BLE_GAP_OP_S_PERIODIC_ADV 2
+#define BLE_GAP_OP_SYNC 1
 
 /**
  * If an attempt to cancel an active procedure fails, the attempt is retried
  * at this rate (ms).
  */
-#define BLE_GAP_CANCEL_RETRY_TIMEOUT_MS         100 /* ms */
+#define BLE_GAP_CANCEL_RETRY_TIMEOUT_MS 100 /* ms */
 
-#define BLE_GAP_UPDATE_TIMEOUT_MS               40000 /* ms */
+#define BLE_GAP_UPDATE_TIMEOUT_MS 40000 /* ms */
 
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
 static const struct ble_gap_conn_params ble_gap_conn_params_dflt = {
-    .scan_itvl = 0x0010,
-    .scan_window = 0x0010,
-    .itvl_min = BLE_GAP_INITIAL_CONN_ITVL_MIN,
-    .itvl_max = BLE_GAP_INITIAL_CONN_ITVL_MAX,
-    .latency = BLE_GAP_INITIAL_CONN_LATENCY,
-    .supervision_timeout = BLE_GAP_INITIAL_SUPERVISION_TIMEOUT,
-    .min_ce_len = BLE_GAP_INITIAL_CONN_MIN_CE_LEN,
-    .max_ce_len = BLE_GAP_INITIAL_CONN_MAX_CE_LEN,
+	.scan_itvl = 0x0010,
+	.scan_window = 0x0010,
+	.itvl_min = BLE_GAP_INITIAL_CONN_ITVL_MIN,
+	.itvl_max = BLE_GAP_INITIAL_CONN_ITVL_MAX,
+	.latency = BLE_GAP_INITIAL_CONN_LATENCY,
+	.supervision_timeout = BLE_GAP_INITIAL_SUPERVISION_TIMEOUT,
+	.min_ce_len = BLE_GAP_INITIAL_CONN_MIN_CE_LEN,
+	.max_ce_len = BLE_GAP_INITIAL_CONN_MAX_CE_LEN,
 };
 #endif
 
@@ -119,35 +119,35 @@ static const struct ble_gap_conn_params ble_gap_conn_params_dflt = {
  * currently in progress, then the op field is set to BLE_GAP_OP_NULL.
  */
 struct ble_gap_master_state {
-    uint8_t op;
+	uint8_t op;
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    /* indicates if discovery was started with legacy API */
-    uint8_t legacy_discovery;
-#endif
-    uint8_t exp_set:1;
-    ble_npl_time_t exp_os_ticks;
-
-    ble_gap_event_fn *cb;
-    void *cb_arg;
-
-    /**
-     * Indicates the type of master procedure that was preempted, or
-     * BLE_GAP_OP_NULL if no procedure was preempted.
-     */
-    uint8_t preempted_op;
-
-    union {
-        struct {
-            uint8_t using_wl:1;
-            uint8_t our_addr_type:2;
-            uint8_t cancel:1;
-        } conn;
-
-        struct {
-            uint8_t limited:1;
-        } disc;
-    };
+	/* indicates if discovery was started with legacy API */
+	uint8_t legacy_discovery;
+#endif
+	uint8_t exp_set : 1;
+	ble_npl_time_t exp_os_ticks;
+
+	ble_gap_event_fn *cb;
+	void *cb_arg;
+
+	/**
+	 * Indicates the type of master procedure that was preempted, or
+	 * BLE_GAP_OP_NULL if no procedure was preempted.
+	 */
+	uint8_t preempted_op;
+
+	union {
+		struct {
+			uint8_t using_wl      : 1;
+			uint8_t our_addr_type : 2;
+			uint8_t cancel        : 1;
+		} conn;
+
+		struct {
+			uint8_t limited : 1;
+		} disc;
+	};
 };
 static bssnz_t struct ble_gap_master_state ble_gap_master;
 
@@ -157,11 +157,11 @@ static bssnz_t struct ble_gap_master_state ble_gap_master;
  * currently in progress, then the op field is set to BLE_GAP_OP_NULL.
  */
 struct ble_gap_sync_state {
-    uint8_t op;
-    struct ble_hs_periodic_sync *psync;
+	uint8_t op;
+	struct ble_hs_periodic_sync *psync;
 
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
 };
 
 static bssnz_t struct ble_gap_sync_state ble_gap_sync;
@@ -172,70 +172,67 @@ static bssnz_t struct ble_gap_sync_state ble_gap_sync;
  * currently in progress, then the op field is set to BLE_GAP_OP_NULL.
  */
 struct ble_gap_slave_state {
-    uint8_t op;
+	uint8_t op;
 
-    unsigned int our_addr_type:2;
-    unsigned int preempted:1;  /** Set to 1 if advertising was preempted. */
-    unsigned int connectable:1;
+	unsigned int our_addr_type : 2;
+	unsigned int preempted     : 1; /** Set to 1 if advertising was preempted. */
+	unsigned int connectable   : 1;
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    unsigned int configured:1; /** If instance is configured */
-    unsigned int scannable:1;
-    unsigned int directed:1;
-    unsigned int high_duty_directed:1;
-    unsigned int legacy_pdu:1;
-    unsigned int rnd_addr_set:1;
+	unsigned int configured         : 1; /** If instance is configured */
+	unsigned int scannable          : 1;
+	unsigned int directed           : 1;
+	unsigned int high_duty_directed : 1;
+	unsigned int legacy_pdu         : 1;
+	unsigned int rnd_addr_set       : 1;
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-    unsigned int periodic_configured:1;
-    uint8_t      periodic_op;
+	unsigned int periodic_configured : 1;
+	uint8_t periodic_op;
 #endif
-    uint8_t rnd_addr[6];
+	uint8_t rnd_addr[6];
 #else
-/* timer is used only with legacy advertising */
-    unsigned int exp_set:1;
-    ble_npl_time_t exp_os_ticks;
+	/* timer is used only with legacy advertising */
+	unsigned int exp_set : 1;
+	ble_npl_time_t exp_os_ticks;
 #endif
 
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
 };
 
 static bssnz_t struct ble_gap_slave_state ble_gap_slave[BLE_ADV_INSTANCES];
 
 struct ble_gap_update_entry {
-    SLIST_ENTRY(ble_gap_update_entry) next;
-    struct ble_gap_upd_params params;
-    ble_npl_time_t exp_os_ticks;
-    uint16_t conn_handle;
+	SLIST_ENTRY(ble_gap_update_entry)
+	next;
+	struct ble_gap_upd_params params;
+	ble_npl_time_t exp_os_ticks;
+	uint16_t conn_handle;
 };
 SLIST_HEAD(ble_gap_update_entry_list, ble_gap_update_entry);
 
 struct ble_gap_snapshot {
-    struct ble_gap_conn_desc *desc;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+	struct ble_gap_conn_desc *desc;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
 };
 
 static SLIST_HEAD(ble_gap_hook_list, ble_gap_event_listener) ble_gap_event_listener_list;
-static os_membuf_t ble_gap_update_entry_mem[
-                        OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE),
-                                        sizeof (struct ble_gap_update_entry))];
+static os_membuf_t ble_gap_update_entry_mem[OS_MEMPOOL_SIZE(
+	MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE), sizeof(struct ble_gap_update_entry))];
 static struct os_mempool ble_gap_update_entry_pool;
 static struct ble_gap_update_entry_list ble_gap_update_entries;
 
 static void ble_gap_update_entry_free(struct ble_gap_update_entry *entry);
 
 #if NIMBLE_BLE_CONNECT
-static struct ble_gap_update_entry *
-ble_gap_update_entry_find(uint16_t conn_handle,
-                          struct ble_gap_update_entry **out_prev);
+static struct ble_gap_update_entry *ble_gap_update_entry_find(
+	uint16_t conn_handle, struct ble_gap_update_entry **out_prev);
 
-static void
-ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void *arg);
+static void ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void *arg);
 #endif
 
-static struct ble_gap_update_entry *
-ble_gap_update_entry_remove(uint16_t conn_handle);
+static struct ble_gap_update_entry *ble_gap_update_entry_remove(uint16_t conn_handle);
 
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
 static int ble_gap_adv_enable_tx(int enable);
@@ -249,39 +246,40 @@ static int ble_gap_conn_cancel_tx(void);
 static int ble_gap_disc_enable_tx(int enable, int filter_duplicates);
 #endif
 
-STATS_SECT_DECL(ble_gap_stats) ble_gap_stats;
+STATS_SECT_DECL(ble_gap_stats)
+ble_gap_stats;
 STATS_NAME_START(ble_gap_stats)
-    STATS_NAME(ble_gap_stats, wl_set)
-    STATS_NAME(ble_gap_stats, wl_set_fail)
-    STATS_NAME(ble_gap_stats, adv_stop)
-    STATS_NAME(ble_gap_stats, adv_stop_fail)
-    STATS_NAME(ble_gap_stats, adv_start)
-    STATS_NAME(ble_gap_stats, adv_start_fail)
-    STATS_NAME(ble_gap_stats, adv_set_data)
-    STATS_NAME(ble_gap_stats, adv_set_data_fail)
-    STATS_NAME(ble_gap_stats, adv_rsp_set_data)
-    STATS_NAME(ble_gap_stats, adv_rsp_set_data_fail)
-    STATS_NAME(ble_gap_stats, discover)
-    STATS_NAME(ble_gap_stats, discover_fail)
-    STATS_NAME(ble_gap_stats, initiate)
-    STATS_NAME(ble_gap_stats, initiate_fail)
-    STATS_NAME(ble_gap_stats, terminate)
-    STATS_NAME(ble_gap_stats, terminate_fail)
-    STATS_NAME(ble_gap_stats, cancel)
-    STATS_NAME(ble_gap_stats, cancel_fail)
-    STATS_NAME(ble_gap_stats, update)
-    STATS_NAME(ble_gap_stats, update_fail)
-    STATS_NAME(ble_gap_stats, connect_mst)
-    STATS_NAME(ble_gap_stats, connect_slv)
-    STATS_NAME(ble_gap_stats, disconnect)
-    STATS_NAME(ble_gap_stats, rx_disconnect)
-    STATS_NAME(ble_gap_stats, rx_update_complete)
-    STATS_NAME(ble_gap_stats, rx_adv_report)
-    STATS_NAME(ble_gap_stats, rx_conn_complete)
-    STATS_NAME(ble_gap_stats, discover_cancel)
-    STATS_NAME(ble_gap_stats, discover_cancel_fail)
-    STATS_NAME(ble_gap_stats, security_initiate)
-    STATS_NAME(ble_gap_stats, security_initiate_fail)
+STATS_NAME(ble_gap_stats, wl_set)
+STATS_NAME(ble_gap_stats, wl_set_fail)
+STATS_NAME(ble_gap_stats, adv_stop)
+STATS_NAME(ble_gap_stats, adv_stop_fail)
+STATS_NAME(ble_gap_stats, adv_start)
+STATS_NAME(ble_gap_stats, adv_start_fail)
+STATS_NAME(ble_gap_stats, adv_set_data)
+STATS_NAME(ble_gap_stats, adv_set_data_fail)
+STATS_NAME(ble_gap_stats, adv_rsp_set_data)
+STATS_NAME(ble_gap_stats, adv_rsp_set_data_fail)
+STATS_NAME(ble_gap_stats, discover)
+STATS_NAME(ble_gap_stats, discover_fail)
+STATS_NAME(ble_gap_stats, initiate)
+STATS_NAME(ble_gap_stats, initiate_fail)
+STATS_NAME(ble_gap_stats, terminate)
+STATS_NAME(ble_gap_stats, terminate_fail)
+STATS_NAME(ble_gap_stats, cancel)
+STATS_NAME(ble_gap_stats, cancel_fail)
+STATS_NAME(ble_gap_stats, update)
+STATS_NAME(ble_gap_stats, update_fail)
+STATS_NAME(ble_gap_stats, connect_mst)
+STATS_NAME(ble_gap_stats, connect_slv)
+STATS_NAME(ble_gap_stats, disconnect)
+STATS_NAME(ble_gap_stats, rx_disconnect)
+STATS_NAME(ble_gap_stats, rx_update_complete)
+STATS_NAME(ble_gap_stats, rx_adv_report)
+STATS_NAME(ble_gap_stats, rx_conn_complete)
+STATS_NAME(ble_gap_stats, discover_cancel)
+STATS_NAME(ble_gap_stats, discover_cancel_fail)
+STATS_NAME(ble_gap_stats, security_initiate)
+STATS_NAME(ble_gap_stats, security_initiate_fail)
 STATS_NAME_END(ble_gap_stats)
 
 /*****************************************************************************
@@ -289,16 +287,15 @@ STATS_NAME_END(ble_gap_stats)
  *****************************************************************************/
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-int
-ble_gap_dbg_update_active(uint16_t conn_handle)
+int ble_gap_dbg_update_active(uint16_t conn_handle)
 {
-    const struct ble_gap_update_entry *entry;
+	const struct ble_gap_update_entry *entry;
 
-    ble_hs_lock();
-    entry = ble_gap_update_entry_find(conn_handle, NULL);
-    ble_hs_unlock();
+	ble_hs_lock();
+	entry = ble_gap_update_entry_find(conn_handle, NULL);
+	ble_hs_unlock();
 
-    return entry != NULL;
+	return entry != NULL;
 }
 #endif
 
@@ -307,97 +304,91 @@ ble_gap_dbg_update_active(uint16_t conn_handle)
  *****************************************************************************/
 
 #if NIMBLE_BLE_SCAN && !MYNEWT_VAL(BLE_EXT_ADV)
-static void
-ble_gap_log_duration(int32_t duration_ms)
+static void ble_gap_log_duration(int32_t duration_ms)
 {
-    if (duration_ms == BLE_HS_FOREVER) {
-        BLE_HS_LOG(INFO, "duration=forever");
-    } else {
-        BLE_HS_LOG(INFO, "duration=%dms", duration_ms);
-    }
+	if (duration_ms == BLE_HS_FOREVER) {
+		BLE_HS_LOG(INFO, "duration=forever");
+	}
+	else {
+		BLE_HS_LOG(INFO, "duration=%dms", duration_ms);
+	}
 }
 #endif
 
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) && !MYNEWT_VAL(BLE_EXT_ADV)
-static void
-ble_gap_log_conn(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                 const struct ble_gap_conn_params *params)
+static void ble_gap_log_conn(uint8_t own_addr_type, const ble_addr_t *peer_addr,
+                             const struct ble_gap_conn_params *params)
 {
-    if (peer_addr != NULL) {
-        BLE_HS_LOG(INFO, "peer_addr_type=%d peer_addr=", peer_addr->type);
-        BLE_HS_LOG_ADDR(INFO, peer_addr->val);
-    }
+	if (peer_addr != NULL) {
+		BLE_HS_LOG(INFO, "peer_addr_type=%d peer_addr=", peer_addr->type);
+		BLE_HS_LOG_ADDR(INFO, peer_addr->val);
+	}
 
-    BLE_HS_LOG(INFO, " scan_itvl=%d scan_window=%d itvl_min=%d itvl_max=%d "
-                     "latency=%d supervision_timeout=%d min_ce_len=%d "
-                     "max_ce_len=%d own_addr_type=%d",
-               params->scan_itvl, params->scan_window, params->itvl_min,
-               params->itvl_max, params->latency, params->supervision_timeout,
-               params->min_ce_len, params->max_ce_len, own_addr_type);
+	BLE_HS_LOG(INFO,
+	           " scan_itvl=%d scan_window=%d itvl_min=%d itvl_max=%d "
+	           "latency=%d supervision_timeout=%d min_ce_len=%d "
+	           "max_ce_len=%d own_addr_type=%d",
+	           params->scan_itvl, params->scan_window, params->itvl_min,
+	           params->itvl_max, params->latency, params->supervision_timeout,
+	           params->min_ce_len, params->max_ce_len, own_addr_type);
 }
 #endif
 
 #if NIMBLE_BLE_SCAN && !MYNEWT_VAL(BLE_EXT_ADV)
-static void
-ble_gap_log_disc(uint8_t own_addr_type, int32_t duration_ms,
-                 const struct ble_gap_disc_params *disc_params)
+static void ble_gap_log_disc(uint8_t own_addr_type, int32_t duration_ms,
+                             const struct ble_gap_disc_params *disc_params)
 {
-    BLE_HS_LOG(INFO, "own_addr_type=%d filter_policy=%d passive=%d limited=%d "
-                     "filter_duplicates=%d ",
-               own_addr_type, disc_params->filter_policy, disc_params->passive,
-               disc_params->limited, disc_params->filter_duplicates);
-    ble_gap_log_duration(duration_ms);
+	BLE_HS_LOG(INFO,
+	           "own_addr_type=%d filter_policy=%d passive=%d limited=%d "
+	           "filter_duplicates=%d ",
+	           own_addr_type, disc_params->filter_policy, disc_params->passive,
+	           disc_params->limited, disc_params->filter_duplicates);
+	ble_gap_log_duration(duration_ms);
 }
 #endif
 
 #if NIMBLE_BLE_CONNECT
-static void
-ble_gap_log_update(uint16_t conn_handle,
-                   const struct ble_gap_upd_params *params)
+static void ble_gap_log_update(uint16_t conn_handle,
+                               const struct ble_gap_upd_params *params)
 {
-    BLE_HS_LOG(INFO, "connection parameter update; "
-                     "conn_handle=%d itvl_min=%d itvl_max=%d latency=%d "
-                     "supervision_timeout=%d min_ce_len=%d max_ce_len=%d",
-               conn_handle, params->itvl_min, params->itvl_max,
-               params->latency, params->supervision_timeout,
-               params->min_ce_len, params->max_ce_len);
+	BLE_HS_LOG(INFO,
+	           "connection parameter update; "
+	           "conn_handle=%d itvl_min=%d itvl_max=%d latency=%d "
+	           "supervision_timeout=%d min_ce_len=%d max_ce_len=%d",
+	           conn_handle, params->itvl_min, params->itvl_max, params->latency,
+	           params->supervision_timeout, params->min_ce_len, params->max_ce_len);
 }
 #endif
 
 #if MYNEWT_VAL(BLE_WHITELIST)
-static void
-ble_gap_log_wl(const ble_addr_t *addr, uint8_t white_list_count)
+static void ble_gap_log_wl(const ble_addr_t *addr, uint8_t white_list_count)
 {
-    int i;
+	int i;
 
-    BLE_HS_LOG(INFO, "count=%d ", white_list_count);
+	BLE_HS_LOG(INFO, "count=%d ", white_list_count);
 
-    for (i = 0; i < white_list_count; i++, addr++) {
-        BLE_HS_LOG(INFO, "entry-%d={addr_type=%d addr=", i, addr->type);
-        BLE_HS_LOG_ADDR(INFO, addr->val);
-        BLE_HS_LOG(INFO, "} ");
-    }
+	for (i = 0; i < white_list_count; i++, addr++) {
+		BLE_HS_LOG(INFO, "entry-%d={addr_type=%d addr=", i, addr->type);
+		BLE_HS_LOG_ADDR(INFO, addr->val);
+		BLE_HS_LOG(INFO, "} ");
+	}
 }
 #endif
 
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-static void
-ble_gap_log_adv(uint8_t own_addr_type, const ble_addr_t *direct_addr,
-                const struct ble_gap_adv_params *adv_params)
-{
-    BLE_HS_LOG(INFO, "disc_mode=%d", adv_params->disc_mode);
-    if (direct_addr) {
-        BLE_HS_LOG(INFO, " direct_addr_type=%d direct_addr=",
-                   direct_addr->type);
-        BLE_HS_LOG_ADDR(INFO, direct_addr->val);
-    }
-    BLE_HS_LOG(INFO, " adv_channel_map=%d own_addr_type=%d "
-                     "adv_filter_policy=%d adv_itvl_min=%d adv_itvl_max=%d",
-               adv_params->channel_map,
-               own_addr_type,
-               adv_params->filter_policy,
-               adv_params->itvl_min,
-               adv_params->itvl_max);
+static void ble_gap_log_adv(uint8_t own_addr_type, const ble_addr_t *direct_addr,
+                            const struct ble_gap_adv_params *adv_params)
+{
+	BLE_HS_LOG(INFO, "disc_mode=%d", adv_params->disc_mode);
+	if (direct_addr) {
+		BLE_HS_LOG(INFO, " direct_addr_type=%d direct_addr=", direct_addr->type);
+		BLE_HS_LOG_ADDR(INFO, direct_addr->val);
+	}
+	BLE_HS_LOG(INFO,
+	           " adv_channel_map=%d own_addr_type=%d "
+	           "adv_filter_policy=%d adv_itvl_min=%d adv_itvl_max=%d",
+	           adv_params->channel_map, own_addr_type, adv_params->filter_policy,
+	           adv_params->itvl_min, adv_params->itvl_max);
 }
 #endif
 
@@ -406,358 +397,349 @@ ble_gap_log_adv(uint8_t own_addr_type, const ble_addr_t *direct_addr,
  *****************************************************************************/
 
 #if NIMBLE_BLE_CONNECT
-static void
-ble_gap_fill_conn_desc(struct ble_hs_conn *conn,
-                       struct ble_gap_conn_desc *desc)
+static void ble_gap_fill_conn_desc(struct ble_hs_conn *conn,
+                                   struct ble_gap_conn_desc *desc)
 {
-    struct ble_hs_conn_addrs addrs;
+	struct ble_hs_conn_addrs addrs;
 
-    ble_hs_conn_addrs(conn, &addrs);
+	ble_hs_conn_addrs(conn, &addrs);
 
-    desc->our_id_addr = addrs.our_id_addr;
-    desc->peer_id_addr = addrs.peer_id_addr;
-    desc->our_ota_addr = addrs.our_ota_addr;
-    desc->peer_ota_addr = addrs.peer_ota_addr;
+	desc->our_id_addr = addrs.our_id_addr;
+	desc->peer_id_addr = addrs.peer_id_addr;
+	desc->our_ota_addr = addrs.our_ota_addr;
+	desc->peer_ota_addr = addrs.peer_ota_addr;
 
-    desc->conn_handle = conn->bhc_handle;
-    desc->conn_itvl = conn->bhc_itvl;
-    desc->conn_latency = conn->bhc_latency;
-    desc->supervision_timeout = conn->bhc_supervision_timeout;
-    desc->master_clock_accuracy = conn->bhc_master_clock_accuracy;
-    desc->sec_state = conn->bhc_sec_state;
+	desc->conn_handle = conn->bhc_handle;
+	desc->conn_itvl = conn->bhc_itvl;
+	desc->conn_latency = conn->bhc_latency;
+	desc->supervision_timeout = conn->bhc_supervision_timeout;
+	desc->master_clock_accuracy = conn->bhc_master_clock_accuracy;
+	desc->sec_state = conn->bhc_sec_state;
 
-    if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
-        desc->role = BLE_GAP_ROLE_MASTER;
-    } else {
-        desc->role = BLE_GAP_ROLE_SLAVE;
-    }
+	if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
+		desc->role = BLE_GAP_ROLE_MASTER;
+	}
+	else {
+		desc->role = BLE_GAP_ROLE_SLAVE;
+	}
 }
 
-static void
-ble_gap_conn_to_snapshot(struct ble_hs_conn *conn,
-                         struct ble_gap_snapshot *snap)
+static void ble_gap_conn_to_snapshot(struct ble_hs_conn *conn,
+                                     struct ble_gap_snapshot *snap)
 {
-    ble_gap_fill_conn_desc(conn, snap->desc);
-    snap->cb = conn->bhc_cb;
-    snap->cb_arg = conn->bhc_cb_arg;
+	ble_gap_fill_conn_desc(conn, snap->desc);
+	snap->cb = conn->bhc_cb;
+	snap->cb_arg = conn->bhc_cb_arg;
 }
 
-static int
-ble_gap_find_snapshot(uint16_t handle, struct ble_gap_snapshot *snap)
+static int ble_gap_find_snapshot(uint16_t handle, struct ble_gap_snapshot *snap)
 {
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn *conn;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(handle);
-    if (conn != NULL) {
-        ble_gap_conn_to_snapshot(conn, snap);
-    }
+	conn = ble_hs_conn_find(handle);
+	if (conn != NULL) {
+		ble_gap_conn_to_snapshot(conn, snap);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (conn == NULL) {
-        return BLE_HS_ENOTCONN;
-    } else {
-        return 0;
-    }
+	if (conn == NULL) {
+		return BLE_HS_ENOTCONN;
+	}
+	else {
+		return 0;
+	}
 }
 #endif
 
-int
-ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
+int ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn *conn;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(handle);
-    if (conn != NULL && out_desc != NULL) {
-        ble_gap_fill_conn_desc(conn, out_desc);
-    }
+	conn = ble_hs_conn_find(handle);
+	if (conn != NULL && out_desc != NULL) {
+		ble_gap_fill_conn_desc(conn, out_desc);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (conn == NULL) {
-        return BLE_HS_ENOTCONN;
-    } else {
-        return 0;
-    }
+	if (conn == NULL) {
+		return BLE_HS_ENOTCONN;
+	}
+	else {
+		return 0;
+	}
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_conn_find_by_addr(const ble_addr_t *addr,
-                          struct ble_gap_conn_desc *out_desc)
+int ble_gap_conn_find_by_addr(const ble_addr_t *addr, struct ble_gap_conn_desc *out_desc)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn *conn;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find_by_addr(addr);
-    if (conn != NULL && out_desc != NULL) {
-        ble_gap_fill_conn_desc(conn, out_desc);
-    }
+	conn = ble_hs_conn_find_by_addr(addr);
+	if (conn != NULL && out_desc != NULL) {
+		ble_gap_fill_conn_desc(conn, out_desc);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (conn == NULL) {
-        return BLE_HS_ENOTCONN;
-    }
+	if (conn == NULL) {
+		return BLE_HS_ENOTCONN;
+	}
 
-    return 0;
+	return 0;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_conn_find_handle_by_addr(const ble_addr_t *addr, uint16_t *out_conn_handle)
+int ble_gap_conn_find_handle_by_addr(const ble_addr_t *addr, uint16_t *out_conn_handle)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn *conn;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find_by_addr(addr);
-    if (conn != NULL) {
-        *out_conn_handle = conn->bhc_handle;
-    } else {
-        *out_conn_handle = BLE_HS_CONN_HANDLE_NONE;
-    }
+	conn = ble_hs_conn_find_by_addr(addr);
+	if (conn != NULL) {
+		*out_conn_handle = conn->bhc_handle;
+	}
+	else {
+		*out_conn_handle = BLE_HS_CONN_HANDLE_NONE;
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (conn == NULL) {
-        return BLE_HS_ENOTCONN;
-    }
+	if (conn == NULL) {
+		return BLE_HS_ENOTCONN;
+	}
 
-    return 0;
+	return 0;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
 struct foreach_handle_cb_arg {
-    ble_gap_conn_foreach_handle_fn *cb;
-    void *arg;
+	ble_gap_conn_foreach_handle_fn *cb;
+	void *arg;
 };
 
-static int
-ble_gap_conn_foreach_handle_callback(struct ble_hs_conn *conn, void *arg)
+static int ble_gap_conn_foreach_handle_callback(struct ble_hs_conn *conn, void *arg)
 {
-    struct foreach_handle_cb_arg *cb_arg = (struct foreach_handle_cb_arg *)arg;
+	struct foreach_handle_cb_arg *cb_arg = (struct foreach_handle_cb_arg *) arg;
 
-    return cb_arg->cb(conn->bhc_handle, cb_arg->arg);
+	return cb_arg->cb(conn->bhc_handle, cb_arg->arg);
 }
 
-void
-ble_gap_conn_foreach_handle(ble_gap_conn_foreach_handle_fn *cb, void *arg)
+void ble_gap_conn_foreach_handle(ble_gap_conn_foreach_handle_fn *cb, void *arg)
 {
-    struct foreach_handle_cb_arg cb_arg = {
-        .cb = cb,
-        .arg = arg,
-    };
+	struct foreach_handle_cb_arg cb_arg = {
+		.cb = cb,
+		.arg = arg,
+	};
 
-    ble_hs_conn_foreach(ble_gap_conn_foreach_handle_callback, &cb_arg);
+	ble_hs_conn_foreach(ble_gap_conn_foreach_handle_callback, &cb_arg);
 }
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_gap_extract_conn_cb(uint16_t conn_handle,
-                        ble_gap_event_fn **out_cb, void **out_cb_arg)
+static int ble_gap_extract_conn_cb(uint16_t conn_handle, ble_gap_event_fn **out_cb,
+                                   void **out_cb_arg)
 {
-    const struct ble_hs_conn *conn;
+	const struct ble_hs_conn *conn;
 
-    BLE_HS_DBG_ASSERT(conn_handle <= BLE_HCI_LE_CONN_HANDLE_MAX);
+	BLE_HS_DBG_ASSERT(conn_handle <= BLE_HCI_LE_CONN_HANDLE_MAX);
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
-        *out_cb = conn->bhc_cb;
-        *out_cb_arg = conn->bhc_cb_arg;
-    } else {
-        *out_cb = NULL;
-        *out_cb_arg = NULL;
-    }
+	conn = ble_hs_conn_find(conn_handle);
+	if (conn != NULL) {
+		*out_cb = conn->bhc_cb;
+		*out_cb_arg = conn->bhc_cb_arg;
+	}
+	else {
+		*out_cb = NULL;
+		*out_cb_arg = NULL;
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (conn == NULL) {
-        return BLE_HS_ENOTCONN;
-    } else {
-        return 0;
-    }
+	if (conn == NULL) {
+		return BLE_HS_ENOTCONN;
+	}
+	else {
+		return 0;
+	}
 }
 #endif
 
-int
-ble_gap_set_priv_mode(const ble_addr_t *peer_addr, uint8_t priv_mode)
+int ble_gap_set_priv_mode(const ble_addr_t *peer_addr, uint8_t priv_mode)
 {
 #if NIMBLE_BLE_CONNECT
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    return ble_hs_pvcy_set_mode(peer_addr, priv_mode);
+	return ble_hs_pvcy_set_mode(peer_addr, priv_mode);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_read_le_phy(uint16_t conn_handle, uint8_t *tx_phy, uint8_t *rx_phy)
+int ble_gap_read_le_phy(uint16_t conn_handle, uint8_t *tx_phy, uint8_t *rx_phy)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hci_le_rd_phy_cp cmd;
-    struct ble_hci_le_rd_phy_rp rsp;
-    struct ble_hs_conn *conn;
-    int rc;
+	struct ble_hci_le_rd_phy_cp cmd;
+	struct ble_hci_le_rd_phy_rp rsp;
+	struct ble_hs_conn *conn;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
-    conn = ble_hs_conn_find(conn_handle);
-    ble_hs_unlock();
+	ble_hs_lock();
+	conn = ble_hs_conn_find(conn_handle);
+	ble_hs_unlock();
 
-    if (conn == NULL) {
-        return BLE_HS_ENOTCONN;
-    }
+	if (conn == NULL) {
+		return BLE_HS_ENOTCONN;
+	}
 
-    cmd.conn_handle = htole16(conn_handle);
+	cmd.conn_handle = htole16(conn_handle);
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_PHY),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_PHY), &cmd,
+	                       sizeof(cmd), &rsp, sizeof(rsp));
+	if (rc != 0) {
+		return rc;
+	}
 
-    /* sanity check for response */
-    if (le16toh(rsp.conn_handle) != conn_handle) {
-        return BLE_HS_ECONTROLLER;
-    }
+	/* sanity check for response */
+	if (le16toh(rsp.conn_handle) != conn_handle) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    *tx_phy = rsp.tx_phy;
-    *rx_phy = rsp.rx_phy;
+	*tx_phy = rsp.tx_phy;
+	*rx_phy = rsp.rx_phy;
 
-    return 0;
+	return 0;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_set_prefered_default_le_phy(uint8_t tx_phys_mask, uint8_t rx_phys_mask)
+int ble_gap_set_prefered_default_le_phy(uint8_t tx_phys_mask, uint8_t rx_phys_mask)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hci_le_set_default_phy_cp cmd;
-
-    if (tx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                        BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    if (rx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                        BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    memset(&cmd, 0, sizeof(cmd));
-
-    if (tx_phys_mask == 0) {
-        cmd.all_phys |= BLE_HCI_LE_PHY_NO_TX_PREF_MASK;
-    } else {
-        cmd.tx_phys = tx_phys_mask;
-    }
-
-    if (rx_phys_mask == 0) {
-        cmd.all_phys |= BLE_HCI_LE_PHY_NO_RX_PREF_MASK;
-    } else {
-        cmd.rx_phys = rx_phys_mask;
-    }
-
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_SET_DEFAULT_PHY),
-                            &cmd, sizeof(cmd), NULL, 0);
+	struct ble_hci_le_set_default_phy_cp cmd;
+
+	if (tx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
+	                    BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	if (rx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
+	                    BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	if (tx_phys_mask == 0) {
+		cmd.all_phys |= BLE_HCI_LE_PHY_NO_TX_PREF_MASK;
+	}
+	else {
+		cmd.tx_phys = tx_phys_mask;
+	}
+
+	if (rx_phys_mask == 0) {
+		cmd.all_phys |= BLE_HCI_LE_PHY_NO_RX_PREF_MASK;
+	}
+	else {
+		cmd.rx_phys = rx_phys_mask;
+	}
+
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_DEFAULT_PHY),
+	                         &cmd, sizeof(cmd), NULL, 0);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
-                   uint8_t rx_phys_mask, uint16_t phy_opts)
+int ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
+                                uint8_t rx_phys_mask, uint16_t phy_opts)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hci_le_set_phy_cp cmd;
-    struct ble_hs_conn *conn;
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    ble_hs_lock();
-    conn = ble_hs_conn_find(conn_handle);
-    ble_hs_unlock();
-
-    if (conn == NULL) {
-        return BLE_HS_ENOTCONN;
-    }
-
-    if (tx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                        BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    if (rx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                        BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    if (phy_opts > BLE_HCI_LE_PHY_CODED_S8_PREF) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    memset(&cmd, 0, sizeof(cmd));
-    cmd.conn_handle = htole16(conn_handle);
-
-    if (tx_phys_mask == 0) {
-        cmd.all_phys |= BLE_HCI_LE_PHY_NO_TX_PREF_MASK;
-    } else {
-        cmd.tx_phys = tx_phys_mask;
-    }
-
-    if (rx_phys_mask == 0) {
-        cmd.all_phys |= BLE_HCI_LE_PHY_NO_RX_PREF_MASK;
-    } else {
-        cmd.rx_phys = rx_phys_mask;
-    }
-
-    cmd.phy_options = htole16(phy_opts);
-
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PHY),
-                             &cmd, sizeof(cmd), NULL, 0);
+	struct ble_hci_le_set_phy_cp cmd;
+	struct ble_hs_conn *conn;
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	ble_hs_lock();
+	conn = ble_hs_conn_find(conn_handle);
+	ble_hs_unlock();
+
+	if (conn == NULL) {
+		return BLE_HS_ENOTCONN;
+	}
+
+	if (tx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
+	                    BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	if (rx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
+	                    BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	if (phy_opts > BLE_HCI_LE_PHY_CODED_S8_PREF) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.conn_handle = htole16(conn_handle);
+
+	if (tx_phys_mask == 0) {
+		cmd.all_phys |= BLE_HCI_LE_PHY_NO_TX_PREF_MASK;
+	}
+	else {
+		cmd.tx_phys = tx_phys_mask;
+	}
+
+	if (rx_phys_mask == 0) {
+		cmd.all_phys |= BLE_HCI_LE_PHY_NO_RX_PREF_MASK;
+	}
+	else {
+		cmd.rx_phys = rx_phys_mask;
+	}
+
+	cmd.phy_options = htole16(phy_opts);
+
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PHY), &cmd,
+	                         sizeof(cmd), NULL, 0);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
@@ -765,352 +747,337 @@ ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
  * $misc                                                                     *
  *****************************************************************************/
 
-static int
-ble_gap_event_listener_call(struct ble_gap_event *event);
+static int ble_gap_event_listener_call(struct ble_gap_event *event);
 
-static int
-ble_gap_call_event_cb(struct ble_gap_event *event,
-                      ble_gap_event_fn *cb, void *cb_arg)
+static int ble_gap_call_event_cb(struct ble_gap_event *event, ble_gap_event_fn *cb,
+                                 void *cb_arg)
 {
-    int rc;
+	int rc;
 
-    BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
+	BLE_HS_DBG_ASSERT(!ble_hs_locked_by_cur_task());
 
-    if (cb != NULL) {
-        rc = cb(event, cb_arg);
-    } else {
-        if (event->type == BLE_GAP_EVENT_CONN_UPDATE_REQ) {
-            /* Just copy peer parameters back into the reply. */
-            *event->conn_update_req.self_params =
-                *event->conn_update_req.peer_params;
-        }
-        rc = 0;
-    }
+	if (cb != NULL) {
+		rc = cb(event, cb_arg);
+	}
+	else {
+		if (event->type == BLE_GAP_EVENT_CONN_UPDATE_REQ) {
+			/* Just copy peer parameters back into the reply. */
+			*event->conn_update_req.self_params = *event->conn_update_req.peer_params;
+		}
+		rc = 0;
+	}
 
-    return rc;
+	return rc;
 }
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_gap_call_conn_event_cb(struct ble_gap_event *event, uint16_t conn_handle)
+static int ble_gap_call_conn_event_cb(struct ble_gap_event *event, uint16_t conn_handle)
 {
-    ble_gap_event_fn *cb;
-    void *cb_arg;
-    int rc;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
+	int rc;
 
-    rc = ble_gap_extract_conn_cb(conn_handle, &cb, &cb_arg);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_gap_extract_conn_cb(conn_handle, &cb, &cb_arg);
+	if (rc != 0) {
+		return rc;
+	}
 
-    rc = ble_gap_call_event_cb(event, cb, cb_arg);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_gap_call_event_cb(event, cb, cb_arg);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 #endif
 
-static bool
-ble_gap_is_preempted(void)
+static bool ble_gap_is_preempted(void)
 {
 #if NIMBLE_BLE_ADVERTISE
-    int i;
+	int i;
 #endif
-    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
+	BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
-    if (ble_gap_master.preempted_op != BLE_GAP_OP_NULL) {
-        return true;
-    }
+	if (ble_gap_master.preempted_op != BLE_GAP_OP_NULL) {
+		return true;
+	}
 #endif
 #if NIMBLE_BLE_ADVERTISE
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (ble_gap_slave[i].preempted) {
-            return true;
-        }
-    }
+	for (i = 0; i < BLE_ADV_INSTANCES; i++) {
+		if (ble_gap_slave[i].preempted) {
+			return true;
+		}
+	}
 #endif
-    return false;
+	return false;
 }
 
 #if MYNEWT_VAL(BLE_ROLE_OBSERVER) || NIMBLE_BLE_CONNECT
-static void
-ble_gap_master_reset_state(void)
+static void ble_gap_master_reset_state(void)
 {
-    ble_gap_master.op = BLE_GAP_OP_NULL;
-    ble_gap_master.exp_set = 0;
-    ble_gap_master.conn.cancel = 0;
+	ble_gap_master.op = BLE_GAP_OP_NULL;
+	ble_gap_master.exp_set = 0;
+	ble_gap_master.conn.cancel = 0;
 
-    ble_hs_timer_resched();
+	ble_hs_timer_resched();
 }
 #endif
 
 #if NIMBLE_BLE_ADVERTISE || NIMBLE_BLE_CONNECT
-static void
-ble_gap_slave_reset_state(uint8_t instance)
+static void ble_gap_slave_reset_state(uint8_t instance)
 {
-    ble_gap_slave[instance].op = BLE_GAP_OP_NULL;
+	ble_gap_slave[instance].op = BLE_GAP_OP_NULL;
 
 #if !MYNEWT_VAL(BLE_EXT_ADV)
-    ble_gap_slave[instance].exp_set = 0;
-    ble_hs_timer_resched();
+	ble_gap_slave[instance].exp_set = 0;
+	ble_hs_timer_resched();
 #endif
 }
 #endif
 
-#if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
-static bool
-ble_gap_has_client(struct ble_gap_master_state *out_state)
+#if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_PERIPHERAL) || \
+	MYNEWT_VAL(BLE_ROLE_OBSERVER)
+static bool ble_gap_has_client(struct ble_gap_master_state *out_state)
 {
-    if (!out_state) {
-        return 0;
-    }
+	if (!out_state) {
+		return 0;
+	}
 
-    return out_state->cb != NULL;
+	return out_state->cb != NULL;
 }
 #endif
 
 #if MYNEWT_VAL(BLE_ROLE_OBSERVER) || NIMBLE_BLE_CONNECT
-static void
-ble_gap_master_extract_state(struct ble_gap_master_state *out_state,
-                             int reset_state)
+static void ble_gap_master_extract_state(struct ble_gap_master_state *out_state,
+                                         int reset_state)
 {
-    ble_hs_lock();
+	ble_hs_lock();
 
-    *out_state = ble_gap_master;
+	*out_state = ble_gap_master;
 
-    if (reset_state) {
-        ble_gap_master_reset_state();
-        ble_gap_master.preempted_op = BLE_GAP_OP_NULL;
-    }
+	if (reset_state) {
+		ble_gap_master_reset_state();
+		ble_gap_master.preempted_op = BLE_GAP_OP_NULL;
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 #endif
 
 #if NIMBLE_BLE_ADVERTISE || NIMBLE_BLE_CONNECT
-static void
-ble_gap_slave_extract_cb(uint8_t instance,
-                         ble_gap_event_fn **out_cb, void **out_cb_arg)
+static void ble_gap_slave_extract_cb(uint8_t instance, ble_gap_event_fn **out_cb,
+                                     void **out_cb_arg)
 {
-    ble_hs_lock();
+	ble_hs_lock();
 
-    *out_cb = ble_gap_slave[instance].cb;
-    *out_cb_arg = ble_gap_slave[instance].cb_arg;
-    ble_gap_slave_reset_state(instance);
+	*out_cb = ble_gap_slave[instance].cb;
+	*out_cb_arg = ble_gap_slave[instance].cb_arg;
+	ble_gap_slave_reset_state(instance);
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
-static void
-ble_gap_adv_finished(uint8_t instance, int reason, uint16_t conn_handle,
-                     uint8_t num_events)
+static void ble_gap_adv_finished(uint8_t instance, int reason, uint16_t conn_handle,
+                                 uint8_t num_events)
 {
-    struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+	struct ble_gap_event event;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_ADV_COMPLETE;
-    event.adv_complete.reason = reason;
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_ADV_COMPLETE;
+	event.adv_complete.reason = reason;
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    event.adv_complete.instance = instance;
-    event.adv_complete.conn_handle = conn_handle;
-    event.adv_complete.num_ext_adv_events = num_events;
+	event.adv_complete.instance = instance;
+	event.adv_complete.conn_handle = conn_handle;
+	event.adv_complete.num_ext_adv_events = num_events;
 #endif
 
-    ble_gap_event_listener_call(&event);
+	ble_gap_event_listener_call(&event);
 
-    ble_gap_slave_extract_cb(instance, &cb, &cb_arg);
-    if (cb != NULL) {
-        cb(&event, cb_arg);
-    }
+	ble_gap_slave_extract_cb(instance, &cb, &cb_arg);
+	if (cb != NULL) {
+		cb(&event, cb_arg);
+	}
 }
 #endif
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_gap_master_connect_failure(int status)
+static int ble_gap_master_connect_failure(int status)
 {
-    struct ble_gap_master_state state;
-    struct ble_gap_event event;
-    int rc;
+	struct ble_gap_master_state state;
+	struct ble_gap_event event;
+	int rc;
 
-    ble_gap_master_extract_state(&state, 1);
-    if (ble_gap_has_client(&state)) {
-        memset(&event, 0, sizeof event);
-        event.type = BLE_GAP_EVENT_CONNECT;
-        event.connect.status = status;
+	ble_gap_master_extract_state(&state, 1);
+	if (ble_gap_has_client(&state)) {
+		memset(&event, 0, sizeof event);
+		event.type = BLE_GAP_EVENT_CONNECT;
+		event.connect.status = status;
 
-        rc = state.cb(&event, state.cb_arg);
-    } else {
-        rc = 0;
-    }
+		rc = state.cb(&event, state.cb_arg);
+	}
+	else {
+		rc = 0;
+	}
 
-    return rc;
+	return rc;
 }
 
-static void
-ble_gap_master_connect_cancelled(void)
+static void ble_gap_master_connect_cancelled(void)
 {
-    struct ble_gap_master_state state;
-    struct ble_gap_event event;
+	struct ble_gap_master_state state;
+	struct ble_gap_event event;
 
-    ble_gap_master_extract_state(&state, 1);
-    if (state.cb != NULL) {
-        memset(&event, 0, sizeof event);
-        event.type = BLE_GAP_EVENT_CONNECT;
-        event.connect.conn_handle = BLE_HS_CONN_HANDLE_NONE;
-        if (state.conn.cancel) {
-            /* Connect procedure successfully cancelled. */
-            event.connect.status = BLE_HS_EAPP;
-        } else {
-            /* Connect procedure timed out. */
-            event.connect.status = BLE_HS_ETIMEOUT;
-        }
-        state.cb(&event, state.cb_arg);
-    }
+	ble_gap_master_extract_state(&state, 1);
+	if (state.cb != NULL) {
+		memset(&event, 0, sizeof event);
+		event.type = BLE_GAP_EVENT_CONNECT;
+		event.connect.conn_handle = BLE_HS_CONN_HANDLE_NONE;
+		if (state.conn.cancel) {
+			/* Connect procedure successfully cancelled. */
+			event.connect.status = BLE_HS_EAPP;
+		}
+		else {
+			/* Connect procedure timed out. */
+			event.connect.status = BLE_HS_ETIMEOUT;
+		}
+		state.cb(&event, state.cb_arg);
+	}
 }
 #endif
 
 #if NIMBLE_BLE_SCAN
-static void
-ble_gap_disc_report(void *desc)
+static void ble_gap_disc_report(void *desc)
 {
-    struct ble_gap_master_state state;
-    struct ble_gap_event event;
+	struct ble_gap_master_state state;
+	struct ble_gap_event event;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_DISC;
-    event.disc = *((struct ble_gap_disc_desc *)desc);
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_DISC;
+	event.disc = *((struct ble_gap_disc_desc *) desc);
 
-    ble_gap_master_extract_state(&state, 0);
-    if (ble_gap_has_client(&state)) {
-        state.cb(&event, state.cb_arg);
-    }
+	ble_gap_master_extract_state(&state, 0);
+	if (ble_gap_has_client(&state)) {
+		state.cb(&event, state.cb_arg);
+	}
 
-    ble_gap_event_listener_call(&event);
+	ble_gap_event_listener_call(&event);
 }
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
-static void
-ble_gap_ext_disc_report(void *desc)
+static void ble_gap_ext_disc_report(void *desc)
 {
-    struct ble_gap_ext_disc_desc *ext_desc = desc;
-    struct ble_gap_disc_desc legacy_desc;
-    struct ble_gap_master_state state;
-    struct ble_gap_event event;
+	struct ble_gap_ext_disc_desc *ext_desc = desc;
+	struct ble_gap_disc_desc legacy_desc;
+	struct ble_gap_master_state state;
+	struct ble_gap_event event;
 
-    if (ble_gap_master.legacy_discovery) {
-        /* ignore non-legacy events */
-        if (!(ext_desc->props & BLE_HCI_ADV_LEGACY_MASK)) {
-            return;
-        }
+	if (ble_gap_master.legacy_discovery) {
+		/* ignore non-legacy events */
+		if (!(ext_desc->props & BLE_HCI_ADV_LEGACY_MASK)) {
+			return;
+		}
 
-        legacy_desc.event_type = ext_desc->legacy_event_type;
-        legacy_desc.length_data = ext_desc->length_data;
-        legacy_desc.addr = ext_desc->addr;
-        legacy_desc.rssi = ext_desc->rssi;
-        legacy_desc.data = ext_desc->data;
-        legacy_desc.direct_addr = ext_desc->direct_addr;
-        ble_gap_disc_report(&legacy_desc);
-        return;
-    }
+		legacy_desc.event_type = ext_desc->legacy_event_type;
+		legacy_desc.length_data = ext_desc->length_data;
+		legacy_desc.addr = ext_desc->addr;
+		legacy_desc.rssi = ext_desc->rssi;
+		legacy_desc.data = ext_desc->data;
+		legacy_desc.direct_addr = ext_desc->direct_addr;
+		ble_gap_disc_report(&legacy_desc);
+		return;
+	}
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_EXT_DISC;
-    event.ext_disc = *((struct ble_gap_ext_disc_desc *)desc);
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_EXT_DISC;
+	event.ext_disc = *((struct ble_gap_ext_disc_desc *) desc);
 
-    ble_gap_master_extract_state(&state, 0);
-    if (ble_gap_has_client(&state)) {
-        state.cb(&event, state.cb_arg);
-    }
+	ble_gap_master_extract_state(&state, 0);
+	if (ble_gap_has_client(&state)) {
+		state.cb(&event, state.cb_arg);
+	}
 
-    ble_gap_event_listener_call(&event);
+	ble_gap_event_listener_call(&event);
 }
 #endif
 
-static void
-ble_gap_disc_complete(void)
+static void ble_gap_disc_complete(void)
 {
-    struct ble_gap_master_state state;
-    struct ble_gap_event event;
+	struct ble_gap_master_state state;
+	struct ble_gap_event event;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_DISC_COMPLETE;
-    event.disc_complete.reason = 0;
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_DISC_COMPLETE;
+	event.disc_complete.reason = 0;
 
-    ble_gap_master_extract_state(&state, 1);
-    if (ble_gap_has_client(&state)) {
-        ble_gap_call_event_cb(&event, state.cb, state.cb_arg);
-    }
+	ble_gap_master_extract_state(&state, 1);
+	if (ble_gap_has_client(&state)) {
+		ble_gap_call_event_cb(&event, state.cb, state.cb_arg);
+	}
 
-    ble_gap_event_listener_call(&event);
+	ble_gap_event_listener_call(&event);
 }
 #endif
 
 #if NIMBLE_BLE_CONNECT
-static void
-ble_gap_update_notify(uint16_t conn_handle, int status)
+static void ble_gap_update_notify(uint16_t conn_handle, int status)
 {
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_CONN_UPDATE;
-    event.conn_update.conn_handle = conn_handle;
-    event.conn_update.status = status;
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_CONN_UPDATE;
+	event.conn_update.conn_handle = conn_handle;
+	event.conn_update.status = status;
 
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 
-    /* Terminate the connection on procedure timeout. */
-    if (status == BLE_HS_ETIMEOUT) {
-        ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);
-    }
+	/* Terminate the connection on procedure timeout. */
+	if (status == BLE_HS_ETIMEOUT) {
+		ble_gap_terminate(conn_handle, BLE_ERR_REM_USER_CONN_TERM);
+	}
 }
 #endif
 
-static uint32_t
-ble_gap_master_ticks_until_exp(void)
+static uint32_t ble_gap_master_ticks_until_exp(void)
 {
-    ble_npl_stime_t ticks;
+	ble_npl_stime_t ticks;
 
-    if (ble_gap_master.op == BLE_GAP_OP_NULL || !ble_gap_master.exp_set) {
-        /* Timer not set; infinity ticks until next event. */
-        return BLE_HS_FOREVER;
-    }
+	if (ble_gap_master.op == BLE_GAP_OP_NULL || !ble_gap_master.exp_set) {
+		/* Timer not set; infinity ticks until next event. */
+		return BLE_HS_FOREVER;
+	}
 
-    ticks = ble_gap_master.exp_os_ticks - ble_npl_time_get();
-    if (ticks > 0) {
-        /* Timer not expired yet. */
-        return ticks;
-    }
+	ticks = ble_gap_master.exp_os_ticks - ble_npl_time_get();
+	if (ticks > 0) {
+		/* Timer not expired yet. */
+		return ticks;
+	}
 
-    /* Timer just expired. */
-    return 0;
+	/* Timer just expired. */
+	return 0;
 }
 
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-static uint32_t
-ble_gap_slave_ticks_until_exp(void)
+static uint32_t ble_gap_slave_ticks_until_exp(void)
 {
-    ble_npl_stime_t ticks;
+	ble_npl_stime_t ticks;
 
-    if (ble_gap_slave[0].op == BLE_GAP_OP_NULL || !ble_gap_slave[0].exp_set) {
-        /* Timer not set; infinity ticks until next event. */
-        return BLE_HS_FOREVER;
-    }
+	if (ble_gap_slave[0].op == BLE_GAP_OP_NULL || !ble_gap_slave[0].exp_set) {
+		/* Timer not set; infinity ticks until next event. */
+		return BLE_HS_FOREVER;
+	}
 
-    ticks = ble_gap_slave[0].exp_os_ticks - ble_npl_time_get();
-    if (ticks > 0) {
-        /* Timer not expired yet. */
-        return ticks;
-    }
+	ticks = ble_gap_slave[0].exp_os_ticks - ble_npl_time_get();
+	if (ticks > 0) {
+		/* Timer not expired yet. */
+		return ticks;
+	}
 
-    /* Timer just expired. */
-    return 0;
+	/* Timer just expired. */
+	return 0;
 }
 #endif
 
@@ -1125,60 +1092,57 @@ ble_gap_slave_ticks_until_exp(void)
  *                                  BLE_HS_CONN_HANDLE_NONE if there are no
  *                                  active update procedures.
  */
-static uint16_t
-ble_gap_update_next_exp(int32_t *out_ticks_from_now)
+static uint16_t ble_gap_update_next_exp(int32_t *out_ticks_from_now)
 {
-    struct ble_gap_update_entry *entry;
-    ble_npl_time_t now;
-    uint16_t conn_handle;
-    int32_t best_ticks;
-    int32_t ticks;
+	struct ble_gap_update_entry *entry;
+	ble_npl_time_t now;
+	uint16_t conn_handle;
+	int32_t best_ticks;
+	int32_t ticks;
 
-    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
+	BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
-    conn_handle = BLE_HS_CONN_HANDLE_NONE;
-    best_ticks = BLE_HS_FOREVER;
-    now = ble_npl_time_get();
+	conn_handle = BLE_HS_CONN_HANDLE_NONE;
+	best_ticks = BLE_HS_FOREVER;
+	now = ble_npl_time_get();
 
-    SLIST_FOREACH(entry, &ble_gap_update_entries, next) {
-        ticks = entry->exp_os_ticks - now;
-        if (ticks <= 0) {
-            ticks = 0;
-        }
+	SLIST_FOREACH(entry, &ble_gap_update_entries, next)
+	{
+		ticks = entry->exp_os_ticks - now;
+		if (ticks <= 0) {
+			ticks = 0;
+		}
 
-        if (ticks < best_ticks) {
-            conn_handle = entry->conn_handle;
-            best_ticks = ticks;
-        }
-    }
+		if (ticks < best_ticks) {
+			conn_handle = entry->conn_handle;
+			best_ticks = ticks;
+		}
+	}
 
-    if (out_ticks_from_now != NULL) {
-        *out_ticks_from_now = best_ticks;
-    }
-
-    return conn_handle;
+	if (out_ticks_from_now != NULL) {
+		*out_ticks_from_now = best_ticks;
+	}
 
+	return conn_handle;
 }
 
 #if NIMBLE_BLE_SCAN
-static void
-ble_gap_master_set_timer(uint32_t ticks_from_now)
+static void ble_gap_master_set_timer(uint32_t ticks_from_now)
 {
-    ble_gap_master.exp_os_ticks = ble_npl_time_get() + ticks_from_now;
-    ble_gap_master.exp_set = 1;
+	ble_gap_master.exp_os_ticks = ble_npl_time_get() + ticks_from_now;
+	ble_gap_master.exp_set = 1;
 
-    ble_hs_timer_resched();
+	ble_hs_timer_resched();
 }
 #endif
 
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-static void
-ble_gap_slave_set_timer(uint32_t ticks_from_now)
+static void ble_gap_slave_set_timer(uint32_t ticks_from_now)
 {
-    ble_gap_slave[0].exp_os_ticks = ble_npl_time_get() + ticks_from_now;
-    ble_gap_slave[0].exp_set = 1;
+	ble_gap_slave[0].exp_os_ticks = ble_npl_time_get() + ticks_from_now;
+	ble_gap_slave[0].exp_set = 1;
 
-    ble_hs_timer_resched();
+	ble_hs_timer_resched();
 }
 #endif
 
@@ -1187,260 +1151,257 @@ ble_gap_slave_set_timer(uint32_t ticks_from_now)
  * Called when an error is encountered while the master-connection-fsm is
  * active.
  */
-static void
-ble_gap_master_failed(int status)
+static void ble_gap_master_failed(int status)
 {
-    switch (ble_gap_master.op) {
+	switch (ble_gap_master.op) {
 #if NIMBLE_BLE_CONNECT
-    case BLE_GAP_OP_M_CONN:
-        STATS_INC(ble_gap_stats, initiate_fail);
-        ble_gap_master_connect_failure(status);
-        break;
+	case BLE_GAP_OP_M_CONN:
+		STATS_INC(ble_gap_stats, initiate_fail);
+		ble_gap_master_connect_failure(status);
+		break;
 #endif
 
 #if NIMBLE_BLE_SCAN
-    case BLE_GAP_OP_M_DISC:
-        STATS_INC(ble_gap_stats, initiate_fail);
-        ble_gap_disc_complete();
-        ble_gap_master_reset_state();
-        break;
+	case BLE_GAP_OP_M_DISC:
+		STATS_INC(ble_gap_stats, initiate_fail);
+		ble_gap_disc_complete();
+		ble_gap_master_reset_state();
+		break;
 #endif
 
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        break;
-    }
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		break;
+	}
 }
 #endif
 
 #if NIMBLE_BLE_CONNECT
-static void
-ble_gap_update_failed(uint16_t conn_handle, int status)
+static void ble_gap_update_failed(uint16_t conn_handle, int status)
 {
-    struct ble_gap_update_entry *entry;
+	struct ble_gap_update_entry *entry;
 
-    STATS_INC(ble_gap_stats, update_fail);
+	STATS_INC(ble_gap_stats, update_fail);
 
-    ble_hs_lock();
-    entry = ble_gap_update_entry_remove(conn_handle);
-    ble_hs_unlock();
+	ble_hs_lock();
+	entry = ble_gap_update_entry_remove(conn_handle);
+	ble_hs_unlock();
 
-    ble_gap_update_entry_free(entry);
+	ble_gap_update_entry_free(entry);
 
-    ble_gap_update_notify(conn_handle, status);
+	ble_gap_update_notify(conn_handle, status);
 }
 #endif
 
-static void
-ble_gap_conn_broken(uint16_t conn_handle, int reason)
+static void ble_gap_conn_broken(uint16_t conn_handle, int reason)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_update_entry *entry;
-    struct ble_gap_snapshot snap;
-    struct ble_gap_event event;
-    int rc;
+	struct ble_gap_update_entry *entry;
+	struct ble_gap_snapshot snap;
+	struct ble_gap_event event;
+	int rc;
 
-    memset(&event, 0, sizeof event);
-    snap.desc = &event.disconnect.conn;
+	memset(&event, 0, sizeof event);
+	snap.desc = &event.disconnect.conn;
 
-    rc = ble_gap_find_snapshot(conn_handle, &snap);
-    if (rc != 0) {
-        /* No longer connected. */
-        return;
-    }
+	rc = ble_gap_find_snapshot(conn_handle, &snap);
+	if (rc != 0) {
+		/* No longer connected. */
+		return;
+	}
 
-    /* If there was a connection update in progress, indicate to the
-     * application that it did not complete.
-     */
-    ble_hs_lock();
-    entry = ble_gap_update_entry_remove(conn_handle);
-    ble_hs_unlock();
+	/* If there was a connection update in progress, indicate to the
+	 * application that it did not complete.
+	 */
+	ble_hs_lock();
+	entry = ble_gap_update_entry_remove(conn_handle);
+	ble_hs_unlock();
 
-    if (entry != NULL) {
-        ble_gap_update_notify(conn_handle, reason);
-        ble_gap_update_entry_free(entry);
-    }
+	if (entry != NULL) {
+		ble_gap_update_notify(conn_handle, reason);
+		ble_gap_update_entry_free(entry);
+	}
 
-    /* Indicate the connection termination to each module.  The order matters
-     * here: gatts must come before gattc to ensure the application does not
-     * get informed of spurious notify-tx events.
-     */
-    ble_l2cap_sig_conn_broken(conn_handle, reason);
-    ble_sm_connection_broken(conn_handle);
-    ble_gatts_connection_broken(conn_handle);
-    ble_gattc_connection_broken(conn_handle);
-    ble_hs_flow_connection_broken(conn_handle);;
+	/* Indicate the connection termination to each module.  The order matters
+	 * here: gatts must come before gattc to ensure the application does not
+	 * get informed of spurious notify-tx events.
+	 */
+	ble_l2cap_sig_conn_broken(conn_handle, reason);
+	ble_sm_connection_broken(conn_handle);
+	ble_gatts_connection_broken(conn_handle);
+	ble_gattc_connection_broken(conn_handle);
+	ble_hs_flow_connection_broken(conn_handle);
+	;
 
-    ble_hs_atomic_conn_delete(conn_handle);
+	ble_hs_atomic_conn_delete(conn_handle);
 
-    event.type = BLE_GAP_EVENT_DISCONNECT;
-    event.disconnect.reason = reason;
+	event.type = BLE_GAP_EVENT_DISCONNECT;
+	event.disconnect.reason = reason;
 
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_event_cb(&event, snap.cb, snap.cb_arg);
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_event_cb(&event, snap.cb, snap.cb_arg);
 
-    STATS_INC(ble_gap_stats, disconnect);
+	STATS_INC(ble_gap_stats, disconnect);
 #endif
 }
 
 #if NIMBLE_BLE_CONNECT
-static void
-ble_gap_update_to_l2cap(const struct ble_gap_upd_params *params,
-                        struct ble_l2cap_sig_update_params *l2cap_params)
+static void ble_gap_update_to_l2cap(const struct ble_gap_upd_params *params,
+                                    struct ble_l2cap_sig_update_params *l2cap_params)
 {
-    l2cap_params->itvl_min = params->itvl_min;
-    l2cap_params->itvl_max = params->itvl_max;
-    l2cap_params->slave_latency = params->latency;
-    l2cap_params->timeout_multiplier = params->supervision_timeout;
+	l2cap_params->itvl_min = params->itvl_min;
+	l2cap_params->itvl_max = params->itvl_max;
+	l2cap_params->slave_latency = params->latency;
+	l2cap_params->timeout_multiplier = params->supervision_timeout;
 }
 #endif
 
-void
-ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp *ev)
+void ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp *ev)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
-    uint16_t handle = le16toh(ev->conn_handle);
+	struct ble_gap_event event;
+	uint16_t handle = le16toh(ev->conn_handle);
 
-    STATS_INC(ble_gap_stats, rx_disconnect);
+	STATS_INC(ble_gap_stats, rx_disconnect);
 
-    if (ev->status == 0) {
-        ble_gap_conn_broken(handle, BLE_HS_HCI_ERR(ev->reason));
-    } else {
-        memset(&event, 0, sizeof event);
-        event.type = BLE_GAP_EVENT_TERM_FAILURE;
-        event.term_failure.conn_handle = handle;
-        event.term_failure.status = BLE_HS_HCI_ERR(ev->status);
+	if (ev->status == 0) {
+		ble_gap_conn_broken(handle, BLE_HS_HCI_ERR(ev->reason));
+	}
+	else {
+		memset(&event, 0, sizeof event);
+		event.type = BLE_GAP_EVENT_TERM_FAILURE;
+		event.term_failure.conn_handle = handle;
+		event.term_failure.status = BLE_HS_HCI_ERR(ev->status);
 
-        ble_gap_event_listener_call(&event);
-        ble_gap_call_conn_event_cb(&event, handle);
-    }
+		ble_gap_event_listener_call(&event);
+		ble_gap_call_conn_event_cb(&event, handle);
+	}
 #endif
 }
 
-void
-ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *ev)
+void ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *ev)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_update_entry *entry;
-    struct ble_l2cap_sig_update_params l2cap_params;
-    struct ble_gap_event event;
-    struct ble_hs_conn *conn;
-    uint16_t conn_handle;
-    int cb_status;
-    int call_cb;
-    int rc;
-
-    STATS_INC(ble_gap_stats, rx_update_complete);
-
-    memset(&event, 0, sizeof event);
-    memset(&l2cap_params, 0, sizeof l2cap_params);
-
-    ble_hs_lock();
-
-    conn_handle = le16toh(ev->conn_handle);
-
-    conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
-        switch (ev->status) {
-        case 0:
-            /* Connection successfully updated. */
-            conn->bhc_itvl = le16toh(ev->conn_itvl);
-            conn->bhc_latency = le16toh(ev->conn_latency);
-            conn->bhc_supervision_timeout = le16toh(ev->supervision_timeout);
-            break;
-
-        case BLE_ERR_UNSUPP_REM_FEATURE:
-            /* Peer reports that it doesn't support the procedure.  This should
-             * only happen if our controller sent the 4.1 Connection Parameters
-             * Request Procedure.  If we are the slave, fail over to the L2CAP
-             * update procedure.
-             */
-            entry = ble_gap_update_entry_find(conn_handle, NULL);
-            if (entry != NULL && !(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
-                ble_gap_update_to_l2cap(&entry->params, &l2cap_params);
-                entry->exp_os_ticks = ble_npl_time_get() +
-                                      ble_npl_time_ms_to_ticks32(BLE_GAP_UPDATE_TIMEOUT_MS);
-            }
-            break;
-
-        default:
-            break;
-        }
-    }
-
-    /* We aren't failing over to L2CAP, the update procedure is complete. */
-    if (l2cap_params.itvl_min == 0) {
-        entry = ble_gap_update_entry_remove(conn_handle);
-        ble_gap_update_entry_free(entry);
-    }
-
-    ble_hs_unlock();
-
-    if (l2cap_params.itvl_min != 0) {
-        rc = ble_l2cap_sig_update(conn_handle, &l2cap_params,
-                                  ble_gap_update_l2cap_cb, NULL);
-        if (rc == 0) {
-            call_cb = 0;
-        } else {
-            call_cb = 1;
-            cb_status = rc;
-        }
-    } else {
-        call_cb = 1;
-        cb_status = BLE_HS_HCI_ERR(ev->status);
-    }
-
-    if (call_cb) {
-        ble_gap_update_notify(conn_handle, cb_status);
-    }
+	struct ble_gap_update_entry *entry;
+	struct ble_l2cap_sig_update_params l2cap_params;
+	struct ble_gap_event event;
+	struct ble_hs_conn *conn;
+	uint16_t conn_handle;
+	int cb_status;
+	int call_cb;
+	int rc;
+
+	STATS_INC(ble_gap_stats, rx_update_complete);
+
+	memset(&event, 0, sizeof event);
+	memset(&l2cap_params, 0, sizeof l2cap_params);
+
+	ble_hs_lock();
+
+	conn_handle = le16toh(ev->conn_handle);
+
+	conn = ble_hs_conn_find(conn_handle);
+	if (conn != NULL) {
+		switch (ev->status) {
+		case 0:
+			/* Connection successfully updated. */
+			conn->bhc_itvl = le16toh(ev->conn_itvl);
+			conn->bhc_latency = le16toh(ev->conn_latency);
+			conn->bhc_supervision_timeout = le16toh(ev->supervision_timeout);
+			break;
+
+		case BLE_ERR_UNSUPP_REM_FEATURE:
+			/* Peer reports that it doesn't support the procedure.  This should
+			 * only happen if our controller sent the 4.1 Connection Parameters
+			 * Request Procedure.  If we are the slave, fail over to the L2CAP
+			 * update procedure.
+			 */
+			entry = ble_gap_update_entry_find(conn_handle, NULL);
+			if (entry != NULL && !(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
+				ble_gap_update_to_l2cap(&entry->params, &l2cap_params);
+				entry->exp_os_ticks =
+					ble_npl_time_get() + ble_npl_time_ms_to_ticks32(BLE_GAP_UPDATE_TIMEOUT_MS);
+			}
+			break;
+		case BLE_ERR_MAX:
+			ble_gap_enc_event(conn_handle, 66, 66, 0);
+			break;
+		default:
+			break;
+		}
+	}
+
+	/* We aren't failing over to L2CAP, the update procedure is complete. */
+	if (l2cap_params.itvl_min == 0) {
+		entry = ble_gap_update_entry_remove(conn_handle);
+		ble_gap_update_entry_free(entry);
+	}
+
+	ble_hs_unlock();
+
+	if (l2cap_params.itvl_min != 0) {
+		rc =
+			ble_l2cap_sig_update(conn_handle, &l2cap_params, ble_gap_update_l2cap_cb, NULL);
+		if (rc == 0) {
+			call_cb = 0;
+		}
+		else {
+			call_cb = 1;
+			cb_status = rc;
+		}
+	}
+	else {
+		call_cb = 1;
+		cb_status = BLE_HS_HCI_ERR(ev->status);
+	}
+
+	if (call_cb) {
+		ble_gap_update_notify(conn_handle, cb_status);
+	}
 #endif
 }
 
 /**
  * Tells you if there is an active central GAP procedure (connect or discover).
  */
-int
-ble_gap_master_in_progress(void)
+int ble_gap_master_in_progress(void)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
-    return ble_gap_master.op != BLE_GAP_OP_NULL;
+	return ble_gap_master.op != BLE_GAP_OP_NULL;
 #else
-    return false;
+	return false;
 #endif
 }
 
 #if NIMBLE_BLE_ADVERTISE || NIMBLE_BLE_CONNECT
-static int
-ble_gap_adv_active_instance(uint8_t instance)
+static int ble_gap_adv_active_instance(uint8_t instance)
 {
-    /* Assume read is atomic; mutex not necessary. */
-    return ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV;
+	/* Assume read is atomic; mutex not necessary. */
+	return ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV;
 }
 #endif
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
 int ble_gap_ext_adv_active(uint8_t instance)
 {
-    if (instance >= BLE_ADV_INSTANCES) {
-        return 0;
-    }
-    return ble_gap_adv_active_instance(instance);
+	if (instance >= BLE_ADV_INSTANCES) {
+		return 0;
+	}
+	return ble_gap_adv_active_instance(instance);
 }
 
-int
-ble_gap_adv_get_free_instance(uint8_t *out_adv_instance)
+int ble_gap_adv_get_free_instance(uint8_t *out_adv_instance)
 {
-    uint8_t i;
+	uint8_t i;
 
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (!ble_gap_slave[i].configured) {
-            *out_adv_instance = i;
-            return 0;
-        }
-    }
+	for (i = 0; i < BLE_ADV_INSTANCES; i++) {
+		if (!ble_gap_slave[i].configured) {
+			*out_adv_instance = i;
+			return 0;
+		}
+	}
 
-    return BLE_HS_ENOENT;
+	return BLE_HS_ENOENT;
 }
 #endif
 
@@ -1448,544 +1409,533 @@ ble_gap_adv_get_free_instance(uint8_t *out_adv_instance)
  * Clears advertisement and discovery state.  This function is necessary
  * when the controller loses its active state (e.g. on stack reset).
  */
-void
-ble_gap_reset_state(int reason)
+void ble_gap_reset_state(int reason)
 {
-    uint16_t conn_handle;
+	uint16_t conn_handle;
 
-    while (1) {
-        conn_handle = ble_hs_atomic_first_conn_handle();
-        if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
-            break;
-        }
+	while (1) {
+		conn_handle = ble_hs_atomic_first_conn_handle();
+		if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
+			break;
+		}
 
-        ble_gap_conn_broken(conn_handle, reason);
-    }
+		ble_gap_conn_broken(conn_handle, reason);
+	}
 
 #if NIMBLE_BLE_ADVERTISE
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    uint8_t i;
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (ble_gap_adv_active_instance(i)) {
-            /* Indicate to application that advertising has stopped. */
-            ble_gap_adv_finished(i, reason, 0, 0);
-        }
-    }
+	uint8_t i;
+	for (i = 0; i < BLE_ADV_INSTANCES; i++) {
+		if (ble_gap_adv_active_instance(i)) {
+			/* Indicate to application that advertising has stopped. */
+			ble_gap_adv_finished(i, reason, 0, 0);
+		}
+	}
 #else
-    if (ble_gap_adv_active_instance(0)) {
-        /* Indicate to application that advertising has stopped. */
-        ble_gap_adv_finished(0, reason, 0, 0);
-    }
+	if (ble_gap_adv_active_instance(0)) {
+		/* Indicate to application that advertising has stopped. */
+		ble_gap_adv_finished(0, reason, 0, 0);
+	}
 #endif
 #endif
 
 #if (NIMBLE_BLE_SCAN || NIMBLE_BLE_CONNECT)
-    ble_gap_master_failed(reason);
+	ble_gap_master_failed(reason);
 #endif
 }
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_gap_accept_master_conn(void)
+static int ble_gap_accept_master_conn(void)
 {
-    int rc;
+	int rc;
 
-    switch (ble_gap_master.op) {
-    case BLE_GAP_OP_NULL:
-    case BLE_GAP_OP_M_DISC:
-        rc = BLE_HS_ENOENT;
-        break;
+	switch (ble_gap_master.op) {
+	case BLE_GAP_OP_NULL:
+	case BLE_GAP_OP_M_DISC:
+		rc = BLE_HS_ENOENT;
+		break;
 
-    case BLE_GAP_OP_M_CONN:
-        rc = 0;
-        break;
+	case BLE_GAP_OP_M_CONN:
+		rc = 0;
+		break;
 
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        rc = BLE_HS_ENOENT;
-        break;
-    }
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		rc = BLE_HS_ENOENT;
+		break;
+	}
 
-    if (rc == 0) {
-        STATS_INC(ble_gap_stats, connect_mst);
-    }
+	if (rc == 0) {
+		STATS_INC(ble_gap_stats, connect_mst);
+	}
 
-    return rc;
+	return rc;
 }
 
-static int
-ble_gap_accept_slave_conn(uint8_t instance)
+static int ble_gap_accept_slave_conn(uint8_t instance)
 {
-    int rc;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-       rc = BLE_HS_ENOENT;
-    } else if (!ble_gap_adv_active_instance(instance)) {
-        rc = BLE_HS_ENOENT;
-    } else {
-        if (ble_gap_slave[instance].connectable) {
-            rc = 0;
-        } else {
-            rc = BLE_HS_ENOENT;
-        }
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		rc = BLE_HS_ENOENT;
+	}
+	else if (!ble_gap_adv_active_instance(instance)) {
+		rc = BLE_HS_ENOENT;
+	}
+	else {
+		if (ble_gap_slave[instance].connectable) {
+			rc = 0;
+		}
+		else {
+			rc = BLE_HS_ENOENT;
+		}
+	}
 
-    if (rc == 0) {
-        STATS_INC(ble_gap_stats, connect_slv);
-    }
+	if (rc == 0) {
+		STATS_INC(ble_gap_stats, connect_slv);
+	}
 
-    return rc;
+	return rc;
 }
 #endif
 
 #if NIMBLE_BLE_SCAN
-static int
-ble_gap_rx_adv_report_sanity_check(const uint8_t *adv_data, uint8_t adv_data_len)
+static int ble_gap_rx_adv_report_sanity_check(const uint8_t *adv_data,
+                                              uint8_t adv_data_len)
 {
-    const struct ble_hs_adv_field *flags;
-    int rc;
+	const struct ble_hs_adv_field *flags;
+	int rc;
 
-    STATS_INC(ble_gap_stats, rx_adv_report);
+	STATS_INC(ble_gap_stats, rx_adv_report);
 
-    if (ble_gap_master.op != BLE_GAP_OP_M_DISC) {
-        return -1;
-    }
+	if (ble_gap_master.op != BLE_GAP_OP_M_DISC) {
+		return -1;
+	}
 
-    /* If a limited discovery procedure is active, discard non-limited
-     * advertisements.
-     */
-    if (ble_gap_master.disc.limited) {
-        rc = ble_hs_adv_find_field(BLE_HS_ADV_TYPE_FLAGS, adv_data,
-                                   adv_data_len, &flags);
-        if ((rc == 0) && (flags->length == 2) &&
-            !(flags->value[0] & BLE_HS_ADV_F_DISC_LTD)) {
-            return -1;
-        }
-    }
+	/* If a limited discovery procedure is active, discard non-limited
+	 * advertisements.
+	 */
+	if (ble_gap_master.disc.limited) {
+		rc = ble_hs_adv_find_field(BLE_HS_ADV_TYPE_FLAGS, adv_data, adv_data_len, &flags);
+		if ((rc == 0) && (flags->length == 2) && !(flags->value[0] & BLE_HS_ADV_F_DISC_LTD)) {
+			return -1;
+		}
+	}
 
-    return 0;
+	return 0;
 }
 #endif
 
-void
-ble_gap_rx_adv_report(struct ble_gap_disc_desc *desc)
+void ble_gap_rx_adv_report(struct ble_gap_disc_desc *desc)
 {
 #if NIMBLE_BLE_SCAN
-    if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data)) {
-        return;
-    }
+	if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data)) {
+		return;
+	}
 
-    ble_gap_disc_report(desc);
+	ble_gap_disc_report(desc);
 #endif
 }
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
 #if NIMBLE_BLE_SCAN
-void
-ble_gap_rx_le_scan_timeout(void)
+void ble_gap_rx_le_scan_timeout(void)
 {
-    ble_gap_disc_complete();
+	ble_gap_disc_complete();
 }
 
-void
-ble_gap_rx_ext_adv_report(struct ble_gap_ext_disc_desc *desc)
+void ble_gap_rx_ext_adv_report(struct ble_gap_ext_disc_desc *desc)
 {
-    if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data)) {
-        return;
-    }
+	if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data)) {
+		return;
+	}
 
-    ble_gap_ext_disc_report(desc);
+	ble_gap_ext_disc_report(desc);
 }
 #endif
 
-void
-ble_gap_rx_adv_set_terminated(const struct ble_hci_ev_le_subev_adv_set_terminated *ev)
+void ble_gap_rx_adv_set_terminated(const struct ble_hci_ev_le_subev_adv_set_terminated *ev)
 {
-    uint16_t conn_handle;
-    int reason;
+	uint16_t conn_handle;
+	int reason;
 
-    /* Currently spec allows only 0x3c and 0x43 when advertising was stopped
-     * due to timeout or events limit, mp this for timeout error for now */
-    if (ev->status) {
-        reason = BLE_HS_ETIMEOUT;
-        conn_handle = 0;
-    } else {
-        reason = 0;
-        conn_handle = le16toh(ev->conn_handle);
-    }
+	/* Currently spec allows only 0x3c and 0x43 when advertising was stopped
+	 * due to timeout or events limit, mp this for timeout error for now */
+	if (ev->status) {
+		reason = BLE_HS_ETIMEOUT;
+		conn_handle = 0;
+	}
+	else {
+		reason = 0;
+		conn_handle = le16toh(ev->conn_handle);
+	}
 
-    ble_gap_adv_finished(ev->adv_handle, reason, conn_handle, ev->num_events);
+	ble_gap_adv_finished(ev->adv_handle, reason, conn_handle, ev->num_events);
 }
 
-void
-ble_gap_rx_scan_req_rcvd(const struct ble_hci_ev_le_subev_scan_req_rcvd *ev)
+void ble_gap_rx_scan_req_rcvd(const struct ble_hci_ev_le_subev_scan_req_rcvd *ev)
 {
-    struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+	struct ble_gap_event event;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
 
-    ble_gap_slave_extract_cb(ev->adv_handle, &cb, &cb_arg);
-    if (cb != NULL) {
-        memset(&event, 0, sizeof event);
-        event.type = BLE_GAP_EVENT_SCAN_REQ_RCVD;
-        event.scan_req_rcvd.instance = ev->adv_handle;
-        event.scan_req_rcvd.scan_addr.type = ev->peer_addr_type;
-        memcpy(event.scan_req_rcvd.scan_addr.val, ev->peer_addr, BLE_DEV_ADDR_LEN);
-        cb(&event, cb_arg);
-    }
+	ble_gap_slave_extract_cb(ev->adv_handle, &cb, &cb_arg);
+	if (cb != NULL) {
+		memset(&event, 0, sizeof event);
+		event.type = BLE_GAP_EVENT_SCAN_REQ_RCVD;
+		event.scan_req_rcvd.instance = ev->adv_handle;
+		event.scan_req_rcvd.scan_addr.type = ev->peer_addr_type;
+		memcpy(event.scan_req_rcvd.scan_addr.val, ev->peer_addr, BLE_DEV_ADDR_LEN);
+		cb(&event, cb_arg);
+	}
 }
 #endif
 
 /* Periodic adv events */
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
 
-void
-ble_gap_rx_peroidic_adv_sync_estab(const struct ble_hci_ev_le_subev_periodic_adv_sync_estab *ev)
+void ble_gap_rx_peroidic_adv_sync_estab(
+	const struct ble_hci_ev_le_subev_periodic_adv_sync_estab *ev)
 {
-    uint16_t sync_handle;
-    struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+	uint16_t sync_handle;
+	struct ble_gap_event event;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
 
-    memset(&event, 0, sizeof event);
+	memset(&event, 0, sizeof event);
 
-    event.type = BLE_GAP_EVENT_PERIODIC_SYNC;
-    event.periodic_sync.status = ev->status;
+	event.type = BLE_GAP_EVENT_PERIODIC_SYNC;
+	event.periodic_sync.status = ev->status;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    BLE_HS_DBG_ASSERT(ble_gap_sync.psync);
+	BLE_HS_DBG_ASSERT(ble_gap_sync.psync);
 
-    if (!ev->status) {
-        sync_handle = le16toh(ev->sync_handle);
+	if (!ev->status) {
+		sync_handle = le16toh(ev->sync_handle);
 
-        ble_gap_sync.psync->sync_handle = sync_handle;
-        ble_gap_sync.psync->adv_sid = ev->sid;
-        memcpy(ble_gap_sync.psync->advertiser_addr.val, ev->peer_addr, 6);
-        ble_gap_sync.psync->advertiser_addr.type = ev->peer_addr_type;
+		ble_gap_sync.psync->sync_handle = sync_handle;
+		ble_gap_sync.psync->adv_sid = ev->sid;
+		memcpy(ble_gap_sync.psync->advertiser_addr.val, ev->peer_addr, 6);
+		ble_gap_sync.psync->advertiser_addr.type = ev->peer_addr_type;
 
-        ble_gap_sync.psync->cb = ble_gap_sync.cb;
-        ble_gap_sync.psync->cb_arg = ble_gap_sync.cb_arg;
+		ble_gap_sync.psync->cb = ble_gap_sync.cb;
+		ble_gap_sync.psync->cb_arg = ble_gap_sync.cb_arg;
 
-        event.periodic_sync.sync_handle = sync_handle;
-        event.periodic_sync.sid = ev->sid;
-        event.periodic_sync.adv_addr = ble_gap_sync.psync->advertiser_addr;
-        event.periodic_sync.adv_phy = ev->phy;
-        event.periodic_sync.per_adv_ival = ev->interval;
-        event.periodic_sync.adv_clk_accuracy = ev->aca;
+		event.periodic_sync.sync_handle = sync_handle;
+		event.periodic_sync.sid = ev->sid;
+		event.periodic_sync.adv_addr = ble_gap_sync.psync->advertiser_addr;
+		event.periodic_sync.adv_phy = ev->phy;
+		event.periodic_sync.per_adv_ival = ev->interval;
+		event.periodic_sync.adv_clk_accuracy = ev->aca;
 
-        ble_hs_periodic_sync_insert(ble_gap_sync.psync);
-    } else {
-        ble_hs_periodic_sync_free(ble_gap_sync.psync);
-    }
+		ble_hs_periodic_sync_insert(ble_gap_sync.psync);
+	}
+	else {
+		ble_hs_periodic_sync_free(ble_gap_sync.psync);
+	}
 
-    cb = ble_gap_sync.cb;
-    cb_arg = ble_gap_sync.cb_arg;
+	cb = ble_gap_sync.cb;
+	cb_arg = ble_gap_sync.cb_arg;
 
-    ble_gap_sync.op = BLE_GAP_OP_NULL;
-    ble_gap_sync.cb_arg = NULL;
-    ble_gap_sync.cb_arg = NULL;
-    ble_gap_sync.psync = NULL;
+	ble_gap_sync.op = BLE_GAP_OP_NULL;
+	ble_gap_sync.cb_arg = NULL;
+	ble_gap_sync.cb_arg = NULL;
+	ble_gap_sync.psync = NULL;
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    ble_gap_event_listener_call(&event);
-    if (cb) {
-        cb(&event, cb_arg);
-    }
+	ble_gap_event_listener_call(&event);
+	if (cb) {
+		cb(&event, cb_arg);
+	}
 }
 
-void
-ble_gap_rx_periodic_adv_rpt(const struct ble_hci_ev_le_subev_periodic_adv_rpt *ev)
+void ble_gap_rx_periodic_adv_rpt(const struct ble_hci_ev_le_subev_periodic_adv_rpt *ev)
 {
-    struct ble_hs_periodic_sync *psync;
-    struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+	struct ble_hs_periodic_sync *psync;
+	struct ble_gap_event event;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
 
-    ble_hs_lock();
-    psync = ble_hs_periodic_sync_find_by_handle(le16toh(ev->sync_handle));
-    if (psync) {
-        cb = psync->cb;
-        cb_arg = psync->cb_arg;
-    }
-    ble_hs_unlock();
+	ble_hs_lock();
+	psync = ble_hs_periodic_sync_find_by_handle(le16toh(ev->sync_handle));
+	if (psync) {
+		cb = psync->cb;
+		cb_arg = psync->cb_arg;
+	}
+	ble_hs_unlock();
 
-    if (!psync || !cb) {
-        return;
-    }
+	if (!psync || !cb) {
+		return;
+	}
 
-    memset(&event, 0, sizeof event);
+	memset(&event, 0, sizeof event);
 
-    event.type = BLE_GAP_EVENT_PERIODIC_REPORT;
-    event.periodic_report.sync_handle = psync->sync_handle;
-    event.periodic_report.tx_power = ev->tx_power;
-    event.periodic_report.rssi = ev->rssi;
-    event.periodic_report.data_status = ev->data_status;
-    event.periodic_report.data_length = ev->data_len;
-    event.periodic_report.data = ev->data;
+	event.type = BLE_GAP_EVENT_PERIODIC_REPORT;
+	event.periodic_report.sync_handle = psync->sync_handle;
+	event.periodic_report.tx_power = ev->tx_power;
+	event.periodic_report.rssi = ev->rssi;
+	event.periodic_report.data_status = ev->data_status;
+	event.periodic_report.data_length = ev->data_len;
+	event.periodic_report.data = ev->data;
 
-    /* TODO should we allow for listener too? this can be spammy and is more
-     * like ACL data, not general event
-     */
-     cb(&event, cb_arg);
+	/* TODO should we allow for listener too? this can be spammy and is more
+	 * like ACL data, not general event
+	 */
+	cb(&event, cb_arg);
 }
 
-void
-ble_gap_rx_periodic_adv_sync_lost(const struct ble_hci_ev_le_subev_periodic_adv_sync_lost *ev)
+void ble_gap_rx_periodic_adv_sync_lost(
+	const struct ble_hci_ev_le_subev_periodic_adv_sync_lost *ev)
 {
-    struct ble_hs_periodic_sync *psync;
-    struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+	struct ble_hs_periodic_sync *psync;
+	struct ble_gap_event event;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
 
-    ble_hs_lock();
-    /* The handle must be in the list */
-    psync = ble_hs_periodic_sync_find_by_handle(le16toh(ev->sync_handle));
-    BLE_HS_DBG_ASSERT(psync);
+	ble_hs_lock();
+	/* The handle must be in the list */
+	psync = ble_hs_periodic_sync_find_by_handle(le16toh(ev->sync_handle));
+	BLE_HS_DBG_ASSERT(psync);
 
-    cb = psync->cb;
-    cb_arg = psync->cb_arg;
+	cb = psync->cb;
+	cb_arg = psync->cb_arg;
 
-    /* Remove the handle from the list */
-    ble_hs_periodic_sync_remove(psync);
-    ble_hs_unlock();
+	/* Remove the handle from the list */
+	ble_hs_periodic_sync_remove(psync);
+	ble_hs_unlock();
 
-    memset(&event, 0, sizeof event);
+	memset(&event, 0, sizeof event);
 
-    event.type = BLE_GAP_EVENT_PERIODIC_SYNC_LOST;
-    event.periodic_sync_lost.sync_handle = psync->sync_handle;
-    event.periodic_sync_lost.reason = BLE_HS_ETIMEOUT;
+	event.type = BLE_GAP_EVENT_PERIODIC_SYNC_LOST;
+	event.periodic_sync_lost.sync_handle = psync->sync_handle;
+	event.periodic_sync_lost.reason = BLE_HS_ETIMEOUT;
 
-    /* remove any sync_lost event from queue */
-    ble_npl_eventq_remove(ble_hs_evq_get(), &psync->lost_ev);
+	/* remove any sync_lost event from queue */
+	ble_npl_eventq_remove(ble_hs_evq_get(), &psync->lost_ev);
 
-    /* Free the memory occupied by psync as it is no longer needed */
-    ble_hs_periodic_sync_free(psync);
+	/* Free the memory occupied by psync as it is no longer needed */
+	ble_hs_periodic_sync_free(psync);
 
-    ble_gap_event_listener_call(&event);
-    if (cb) {
-        cb(&event, cb_arg);
-    }
+	ble_gap_event_listener_call(&event);
+	if (cb) {
+		cb(&event, cb_arg);
+	}
 }
 #endif
 
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
-void
-ble_gap_rx_le_pathloss_threshold(const struct ble_hci_ev_le_subev_path_loss_threshold *ev)
+void ble_gap_rx_le_pathloss_threshold(const struct ble_hci_ev_le_subev_path_loss_threshold *ev)
 {
-    struct ble_gap_event event;
-    uint16_t conn_handle = le16toh(ev->conn_handle);
+	struct ble_gap_event event;
+	uint16_t conn_handle = le16toh(ev->conn_handle);
 
-    memset(&event, 0, sizeof event);
+	memset(&event, 0, sizeof event);
 
-    event.type = BLE_GAP_EVENT_PATHLOSS_THRESHOLD;
-    event.pathloss_threshold.conn_handle = conn_handle;
-    event.pathloss_threshold.current_path_loss = ev->current_path_loss;
-    event.pathloss_threshold.zone_entered = ev->zone_entered;
+	event.type = BLE_GAP_EVENT_PATHLOSS_THRESHOLD;
+	event.pathloss_threshold.conn_handle = conn_handle;
+	event.pathloss_threshold.current_path_loss = ev->current_path_loss;
+	event.pathloss_threshold.zone_entered = ev->zone_entered;
 
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 }
 
-void
-ble_gap_rx_transmit_power_report(const struct ble_hci_ev_le_subev_transmit_power_report *ev)
+void ble_gap_rx_transmit_power_report(
+	const struct ble_hci_ev_le_subev_transmit_power_report *ev)
 {
-    struct ble_gap_event event;
-    uint16_t conn_handle = le16toh(ev->conn_handle);
+	struct ble_gap_event event;
+	uint16_t conn_handle = le16toh(ev->conn_handle);
 
-    memset(&event, 0, sizeof event);
+	memset(&event, 0, sizeof event);
 
-    event.type = BLE_GAP_EVENT_TRANSMIT_POWER;
-    event.transmit_power.status = ev->status;
-    event.transmit_power.conn_handle = conn_handle;
-    event.transmit_power.reason = ev->reason;
-    event.transmit_power.phy = ev->phy;
-    event.transmit_power.transmit_power_level = ev->transmit_power_level;
-    event.transmit_power.transmit_power_level_flag = ev->transmit_power_level_flag;
-    event.transmit_power.delta = ev->delta;
+	event.type = BLE_GAP_EVENT_TRANSMIT_POWER;
+	event.transmit_power.status = ev->status;
+	event.transmit_power.conn_handle = conn_handle;
+	event.transmit_power.reason = ev->reason;
+	event.transmit_power.phy = ev->phy;
+	event.transmit_power.transmit_power_level = ev->transmit_power_level;
+	event.transmit_power.transmit_power_level_flag = ev->transmit_power_level_flag;
+	event.transmit_power.delta = ev->delta;
 
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 }
 #endif
 
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_TRANSFER)
-static int
-periodic_adv_transfer_disable(uint16_t conn_handle)
+static int periodic_adv_transfer_disable(uint16_t conn_handle)
 {
-    struct ble_hci_le_periodic_adv_sync_transfer_params_cp cmd;
-    struct ble_hci_le_periodic_adv_sync_transfer_params_rp rsp;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_periodic_adv_sync_transfer_params_cp cmd;
+	struct ble_hci_le_periodic_adv_sync_transfer_params_rp rsp;
+	uint16_t opcode;
+	int rc;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS);
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.sync_cte_type = 0x00;
-    cmd.mode = 0x00;
-    cmd.skip = 0x0000;
-    cmd.sync_timeout = 0x000a;
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.sync_cte_type = 0x00;
+	cmd.mode = 0x00;
+	cmd.skip = 0x0000;
+	cmd.sync_timeout = 0x000a;
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (!rc) {
-        BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
-    }
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+	if (!rc) {
+		BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
+	}
 
-    return rc;
+	return rc;
 }
 
-void
-ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_adv_sync_transfer *ev)
+void ble_gap_rx_periodic_adv_sync_transfer(
+	const struct ble_hci_ev_le_subev_periodic_adv_sync_transfer *ev)
 {
-    struct ble_hci_le_periodic_adv_term_sync_cp cmd_term;
-    struct ble_gap_event event;
-    struct ble_hs_conn *conn;
-    ble_gap_event_fn *cb;
-    uint16_t sync_handle;
-    uint16_t conn_handle;
-    uint16_t opcode;
-    void *cb_arg;
+	struct ble_hci_le_periodic_adv_term_sync_cp cmd_term;
+	struct ble_gap_event event;
+	struct ble_hs_conn *conn;
+	ble_gap_event_fn *cb;
+	uint16_t sync_handle;
+	uint16_t conn_handle;
+	uint16_t opcode;
+	void *cb_arg;
 
-    conn_handle = le16toh(ev->conn_handle);
+	conn_handle = le16toh(ev->conn_handle);
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    /* Unfortunately spec sucks here as it doesn't explicitly stop
-     * transfer reception on first transfer... for now just disable it on
-     * every transfer event we get.
-     */
-    periodic_adv_transfer_disable(conn_handle);
+	/* Unfortunately spec sucks here as it doesn't explicitly stop
+	 * transfer reception on first transfer... for now just disable it on
+	 * every transfer event we get.
+	 */
+	periodic_adv_transfer_disable(conn_handle);
 
-    conn = ble_hs_conn_find(le16toh(ev->conn_handle));
-    if (!conn || !conn->psync) {
-        /* terminate sync if we didn't expect it */
-        if (!ev->status) {
-            opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC);
-            cmd_term.sync_handle = ev->sync_handle;
-            ble_hs_hci_cmd_tx(opcode, &cmd_term, sizeof(cmd_term), NULL, 0);
-        }
+	conn = ble_hs_conn_find(le16toh(ev->conn_handle));
+	if (!conn || !conn->psync) {
+		/* terminate sync if we didn't expect it */
+		if (!ev->status) {
+			opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC);
+			cmd_term.sync_handle = ev->sync_handle;
+			ble_hs_hci_cmd_tx(opcode, &cmd_term, sizeof(cmd_term), NULL, 0);
+		}
 
-        ble_hs_unlock();
-        return;
-    }
+		ble_hs_unlock();
+		return;
+	}
 
-    cb = conn->psync->cb;
-    cb_arg = conn->psync->cb_arg;
+	cb = conn->psync->cb;
+	cb_arg = conn->psync->cb_arg;
 
-    memset(&event, 0, sizeof event);
+	memset(&event, 0, sizeof event);
 
-    event.type = BLE_GAP_EVENT_PERIODIC_TRANSFER;
-    event.periodic_transfer.status = ev->status;
+	event.type = BLE_GAP_EVENT_PERIODIC_TRANSFER;
+	event.periodic_transfer.status = ev->status;
 
-    /* only sync handle is not valid on error */
-    if (ev->status) {
-        sync_handle = 0;
-        ble_hs_periodic_sync_free(conn->psync);
-    } else {
-        sync_handle = le16toh(ev->sync_handle);
+	/* only sync handle is not valid on error */
+	if (ev->status) {
+		sync_handle = 0;
+		ble_hs_periodic_sync_free(conn->psync);
+	}
+	else {
+		sync_handle = le16toh(ev->sync_handle);
 
-        conn->psync->sync_handle = sync_handle;
-        conn->psync->adv_sid = ev->sid;
-        memcpy(conn->psync->advertiser_addr.val, ev->peer_addr, 6);
-        conn->psync->advertiser_addr.type = ev->peer_addr_type;
-        ble_hs_periodic_sync_insert(conn->psync);
-    }
+		conn->psync->sync_handle = sync_handle;
+		conn->psync->adv_sid = ev->sid;
+		memcpy(conn->psync->advertiser_addr.val, ev->peer_addr, 6);
+		conn->psync->advertiser_addr.type = ev->peer_addr_type;
+		ble_hs_periodic_sync_insert(conn->psync);
+	}
 
-    conn->psync = NULL;
+	conn->psync = NULL;
 
-    event.periodic_transfer.sync_handle = sync_handle;
-    event.periodic_transfer.conn_handle = conn_handle;
-    event.periodic_transfer.service_data = le16toh(ev->service_data);
-    event.periodic_transfer.sid = ev->sid;
-    memcpy(event.periodic_transfer.adv_addr.val, ev->peer_addr, 6);
-    event.periodic_transfer.adv_addr.type = ev->peer_addr_type;
+	event.periodic_transfer.sync_handle = sync_handle;
+	event.periodic_transfer.conn_handle = conn_handle;
+	event.periodic_transfer.service_data = le16toh(ev->service_data);
+	event.periodic_transfer.sid = ev->sid;
+	memcpy(event.periodic_transfer.adv_addr.val, ev->peer_addr, 6);
+	event.periodic_transfer.adv_addr.type = ev->peer_addr_type;
 
-    event.periodic_transfer.adv_phy = ev->phy;
-    event.periodic_transfer.per_adv_itvl = le16toh(ev->interval);
-    event.periodic_transfer.adv_clk_accuracy = ev->aca;
+	event.periodic_transfer.adv_phy = ev->phy;
+	event.periodic_transfer.per_adv_itvl = le16toh(ev->interval);
+	event.periodic_transfer.adv_clk_accuracy = ev->aca;
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    cb(&event, cb_arg);
+	cb(&event, cb_arg);
 }
 #endif
 
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_BIGINFO_REPORTS)
-void
-ble_gap_rx_biginfo_adv_rpt(const struct ble_hci_ev_le_subev_biginfo_adv_report *ev)
-{
-    struct ble_hs_periodic_sync *psync;
-    struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
-
-    cb = NULL;
-    cb_arg = NULL;
-
-    ble_hs_lock();
-    psync = ble_hs_periodic_sync_find_by_handle(le16toh(ev->sync_handle));
-    if (psync) {
-        cb = psync->cb;
-        cb_arg = psync->cb_arg;
-    }
-    ble_hs_unlock();
-
-    memset(&event, 0, sizeof event);
-
-    event.type = BLE_GAP_EVENT_BIGINFO_REPORT;
-    event.biginfo_report.sync_handle = ev->sync_handle;
-    event.biginfo_report.bis_cnt = ev->bis_cnt;
-    event.biginfo_report.nse = ev->nse;
-    event.biginfo_report.iso_interval = ev->iso_interval;
-    event.biginfo_report.bn = ev->bn;
-    event.biginfo_report.pto = ev->pto;
-    event.biginfo_report.irc = ev->irc;
-    event.biginfo_report.max_pdu = ev->max_pdu;
-    event.biginfo_report.sdu_interval = get_le24(&ev->sdu_interval[0]);
-    event.biginfo_report.max_sdu = ev->max_sdu;
-    event.biginfo_report.phy = ev->phy;
-    event.biginfo_report.framing = ev->framing;
-    event.biginfo_report.encryption = ev->encryption;
-
-    ble_gap_event_listener_call(&event);
-    if (cb) {
-        cb(&event, cb_arg);
-    }
+void ble_gap_rx_biginfo_adv_rpt(const struct ble_hci_ev_le_subev_biginfo_adv_report *ev)
+{
+	struct ble_hs_periodic_sync *psync;
+	struct ble_gap_event event;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
+
+	cb = NULL;
+	cb_arg = NULL;
+
+	ble_hs_lock();
+	psync = ble_hs_periodic_sync_find_by_handle(le16toh(ev->sync_handle));
+	if (psync) {
+		cb = psync->cb;
+		cb_arg = psync->cb_arg;
+	}
+	ble_hs_unlock();
+
+	memset(&event, 0, sizeof event);
+
+	event.type = BLE_GAP_EVENT_BIGINFO_REPORT;
+	event.biginfo_report.sync_handle = ev->sync_handle;
+	event.biginfo_report.bis_cnt = ev->bis_cnt;
+	event.biginfo_report.nse = ev->nse;
+	event.biginfo_report.iso_interval = ev->iso_interval;
+	event.biginfo_report.bn = ev->bn;
+	event.biginfo_report.pto = ev->pto;
+	event.biginfo_report.irc = ev->irc;
+	event.biginfo_report.max_pdu = ev->max_pdu;
+	event.biginfo_report.sdu_interval = get_le24(&ev->sdu_interval[0]);
+	event.biginfo_report.max_sdu = ev->max_sdu;
+	event.biginfo_report.phy = ev->phy;
+	event.biginfo_report.framing = ev->framing;
+	event.biginfo_report.encryption = ev->encryption;
+
+	ble_gap_event_listener_call(&event);
+	if (cb) {
+		cb(&event, cb_arg);
+	}
 }
 #endif
 
 #if MYNEWT_VAL(BLE_CONN_SUBRATING)
-void
-ble_gap_rx_subrate_change(const struct ble_hci_ev_le_subev_subrate_change *ev)
+void ble_gap_rx_subrate_change(const struct ble_hci_ev_le_subev_subrate_change *ev)
 {
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    memset(&event, 0x0, sizeof event);
+	memset(&event, 0x0, sizeof event);
 
-    event.type = BLE_GAP_EVENT_SUBRATE_CHANGE;
-    event.subrate_change.status = ev->status;
-    event.subrate_change.conn_handle = le16toh(ev->conn_handle);
-    event.subrate_change.subrate_factor = le16toh(ev->subrate_factor);
-    event.subrate_change.periph_latency = le16toh(ev->periph_latency);
-    event.subrate_change.cont_num = le16toh(ev->cont_num);
-    event.subrate_change.supervision_tmo = le16toh(ev->supervision_tmo);
+	event.type = BLE_GAP_EVENT_SUBRATE_CHANGE;
+	event.subrate_change.status = ev->status;
+	event.subrate_change.conn_handle = le16toh(ev->conn_handle);
+	event.subrate_change.subrate_factor = le16toh(ev->subrate_factor);
+	event.subrate_change.periph_latency = le16toh(ev->periph_latency);
+	event.subrate_change.cont_num = le16toh(ev->cont_num);
+	event.subrate_change.supervision_tmo = le16toh(ev->supervision_tmo);
 
-    ble_gap_event_listener_call(&event);
+	ble_gap_event_listener_call(&event);
 }
 #endif
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_gap_rd_rem_sup_feat_tx(uint16_t handle)
+static int ble_gap_rd_rem_sup_feat_tx(uint16_t handle)
 {
-    struct ble_hci_le_rd_rem_feat_cp cmd;
+	struct ble_hci_le_rd_rem_feat_cp cmd;
 
-    cmd.conn_handle = htole16(handle);
+	cmd.conn_handle = htole16(handle);
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_RD_REM_FEAT),
-                             &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_REM_FEAT),
+	                         &cmd, sizeof(cmd), NULL, 0);
 }
 #endif
 
@@ -1993,344 +1943,342 @@ ble_gap_rd_rem_sup_feat_tx(uint16_t handle)
  * Processes an incoming connection-complete HCI event.
  * instance parameter is valid only for slave connection.
  */
-int
-ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
+int ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
-    struct ble_hs_conn *conn;
-    int rc;
-
-    STATS_INC(ble_gap_stats, rx_conn_complete);
-
-    /* in that case *only* status field is valid so we determine role
-     * based on error code
-     */
-    if (evt->status != BLE_ERR_SUCCESS) {
-        switch (evt->status) {
-        case BLE_ERR_DIR_ADV_TMO:
-            /* slave role (HD directed advertising)
-             *
-             * with ext advertising this is send from set terminated event
-             */
+	struct ble_gap_event event;
+	struct ble_hs_conn *conn;
+	int rc;
+
+	STATS_INC(ble_gap_stats, rx_conn_complete);
+
+	/* in that case *only* status field is valid so we determine role
+	 * based on error code
+	 */
+	if (evt->status != BLE_ERR_SUCCESS) {
+		switch (evt->status) {
+		case BLE_ERR_DIR_ADV_TMO:
+			/* slave role (HD directed advertising)
+			 *
+			 * with ext advertising this is send from set terminated event
+			 */
 #if !MYNEWT_VAL(BLE_EXT_ADV)
-            if (ble_gap_adv_active()) {
-                ble_gap_adv_finished(0, 0, 0, 0);
-            }
-#endif
-            break;
-        case BLE_ERR_UNK_CONN_ID:
-            /* master role */
-            if (ble_gap_master_in_progress()) {
-                /* Connect procedure successfully cancelled. */
-                if (ble_gap_master.preempted_op == BLE_GAP_OP_M_CONN) {
-                    ble_gap_master_failed(BLE_HS_EPREEMPTED);
-                } else {
-                    ble_gap_master_connect_cancelled();
-                }
-            }
-            break;
-        default:
-            /* this should never happen, unless controller is broken */
-            BLE_HS_LOG(INFO, "controller reported invalid error code in conn"
-                             "complete event: %u", evt->status);
-            assert(0);
-            break;
-        }
-        return 0;
-    }
-
-    /* Apply the event to the existing connection if it exists. */
-    if (ble_hs_atomic_conn_flags(evt->connection_handle, NULL) == 0) {
-        /* XXX: Does this ever happen? */
-        return 0;
-    }
-
-    /* This event refers to a new connection. */
-
-    switch (evt->role) {
-    case BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER:
-        rc = ble_gap_accept_master_conn();
-        if (rc != 0) {
-            return rc;
-        }
-        break;
-
-    case BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE:
-        rc = ble_gap_accept_slave_conn(instance);
-        if (rc != 0) {
-            return rc;
-        }
-        break;
-
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        break;
-    }
-
-    /* We verified that there is a free connection when the procedure began. */
-    conn = ble_hs_conn_alloc(evt->connection_handle);
-    BLE_HS_DBG_ASSERT(conn != NULL);
-
-    conn->bhc_itvl = evt->conn_itvl;
-    conn->bhc_latency = evt->conn_latency;
-    conn->bhc_supervision_timeout = evt->supervision_timeout;
-    conn->bhc_master_clock_accuracy = evt->master_clk_acc;
-    if (evt->role == BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER) {
-        conn->bhc_cb = ble_gap_master.cb;
-        conn->bhc_cb_arg = ble_gap_master.cb_arg;
-        conn->bhc_flags |= BLE_HS_CONN_F_MASTER;
-        conn->bhc_our_addr_type = ble_gap_master.conn.our_addr_type;
-        ble_gap_master_reset_state();
-    } else {
-        conn->bhc_cb = ble_gap_slave[instance].cb;
-        conn->bhc_cb_arg = ble_gap_slave[instance].cb_arg;
-        conn->bhc_our_addr_type = ble_gap_slave[instance].our_addr_type;
+			if (ble_gap_adv_active()) {
+				ble_gap_adv_finished(0, 0, 0, 0);
+			}
+#endif
+			break;
+		case BLE_ERR_UNK_CONN_ID:
+			/* master role */
+			if (ble_gap_master_in_progress()) {
+				/* Connect procedure successfully cancelled. */
+				if (ble_gap_master.preempted_op == BLE_GAP_OP_M_CONN) {
+					ble_gap_master_failed(BLE_HS_EPREEMPTED);
+				}
+				else {
+					ble_gap_master_connect_cancelled();
+				}
+			}
+			break;
+		default:
+			/* this should never happen, unless controller is broken */
+			BLE_HS_LOG(INFO,
+			           "controller reported invalid error code in conn"
+			           "complete event: %u",
+			           evt->status);
+			assert(0);
+			break;
+		}
+		return 0;
+	}
+
+	/* Apply the event to the existing connection if it exists. */
+	if (ble_hs_atomic_conn_flags(evt->connection_handle, NULL) == 0) {
+		/* XXX: Does this ever happen? */
+		return 0;
+	}
+
+	/* This event refers to a new connection. */
+
+	switch (evt->role) {
+	case BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER:
+		rc = ble_gap_accept_master_conn();
+		if (rc != 0) {
+			return rc;
+		}
+		break;
+
+	case BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE:
+		rc = ble_gap_accept_slave_conn(instance);
+		if (rc != 0) {
+			return rc;
+		}
+		break;
+
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		break;
+	}
+
+	/* We verified that there is a free connection when the procedure began. */
+	conn = ble_hs_conn_alloc(evt->connection_handle);
+	BLE_HS_DBG_ASSERT(conn != NULL);
+
+	conn->bhc_itvl = evt->conn_itvl;
+	conn->bhc_latency = evt->conn_latency;
+	conn->bhc_supervision_timeout = evt->supervision_timeout;
+	conn->bhc_master_clock_accuracy = evt->master_clk_acc;
+	if (evt->role == BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER) {
+		conn->bhc_cb = ble_gap_master.cb;
+		conn->bhc_cb_arg = ble_gap_master.cb_arg;
+		conn->bhc_flags |= BLE_HS_CONN_F_MASTER;
+		conn->bhc_our_addr_type = ble_gap_master.conn.our_addr_type;
+		ble_gap_master_reset_state();
+	}
+	else {
+		conn->bhc_cb = ble_gap_slave[instance].cb;
+		conn->bhc_cb_arg = ble_gap_slave[instance].cb_arg;
+		conn->bhc_our_addr_type = ble_gap_slave[instance].our_addr_type;
 #if MYNEWT_VAL(BLE_EXT_ADV)
-        memcpy(conn->bhc_our_rnd_addr, ble_gap_slave[instance].rnd_addr, 6);
+		memcpy(conn->bhc_our_rnd_addr, ble_gap_slave[instance].rnd_addr, 6);
 #endif
-        ble_gap_slave_reset_state(instance);
-    }
+		ble_gap_slave_reset_state(instance);
+	}
 
-    conn->bhc_peer_addr.type = evt->peer_addr_type;
-    memcpy(conn->bhc_peer_addr.val, evt->peer_addr, 6);
+	conn->bhc_peer_addr.type = evt->peer_addr_type;
+	memcpy(conn->bhc_peer_addr.val, evt->peer_addr, 6);
 
-    conn->bhc_our_rpa_addr.type = BLE_ADDR_RANDOM;
-    memcpy(conn->bhc_our_rpa_addr.val, evt->local_rpa, 6);
+	conn->bhc_our_rpa_addr.type = BLE_ADDR_RANDOM;
+	memcpy(conn->bhc_our_rpa_addr.val, evt->local_rpa, 6);
 
-    /* If peer RPA is not set in the event and peer address
-     * is RPA then store the peer RPA address so when the peer
-     * address is resolved, the RPA is not forgotten.
-     */
-    if (memcmp(BLE_ADDR_ANY->val, evt->peer_rpa, 6) == 0) {
-        if (BLE_ADDR_IS_RPA(&conn->bhc_peer_addr)) {
-            conn->bhc_peer_rpa_addr = conn->bhc_peer_addr;
-        }
-    } else {
-        conn->bhc_peer_rpa_addr.type = BLE_ADDR_RANDOM;
-        memcpy(conn->bhc_peer_rpa_addr.val, evt->peer_rpa, 6);
-    }
+	/* If peer RPA is not set in the event and peer address
+	 * is RPA then store the peer RPA address so when the peer
+	 * address is resolved, the RPA is not forgotten.
+	 */
+	if (memcmp(BLE_ADDR_ANY->val, evt->peer_rpa, 6) == 0) {
+		if (BLE_ADDR_IS_RPA(&conn->bhc_peer_addr)) {
+			conn->bhc_peer_rpa_addr = conn->bhc_peer_addr;
+		}
+	}
+	else {
+		conn->bhc_peer_rpa_addr.type = BLE_ADDR_RANDOM;
+		memcpy(conn->bhc_peer_rpa_addr.val, evt->peer_rpa, 6);
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    memset(&event, 0, sizeof event);
-    ble_hs_conn_insert(conn);
+	memset(&event, 0, sizeof event);
+	ble_hs_conn_insert(conn);
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    event.type = BLE_GAP_EVENT_CONNECT;
-    event.connect.conn_handle = evt->connection_handle;
-    event.connect.status = 0;
+	event.type = BLE_GAP_EVENT_CONNECT;
+	event.connect.conn_handle = evt->connection_handle;
+	event.connect.status = 0;
 
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, evt->connection_handle);
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, evt->connection_handle);
 
-    ble_gap_rd_rem_sup_feat_tx(evt->connection_handle);
+	ble_gap_rd_rem_sup_feat_tx(evt->connection_handle);
 
-    return 0;
+	return 0;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-void
-ble_gap_rx_rd_rem_sup_feat_complete(const struct ble_hci_ev_le_subev_rd_rem_used_feat *ev)
+void ble_gap_rx_rd_rem_sup_feat_complete(const struct ble_hci_ev_le_subev_rd_rem_used_feat *ev)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn *conn;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(le16toh(ev->conn_handle));
-    if ((conn != NULL) && (ev->status == 0)) {
-        conn->supported_feat = get_le32(ev->features);
-    }
+	conn = ble_hs_conn_find(le16toh(ev->conn_handle));
+	if ((conn != NULL) && (ev->status == 0)) {
+		conn->supported_feat = get_le32(ev->features);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 #endif
 }
 
-int
-ble_gap_rx_l2cap_update_req(uint16_t conn_handle,
-                            struct ble_gap_upd_params *params)
+int ble_gap_rx_l2cap_update_req(uint16_t conn_handle, struct ble_gap_upd_params *params)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
-    int rc;
+	struct ble_gap_event event;
+	int rc;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_L2CAP_UPDATE_REQ;
-    event.conn_update_req.conn_handle = conn_handle;
-    event.conn_update_req.peer_params = params;
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_L2CAP_UPDATE_REQ;
+	event.conn_update_req.conn_handle = conn_handle;
+	event.conn_update_req.peer_params = params;
 
-    rc = ble_gap_call_conn_event_cb(&event, conn_handle);
-    return rc;
+	rc = ble_gap_call_conn_event_cb(&event, conn_handle);
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-void
-ble_gap_rx_phy_update_complete(const struct ble_hci_ev_le_subev_phy_update_complete *ev)
+void ble_gap_rx_phy_update_complete(const struct ble_hci_ev_le_subev_phy_update_complete *ev)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
-    uint16_t conn_handle = le16toh(ev->conn_handle);
+	struct ble_gap_event event;
+	uint16_t conn_handle = le16toh(ev->conn_handle);
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_PHY_UPDATE_COMPLETE;
-    event.phy_updated.status = ev->status;
-    event.phy_updated.conn_handle = conn_handle;
-    event.phy_updated.tx_phy = ev->tx_phy;
-    event.phy_updated.rx_phy = ev->rx_phy;
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_PHY_UPDATE_COMPLETE;
+	event.phy_updated.status = ev->status;
+	event.phy_updated.conn_handle = conn_handle;
+	event.phy_updated.tx_phy = ev->tx_phy;
+	event.phy_updated.rx_phy = ev->rx_phy;
 
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 #endif
 }
 
-static int32_t
-ble_gap_master_timer(void)
+static int32_t ble_gap_master_timer(void)
 {
-    uint32_t ticks_until_exp;
+	uint32_t ticks_until_exp;
 #if NIMBLE_BLE_SCAN || NIMBLE_BLE_CONNECT
-    int rc;
+	int rc;
 #endif
 
-    ticks_until_exp = ble_gap_master_ticks_until_exp();
-    if (ticks_until_exp != 0) {
-        /* Timer not expired yet. */
-        return ticks_until_exp;
-    }
+	ticks_until_exp = ble_gap_master_ticks_until_exp();
+	if (ticks_until_exp != 0) {
+		/* Timer not expired yet. */
+		return ticks_until_exp;
+	}
 
-    /*** Timer expired; process event. */
+	/*** Timer expired; process event. */
 
-    switch (ble_gap_master.op) {
+	switch (ble_gap_master.op) {
 #if NIMBLE_BLE_CONNECT
-    case BLE_GAP_OP_M_CONN:
-        rc = ble_gap_conn_cancel_tx();
-        if (rc != 0) {
-            /* Failed to stop connecting; try again in 100 ms. */
-            return ble_npl_time_ms_to_ticks32(BLE_GAP_CANCEL_RETRY_TIMEOUT_MS);
-        } else {
-            /* Stop the timer now that the cancel command has been acked. */
-            ble_gap_master.exp_set = 0;
-
-            /* Timeout gets reported when we receive a connection complete
-             * event indicating the connect procedure has been cancelled.
-             */
-            /* XXX: Set a timer to reset the controller if a connection
-             * complete event isn't received within a reasonable interval.
-             */
-        }
-        break;
-#endif
-
-    case BLE_GAP_OP_M_DISC:
+	case BLE_GAP_OP_M_CONN:
+		rc = ble_gap_conn_cancel_tx();
+		if (rc != 0) {
+			/* Failed to stop connecting; try again in 100 ms. */
+			return ble_npl_time_ms_to_ticks32(BLE_GAP_CANCEL_RETRY_TIMEOUT_MS);
+		}
+		else {
+			/* Stop the timer now that the cancel command has been acked. */
+			ble_gap_master.exp_set = 0;
+
+			/* Timeout gets reported when we receive a connection complete
+			 * event indicating the connect procedure has been cancelled.
+			 */
+			/* XXX: Set a timer to reset the controller if a connection
+			 * complete event isn't received within a reasonable interval.
+			 */
+		}
+		break;
+#endif
+
+	case BLE_GAP_OP_M_DISC:
 #if NIMBLE_BLE_SCAN && !MYNEWT_VAL(BLE_EXT_ADV)
-        /* When a discovery procedure times out, it is not a failure. */
-        rc = ble_gap_disc_enable_tx(0, 0);
-        if (rc != 0) {
-            /* Failed to stop discovery; try again in 100 ms. */
-            return ble_npl_time_ms_to_ticks32(BLE_GAP_CANCEL_RETRY_TIMEOUT_MS);
-        }
-
-        ble_gap_disc_complete();
+		/* When a discovery procedure times out, it is not a failure. */
+		rc = ble_gap_disc_enable_tx(0, 0);
+		if (rc != 0) {
+			/* Failed to stop discovery; try again in 100 ms. */
+			return ble_npl_time_ms_to_ticks32(BLE_GAP_CANCEL_RETRY_TIMEOUT_MS);
+		}
+
+		ble_gap_disc_complete();
 #else
-        assert(0);
+		assert(0);
 #endif
-        break;
+		break;
 
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        break;
-    }
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		break;
+	}
 
-    return BLE_HS_FOREVER;
+	return BLE_HS_FOREVER;
 }
 
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-static int32_t
-ble_gap_slave_timer(void)
+static int32_t ble_gap_slave_timer(void)
 {
-    uint32_t ticks_until_exp;
-    int rc;
+	uint32_t ticks_until_exp;
+	int rc;
 
-    ticks_until_exp = ble_gap_slave_ticks_until_exp();
-    if (ticks_until_exp != 0) {
-        /* Timer not expired yet. */
-        return ticks_until_exp;
-    }
+	ticks_until_exp = ble_gap_slave_ticks_until_exp();
+	if (ticks_until_exp != 0) {
+		/* Timer not expired yet. */
+		return ticks_until_exp;
+	}
 
-    /*** Timer expired; process event. */
+	/*** Timer expired; process event. */
 
-    /* Stop advertising. */
-    rc = ble_gap_adv_enable_tx(0);
-    if (rc != 0) {
-        /* Failed to stop advertising; try again in 100 ms. */
-        return 100;
-    }
+	/* Stop advertising. */
+	rc = ble_gap_adv_enable_tx(0);
+	if (rc != 0) {
+		/* Failed to stop advertising; try again in 100 ms. */
+		return 100;
+	}
 
-    /* Clear the timer and cancel the current procedure. */
-    ble_gap_slave_reset_state(0);
+	/* Clear the timer and cancel the current procedure. */
+	ble_gap_slave_reset_state(0);
 
-    /* Indicate to application that advertising has stopped. */
-    ble_gap_adv_finished(0, BLE_HS_ETIMEOUT, 0, 0);
+	/* Indicate to application that advertising has stopped. */
+	ble_gap_adv_finished(0, BLE_HS_ETIMEOUT, 0, 0);
 
-    return BLE_HS_FOREVER;
+	return BLE_HS_FOREVER;
 }
 #endif
 
-static int32_t
-ble_gap_update_timer(void)
+static int32_t ble_gap_update_timer(void)
 {
-    struct ble_gap_update_entry *entry;
-    int32_t ticks_until_exp;
-    uint16_t conn_handle;
+	struct ble_gap_update_entry *entry;
+	int32_t ticks_until_exp;
+	uint16_t conn_handle;
 
-    do {
-        ble_hs_lock();
+	do {
+		ble_hs_lock();
 
-        conn_handle = ble_gap_update_next_exp(&ticks_until_exp);
-        if (ticks_until_exp == 0) {
-            entry = ble_gap_update_entry_remove(conn_handle);
-        } else {
-            entry = NULL;
-        }
+		conn_handle = ble_gap_update_next_exp(&ticks_until_exp);
+		if (ticks_until_exp == 0) {
+			entry = ble_gap_update_entry_remove(conn_handle);
+		}
+		else {
+			entry = NULL;
+		}
 
-        ble_hs_unlock();
+		ble_hs_unlock();
 
-        if (entry != NULL) {
-            ble_gap_update_entry_free(entry);
-        }
-    } while (entry != NULL);
+		if (entry != NULL) {
+			ble_gap_update_entry_free(entry);
+		}
+	} while (entry != NULL);
 
-    return ticks_until_exp;
+	return ticks_until_exp;
 }
 
-int
-ble_gap_set_event_cb(uint16_t conn_handle, ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_set_event_cb(uint16_t conn_handle, ble_gap_event_fn *cb, void *cb_arg)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn *conn;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
-        conn->bhc_cb = cb;
-        conn->bhc_cb_arg = cb_arg;
-    }
+	conn = ble_hs_conn_find(conn_handle);
+	if (conn != NULL) {
+		conn->bhc_cb = cb;
+		conn->bhc_cb_arg = cb_arg;
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (conn == NULL) {
-        return BLE_HS_ENOTCONN;
-    }
+	if (conn == NULL) {
+		return BLE_HS_ENOTCONN;
+	}
 
-    return 0;
+	return 0;
 #else
-    return BLE_HS_ENOTCONN;
+	return BLE_HS_ENOTCONN;
 #endif
 }
 
@@ -2340,23 +2288,22 @@ ble_gap_set_event_cb(uint16_t conn_handle, ble_gap_event_fn *cb, void *cb_arg)
  * @return                      The number of ticks until this function should
  *                                  be called again.
  */
-int32_t
-ble_gap_timer(void)
+int32_t ble_gap_timer(void)
 {
-    int32_t update_ticks;
-    int32_t master_ticks;
-    int32_t min_ticks;
+	int32_t update_ticks;
+	int32_t master_ticks;
+	int32_t min_ticks;
 
-    master_ticks = ble_gap_master_timer();
-    update_ticks = ble_gap_update_timer();
+	master_ticks = ble_gap_master_timer();
+	update_ticks = ble_gap_update_timer();
 
-    min_ticks = min(master_ticks, update_ticks);
+	min_ticks = min(master_ticks, update_ticks);
 
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-    min_ticks = min(min_ticks, ble_gap_slave_timer());
+	min_ticks = min(min_ticks, ble_gap_slave_timer());
 #endif
 
-    return min_ticks;
+	return min_ticks;
 }
 
 /*****************************************************************************
@@ -2364,98 +2311,89 @@ ble_gap_timer(void)
  *****************************************************************************/
 
 #if MYNEWT_VAL(BLE_WHITELIST)
-static int
-ble_gap_wl_busy(void)
+static int ble_gap_wl_busy(void)
 {
-    /* Check if an auto or selective connection establishment procedure is in
-     * progress.
-     */
-    return ble_gap_master.op == BLE_GAP_OP_M_CONN &&
-           ble_gap_master.conn.using_wl;
+	/* Check if an auto or selective connection establishment procedure is in
+	 * progress.
+	 */
+	return ble_gap_master.op == BLE_GAP_OP_M_CONN && ble_gap_master.conn.using_wl;
 }
 
-static int
-ble_gap_wl_tx_add(const ble_addr_t *addr)
+static int ble_gap_wl_tx_add(const ble_addr_t *addr)
 {
-    struct ble_hci_le_add_whte_list_cp cmd;
+	struct ble_hci_le_add_whte_list_cp cmd;
 
-    if (addr->type > BLE_ADDR_RANDOM) {
-        return BLE_HS_EINVAL;
-    }
+	if (addr->type > BLE_ADDR_RANDOM) {
+		return BLE_HS_EINVAL;
+	}
 
-    memcpy(cmd.addr, addr->val, BLE_DEV_ADDR_LEN);
-    cmd.addr_type = addr->type;
+	memcpy(cmd.addr, addr->val, BLE_DEV_ADDR_LEN);
+	cmd.addr_type = addr->type;
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_ADD_WHITE_LIST),
-                             &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_ADD_WHITE_LIST),
+	                         &cmd, sizeof(cmd), NULL, 0);
 }
 
-static int
-ble_gap_wl_tx_clear(void)
+static int ble_gap_wl_tx_clear(void)
 {
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_CLEAR_WHITE_LIST),
-                             NULL, 0, NULL, 0 );
+	return ble_hs_hci_cmd_tx(
+		BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CLEAR_WHITE_LIST), NULL, 0, NULL, 0);
 }
 #endif
 
-int
-ble_gap_wl_set(const ble_addr_t *addrs, uint8_t white_list_count)
+int ble_gap_wl_set(const ble_addr_t *addrs, uint8_t white_list_count)
 {
 #if MYNEWT_VAL(BLE_WHITELIST)
-    int rc;
-    int i;
-
-    STATS_INC(ble_gap_stats, wl_set);
+	int rc;
+	int i;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	STATS_INC(ble_gap_stats, wl_set);
 
-    ble_hs_lock();
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    for (i = 0; i < white_list_count; i++) {
-        if (addrs[i].type != BLE_ADDR_PUBLIC &&
-            addrs[i].type != BLE_ADDR_RANDOM) {
+	ble_hs_lock();
 
-            rc = BLE_HS_EINVAL;
-            goto done;
-        }
-    }
+	for (i = 0; i < white_list_count; i++) {
+		if (addrs[i].type != BLE_ADDR_PUBLIC && addrs[i].type != BLE_ADDR_RANDOM) {
+			rc = BLE_HS_EINVAL;
+			goto done;
+		}
+	}
 
-    if (ble_gap_wl_busy()) {
-        rc = BLE_HS_EBUSY;
-        goto done;
-    }
+	if (ble_gap_wl_busy()) {
+		rc = BLE_HS_EBUSY;
+		goto done;
+	}
 
-    BLE_HS_LOG(INFO, "GAP procedure initiated: set whitelist; ");
-    ble_gap_log_wl(addrs, white_list_count);
-    BLE_HS_LOG(INFO, "\n");
+	BLE_HS_LOG(INFO, "GAP procedure initiated: set whitelist; ");
+	ble_gap_log_wl(addrs, white_list_count);
+	BLE_HS_LOG(INFO, "\n");
 
-    rc = ble_gap_wl_tx_clear();
-    if (rc != 0) {
-        goto done;
-    }
+	rc = ble_gap_wl_tx_clear();
+	if (rc != 0) {
+		goto done;
+	}
 
-    for (i = 0; i < white_list_count; i++) {
-        rc = ble_gap_wl_tx_add(addrs + i);
-        if (rc != 0) {
-            goto done;
-        }
-    }
+	for (i = 0; i < white_list_count; i++) {
+		rc = ble_gap_wl_tx_add(addrs + i);
+		if (rc != 0) {
+			goto done;
+		}
+	}
 
-    rc = 0;
+	rc = 0;
 
 done:
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, wl_set_fail);
-    }
-    return rc;
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, wl_set_fail);
+	}
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
@@ -2463,71 +2401,68 @@ done:
  * $stop advertise                                                           *
  *****************************************************************************/
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-static int
-ble_gap_adv_enable_tx(int enable)
+static int ble_gap_adv_enable_tx(int enable)
 {
-    struct ble_hci_le_set_adv_enable_cp cmd;
+	struct ble_hci_le_set_adv_enable_cp cmd;
 
-    cmd.enable = !!enable;
-
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_SET_ADV_ENABLE),
-                             &cmd, sizeof(cmd), NULL, 0);
+	cmd.enable = !!enable;
+	// TODO: Here we set a pairable flag?
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_ADV_ENABLE),
+	                         &cmd, sizeof(cmd), NULL, 0);
 }
 
-static int
-ble_gap_adv_stop_no_lock(void)
+static int ble_gap_adv_stop_no_lock(void)
 {
-    bool active;
-    int rc;
+	bool active;
+	int rc;
 
-    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
+	BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
-    STATS_INC(ble_gap_stats, adv_stop);
+	STATS_INC(ble_gap_stats, adv_stop);
 
-    active = ble_gap_adv_active();
+	active = ble_gap_adv_active();
 
-    BLE_HS_LOG(INFO, "GAP procedure initiated: stop advertising.\n");
+	BLE_HS_LOG(INFO, "GAP procedure initiated: stop advertising.\n");
 
-    rc = ble_gap_adv_enable_tx(0);
-    if (rc != 0) {
-        goto done;
-    }
+	rc = ble_gap_adv_enable_tx(0);
+	if (rc != 0) {
+		goto done;
+	}
 
-    ble_gap_slave_reset_state(0);
+	ble_gap_slave_reset_state(0);
 
-    if (!active) {
-        rc = BLE_HS_EALREADY;
-    } else {
-        rc = 0;
-    }
+	if (!active) {
+		rc = BLE_HS_EALREADY;
+	}
+	else {
+		rc = 0;
+	}
 
 done:
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, adv_stop_fail);
-    }
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, adv_stop_fail);
+	}
 
-    return rc;
+	return rc;
 }
 #endif
 
-int
-ble_gap_adv_stop(void)
+int ble_gap_adv_stop(void)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-    int rc;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
-    rc = ble_gap_adv_stop_no_lock();
-    ble_hs_unlock();
+	ble_hs_lock();
+	rc = ble_gap_adv_stop_no_lock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
@@ -2535,2013 +2470,1952 @@ ble_gap_adv_stop(void)
  * $advertise                                                                *
  *****************************************************************************/
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-static int
-ble_gap_adv_type(const struct ble_gap_adv_params *adv_params)
-{
-    switch (adv_params->conn_mode) {
-    case BLE_GAP_CONN_MODE_NON:
-        if (adv_params->disc_mode == BLE_GAP_DISC_MODE_NON) {
-            return BLE_HCI_ADV_TYPE_ADV_NONCONN_IND;
-        } else {
-            return BLE_HCI_ADV_TYPE_ADV_SCAN_IND;
-        }
-
-    case BLE_GAP_CONN_MODE_UND:
-        return BLE_HCI_ADV_TYPE_ADV_IND;
-
-    case BLE_GAP_CONN_MODE_DIR:
-        if (adv_params->high_duty_cycle) {
-            return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD;
-        } else {
-            return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD;
-        }
-
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        return BLE_HCI_ADV_TYPE_ADV_IND;
-    }
-}
-
-static void
-ble_gap_adv_dflt_itvls(uint8_t conn_mode,
-                       uint16_t *out_itvl_min, uint16_t *out_itvl_max)
-{
-    switch (conn_mode) {
-    case BLE_GAP_CONN_MODE_NON:
-        *out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL2_MIN;
-        *out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL2_MAX;
-        break;
-
-    case BLE_GAP_CONN_MODE_UND:
-        *out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL1_MIN;
-        *out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL1_MAX;
-        break;
-
-    case BLE_GAP_CONN_MODE_DIR:
-        *out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL1_MIN;
-        *out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL1_MAX;
-        break;
-
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        *out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL1_MIN;
-        *out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL1_MAX;
-        break;
-    }
-}
-
-static int
-ble_gap_adv_params_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                      const struct ble_gap_adv_params *adv_params)
-
-{
-    const ble_addr_t *peer_any = BLE_ADDR_ANY;
-    struct ble_hci_le_set_adv_params_cp cmd;
-    uint16_t opcode;
-    uint16_t min;
-    uint16_t max;
-
-    /* Fill optional fields if application did not specify them. */
-    if ((adv_params->itvl_min == 0) && (adv_params->itvl_max == 0)) {
-        ble_gap_adv_dflt_itvls(adv_params->conn_mode, &min, &max);
-        cmd.min_interval = htole16(min);
-        cmd.max_interval = htole16(max);
-    } else {
-        cmd.min_interval = htole16(adv_params->itvl_min);
-        cmd.max_interval = htole16(adv_params->itvl_max);
-    }
-
-    cmd.type = ble_gap_adv_type(adv_params);
-    cmd.own_addr_type = own_addr_type;
-
-    if (peer_addr == NULL) {
-        peer_addr = peer_any;
-    }
-
-    cmd.peer_addr_type = peer_addr->type;
-    memcpy(&cmd.peer_addr, peer_addr->val, sizeof(cmd.peer_addr));
-
-    if (adv_params->channel_map == 0) {
-        cmd.chan_map = BLE_GAP_ADV_DFLT_CHANNEL_MAP;
-    } else {
-        cmd.chan_map = adv_params->channel_map;
-    }
-
-    /* Zero is the default value for filter policy and high duty cycle */
-    cmd.filter_policy = adv_params->filter_policy;
-
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_ADV_PARAMS);
-
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-}
-
-static int
-ble_gap_adv_validate(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                     const struct ble_gap_adv_params *adv_params)
-{
-    if (adv_params == NULL) {
-        return BLE_HS_EINVAL;
-    }
-
-    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
-        return BLE_HS_EINVAL;
-    }
-
-    if (adv_params->disc_mode >= BLE_GAP_DISC_MODE_MAX) {
-        return BLE_HS_EINVAL;
-    }
-
-    if (ble_gap_slave[0].op != BLE_GAP_OP_NULL) {
-        return BLE_HS_EALREADY;
-    }
-
-    switch (adv_params->conn_mode) {
-    case BLE_GAP_CONN_MODE_NON:
-        /* High duty cycle only allowed for directed advertising. */
-        if (adv_params->high_duty_cycle) {
-            return BLE_HS_EINVAL;
-        }
-        break;
-
-    case BLE_GAP_CONN_MODE_UND:
-        /* High duty cycle only allowed for directed advertising. */
-        if (adv_params->high_duty_cycle) {
-            return BLE_HS_EINVAL;
-        }
-
-        /* Don't allow connectable advertising if we won't be able to allocate
-         * a new connection.
-         */
-        if (!ble_hs_conn_can_alloc()) {
-            return BLE_HS_ENOMEM;
-        }
-        break;
-
-    case BLE_GAP_CONN_MODE_DIR:
-        if (peer_addr == NULL) {
-            return BLE_HS_EINVAL;
-        }
-
-        if (peer_addr->type != BLE_ADDR_PUBLIC &&
-            peer_addr->type != BLE_ADDR_RANDOM &&
-            peer_addr->type != BLE_ADDR_PUBLIC_ID &&
-            peer_addr->type != BLE_ADDR_RANDOM_ID) {
-
-            return BLE_HS_EINVAL;
-        }
+static int ble_gap_adv_type(const struct ble_gap_adv_params *adv_params)
+{
+	switch (adv_params->conn_mode) {
+	case BLE_GAP_CONN_MODE_NON:
+		if (adv_params->disc_mode == BLE_GAP_DISC_MODE_NON) {
+			return BLE_HCI_ADV_TYPE_ADV_NONCONN_IND;
+		}
+		else {
+			return BLE_HCI_ADV_TYPE_ADV_SCAN_IND;
+		}
+
+	case BLE_GAP_CONN_MODE_UND:
+		return BLE_HCI_ADV_TYPE_ADV_IND;
+
+	case BLE_GAP_CONN_MODE_DIR:
+		if (adv_params->high_duty_cycle) {
+			return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD;
+		}
+		else {
+			return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD;
+		}
+
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		return BLE_HCI_ADV_TYPE_ADV_IND;
+	}
+}
+
+static void ble_gap_adv_dflt_itvls(uint8_t conn_mode, uint16_t *out_itvl_min,
+                                   uint16_t *out_itvl_max)
+{
+	switch (conn_mode) {
+	case BLE_GAP_CONN_MODE_NON:
+		*out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL2_MIN;
+		*out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL2_MAX;
+		break;
+
+	case BLE_GAP_CONN_MODE_UND:
+		*out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL1_MIN;
+		*out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL1_MAX;
+		break;
+
+	case BLE_GAP_CONN_MODE_DIR:
+		*out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL1_MIN;
+		*out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL1_MAX;
+		break;
+
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		*out_itvl_min = BLE_GAP_ADV_FAST_INTERVAL1_MIN;
+		*out_itvl_max = BLE_GAP_ADV_FAST_INTERVAL1_MAX;
+		break;
+	}
+}
+
+static int ble_gap_adv_params_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
+                                 const struct ble_gap_adv_params *adv_params)
+
+{
+	const ble_addr_t *peer_any = BLE_ADDR_ANY;
+	struct ble_hci_le_set_adv_params_cp cmd;
+	uint16_t opcode;
+	uint16_t min;
+	uint16_t max;
+
+	/* Fill optional fields if application did not specify them. */
+	if ((adv_params->itvl_min == 0) && (adv_params->itvl_max == 0)) {
+		ble_gap_adv_dflt_itvls(adv_params->conn_mode, &min, &max);
+		cmd.min_interval = htole16(min);
+		cmd.max_interval = htole16(max);
+	}
+	else {
+		cmd.min_interval = htole16(adv_params->itvl_min);
+		cmd.max_interval = htole16(adv_params->itvl_max);
+	}
+
+	cmd.type = ble_gap_adv_type(adv_params);
+	cmd.own_addr_type = own_addr_type;
+
+	if (peer_addr == NULL) {
+		peer_addr = peer_any;
+	}
+
+	cmd.peer_addr_type = peer_addr->type;
+	memcpy(&cmd.peer_addr, peer_addr->val, sizeof(cmd.peer_addr));
+
+	if (adv_params->channel_map == 0) {
+		cmd.chan_map = BLE_GAP_ADV_DFLT_CHANNEL_MAP;
+	}
+	else {
+		cmd.chan_map = adv_params->channel_map;
+	}
+
+	/* Zero is the default value for filter policy and high duty cycle */
+	cmd.filter_policy = adv_params->filter_policy;
+
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_ADV_PARAMS);
+
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+}
+
+static int ble_gap_adv_validate(uint8_t own_addr_type, const ble_addr_t *peer_addr,
+                                const struct ble_gap_adv_params *adv_params)
+{
+	if (adv_params == NULL) {
+		return BLE_HS_EINVAL;
+	}
+
+	if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+		return BLE_HS_EINVAL;
+	}
+
+	if (adv_params->disc_mode >= BLE_GAP_DISC_MODE_MAX) {
+		return BLE_HS_EINVAL;
+	}
+
+	if (ble_gap_slave[0].op != BLE_GAP_OP_NULL) {
+		return BLE_HS_EALREADY;
+	}
+
+	switch (adv_params->conn_mode) {
+	case BLE_GAP_CONN_MODE_NON:
+		/* High duty cycle only allowed for directed advertising. */
+		if (adv_params->high_duty_cycle) {
+			return BLE_HS_EINVAL;
+		}
+		break;
+
+	case BLE_GAP_CONN_MODE_UND:
+		/* High duty cycle only allowed for directed advertising. */
+		if (adv_params->high_duty_cycle) {
+			return BLE_HS_EINVAL;
+		}
+
+		/* Don't allow connectable advertising if we won't be able to allocate
+		 * a new connection.
+		 */
+		if (!ble_hs_conn_can_alloc()) {
+			return BLE_HS_ENOMEM;
+		}
+		break;
+
+	case BLE_GAP_CONN_MODE_DIR:
+		if (peer_addr == NULL) {
+			return BLE_HS_EINVAL;
+		}
+
+		if (peer_addr->type != BLE_ADDR_PUBLIC && peer_addr->type != BLE_ADDR_RANDOM &&
+		    peer_addr->type != BLE_ADDR_PUBLIC_ID && peer_addr->type != BLE_ADDR_RANDOM_ID) {
+			return BLE_HS_EINVAL;
+		}
 
-        /* Don't allow connectable advertising if we won't be able to allocate
-         * a new connection.
-         */
-        if (!ble_hs_conn_can_alloc()) {
-            return BLE_HS_ENOMEM;
-        }
-        break;
-
-    default:
-        return BLE_HS_EINVAL;
-    }
-
-    return 0;
-}
-#endif
-
-int
-ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
-                  int32_t duration_ms,
-                  const struct ble_gap_adv_params *adv_params,
-                  ble_gap_event_fn *cb, void *cb_arg)
+		/* Don't allow connectable advertising if we won't be able to allocate
+		 * a new connection.
+		 */
+		if (!ble_hs_conn_can_alloc()) {
+			return BLE_HS_ENOMEM;
+		}
+		break;
+
+	default:
+		return BLE_HS_EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+int ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
+                      int32_t duration_ms, const struct ble_gap_adv_params *adv_params,
+                      ble_gap_event_fn *cb, void *cb_arg)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-    uint32_t duration_ticks;
-    int rc;
-
-    STATS_INC(ble_gap_stats, adv_start);
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    ble_hs_lock();
-
-    rc = ble_gap_adv_validate(own_addr_type, direct_addr, adv_params);
-    if (rc != 0) {
-        goto done;
-    }
-
-    if (duration_ms != BLE_HS_FOREVER) {
-        rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
-        if (rc != 0) {
-            /* Duration too great. */
-            rc = BLE_HS_EINVAL;
-            goto done;
-        }
-    }
-
-    if (ble_gap_is_preempted()) {
-        rc = BLE_HS_EPREEMPTED;
-        goto done;
-    }
-
-    rc = ble_hs_id_use_addr(own_addr_type);
-    if (rc != 0) {
-        goto done;
-    }
-
-    BLE_HS_LOG(INFO, "GAP procedure initiated: advertise; ");
-    ble_gap_log_adv(own_addr_type, direct_addr, adv_params);
-    BLE_HS_LOG(INFO, "\n");
-
-    ble_gap_slave[0].cb = cb;
-    ble_gap_slave[0].cb_arg = cb_arg;
-    ble_gap_slave[0].our_addr_type = own_addr_type;
-
-    if (adv_params->conn_mode != BLE_GAP_CONN_MODE_NON) {
-        ble_gap_slave[0].connectable = 1;
-    } else {
-        ble_gap_slave[0].connectable = 0;
-    }
-
-    rc = ble_gap_adv_params_tx(own_addr_type, direct_addr, adv_params);
-    if (rc != 0) {
-        goto done;
-    }
-
-    ble_gap_slave[0].op = BLE_GAP_OP_S_ADV;
-
-    rc = ble_gap_adv_enable_tx(1);
-    if (rc != 0) {
-        ble_gap_slave_reset_state(0);
-        goto done;
-    }
-
-    if (duration_ms != BLE_HS_FOREVER) {
-        ble_gap_slave_set_timer(duration_ticks);
-    }
-
-    rc = 0;
+	uint32_t duration_ticks;
+	int rc;
+
+	STATS_INC(ble_gap_stats, adv_start);
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	ble_hs_lock();
+
+	rc = ble_gap_adv_validate(own_addr_type, direct_addr, adv_params);
+	if (rc != 0) {
+		goto done;
+	}
+
+	if (duration_ms != BLE_HS_FOREVER) {
+		rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
+		if (rc != 0) {
+			/* Duration too great. */
+			rc = BLE_HS_EINVAL;
+			goto done;
+		}
+	}
+
+	if (ble_gap_is_preempted()) {
+		rc = BLE_HS_EPREEMPTED;
+		goto done;
+	}
+
+	rc = ble_hs_id_use_addr(own_addr_type);
+	if (rc != 0) {
+		goto done;
+	}
+
+	BLE_HS_LOG(INFO, "GAP procedure initiated: advertise; ");
+	ble_gap_log_adv(own_addr_type, direct_addr, adv_params);
+	BLE_HS_LOG(INFO, "\n");
+
+	ble_gap_slave[0].cb = cb;
+	ble_gap_slave[0].cb_arg = cb_arg;
+	ble_gap_slave[0].our_addr_type = own_addr_type;
+
+	if (adv_params->conn_mode != BLE_GAP_CONN_MODE_NON) {
+		ble_gap_slave[0].connectable = 1;
+	}
+	else {
+		ble_gap_slave[0].connectable = 0;
+	}
+
+	rc = ble_gap_adv_params_tx(own_addr_type, direct_addr, adv_params);
+	if (rc != 0) {
+		goto done;
+	}
+
+	ble_gap_slave[0].op = BLE_GAP_OP_S_ADV;
+
+	rc = ble_gap_adv_enable_tx(1);
+	if (rc != 0) {
+		ble_gap_slave_reset_state(0);
+		goto done;
+	}
+
+	if (duration_ms != BLE_HS_FOREVER) {
+		ble_gap_slave_set_timer(duration_ticks);
+	}
+
+	rc = 0;
 
 done:
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, adv_start_fail);
-    }
-    return rc;
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, adv_start_fail);
+	}
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_adv_set_data(const uint8_t *data, int data_len)
+int ble_gap_adv_set_data(const uint8_t *data, int data_len)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-    struct ble_hci_le_set_adv_data_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_adv_data_cp cmd;
+	uint16_t opcode;
 
-    STATS_INC(ble_gap_stats, adv_set_data);
+	STATS_INC(ble_gap_stats, adv_set_data);
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    /* Check for valid parameters */
-    if (((data == NULL) && (data_len != 0)) ||
-            (data_len > BLE_HCI_MAX_ADV_DATA_LEN)) {
-        return BLE_HS_EINVAL;
-    }
+	/* Check for valid parameters */
+	if (((data == NULL) && (data_len != 0)) || (data_len > BLE_HCI_MAX_ADV_DATA_LEN)) {
+		return BLE_HS_EINVAL;
+	}
 
-    memcpy(cmd.adv_data, data, data_len);
-    cmd.adv_data_len = data_len;
+	memcpy(cmd.adv_data, data, data_len);
+	cmd.adv_data_len = data_len;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_ADV_DATA);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_ADV_DATA);
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_adv_rsp_set_data(const uint8_t *data, int data_len)
+int ble_gap_adv_rsp_set_data(const uint8_t *data, int data_len)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-    struct ble_hci_le_set_scan_rsp_data_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_scan_rsp_data_cp cmd;
+	uint16_t opcode;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    /* Check for valid parameters */
-    if (((data == NULL) && (data_len != 0)) ||
-            (data_len > BLE_HCI_MAX_SCAN_RSP_DATA_LEN)) {
-        return BLE_HS_EINVAL;
-    }
+	/* Check for valid parameters */
+	if (((data == NULL) && (data_len != 0)) || (data_len > BLE_HCI_MAX_SCAN_RSP_DATA_LEN)) {
+		return BLE_HS_EINVAL;
+	}
 
-    memcpy(cmd.scan_rsp, data, data_len);
-    cmd.scan_rsp_len = data_len;
+	memcpy(cmd.scan_rsp, data, data_len);
+	cmd.scan_rsp_len = data_len;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA);
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_adv_set_fields(const struct ble_hs_adv_fields *adv_fields)
+int ble_gap_adv_set_fields(const struct ble_hs_adv_fields *adv_fields)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-    uint8_t buf[BLE_HS_ADV_MAX_SZ];
-    uint8_t buf_sz;
-    int rc;
+	uint8_t buf[BLE_HS_ADV_MAX_SZ];
+	uint8_t buf_sz;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    rc = ble_hs_adv_set_fields(adv_fields, buf, &buf_sz, sizeof buf);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_adv_set_fields(adv_fields, buf, &buf_sz, sizeof buf);
+	if (rc != 0) {
+		return rc;
+	}
 
-    rc = ble_gap_adv_set_data(buf, buf_sz);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_gap_adv_set_data(buf, buf_sz);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_adv_rsp_set_fields(const struct ble_hs_adv_fields *rsp_fields)
+int ble_gap_adv_rsp_set_fields(const struct ble_hs_adv_fields *rsp_fields)
 {
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-    uint8_t buf[BLE_HS_ADV_MAX_SZ];
-    uint8_t buf_sz;
-    int rc;
+	uint8_t buf[BLE_HS_ADV_MAX_SZ];
+	uint8_t buf_sz;
+	int rc;
 
-    rc = ble_hs_adv_set_fields(rsp_fields, buf, &buf_sz, sizeof buf);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_adv_set_fields(rsp_fields, buf, &buf_sz, sizeof buf);
+	if (rc != 0) {
+		return rc;
+	}
 
-    rc = ble_gap_adv_rsp_set_data(buf, buf_sz);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_gap_adv_rsp_set_data(buf, buf_sz);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_adv_active(void)
+int ble_gap_adv_active(void)
 {
 #if NIMBLE_BLE_ADVERTISE
-    return ble_gap_adv_active_instance(0);
+	return ble_gap_adv_active_instance(0);
 #else
-    return 0;
+	return 0;
 #endif
 }
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
-static int
-ble_gap_ext_adv_params_tx(uint8_t instance,
-                          const struct ble_gap_ext_adv_params *params,
-                          int8_t *selected_tx_power)
-
-{
-    struct ble_hci_le_set_ext_adv_params_cp cmd;
-    struct ble_hci_le_set_ext_adv_params_rp rsp;
-    int rc;
-
-    memset(&cmd, 0, sizeof(cmd));
-
-    cmd.adv_handle = instance;
-
-    if (params->connectable) {
-        cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_CONNECTABLE;
-    }
-    if (params->scannable) {
-        cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_SCANNABLE;
-    }
-    if (params->directed) {
-        cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_DIRECTED;
-        cmd.peer_addr_type = params->peer.type;
-        memcpy(cmd.peer_addr, params->peer.val, BLE_DEV_ADDR_LEN);
-    }
-    if (params->high_duty_directed) {
-        cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_HD_DIRECTED;
-    }
-    if (params->anonymous) {
-        cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_ANON_ADV;
-    }
-    if (params->include_tx_power) {
-        cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_INC_TX_PWR;
-    }
-    if (params->legacy_pdu) {
-        cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY;
-
-        /* check right away if the applied configuration is valid before handing
-         * the command to the controller to improve error reporting */
-        switch (cmd.props) {
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN:
-                break;
-            default:
-                return BLE_HS_EINVAL;
-        }
-    }
-
-    /* Fill optional fields if application did not specify them. */
-    if (params->itvl_min == 0 && params->itvl_max == 0) {
-        /* TODO for now limited to legacy values*/
-        put_le24(cmd.pri_itvl_min, BLE_GAP_ADV_FAST_INTERVAL1_MIN);
-        put_le24(cmd.pri_itvl_max, BLE_GAP_ADV_FAST_INTERVAL2_MAX);
-    } else {
-        put_le24(cmd.pri_itvl_min, params->itvl_min);
-        put_le24(cmd.pri_itvl_max, params->itvl_max);
-    }
-
-    if (params->channel_map == 0) {
-        cmd.pri_chan_map = BLE_GAP_ADV_DFLT_CHANNEL_MAP;
-    } else {
-        cmd.pri_chan_map = params->channel_map;
-    }
-
-    /* Zero is the default value for filter policy and high duty cycle */
-    cmd.filter_policy = params->filter_policy;
-    cmd.tx_power = params->tx_power;
-
-    if (params->legacy_pdu) {
-        cmd.pri_phy = BLE_HCI_LE_PHY_1M;
-        cmd.sec_phy = BLE_HCI_LE_PHY_1M;
-    } else {
-        cmd.pri_phy = params->primary_phy;
-        cmd.sec_phy = params->secondary_phy;
-    }
-
-    cmd.own_addr_type = params->own_addr_type;
-    cmd.sec_max_skip = 0;
-    cmd.sid = params->sid;
-    cmd.scan_req_notif = params->scan_req_notif;
-
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-
-    if (rc != 0) {
-        return rc;
-    }
-
-    if (selected_tx_power) {
-        *selected_tx_power = rsp.tx_power;
-    }
-
-    return 0;
-}
-
-static int
-ble_gap_ext_adv_params_validate(const struct ble_gap_ext_adv_params *params)
-{
-    if (!params) {
-        return BLE_HS_EINVAL;
-    }
-
-    if (params->own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
-        return BLE_HS_EINVAL;
-    }
-
-    /* Don't allow connectable advertising if we won't be able to allocate
-     * a new connection.
-     */
-    if (params->connectable && !ble_hs_conn_can_alloc()) {
-        return BLE_HS_ENOMEM;
-    }
-
-    if (params->legacy_pdu) {
-        /* not allowed for legacy PDUs */
-        if (params->anonymous || params->include_tx_power) {
-            return BLE_HS_EINVAL;
-        }
-    }
-
-    if (params->directed) {
-        if (params->scannable && params->connectable) {
-            return BLE_HS_EINVAL;
-        }
-    }
-
-    if (!params->legacy_pdu) {
-        /* not allowed for extended advertising PDUs */
-        if (params->connectable && params->scannable) {
-            return BLE_HS_EINVAL;
-        }
-
-        /* HD directed advertising allowed only for legacy PDUs */
-        if (params->high_duty_directed) {
-            return BLE_HS_EINVAL;
-        }
-    }
-
-    return 0;
-}
-
-int
-ble_gap_ext_adv_configure(uint8_t instance,
-                          const struct ble_gap_ext_adv_params *params,
-                          int8_t *selected_tx_power,
-                          ble_gap_event_fn *cb, void *cb_arg)
+static int ble_gap_ext_adv_params_tx(uint8_t instance,
+                                     const struct ble_gap_ext_adv_params *params,
+                                     int8_t *selected_tx_power)
+
+{
+	struct ble_hci_le_set_ext_adv_params_cp cmd;
+	struct ble_hci_le_set_ext_adv_params_rp rsp;
+	int rc;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	cmd.adv_handle = instance;
+
+	if (params->connectable) {
+		cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_CONNECTABLE;
+	}
+	if (params->scannable) {
+		cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_SCANNABLE;
+	}
+	if (params->directed) {
+		cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_DIRECTED;
+		cmd.peer_addr_type = params->peer.type;
+		memcpy(cmd.peer_addr, params->peer.val, BLE_DEV_ADDR_LEN);
+	}
+	if (params->high_duty_directed) {
+		cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_HD_DIRECTED;
+	}
+	if (params->anonymous) {
+		cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_ANON_ADV;
+	}
+	if (params->include_tx_power) {
+		cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_INC_TX_PWR;
+	}
+	if (params->legacy_pdu) {
+		cmd.props |= BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY;
+
+		/* check right away if the applied configuration is valid before handing
+		 * the command to the controller to improve error reporting */
+		switch (cmd.props) {
+		case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND:
+		case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR:
+		case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR:
+		case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN:
+		case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN:
+			break;
+		default:
+			return BLE_HS_EINVAL;
+		}
+	}
+
+	/* Fill optional fields if application did not specify them. */
+	if (params->itvl_min == 0 && params->itvl_max == 0) {
+		/* TODO for now limited to legacy values*/
+		put_le24(cmd.pri_itvl_min, BLE_GAP_ADV_FAST_INTERVAL1_MIN);
+		put_le24(cmd.pri_itvl_max, BLE_GAP_ADV_FAST_INTERVAL2_MAX);
+	}
+	else {
+		put_le24(cmd.pri_itvl_min, params->itvl_min);
+		put_le24(cmd.pri_itvl_max, params->itvl_max);
+	}
+
+	if (params->channel_map == 0) {
+		cmd.pri_chan_map = BLE_GAP_ADV_DFLT_CHANNEL_MAP;
+	}
+	else {
+		cmd.pri_chan_map = params->channel_map;
+	}
+
+	/* Zero is the default value for filter policy and high duty cycle */
+	cmd.filter_policy = params->filter_policy;
+	cmd.tx_power = params->tx_power;
+
+	if (params->legacy_pdu) {
+		cmd.pri_phy = BLE_HCI_LE_PHY_1M;
+		cmd.sec_phy = BLE_HCI_LE_PHY_1M;
+	}
+	else {
+		cmd.pri_phy = params->primary_phy;
+		cmd.sec_phy = params->secondary_phy;
+	}
+
+	cmd.own_addr_type = params->own_addr_type;
+	cmd.sec_max_skip = 0;
+	cmd.sid = params->sid;
+	cmd.scan_req_notif = params->scan_req_notif;
+
+	rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM),
+	                       &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+
+	if (rc != 0) {
+		return rc;
+	}
+
+	if (selected_tx_power) {
+		*selected_tx_power = rsp.tx_power;
+	}
+
+	return 0;
+}
+
+static int ble_gap_ext_adv_params_validate(const struct ble_gap_ext_adv_params *params)
+{
+	if (!params) {
+		return BLE_HS_EINVAL;
+	}
+
+	if (params->own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+		return BLE_HS_EINVAL;
+	}
+
+	/* Don't allow connectable advertising if we won't be able to allocate
+	 * a new connection.
+	 */
+	if (params->connectable && !ble_hs_conn_can_alloc()) {
+		return BLE_HS_ENOMEM;
+	}
+
+	if (params->legacy_pdu) {
+		/* not allowed for legacy PDUs */
+		if (params->anonymous || params->include_tx_power) {
+			return BLE_HS_EINVAL;
+		}
+	}
+
+	if (params->directed) {
+		if (params->scannable && params->connectable) {
+			return BLE_HS_EINVAL;
+		}
+	}
+
+	if (!params->legacy_pdu) {
+		/* not allowed for extended advertising PDUs */
+		if (params->connectable && params->scannable) {
+			return BLE_HS_EINVAL;
+		}
+
+		/* HD directed advertising allowed only for legacy PDUs */
+		if (params->high_duty_directed) {
+			return BLE_HS_EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+int ble_gap_ext_adv_configure(uint8_t instance,
+                              const struct ble_gap_ext_adv_params *params,
+                              int8_t *selected_tx_power, ble_gap_event_fn *cb,
+                              void *cb_arg)
 {
-    int rc;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-        return BLE_HS_EINVAL;
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		return BLE_HS_EINVAL;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    rc = ble_gap_ext_adv_params_validate(params);
-    if (rc) {
-        return rc;
-    }
+	rc = ble_gap_ext_adv_params_validate(params);
+	if (rc) {
+		return rc;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    if (ble_gap_adv_active_instance(instance)) {
-        ble_hs_unlock();
-        return BLE_HS_EBUSY;
-    }
+	if (ble_gap_adv_active_instance(instance)) {
+		ble_hs_unlock();
+		return BLE_HS_EBUSY;
+	}
 
-    rc = ble_gap_ext_adv_params_tx(instance, params, selected_tx_power);
-    if (rc) {
-        ble_hs_unlock();
-        return rc;
-    }
+	rc = ble_gap_ext_adv_params_tx(instance, params, selected_tx_power);
+	if (rc) {
+		ble_hs_unlock();
+		return rc;
+	}
 
-    ble_gap_slave[instance].configured = 1;
-    ble_gap_slave[instance].cb = cb;
-    ble_gap_slave[instance].cb_arg = cb_arg;
-    ble_gap_slave[instance].our_addr_type = params->own_addr_type;
-
-    ble_gap_slave[instance].connectable = params->connectable;
-    ble_gap_slave[instance].scannable = params->scannable;
-    ble_gap_slave[instance].directed = params->directed;
-    ble_gap_slave[instance].high_duty_directed = params->high_duty_directed;
-    ble_gap_slave[instance].legacy_pdu = params->legacy_pdu;
-
-    ble_hs_unlock();
-    return 0;
-}
-
-static int
-ble_gap_ext_adv_set_addr_no_lock(uint8_t instance, const uint8_t *addr)
-{
-    struct ble_hci_le_set_adv_set_rnd_addr_cp cmd;
-    int rc;
-
-    cmd.adv_handle = instance;
-    memcpy(cmd.addr, addr, BLE_DEV_ADDR_LEN);
-
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR),
-                           &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
-        return rc;
-    }
-
-    ble_gap_slave[instance].rnd_addr_set = 1;
-    memcpy(ble_gap_slave[instance].rnd_addr, addr, 6);
-
-    return 0;
-}
-
-int
-ble_gap_ext_adv_set_addr(uint8_t instance, const ble_addr_t *addr)
-{
-    int rc;
-
-    if (instance >= BLE_ADV_INSTANCES || addr->type != BLE_ADDR_RANDOM) {
-        return BLE_HS_EINVAL;
-    }
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    ble_hs_lock();
-    rc = ble_gap_ext_adv_set_addr_no_lock(instance, addr->val);
-    ble_hs_unlock();
-
-    return rc;
-}
-
-int
-ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
-{
-    struct ble_hci_le_set_ext_adv_enable_cp *cmd;
-    uint8_t buf[sizeof(*cmd) + sizeof(cmd->sets[0])];
-    const uint8_t *rnd_addr;
-    uint16_t opcode;
-    int rc;
-
-    if (instance >= BLE_ADV_INSTANCES) {
-        return BLE_HS_EINVAL;
-    }
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    ble_hs_lock();
-    if (!ble_gap_slave[instance].configured) {
-        ble_hs_unlock();
-        return BLE_HS_EINVAL;
-    }
-
-    if (ble_gap_slave[instance].op != BLE_GAP_OP_NULL) {
-        ble_hs_unlock();
-        return  BLE_HS_EALREADY;
-    }
-
-    /* HD directed duration shall not be 0 or larger than >1.28s */
-    if (ble_gap_slave[instance].high_duty_directed &&
-            ((duration == 0) || (duration > 128)) ) {
-        ble_hs_unlock();
-        return BLE_HS_EINVAL;
-    }
-
-    /* verify own address type if random address for instance wasn't explicitly
-     * set
-     */
-    switch (ble_gap_slave[instance].our_addr_type) {
-    case BLE_OWN_ADDR_RANDOM:
-    case BLE_OWN_ADDR_RPA_RANDOM_DEFAULT:
-        if (ble_gap_slave[instance].rnd_addr_set) {
-            break;
-        }
-    /* fall through */
-    case BLE_OWN_ADDR_PUBLIC:
-    case BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT:
-    default:
-        rc = ble_hs_id_use_addr(ble_gap_slave[instance].our_addr_type);
-        if (rc) {
-            ble_hs_unlock();
-            return BLE_HS_EINVAL;
-        }
-        break;
-    }
-
-    /* fallback to ID static random address if using random address and instance
-     * wasn't configured with own address
-     */
-    if (!ble_gap_slave[instance].rnd_addr_set) {
-        switch (ble_gap_slave[instance].our_addr_type) {
-        case BLE_OWN_ADDR_RANDOM:
-        case BLE_OWN_ADDR_RPA_RANDOM_DEFAULT:
-            rc = ble_hs_id_addr(BLE_ADDR_RANDOM, &rnd_addr, NULL);
-            if (rc != 0) {
-                ble_hs_unlock();
-                return rc;
-            }
+	ble_gap_slave[instance].configured = 1;
+	ble_gap_slave[instance].cb = cb;
+	ble_gap_slave[instance].cb_arg = cb_arg;
+	ble_gap_slave[instance].our_addr_type = params->own_addr_type;
+
+	ble_gap_slave[instance].connectable = params->connectable;
+	ble_gap_slave[instance].scannable = params->scannable;
+	ble_gap_slave[instance].directed = params->directed;
+	ble_gap_slave[instance].high_duty_directed = params->high_duty_directed;
+	ble_gap_slave[instance].legacy_pdu = params->legacy_pdu;
+
+	ble_hs_unlock();
+	return 0;
+}
+
+static int ble_gap_ext_adv_set_addr_no_lock(uint8_t instance, const uint8_t *addr)
+{
+	struct ble_hci_le_set_adv_set_rnd_addr_cp cmd;
+	int rc;
+
+	cmd.adv_handle = instance;
+	memcpy(cmd.addr, addr, BLE_DEV_ADDR_LEN);
+
+	rc =
+		ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR),
+	                    &cmd, sizeof(cmd), NULL, 0);
+	if (rc != 0) {
+		return rc;
+	}
+
+	ble_gap_slave[instance].rnd_addr_set = 1;
+	memcpy(ble_gap_slave[instance].rnd_addr, addr, 6);
+
+	return 0;
+}
+
+int ble_gap_ext_adv_set_addr(uint8_t instance, const ble_addr_t *addr)
+{
+	int rc;
+
+	if (instance >= BLE_ADV_INSTANCES || addr->type != BLE_ADDR_RANDOM) {
+		return BLE_HS_EINVAL;
+	}
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	ble_hs_lock();
+	rc = ble_gap_ext_adv_set_addr_no_lock(instance, addr->val);
+	ble_hs_unlock();
+
+	return rc;
+}
+
+int ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
+{
+	struct ble_hci_le_set_ext_adv_enable_cp *cmd;
+	uint8_t buf[sizeof(*cmd) + sizeof(cmd->sets[0])];
+	const uint8_t *rnd_addr;
+	uint16_t opcode;
+	int rc;
+
+	if (instance >= BLE_ADV_INSTANCES) {
+		return BLE_HS_EINVAL;
+	}
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	ble_hs_lock();
+	if (!ble_gap_slave[instance].configured) {
+		ble_hs_unlock();
+		return BLE_HS_EINVAL;
+	}
+
+	if (ble_gap_slave[instance].op != BLE_GAP_OP_NULL) {
+		ble_hs_unlock();
+		return BLE_HS_EALREADY;
+	}
+
+	/* HD directed duration shall not be 0 or larger than >1.28s */
+	if (ble_gap_slave[instance].high_duty_directed &&
+	    ((duration == 0) || (duration > 128))) {
+		ble_hs_unlock();
+		return BLE_HS_EINVAL;
+	}
+
+	/* verify own address type if random address for instance wasn't explicitly
+	 * set
+	 */
+	switch (ble_gap_slave[instance].our_addr_type) {
+	case BLE_OWN_ADDR_RANDOM:
+	case BLE_OWN_ADDR_RPA_RANDOM_DEFAULT:
+		if (ble_gap_slave[instance].rnd_addr_set) {
+			break;
+		}
+	/* fall through */
+	case BLE_OWN_ADDR_PUBLIC:
+	case BLE_OWN_ADDR_RPA_PUBLIC_DEFAULT:
+	default:
+		rc = ble_hs_id_use_addr(ble_gap_slave[instance].our_addr_type);
+		if (rc) {
+			ble_hs_unlock();
+			return BLE_HS_EINVAL;
+		}
+		break;
+	}
 
-            rc = ble_gap_ext_adv_set_addr_no_lock(instance, rnd_addr);
-            if (rc != 0) {
-                ble_hs_unlock();
-                return rc;
-            }
-            break;
-        default:
-            break;
-        }
-    }
-
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE);
-
-    cmd = (void *) buf;
-
-    cmd->enable = 0x01;
-    cmd->num_sets = 1;
-
-    cmd->sets[0].adv_handle = instance;
-    cmd->sets[0].duration = htole16(duration);
-    cmd->sets[0].max_events = max_events;
-
-    rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(buf), NULL, 0);
-    if (rc != 0) {
-        ble_hs_unlock();
-        return rc;
-    }
-
-    ble_gap_slave[instance].op = BLE_GAP_OP_S_ADV;
-
-    ble_hs_unlock();
-    return 0;
-}
-
-static int
-ble_gap_ext_adv_stop_no_lock(uint8_t instance)
-{
-    struct ble_hci_le_set_ext_adv_enable_cp *cmd;
-    uint8_t buf[sizeof(*cmd) + sizeof(cmd->sets[0])];
-    uint16_t opcode;
-    bool active;
-    int rc;
-
-    if (!ble_gap_slave[instance].configured) {
-        return BLE_HS_EINVAL;
-    }
-
-    active = ble_gap_adv_active_instance(instance);
-
-    cmd = (void *) buf;
-
-    cmd->enable = 0x00;
-    cmd->num_sets = 1;
-    cmd->sets[0].adv_handle = instance;
-    cmd->sets[0].duration = 0x0000;
-    cmd->sets[0].max_events = 0x00;
-
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE);
-
-    rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(buf), NULL, 0);
-    if (rc != 0) {
-        return rc;
-    }
-
-    ble_gap_slave[instance].op = BLE_GAP_OP_NULL;
-
-    if (!active) {
-        return BLE_HS_EALREADY;
-    } else {
-        return 0;
-    }
-}
+	/* fallback to ID static random address if using random address and instance
+	 * wasn't configured with own address
+	 */
+	if (!ble_gap_slave[instance].rnd_addr_set) {
+		switch (ble_gap_slave[instance].our_addr_type) {
+		case BLE_OWN_ADDR_RANDOM:
+		case BLE_OWN_ADDR_RPA_RANDOM_DEFAULT:
+			rc = ble_hs_id_addr(BLE_ADDR_RANDOM, &rnd_addr, NULL);
+			if (rc != 0) {
+				ble_hs_unlock();
+				return rc;
+			}
 
-int
-ble_gap_ext_adv_stop(uint8_t instance)
+			rc = ble_gap_ext_adv_set_addr_no_lock(instance, rnd_addr);
+			if (rc != 0) {
+				ble_hs_unlock();
+				return rc;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE);
+
+	cmd = (void *) buf;
+
+	cmd->enable = 0x01;
+	cmd->num_sets = 1;
+
+	cmd->sets[0].adv_handle = instance;
+	cmd->sets[0].duration = htole16(duration);
+	cmd->sets[0].max_events = max_events;
+
+	rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(buf), NULL, 0);
+	if (rc != 0) {
+		ble_hs_unlock();
+		return rc;
+	}
+
+	ble_gap_slave[instance].op = BLE_GAP_OP_S_ADV;
+
+	ble_hs_unlock();
+	return 0;
+}
+
+static int ble_gap_ext_adv_stop_no_lock(uint8_t instance)
+{
+	struct ble_hci_le_set_ext_adv_enable_cp *cmd;
+	uint8_t buf[sizeof(*cmd) + sizeof(cmd->sets[0])];
+	uint16_t opcode;
+	bool active;
+	int rc;
+
+	if (!ble_gap_slave[instance].configured) {
+		return BLE_HS_EINVAL;
+	}
+
+	active = ble_gap_adv_active_instance(instance);
+
+	cmd = (void *) buf;
+
+	cmd->enable = 0x00;
+	cmd->num_sets = 1;
+	cmd->sets[0].adv_handle = instance;
+	cmd->sets[0].duration = 0x0000;
+	cmd->sets[0].max_events = 0x00;
+
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE);
+
+	rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(buf), NULL, 0);
+	if (rc != 0) {
+		return rc;
+	}
+
+	ble_gap_slave[instance].op = BLE_GAP_OP_NULL;
+
+	if (!active) {
+		return BLE_HS_EALREADY;
+	}
+	else {
+		return 0;
+	}
+}
+
+int ble_gap_ext_adv_stop(uint8_t instance)
 {
-    int rc;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-        return BLE_HS_EINVAL;
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		return BLE_HS_EINVAL;
+	}
 
-    ble_hs_lock();
-    rc = ble_gap_ext_adv_stop_no_lock(instance);
-    ble_hs_unlock();
+	ble_hs_lock();
+	rc = ble_gap_ext_adv_stop_no_lock(instance);
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 
-
-static int
-ble_gap_ext_adv_set_data_validate(uint8_t instance, struct os_mbuf *data)
+static int ble_gap_ext_adv_set_data_validate(uint8_t instance, struct os_mbuf *data)
 {
-    uint16_t len = OS_MBUF_PKTLEN(data);
+	uint16_t len = OS_MBUF_PKTLEN(data);
 
-    if (!ble_gap_slave[instance].configured) {
-        return BLE_HS_EINVAL;
-    }
+	if (!ble_gap_slave[instance].configured) {
+		return BLE_HS_EINVAL;
+	}
 
-    /* not allowed with directed advertising for legacy*/
-    if (ble_gap_slave[instance].legacy_pdu && ble_gap_slave[instance].directed) {
-        return BLE_HS_EINVAL;
-    }
+	/* not allowed with directed advertising for legacy*/
+	if (ble_gap_slave[instance].legacy_pdu && ble_gap_slave[instance].directed) {
+		return BLE_HS_EINVAL;
+	}
 
-    /* always allowed with legacy PDU but limited to legacy length */
-    if (ble_gap_slave[instance].legacy_pdu) {
-        if (len > BLE_HS_ADV_MAX_SZ) {
-            return BLE_HS_EINVAL;
-        }
+	/* always allowed with legacy PDU but limited to legacy length */
+	if (ble_gap_slave[instance].legacy_pdu) {
+		if (len > BLE_HS_ADV_MAX_SZ) {
+			return BLE_HS_EINVAL;
+		}
 
-        return 0;
-    }
+		return 0;
+	}
 
-    /* if already advertising, data must fit in single HCI command
-     * as per BT 5.0 Vol 2, Part E, 7.8.54. Don't bother Controller with such
-     * a request.
-     */
-    if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV) {
-        if (len > min(MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE), 251)) {
-            return BLE_HS_EINVAL;
-        }
-    }
+	/* if already advertising, data must fit in single HCI command
+	 * as per BT 5.0 Vol 2, Part E, 7.8.54. Don't bother Controller with such
+	 * a request.
+	 */
+	if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV) {
+		if (len > min(MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE), 251)) {
+			return BLE_HS_EINVAL;
+		}
+	}
 
-    /* not allowed with scannable advertising */
-    if (ble_gap_slave[instance].scannable) {
-        return BLE_HS_EINVAL;
-    }
+	/* not allowed with scannable advertising */
+	if (ble_gap_slave[instance].scannable) {
+		return BLE_HS_EINVAL;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
+static int ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
 {
-    /* in that case we always fit all data in single HCI command */
+	/* in that case we always fit all data in single HCI command */
 #if MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE) <= BLE_HCI_MAX_EXT_ADV_DATA_LEN
-    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) + \
-                       MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE)];
-    struct ble_hci_le_set_ext_adv_data_cp *cmd = (void *)buf;
-    uint16_t len = OS_MBUF_PKTLEN(*data);
-
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, opcode);
-    cmd->adv_handle = instance;
-    cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
-    cmd->fragment_pref = 0;
-    cmd->adv_data_len = len;
-    os_mbuf_copydata(*data, 0, len, cmd->adv_data);
-
-    os_mbuf_adj(*data, len);
-    *data = os_mbuf_trim_front(*data);
-
-    return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
-                             NULL, 0);
+	static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) +
+	                   MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE)];
+	struct ble_hci_le_set_ext_adv_data_cp *cmd = (void *) buf;
+	uint16_t len = OS_MBUF_PKTLEN(*data);
+
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, opcode);
+	cmd->adv_handle = instance;
+	cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
+	cmd->fragment_pref = 0;
+	cmd->adv_data_len = len;
+	os_mbuf_copydata(*data, 0, len, cmd->adv_data);
+
+	os_mbuf_adj(*data, len);
+	*data = os_mbuf_trim_front(*data);
+
+	return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len, NULL, 0);
 #else
-    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) + \
-                       BLE_HCI_MAX_EXT_ADV_DATA_LEN];
-    struct ble_hci_le_set_ext_adv_data_cp *cmd = (void *)buf;
-    uint16_t len = OS_MBUF_PKTLEN(*data);
-    uint8_t op;
-    int rc;
+	static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) + BLE_HCI_MAX_EXT_ADV_DATA_LEN];
+	struct ble_hci_le_set_ext_adv_data_cp *cmd = (void *) buf;
+	uint16_t len = OS_MBUF_PKTLEN(*data);
+	uint8_t op;
+	int rc;
 
-    opcode =  BLE_HCI_OP(BLE_HCI_OGF_LE, opcode);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, opcode);
 
-    cmd->adv_handle = instance;
+	cmd->adv_handle = instance;
 
-    /* complete data */
-    if (len <= BLE_HCI_MAX_EXT_ADV_DATA_LEN) {
-        cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
-        cmd->fragment_pref = 0;
-        cmd->adv_data_len = len;
-        os_mbuf_copydata(*data, 0, len, cmd->adv_data);
+	/* complete data */
+	if (len <= BLE_HCI_MAX_EXT_ADV_DATA_LEN) {
+		cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
+		cmd->fragment_pref = 0;
+		cmd->adv_data_len = len;
+		os_mbuf_copydata(*data, 0, len, cmd->adv_data);
 
-        os_mbuf_adj(*data, len);
-        *data = os_mbuf_trim_front(*data);
+		os_mbuf_adj(*data, len);
+		*data = os_mbuf_trim_front(*data);
 
-        return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
-                                 NULL, 0);
-    }
+		return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len, NULL, 0);
+	}
 
-    /* first fragment  */
-    op = BLE_HCI_LE_SET_DATA_OPER_FIRST;
+	/* first fragment  */
+	op = BLE_HCI_LE_SET_DATA_OPER_FIRST;
 
-    do {
-        cmd->operation = op;
-        cmd->fragment_pref = 0;
-        cmd->adv_data_len = BLE_HCI_MAX_EXT_ADV_DATA_LEN;
-        os_mbuf_copydata(*data, 0, BLE_HCI_MAX_EXT_ADV_DATA_LEN, cmd->adv_data);
+	do {
+		cmd->operation = op;
+		cmd->fragment_pref = 0;
+		cmd->adv_data_len = BLE_HCI_MAX_EXT_ADV_DATA_LEN;
+		os_mbuf_copydata(*data, 0, BLE_HCI_MAX_EXT_ADV_DATA_LEN, cmd->adv_data);
 
-        os_mbuf_adj(*data, BLE_HCI_MAX_EXT_ADV_DATA_LEN);
-        *data = os_mbuf_trim_front(*data);
+		os_mbuf_adj(*data, BLE_HCI_MAX_EXT_ADV_DATA_LEN);
+		*data = os_mbuf_trim_front(*data);
 
-        rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
-                               NULL, 0);
-        if (rc) {
-            return rc;
-        }
+		rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len, NULL, 0);
+		if (rc) {
+			return rc;
+		}
 
-        len -= BLE_HCI_MAX_EXT_ADV_DATA_LEN;
-        op = BLE_HCI_LE_SET_DATA_OPER_INT;
-    } while (len > BLE_HCI_MAX_EXT_ADV_DATA_LEN);
+		len -= BLE_HCI_MAX_EXT_ADV_DATA_LEN;
+		op = BLE_HCI_LE_SET_DATA_OPER_INT;
+	} while (len > BLE_HCI_MAX_EXT_ADV_DATA_LEN);
 
-    /* last fragment */
-    cmd->operation = BLE_HCI_LE_SET_DATA_OPER_LAST;
-    cmd->fragment_pref = 0;
-    cmd->adv_data_len = len;
-    os_mbuf_copydata(*data, 0, len, cmd->adv_data);
+	/* last fragment */
+	cmd->operation = BLE_HCI_LE_SET_DATA_OPER_LAST;
+	cmd->fragment_pref = 0;
+	cmd->adv_data_len = len;
+	os_mbuf_copydata(*data, 0, len, cmd->adv_data);
 
-    os_mbuf_adj(*data, len);
-    *data = os_mbuf_trim_front(*data);
+	os_mbuf_adj(*data, len);
+	*data = os_mbuf_trim_front(*data);
 
-    return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
-                             NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len, NULL, 0);
 #endif
 }
 
-int
-ble_gap_ext_adv_set_data(uint8_t instance, struct os_mbuf *data)
+int ble_gap_ext_adv_set_data(uint8_t instance, struct os_mbuf *data)
 {
-    int rc;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-        rc = BLE_HS_EINVAL;
-        goto done;
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		rc = BLE_HS_EINVAL;
+		goto done;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        rc = BLE_HS_EDISABLED;
-        goto done;
-    }
+	if (!ble_hs_is_enabled()) {
+		rc = BLE_HS_EDISABLED;
+		goto done;
+	}
 
-    ble_hs_lock();
-    rc = ble_gap_ext_adv_set_data_validate(instance, data);
-    if (rc != 0) {
-        ble_hs_unlock();
-        goto done;
-    }
+	ble_hs_lock();
+	rc = ble_gap_ext_adv_set_data_validate(instance, data);
+	if (rc != 0) {
+		ble_hs_unlock();
+		goto done;
+	}
 
-    rc = ble_gap_ext_adv_set(instance, BLE_HCI_OCF_LE_SET_EXT_ADV_DATA, &data);
+	rc = ble_gap_ext_adv_set(instance, BLE_HCI_OCF_LE_SET_EXT_ADV_DATA, &data);
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
 done:
-    os_mbuf_free_chain(data);
-    return rc;
+	os_mbuf_free_chain(data);
+	return rc;
 }
 
-static int
-ble_gap_ext_adv_rsp_set_validate(uint8_t instance,  struct os_mbuf *data)
+static int ble_gap_ext_adv_rsp_set_validate(uint8_t instance, struct os_mbuf *data)
 {
-    uint16_t len = OS_MBUF_PKTLEN(data);
+	uint16_t len = OS_MBUF_PKTLEN(data);
 
-    if (!ble_gap_slave[instance].configured) {
-        return BLE_HS_EINVAL;
-    }
+	if (!ble_gap_slave[instance].configured) {
+		return BLE_HS_EINVAL;
+	}
 
-    /* not allowed with directed advertising */
-    if (ble_gap_slave[instance].directed && ble_gap_slave[instance].connectable) {
-        return BLE_HS_EINVAL;
-    }
+	/* not allowed with directed advertising */
+	if (ble_gap_slave[instance].directed && ble_gap_slave[instance].connectable) {
+		return BLE_HS_EINVAL;
+	}
 
-    /* only allowed with scannable advertising */
-    if (!ble_gap_slave[instance].scannable) {
-        return BLE_HS_EINVAL;
-    }
+	/* only allowed with scannable advertising */
+	if (!ble_gap_slave[instance].scannable) {
+		return BLE_HS_EINVAL;
+	}
 
-    /* with legacy PDU limited to legacy length */
-    if (ble_gap_slave[instance].legacy_pdu) {
-        if (len > BLE_HS_ADV_MAX_SZ) {
-            return BLE_HS_EINVAL;
-        }
+	/* with legacy PDU limited to legacy length */
+	if (ble_gap_slave[instance].legacy_pdu) {
+		if (len > BLE_HS_ADV_MAX_SZ) {
+			return BLE_HS_EINVAL;
+		}
 
-        return 0;
-    }
+		return 0;
+	}
 
-    /* if already advertising, data must fit in single HCI command
-     * as per BT 5.0 Vol 2, Part E, 7.8.55. Don't bother Controller with such
-     * a request.
-     */
-    if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV) {
-        if (len > min(MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE), 251)) {
-            return BLE_HS_EINVAL;
-        }
-    }
+	/* if already advertising, data must fit in single HCI command
+	 * as per BT 5.0 Vol 2, Part E, 7.8.55. Don't bother Controller with such
+	 * a request.
+	 */
+	if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV) {
+		if (len > min(MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE), 251)) {
+			return BLE_HS_EINVAL;
+		}
+	}
 
-    return 0;
+	return 0;
 }
 
-int
-ble_gap_ext_adv_rsp_set_data(uint8_t instance, struct os_mbuf *data)
+int ble_gap_ext_adv_rsp_set_data(uint8_t instance, struct os_mbuf *data)
 {
-    int rc;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-        rc = BLE_HS_EINVAL;
-        goto done;
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		rc = BLE_HS_EINVAL;
+		goto done;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        rc = BLE_HS_EDISABLED;
-        goto done;
-    }
+	if (!ble_hs_is_enabled()) {
+		rc = BLE_HS_EDISABLED;
+		goto done;
+	}
 
-    ble_hs_lock();
-    rc = ble_gap_ext_adv_rsp_set_validate(instance, data);
-    if (rc != 0) {
-        ble_hs_unlock();
-        goto done;
-    }
+	ble_hs_lock();
+	rc = ble_gap_ext_adv_rsp_set_validate(instance, data);
+	if (rc != 0) {
+		ble_hs_unlock();
+		goto done;
+	}
 
-    rc = ble_gap_ext_adv_set(instance, BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA,
-                             &data);
+	rc = ble_gap_ext_adv_set(instance, BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA, &data);
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
 done:
-    os_mbuf_free_chain(data);
-    return rc;
+	os_mbuf_free_chain(data);
+	return rc;
 }
 
-int
-ble_gap_ext_adv_remove(uint8_t instance)
+int ble_gap_ext_adv_remove(uint8_t instance)
 {
-    struct ble_hci_le_remove_adv_set_cp cmd;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_remove_adv_set_cp cmd;
+	uint16_t opcode;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-        return BLE_HS_EINVAL;
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		return BLE_HS_EINVAL;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
-    if (!ble_gap_slave[instance].configured) {
-        ble_hs_unlock();
-        return BLE_HS_EALREADY;
-    }
+	ble_hs_lock();
+	if (!ble_gap_slave[instance].configured) {
+		ble_hs_unlock();
+		return BLE_HS_EALREADY;
+	}
 
-    if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV) {
-        ble_hs_unlock();
-        return BLE_HS_EBUSY;
-    }
+	if (ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV) {
+		ble_hs_unlock();
+		return BLE_HS_EBUSY;
+	}
 
-    cmd.adv_handle = instance;
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REMOVE_ADV_SET);
+	cmd.adv_handle = instance;
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REMOVE_ADV_SET);
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
-        ble_hs_unlock();
-        return rc;
-    }
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	if (rc != 0) {
+		ble_hs_unlock();
+		return rc;
+	}
 
-    memset(&ble_gap_slave[instance], 0, sizeof(struct ble_gap_slave_state));
-    ble_hs_unlock();
+	memset(&ble_gap_slave[instance], 0, sizeof(struct ble_gap_slave_state));
+	ble_hs_unlock();
 
-    return 0;
+	return 0;
 }
 
-int
-ble_gap_ext_adv_clear(void)
+int ble_gap_ext_adv_clear(void)
 {
-    int rc;
-    uint8_t instance;
-    uint16_t opcode;
+	int rc;
+	uint8_t instance;
+	uint16_t opcode;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    for (instance = 0; instance < BLE_ADV_INSTANCES; instance++) {
-        /* If there is an active instance or periodic adv instance,
-         * Don't send the command
-         * */
-        if ((ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV)) {
-            ble_hs_unlock();
-            return BLE_HS_EBUSY;
-        }
+	for (instance = 0; instance < BLE_ADV_INSTANCES; instance++) {
+		/* If there is an active instance or periodic adv instance,
+		 * Don't send the command
+		 * */
+		if ((ble_gap_slave[instance].op == BLE_GAP_OP_S_ADV)) {
+			ble_hs_unlock();
+			return BLE_HS_EBUSY;
+		}
 
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-        if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV) {
-            ble_hs_unlock();
-            return BLE_HS_EBUSY;
-        }
+		if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV) {
+			ble_hs_unlock();
+			return BLE_HS_EBUSY;
+		}
 #endif
-    }
+	}
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CLEAR_ADV_SETS);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CLEAR_ADV_SETS);
 
-    rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, NULL, 0);
-    if (rc != 0) {
-        ble_hs_unlock();
-        return rc;
-    }
+	rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, NULL, 0);
+	if (rc != 0) {
+		ble_hs_unlock();
+		return rc;
+	}
 
-    memset(ble_gap_slave, 0, sizeof(ble_gap_slave));
-    ble_hs_unlock();
+	memset(ble_gap_slave, 0, sizeof(ble_gap_slave));
+	ble_hs_unlock();
 
-    return 0;
+	return 0;
 }
 
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-static int
-ble_gap_periodic_adv_params_tx(uint8_t instance,
-                               const struct ble_gap_periodic_adv_params *params)
+static int ble_gap_periodic_adv_params_tx(uint8_t instance,
+                                          const struct ble_gap_periodic_adv_params *params)
 
 {
-    struct ble_hci_le_set_periodic_adv_params_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_periodic_adv_params_cp cmd;
+	uint16_t opcode;
 
-    cmd.adv_handle = instance;
+	cmd.adv_handle = instance;
 
-    /* Fill optional fields if application did not specify them. */
-    if (params->itvl_min == 0 && params->itvl_max == 0) {
-        cmd.min_itvl = BLE_GAP_PERIODIC_ITVL_MS(30);
-        cmd.max_itvl = BLE_GAP_PERIODIC_ITVL_MS(60);
+	/* Fill optional fields if application did not specify them. */
+	if (params->itvl_min == 0 && params->itvl_max == 0) {
+		cmd.min_itvl = BLE_GAP_PERIODIC_ITVL_MS(30);
+		cmd.max_itvl = BLE_GAP_PERIODIC_ITVL_MS(60);
+	}
+	else {
+		cmd.min_itvl = htole16(params->itvl_min);
+		cmd.max_itvl = htole16(params->itvl_max);
+	}
 
-    } else {
-        cmd.min_itvl = htole16(params->itvl_min);
-        cmd.max_itvl = htole16(params->itvl_max);
-    }
+	if (params->include_tx_power) {
+		cmd.props = BLE_HCI_LE_SET_PERIODIC_ADV_PROP_INC_TX_PWR;
+	}
+	else {
+		cmd.props = 0;
+	}
 
-    if (params->include_tx_power) {
-        cmd.props = BLE_HCI_LE_SET_PERIODIC_ADV_PROP_INC_TX_PWR;
-    } else {
-        cmd.props = 0;
-    }
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS);
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS);
-
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-static int
-ble_gap_periodic_adv_params_validate(
-        const struct ble_gap_periodic_adv_params *params)
+static int ble_gap_periodic_adv_params_validate(const struct ble_gap_periodic_adv_params *params)
 {
-    if (!params) {
-        return BLE_HS_EINVAL;
-    }
+	if (!params) {
+		return BLE_HS_EINVAL;
+	}
 
-    if (params->itvl_min && params->itvl_min < 6) {
-        return BLE_HS_EINVAL;
-    }
-    if (params->itvl_max && params->itvl_max < 6) {
-            return BLE_HS_EINVAL;
-    }
-    return 0;
+	if (params->itvl_min && params->itvl_min < 6) {
+		return BLE_HS_EINVAL;
+	}
+	if (params->itvl_max && params->itvl_max < 6) {
+		return BLE_HS_EINVAL;
+	}
+	return 0;
 }
 
-int
-ble_gap_periodic_adv_configure(uint8_t instance,
-        const struct ble_gap_periodic_adv_params *params)
+int ble_gap_periodic_adv_configure(uint8_t instance,
+                                   const struct ble_gap_periodic_adv_params *params)
 {
-    int rc;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-        return BLE_HS_EINVAL;
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		return BLE_HS_EINVAL;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    rc = ble_gap_periodic_adv_params_validate(params);
-    if (rc) {
-        return rc;
-    }
+	rc = ble_gap_periodic_adv_params_validate(params);
+	if (rc) {
+		return rc;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    /* The corresponding extended advertising instance should be configured */
-    if (!ble_gap_slave[instance].configured) {
-        ble_hs_unlock();
-        return ENOMEM;
-    }
+	/* The corresponding extended advertising instance should be configured */
+	if (!ble_gap_slave[instance].configured) {
+		ble_hs_unlock();
+		return ENOMEM;
+	}
 
-    /* Periodic advertising shall not be configured while it is already
-     * running.
-     * Bluetooth Core Specification, Section 7.8.61
-     */
-    if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV) {
-        ble_hs_unlock();
-        return BLE_HS_EINVAL;
-    }
+	/* Periodic advertising shall not be configured while it is already
+	 * running.
+	 * Bluetooth Core Specification, Section 7.8.61
+	 */
+	if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV) {
+		ble_hs_unlock();
+		return BLE_HS_EINVAL;
+	}
 
-    rc = ble_gap_periodic_adv_params_tx(instance, params);
-    if (rc) {
-        ble_hs_unlock();
-        return rc;
-    }
+	rc = ble_gap_periodic_adv_params_tx(instance, params);
+	if (rc) {
+		ble_hs_unlock();
+		return rc;
+	}
 
-    ble_gap_slave[instance].periodic_configured = 1;
+	ble_gap_slave[instance].periodic_configured = 1;
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    return 0;
+	return 0;
 }
 
-int
-ble_gap_periodic_adv_start(uint8_t instance, const struct ble_gap_periodic_adv_start_params *params)
+int ble_gap_periodic_adv_start(uint8_t instance,
+                               const struct ble_gap_periodic_adv_start_params *params)
 {
-    struct ble_hci_le_set_periodic_adv_enable_cp cmd;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_set_periodic_adv_enable_cp cmd;
+	uint16_t opcode;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-        return BLE_HS_EINVAL;
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		return BLE_HS_EINVAL;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    /* Periodic advertising cannot start unless it is configured before */
-    if (!ble_gap_slave[instance].periodic_configured) {
-        ble_hs_unlock();
-        return BLE_HS_EINVAL;
-    }
+	/* Periodic advertising cannot start unless it is configured before */
+	if (!ble_gap_slave[instance].periodic_configured) {
+		ble_hs_unlock();
+		return BLE_HS_EINVAL;
+	}
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE);
 
-    cmd.enable = 0x01;
+	cmd.enable = 0x01;
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-    if (params && params->include_adi) {
-        SET_BIT(cmd.enable, 1);
-    }
+	if (params && params->include_adi) {
+		SET_BIT(cmd.enable, 1);
+	}
 #endif
-    cmd.adv_handle = instance;
+	cmd.adv_handle = instance;
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
-        ble_hs_unlock();
-        return rc;
-    }
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	if (rc != 0) {
+		ble_hs_unlock();
+		return rc;
+	}
 
-    ble_gap_slave[instance].periodic_op = BLE_GAP_OP_S_PERIODIC_ADV;
+	ble_gap_slave[instance].periodic_op = BLE_GAP_OP_S_PERIODIC_ADV;
 
-    ble_hs_unlock();
-    return 0;
+	ble_hs_unlock();
+	return 0;
 }
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-static int
-ble_gap_periodic_adv_update_did(uint8_t instance)
+static int ble_gap_periodic_adv_update_did(uint8_t instance)
 {
-    static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp)];
-    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
-    uint16_t opcode;
+	static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp)];
+	struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
+	uint16_t opcode;
 
-    memset(buf, 0, sizeof(buf));
+	memset(buf, 0, sizeof(buf));
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA);
 
-    cmd->adv_handle = instance;
-    cmd->operation = BLE_HCI_LE_SET_DATA_OPER_UNCHANGED;
-    cmd->adv_data_len = 0;
+	cmd->adv_handle = instance;
+	cmd->operation = BLE_HCI_LE_SET_DATA_OPER_UNCHANGED;
+	cmd->adv_data_len = 0;
 
-    return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
-                             NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len, NULL, 0);
 }
 #endif
 
-static int
-ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
+static int ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
 {
-    /* In that case we always fit all data in single HCI command */
+	/* In that case we always fit all data in single HCI command */
 #if MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE) <= BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN
-    static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp) +
-                       MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE)];
-    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
-    uint16_t len = 0;
-    uint16_t opcode;
+	static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp) +
+	                   MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE)];
+	struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
+	uint16_t len = 0;
+	uint16_t opcode;
 
-    if (*data) {
-        len = OS_MBUF_PKTLEN(*data);
-    }
+	if (*data) {
+		len = OS_MBUF_PKTLEN(*data);
+	}
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA);
 
-    cmd->adv_handle = instance;
-    cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
-    cmd->adv_data_len = len;
+	cmd->adv_handle = instance;
+	cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
+	cmd->adv_data_len = len;
 
-    if (len) {
-        os_mbuf_copydata(*data, 0, len, cmd->adv_data);
+	if (len) {
+		os_mbuf_copydata(*data, 0, len, cmd->adv_data);
 
-        os_mbuf_adj(*data, len);
-        *data = os_mbuf_trim_front(*data);
-    }
+		os_mbuf_adj(*data, len);
+		*data = os_mbuf_trim_front(*data);
+	}
 
-    return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
-                             NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len, NULL, 0);
 #else
-    static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp) +
-                       BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN];
-    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
-    uint16_t len = 0;
-    uint16_t opcode;
-    uint8_t op;
-    int rc;
-
-    if (*data) {
-        len = OS_MBUF_PKTLEN(*data);
-    }
-
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA);
-    cmd->adv_handle = instance;
-
-    /* Complete data */
-    if (len <= BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN) {
-        cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
-        cmd->adv_data_len = len;
-
-        if (len) {
-            os_mbuf_copydata(*data, 0, len, cmd->adv_data);
-
-            os_mbuf_adj(*data, len);
-            *data = os_mbuf_trim_front(*data);
-        }
-
-        return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
-                                 NULL, 0);
-    }
-
-    /* If the periodic advertising is already enabled, the periodic advertising
-     * the op code shall be nothing but 0x03
-     * Bluetooth Core Specification, section 7.8.62
-     */
-    if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV) {
-        return BLE_HS_EINVAL;
-    }
-
-    /* First fragment  */
-    op = BLE_HCI_LE_SET_DATA_OPER_FIRST;
-
-    do{
-        cmd->operation = op;
-        cmd->adv_data_len = BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN;
-        os_mbuf_copydata(*data, 0, BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN,
-                         cmd->adv_data);
-
-        os_mbuf_adj(*data, BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN);
-        *data = os_mbuf_trim_front(*data);
-
-        rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
-                               NULL, 0);
-        if (rc) {
-            return rc;
-        }
-
-        len -= BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN;
-        op = BLE_HCI_LE_SET_DATA_OPER_INT;
-    } while (len > BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN);
-
-    /* Last fragment */
-    cmd->operation = BLE_HCI_LE_SET_DATA_OPER_LAST;
-    cmd->adv_data_len = len;
-    os_mbuf_copydata(*data, 0, len, cmd->adv_data);
-
-    os_mbuf_adj(*data, len);
-    *data = os_mbuf_trim_front(*data);
-
-    return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
-                             NULL, 0);
-#endif
-}
-
-static int
-ble_gap_periodic_adv_set_data_validate(uint8_t instance,
-                                       struct os_mbuf *data)
-{
-    /* The corresponding extended advertising instance should be configured */
-    if (!ble_gap_slave[instance].configured) {
-        return BLE_HS_EINVAL;
-    }
-
-    if (ble_gap_slave[instance].legacy_pdu) {
-        return BLE_HS_EINVAL;
-    }
-
-    /* One more check states that if the periodic advertising is already
-     * enabled, the operation shall be 0x03 (Complete).
-     * This check is handled during sending the data to the controller, as the
-     * length checks are already checked there, so this saves duplicate code
-     */
-
-    return 0;
-}
-
-int
-ble_gap_periodic_adv_set_data(uint8_t instance,
-                              struct os_mbuf *data,
-                              const struct ble_gap_periodic_adv_set_data_params *params)
-{
-    int rc;
-    if (instance >= BLE_ADV_INSTANCES) {
-        rc = BLE_HS_EINVAL;
-        goto done;
-    }
+	static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp) +
+	                   BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN];
+	struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
+	uint16_t len = 0;
+	uint16_t opcode;
+	uint8_t op;
+	int rc;
+
+	if (*data) {
+		len = OS_MBUF_PKTLEN(*data);
+	}
+
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA);
+	cmd->adv_handle = instance;
+
+	/* Complete data */
+	if (len <= BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN) {
+		cmd->operation = BLE_HCI_LE_SET_DATA_OPER_COMPLETE;
+		cmd->adv_data_len = len;
+
+		if (len) {
+			os_mbuf_copydata(*data, 0, len, cmd->adv_data);
+
+			os_mbuf_adj(*data, len);
+			*data = os_mbuf_trim_front(*data);
+		}
+
+		return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len, NULL, 0);
+	}
+
+	/* If the periodic advertising is already enabled, the periodic advertising
+	 * the op code shall be nothing but 0x03
+	 * Bluetooth Core Specification, section 7.8.62
+	 */
+	if (ble_gap_slave[instance].periodic_op == BLE_GAP_OP_S_PERIODIC_ADV) {
+		return BLE_HS_EINVAL;
+	}
+
+	/* First fragment  */
+	op = BLE_HCI_LE_SET_DATA_OPER_FIRST;
+
+	do {
+		cmd->operation = op;
+		cmd->adv_data_len = BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN;
+		os_mbuf_copydata(*data, 0, BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN, cmd->adv_data);
+
+		os_mbuf_adj(*data, BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN);
+		*data = os_mbuf_trim_front(*data);
+
+		rc = ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len, NULL, 0);
+		if (rc) {
+			return rc;
+		}
 
-    if (!ble_hs_is_enabled()) {
-        rc = BLE_HS_EDISABLED;
-        goto done;
-    }
+		len -= BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN;
+		op = BLE_HCI_LE_SET_DATA_OPER_INT;
+	} while (len > BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN);
+
+	/* Last fragment */
+	cmd->operation = BLE_HCI_LE_SET_DATA_OPER_LAST;
+	cmd->adv_data_len = len;
+	os_mbuf_copydata(*data, 0, len, cmd->adv_data);
+
+	os_mbuf_adj(*data, len);
+	*data = os_mbuf_trim_front(*data);
+
+	return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len, NULL, 0);
+#endif
+}
+
+static int ble_gap_periodic_adv_set_data_validate(uint8_t instance, struct os_mbuf *data)
+{
+	/* The corresponding extended advertising instance should be configured */
+	if (!ble_gap_slave[instance].configured) {
+		return BLE_HS_EINVAL;
+	}
+
+	if (ble_gap_slave[instance].legacy_pdu) {
+		return BLE_HS_EINVAL;
+	}
+
+	/* One more check states that if the periodic advertising is already
+	 * enabled, the operation shall be 0x03 (Complete).
+	 * This check is handled during sending the data to the controller, as the
+	 * length checks are already checked there, so this saves duplicate code
+	 */
+
+	return 0;
+}
+
+int ble_gap_periodic_adv_set_data(uint8_t instance, struct os_mbuf *data,
+                                  const struct ble_gap_periodic_adv_set_data_params *params)
+{
+	int rc;
+	if (instance >= BLE_ADV_INSTANCES) {
+		rc = BLE_HS_EINVAL;
+		goto done;
+	}
+
+	if (!ble_hs_is_enabled()) {
+		rc = BLE_HS_EDISABLED;
+		goto done;
+	}
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-    /* update_did and data cannot be set at the same time */
-    if (params && params->update_did && data) {
-        rc = BLE_HS_EINVAL;
-        goto done;
-    }
+	/* update_did and data cannot be set at the same time */
+	if (params && params->update_did && data) {
+		rc = BLE_HS_EINVAL;
+		goto done;
+	}
 #endif
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    rc = ble_gap_periodic_adv_set_data_validate(instance, data);
-    if (rc != 0) {
-        ble_hs_unlock();
-        goto done;
-    }
+	rc = ble_gap_periodic_adv_set_data_validate(instance, data);
+	if (rc != 0) {
+		ble_hs_unlock();
+		goto done;
+	}
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-    if (params && params->update_did) {
-        rc = ble_gap_periodic_adv_update_did(instance);
-    } else {
-        rc = ble_gap_periodic_adv_set(instance, &data);
-    }
+	if (params && params->update_did) {
+		rc = ble_gap_periodic_adv_update_did(instance);
+	}
+	else {
+		rc = ble_gap_periodic_adv_set(instance, &data);
+	}
 #else
-    rc = ble_gap_periodic_adv_set(instance, &data);
+	rc = ble_gap_periodic_adv_set(instance, &data);
 #endif
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
 done:
-    os_mbuf_free_chain(data);
-    return rc;
+	os_mbuf_free_chain(data);
+	return rc;
 }
 
-static int
-ble_gap_periodic_adv_stop_no_lock(uint8_t instance)
+static int ble_gap_periodic_adv_stop_no_lock(uint8_t instance)
 {
-    struct ble_hci_le_set_periodic_adv_enable_cp cmd;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_set_periodic_adv_enable_cp cmd;
+	uint16_t opcode;
+	int rc;
 
-    cmd.enable = 0x00;
-    cmd.adv_handle = instance;
+	cmd.enable = 0x00;
+	cmd.adv_handle = instance;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE);
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	if (rc != 0) {
+		return rc;
+	}
 
-    ble_gap_slave[instance].periodic_op = BLE_GAP_OP_NULL;
+	ble_gap_slave[instance].periodic_op = BLE_GAP_OP_NULL;
 
-    return 0;
+	return 0;
 }
 
-int
-ble_gap_periodic_adv_stop(uint8_t instance)
+int ble_gap_periodic_adv_stop(uint8_t instance)
 {
-    int rc;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-        return BLE_HS_EINVAL;
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		return BLE_HS_EINVAL;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
-    rc = ble_gap_periodic_adv_stop_no_lock(instance);
-    ble_hs_unlock();
+	ble_hs_lock();
+	rc = ble_gap_periodic_adv_stop_no_lock(instance);
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 
-static void
-ble_gap_npl_sync_lost(struct ble_npl_event *ev)
+static void ble_gap_npl_sync_lost(struct ble_npl_event *ev)
 {
-    struct ble_hs_periodic_sync *psync;
-    struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+	struct ble_hs_periodic_sync *psync;
+	struct ble_gap_event event;
+	ble_gap_event_fn *cb;
+	void *cb_arg;
 
-    /* this psync is no longer on list so no lock needed */
-    psync = ble_npl_event_get_arg(ev);
-    cb = psync->cb;
-    cb_arg = psync->cb_arg;
+	/* this psync is no longer on list so no lock needed */
+	psync = ble_npl_event_get_arg(ev);
+	cb = psync->cb;
+	cb_arg = psync->cb_arg;
 
-    memset(&event, 0, sizeof event);
+	memset(&event, 0, sizeof event);
 
-    event.type = BLE_GAP_EVENT_PERIODIC_SYNC_LOST;
-    event.periodic_sync_lost.sync_handle = psync->sync_handle;
-    event.periodic_sync_lost.reason = BLE_HS_EDONE;
+	event.type = BLE_GAP_EVENT_PERIODIC_SYNC_LOST;
+	event.periodic_sync_lost.sync_handle = psync->sync_handle;
+	event.periodic_sync_lost.reason = BLE_HS_EDONE;
 
-    /* Free the memory occupied by psync as it is no longer needed */
-    ble_hs_periodic_sync_free(psync);
+	/* Free the memory occupied by psync as it is no longer needed */
+	ble_hs_periodic_sync_free(psync);
 
-    ble_gap_event_listener_call(&event);
-    if (cb) {
-        cb(&event, cb_arg);
-    }
+	ble_gap_event_listener_call(&event);
+	if (cb) {
+		cb(&event, cb_arg);
+	}
 }
 
-int
-ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
-                                 const struct ble_gap_periodic_sync_params *params,
-                                 ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
+                                     const struct ble_gap_periodic_sync_params *params,
+                                     ble_gap_event_fn *cb, void *cb_arg)
 {
-    struct ble_hci_le_periodic_adv_create_sync_cp cmd;
-    struct ble_hs_periodic_sync *psync;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_periodic_adv_create_sync_cp cmd;
+	struct ble_hs_periodic_sync *psync;
+	uint16_t opcode;
+	int rc;
 
-    if (addr && (addr->type > BLE_ADDR_RANDOM)) {
-        return BLE_HS_EINVAL;
-    }
-    if (adv_sid > 0x0f) {
-        return BLE_HS_EINVAL;
-    }
-    if ((params->skip > 0x1f3) || (params->sync_timeout > 0x4000) ||
-            (params->sync_timeout < 0x0A)) {
-        return BLE_HS_EINVAL;
-    }
+	if (addr && (addr->type > BLE_ADDR_RANDOM)) {
+		return BLE_HS_EINVAL;
+	}
+	if (adv_sid > 0x0f) {
+		return BLE_HS_EINVAL;
+	}
+	if ((params->skip > 0x1f3) || (params->sync_timeout > 0x4000) ||
+	    (params->sync_timeout < 0x0A)) {
+		return BLE_HS_EINVAL;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    /* No sync can be created if another sync is still pending */
-    if (ble_gap_sync.op == BLE_GAP_OP_SYNC) {
-        ble_hs_unlock();
-        return BLE_HS_EBUSY;
-    }
+	/* No sync can be created if another sync is still pending */
+	if (ble_gap_sync.op == BLE_GAP_OP_SYNC) {
+		ble_hs_unlock();
+		return BLE_HS_EBUSY;
+	}
 
-    /* cannot create another sync if already synchronized */
-    if (ble_hs_periodic_sync_find(addr, adv_sid)) {
-        ble_hs_unlock();
-        return BLE_HS_EALREADY;
-    }
+	/* cannot create another sync if already synchronized */
+	if (ble_hs_periodic_sync_find(addr, adv_sid)) {
+		ble_hs_unlock();
+		return BLE_HS_EALREADY;
+	}
 
-    /* preallocate sync element */
-    psync = ble_hs_periodic_sync_alloc();
-    if (!psync) {
-        ble_hs_unlock();
-        return BLE_HS_ENOMEM;
-    }
+	/* preallocate sync element */
+	psync = ble_hs_periodic_sync_alloc();
+	if (!psync) {
+		ble_hs_unlock();
+		return BLE_HS_ENOMEM;
+	}
 
-    ble_npl_event_init(&psync->lost_ev, ble_gap_npl_sync_lost, psync);
+	ble_npl_event_init(&psync->lost_ev, ble_gap_npl_sync_lost, psync);
 
-    if (addr) {
-        cmd.options = 0x00;
-        cmd.peer_addr_type = addr->type;
-        memcpy(cmd.peer_addr, addr->val, BLE_DEV_ADDR_LEN);
-    } else {
-        cmd.options = 0x01;
-        cmd.peer_addr_type = BLE_ADDR_ANY->type;
-        memcpy(cmd.peer_addr, BLE_ADDR_ANY->val, BLE_DEV_ADDR_LEN);
-    }
+	if (addr) {
+		cmd.options = 0x00;
+		cmd.peer_addr_type = addr->type;
+		memcpy(cmd.peer_addr, addr->val, BLE_DEV_ADDR_LEN);
+	}
+	else {
+		cmd.options = 0x01;
+		cmd.peer_addr_type = BLE_ADDR_ANY->type;
+		memcpy(cmd.peer_addr, BLE_ADDR_ANY->val, BLE_DEV_ADDR_LEN);
+	}
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-    /* LE Periodic Advertising Create Sync command */
-    if (params->reports_disabled) {
-        SET_BIT(cmd.options, 1);
-    }
-    if (params->filter_duplicates) {
-        SET_BIT(cmd.options, 2);
-    }
+	/* LE Periodic Advertising Create Sync command */
+	if (params->reports_disabled) {
+		SET_BIT(cmd.options, 1);
+	}
+	if (params->filter_duplicates) {
+		SET_BIT(cmd.options, 2);
+	}
 #endif
-    cmd.sid = adv_sid;
-    cmd.skip = params->skip;
-    cmd.sync_timeout = htole16(params->sync_timeout);
-    cmd.sync_cte_type = 0x00;
+	cmd.sid = adv_sid;
+	cmd.skip = params->skip;
+	cmd.sync_timeout = htole16(params->sync_timeout);
+	cmd.sync_cte_type = 0x00;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC);
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (!rc) {
-        /* This shall be reset upon receiving sync_established event,
-         * or if the sync is cancelled before receiving that event.
-         */
-        ble_gap_sync.op = BLE_GAP_OP_SYNC;
-        ble_gap_sync.cb = cb;
-        ble_gap_sync.cb_arg = cb_arg;
-        ble_gap_sync.psync = psync;
-    } else {
-        ble_hs_periodic_sync_free(psync);
-    }
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC);
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	if (!rc) {
+		/* This shall be reset upon receiving sync_established event,
+		 * or if the sync is cancelled before receiving that event.
+		 */
+		ble_gap_sync.op = BLE_GAP_OP_SYNC;
+		ble_gap_sync.cb = cb;
+		ble_gap_sync.cb_arg = cb_arg;
+		ble_gap_sync.psync = psync;
+	}
+	else {
+		ble_hs_periodic_sync_free(psync);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 
-int
-ble_gap_periodic_adv_sync_create_cancel(void)
+int ble_gap_periodic_adv_sync_create_cancel(void)
 {
-    uint16_t opcode;
-    int rc = 0;
+	uint16_t opcode;
+	int rc = 0;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    if (ble_gap_sync.op != BLE_GAP_OP_SYNC) {
-        ble_hs_unlock();
-        return BLE_HS_EBUSY;
-    }
+	if (ble_gap_sync.op != BLE_GAP_OP_SYNC) {
+		ble_hs_unlock();
+		return BLE_HS_EBUSY;
+	}
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
-                        BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL);
 
-    rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, NULL, 0);
+	rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, NULL, 0);
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 
-int
-ble_gap_periodic_adv_sync_terminate(uint16_t sync_handle)
+int ble_gap_periodic_adv_sync_terminate(uint16_t sync_handle)
 {
-    struct ble_hci_le_periodic_adv_term_sync_cp cmd;
-    struct ble_hs_periodic_sync *psync;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_periodic_adv_term_sync_cp cmd;
+	struct ble_hs_periodic_sync *psync;
+	uint16_t opcode;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    if (ble_gap_sync.op == BLE_GAP_OP_SYNC) {
-        ble_hs_unlock();
-        return BLE_HS_EBUSY;
-    }
+	if (ble_gap_sync.op == BLE_GAP_OP_SYNC) {
+		ble_hs_unlock();
+		return BLE_HS_EBUSY;
+	}
 
-    /* The handle must be in the list. If it doesn't exist, it means
-     * that the sync may have been lost at the same moment in which
-     * the app wants to terminate that sync handle
-     */
-    psync = ble_hs_periodic_sync_find_by_handle(sync_handle);
-    if (!psync) {
-        /* Sync already terminated.*/
-        ble_hs_unlock();
-        return BLE_HS_ENOTCONN;
-    }
+	/* The handle must be in the list. If it doesn't exist, it means
+	 * that the sync may have been lost at the same moment in which
+	 * the app wants to terminate that sync handle
+	 */
+	psync = ble_hs_periodic_sync_find_by_handle(sync_handle);
+	if (!psync) {
+		/* Sync already terminated.*/
+		ble_hs_unlock();
+		return BLE_HS_ENOTCONN;
+	}
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC);
 
-    cmd.sync_handle = htole16(sync_handle);
+	cmd.sync_handle = htole16(sync_handle);
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
-    if (rc == 0) {
-        /* Remove the handle from the list */
-        ble_hs_periodic_sync_remove(psync);
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	if (rc == 0) {
+		/* Remove the handle from the list */
+		ble_hs_periodic_sync_remove(psync);
 
-        /* send sync_lost event, this is to mimic connection behavior and thus
-         * simplify application error handling
-         */
-        ble_npl_eventq_put(ble_hs_evq_get(), &psync->lost_ev);
-    }
+		/* send sync_lost event, this is to mimic connection behavior and thus
+		 * simplify application error handling
+		 */
+		ble_npl_eventq_put(ble_hs_evq_get(), &psync->lost_ev);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_TRANSFER)
 /* LE Set Periodic Advertising Receive Enable command */
-int
-ble_gap_periodic_adv_sync_reporting(uint16_t sync_handle,
-                                    bool enable,
-                                    const struct ble_gap_periodic_adv_sync_reporting_params *params)
+int ble_gap_periodic_adv_sync_reporting(
+	uint16_t sync_handle, bool enable,
+	const struct ble_gap_periodic_adv_sync_reporting_params *params)
 {
-    struct ble_hci_le_periodic_adv_receive_enable_cp cmd;
-    struct ble_hs_periodic_sync *psync;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_periodic_adv_receive_enable_cp cmd;
+	struct ble_hs_periodic_sync *psync;
+	uint16_t opcode;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    if (ble_gap_sync.op == BLE_GAP_OP_SYNC) {
-        ble_hs_unlock();
-        return BLE_HS_EBUSY;
-    }
+	if (ble_gap_sync.op == BLE_GAP_OP_SYNC) {
+		ble_hs_unlock();
+		return BLE_HS_EBUSY;
+	}
 
-    psync = ble_hs_periodic_sync_find_by_handle(sync_handle);
-    if (!psync) {
-        ble_hs_unlock();
-        return BLE_HS_ENOTCONN;
-    }
+	psync = ble_hs_periodic_sync_find_by_handle(sync_handle);
+	if (!psync) {
+		ble_hs_unlock();
+		return BLE_HS_ENOTCONN;
+	}
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE);
 
-    cmd.sync_handle = htole16(sync_handle);
-    cmd.enable = enable ? 0x01 : 0x00;
+	cmd.sync_handle = htole16(sync_handle);
+	cmd.enable = enable ? 0x01 : 0x00;
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-    if (params && params->filter_duplicates) {
-        SET_BIT(cmd.enable, 1);
-    }
+	if (params && params->filter_duplicates) {
+		SET_BIT(cmd.enable, 1);
+	}
 #endif
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 
-int
-ble_gap_periodic_adv_sync_transfer(uint16_t sync_handle, uint16_t conn_handle,
-                                   uint16_t service_data)
+int ble_gap_periodic_adv_sync_transfer(uint16_t sync_handle, uint16_t conn_handle,
+                                       uint16_t service_data)
 {
-    struct ble_hci_le_periodic_adv_sync_transfer_cp cmd;
-    struct ble_hci_le_periodic_adv_sync_transfer_rp rsp;
-    struct ble_hs_periodic_sync *psync;
-    struct ble_hs_conn *conn;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_periodic_adv_sync_transfer_cp cmd;
+	struct ble_hci_le_periodic_adv_sync_transfer_rp rsp;
+	struct ble_hs_periodic_sync *psync;
+	struct ble_hs_conn *conn;
+	uint16_t opcode;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(conn_handle);
-    if (!conn) {
-        ble_hs_unlock();
-        return BLE_HS_ENOTCONN;
-    }
+	conn = ble_hs_conn_find(conn_handle);
+	if (!conn) {
+		ble_hs_unlock();
+		return BLE_HS_ENOTCONN;
+	}
 
-    psync = ble_hs_periodic_sync_find_by_handle(sync_handle);
-    if (!psync) {
-        ble_hs_unlock();
-        return BLE_HS_ENOTCONN;
-    }
+	psync = ble_hs_periodic_sync_find_by_handle(sync_handle);
+	if (!psync) {
+		ble_hs_unlock();
+		return BLE_HS_ENOTCONN;
+	}
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER);
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.sync_handle = htole16(sync_handle);
-    cmd.service_data = htole16(service_data);
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.sync_handle = htole16(sync_handle);
+	cmd.service_data = htole16(service_data);
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (!rc) {
-        BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
-    }
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+	if (!rc) {
+		BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 
-int
-ble_gap_periodic_adv_sync_set_info(uint8_t instance, uint16_t conn_handle,
-                                   uint16_t service_data)
+int ble_gap_periodic_adv_sync_set_info(uint8_t instance, uint16_t conn_handle,
+                                       uint16_t service_data)
 {
-    struct ble_hci_le_periodic_adv_set_info_transfer_cp cmd;
-    struct ble_hci_le_periodic_adv_set_info_transfer_rp rsp;
-    struct ble_hs_conn *conn;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_periodic_adv_set_info_transfer_cp cmd;
+	struct ble_hci_le_periodic_adv_set_info_transfer_rp rsp;
+	struct ble_hs_conn *conn;
+	uint16_t opcode;
+	int rc;
 
-    if (instance >= BLE_ADV_INSTANCES) {
-        return BLE_HS_EINVAL;
-    }
+	if (instance >= BLE_ADV_INSTANCES) {
+		return BLE_HS_EINVAL;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
-    if (ble_gap_slave[instance].periodic_op != BLE_GAP_OP_S_PERIODIC_ADV) {
-        /* periodic adv not enabled */
-        ble_hs_unlock();
-        return BLE_HS_EINVAL;
-    }
+	ble_hs_lock();
+	if (ble_gap_slave[instance].periodic_op != BLE_GAP_OP_S_PERIODIC_ADV) {
+		/* periodic adv not enabled */
+		ble_hs_unlock();
+		return BLE_HS_EINVAL;
+	}
 
-    conn = ble_hs_conn_find(conn_handle);
-    if (!conn) {
-        ble_hs_unlock();
-        return BLE_HS_ENOTCONN;
-    }
+	conn = ble_hs_conn_find(conn_handle);
+	if (!conn) {
+		ble_hs_unlock();
+		return BLE_HS_ENOTCONN;
+	}
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER);
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.adv_handle = instance;
-    cmd.service_data = htole16(service_data);
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.adv_handle = instance;
+	cmd.service_data = htole16(service_data);
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (!rc) {
-        BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
-    }
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+	if (!rc) {
+		BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 
-static int
-periodic_adv_transfer_enable(uint16_t conn_handle,
-                             const struct ble_gap_periodic_sync_params *params)
+static int periodic_adv_transfer_enable(uint16_t conn_handle,
+                                        const struct ble_gap_periodic_sync_params *params)
 {
-    struct ble_hci_le_periodic_adv_sync_transfer_params_cp cmd;
-    struct ble_hci_le_periodic_adv_sync_transfer_params_rp rsp;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_periodic_adv_sync_transfer_params_cp cmd;
+	struct ble_hci_le_periodic_adv_sync_transfer_params_rp rsp;
+	uint16_t opcode;
+	int rc;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS);
 
-    memset(&cmd, 0, sizeof(cmd));
-    cmd.conn_handle = htole16(conn_handle);
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.conn_handle = htole16(conn_handle);
 
-    if (params != NULL) {
-        cmd.sync_cte_type = 0x00;
-        cmd.mode = params->reports_disabled ? 0x01 : 0x02;
+	if (params != NULL) {
+		cmd.sync_cte_type = 0x00;
+		cmd.mode = params->reports_disabled ? 0x01 : 0x02;
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-        if (!params->reports_disabled && params->filter_duplicates) {
-            cmd.mode = 0x03;
-        }
+		if (!params->reports_disabled && params->filter_duplicates) {
+			cmd.mode = 0x03;
+		}
 #endif
 
-        cmd.skip = htole16(params->skip);
-        cmd.sync_timeout = htole16(params->sync_timeout);
-    }
+		cmd.skip = htole16(params->skip);
+		cmd.sync_timeout = htole16(params->sync_timeout);
+	}
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (!rc) {
-        BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
-    }
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+	if (!rc) {
+		BLE_HS_DBG_ASSERT(le16toh(rsp.conn_handle) == conn_handle);
+	}
 
-    return rc;
+	return rc;
 }
 
-int
-periodic_adv_set_default_sync_params(const struct ble_gap_periodic_sync_params *params)
+int periodic_adv_set_default_sync_params(const struct ble_gap_periodic_sync_params *params)
 {
-    struct ble_hci_le_set_default_periodic_sync_transfer_params_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_default_periodic_sync_transfer_params_cp cmd;
+	uint16_t opcode;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS);
 
-    memset(&cmd, 0, sizeof(cmd));
+	memset(&cmd, 0, sizeof(cmd));
 
-    if (params != NULL) {
-        cmd.sync_cte_type = 0x00;
-        cmd.mode = params->reports_disabled ? 0x01 : 0x02;
+	if (params != NULL) {
+		cmd.sync_cte_type = 0x00;
+		cmd.mode = params->reports_disabled ? 0x01 : 0x02;
 
 #if MYNEWT_VAL(BLE_VERSION) >= 53
-        if (!params->reports_disabled && params->filter_duplicates) {
-            cmd.mode = 0x03;
-        }
+		if (!params->reports_disabled && params->filter_duplicates) {
+			cmd.mode = 0x03;
+		}
 #endif
 
-        cmd.skip = htole16(params->skip);
-        cmd.sync_timeout = htole16(params->sync_timeout);
-    }
+		cmd.skip = htole16(params->skip);
+		cmd.sync_timeout = htole16(params->sync_timeout);
+	}
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-int
-ble_gap_periodic_adv_sync_receive(uint16_t conn_handle,
-                                  const struct ble_gap_periodic_sync_params *params,
-                                  ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_periodic_adv_sync_receive(uint16_t conn_handle,
+                                      const struct ble_gap_periodic_sync_params *params,
+                                      ble_gap_event_fn *cb, void *cb_arg)
 {
-    struct ble_hs_conn *conn;
-    int rc;
+	struct ble_hs_conn *conn;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(conn_handle);
-    if (!conn) {
-        ble_hs_unlock();
-        return BLE_HS_ENOTCONN;
-    }
+	conn = ble_hs_conn_find(conn_handle);
+	if (!conn) {
+		ble_hs_unlock();
+		return BLE_HS_ENOTCONN;
+	}
 
-    if (params) {
-        if (conn->psync) {
-            ble_hs_unlock();
-            return BLE_HS_EALREADY;
-        }
+	if (params) {
+		if (conn->psync) {
+			ble_hs_unlock();
+			return BLE_HS_EALREADY;
+		}
 
-        conn->psync = ble_hs_periodic_sync_alloc();
-        if (!conn->psync) {
-            ble_hs_unlock();
-            return BLE_HS_ENOMEM;
-        }
+		conn->psync = ble_hs_periodic_sync_alloc();
+		if (!conn->psync) {
+			ble_hs_unlock();
+			return BLE_HS_ENOMEM;
+		}
 
-        rc = periodic_adv_transfer_enable(conn_handle, params);
-        if (rc) {
-            ble_hs_periodic_sync_free(conn->psync);
-            conn->psync = NULL;
-        } else {
-            conn->psync->cb = cb;
-            conn->psync->cb_arg = cb_arg;
-            ble_npl_event_init(&conn->psync->lost_ev, ble_gap_npl_sync_lost,
-                               conn->psync);
-        }
-    } else {
-        if (!conn->psync) {
-            ble_hs_unlock();
-            return BLE_HS_EALREADY;
-        }
+		rc = periodic_adv_transfer_enable(conn_handle, params);
+		if (rc) {
+			ble_hs_periodic_sync_free(conn->psync);
+			conn->psync = NULL;
+		}
+		else {
+			conn->psync->cb = cb;
+			conn->psync->cb_arg = cb_arg;
+			ble_npl_event_init(&conn->psync->lost_ev, ble_gap_npl_sync_lost, conn->psync);
+		}
+	}
+	else {
+		if (!conn->psync) {
+			ble_hs_unlock();
+			return BLE_HS_EALREADY;
+		}
 
-        rc = periodic_adv_transfer_disable(conn_handle);
-        if (!rc) {
-            ble_hs_periodic_sync_free(conn->psync);
-            conn->psync = NULL;
-        }
-    }
+		rc = periodic_adv_transfer_disable(conn_handle);
+		if (!rc) {
+			ble_hs_periodic_sync_free(conn->psync);
+			conn->psync = NULL;
+		}
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 #endif
 
-int
-ble_gap_add_dev_to_periodic_adv_list(const ble_addr_t *peer_addr,
-                                     uint8_t adv_sid)
+int ble_gap_add_dev_to_periodic_adv_list(const ble_addr_t *peer_addr, uint8_t adv_sid)
 {
-    struct ble_hci_le_add_dev_to_periodic_adv_list_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_add_dev_to_periodic_adv_list_cp cmd;
+	uint16_t opcode;
 
-    if ((peer_addr->type > BLE_ADDR_RANDOM) || (adv_sid > 0x0f)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if ((peer_addr->type > BLE_ADDR_RANDOM) || (adv_sid > 0x0f)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    cmd.peer_addr_type = peer_addr->type;
-    memcpy(cmd.peer_addr, peer_addr->val, BLE_DEV_ADDR_LEN);
-    cmd.sid = adv_sid;
+	cmd.peer_addr_type = peer_addr->type;
+	memcpy(cmd.peer_addr, peer_addr->val, BLE_DEV_ADDR_LEN);
+	cmd.sid = adv_sid;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
-                        BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST);
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-int
-ble_gap_rem_dev_from_periodic_adv_list(const ble_addr_t *peer_addr, uint8_t adv_sid)
+int ble_gap_rem_dev_from_periodic_adv_list(const ble_addr_t *peer_addr, uint8_t adv_sid)
 {
-    struct ble_hci_le_rem_dev_from_periodic_adv_list_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_rem_dev_from_periodic_adv_list_cp cmd;
+	uint16_t opcode;
 
-    if ((peer_addr->type > BLE_ADDR_RANDOM) || (adv_sid > 0x0f)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if ((peer_addr->type > BLE_ADDR_RANDOM) || (adv_sid > 0x0f)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    cmd.peer_addr_type = peer_addr->type;
-    memcpy(cmd.peer_addr, peer_addr->val, BLE_DEV_ADDR_LEN);
-    cmd.sid = adv_sid;
+	cmd.peer_addr_type = peer_addr->type;
+	memcpy(cmd.peer_addr, peer_addr->val, BLE_DEV_ADDR_LEN);
+	cmd.sid = adv_sid;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
-                        BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST);
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-int
-ble_gap_clear_periodic_adv_list(void)
+int ble_gap_clear_periodic_adv_list(void)
 {
-    uint16_t opcode;
-    int rc = 0;
+	uint16_t opcode;
+	int rc = 0;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST);
 
-    rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, NULL, 0);
+	rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, NULL, 0);
 
-    return rc;
+	return rc;
 }
 
-int
-ble_gap_read_periodic_adv_list_size(uint8_t *per_adv_list_size)
+int ble_gap_read_periodic_adv_list_size(uint8_t *per_adv_list_size)
 {
-    struct ble_hci_le_rd_periodic_adv_list_size_rp rsp;
-    uint16_t opcode;
-    int rc = 0;
+	struct ble_hci_le_rd_periodic_adv_list_size_rp rsp;
+	uint16_t opcode;
+	int rc = 0;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE);
 
-    rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, &rsp, sizeof(rsp));
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, &rsp, sizeof(rsp));
+	if (rc != 0) {
+		return rc;
+	}
 
-    *per_adv_list_size = rsp.list_size;
+	*per_adv_list_size = rsp.list_size;
 
-    return 0;
+	return 0;
 }
 #endif
 
@@ -4550,508 +4424,496 @@ ble_gap_read_periodic_adv_list_size(uint8_t *per_adv_list_size)
  *****************************************************************************/
 
 #if MYNEWT_VAL(BLE_EXT_ADV) && NIMBLE_BLE_SCAN
-static int
-ble_gap_ext_disc_tx_params(uint8_t own_addr_type, uint8_t filter_policy,
-                       const struct ble_hs_hci_ext_scan_param *uncoded_params,
-                       const struct ble_hs_hci_ext_scan_param *coded_params)
+static int ble_gap_ext_disc_tx_params(uint8_t own_addr_type, uint8_t filter_policy,
+                                      const struct ble_hs_hci_ext_scan_param *uncoded_params,
+                                      const struct ble_hs_hci_ext_scan_param *coded_params)
 {
-    struct ble_hci_le_set_ext_scan_params_cp *cmd;
-    struct scan_params *params;
-    uint8_t buf[sizeof(*cmd) + 2 * sizeof(*params)];
-    uint8_t len = sizeof(*cmd);
+	struct ble_hci_le_set_ext_scan_params_cp *cmd;
+	struct scan_params *params;
+	uint8_t buf[sizeof(*cmd) + 2 * sizeof(*params)];
+	uint8_t len = sizeof(*cmd);
 
-    /* Check own addr type */
-    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	/* Check own addr type */
+	if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    /* Check scanner filter policy */
-    if (filter_policy > BLE_HCI_SCAN_FILT_MAX) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	/* Check scanner filter policy */
+	if (filter_policy > BLE_HCI_SCAN_FILT_MAX) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    cmd = (void *) buf;
-    params = cmd->scans;
+	cmd = (void *) buf;
+	params = cmd->scans;
 
-    cmd->filter_policy = filter_policy;
-    cmd->own_addr_type = own_addr_type;
-    cmd->phys = 0;
+	cmd->filter_policy = filter_policy;
+	cmd->own_addr_type = own_addr_type;
+	cmd->phys = 0;
 
-    if (uncoded_params) {
-        cmd->phys |= BLE_HCI_LE_PHY_1M_PREF_MASK;
+	if (uncoded_params) {
+		cmd->phys |= BLE_HCI_LE_PHY_1M_PREF_MASK;
 
-        params->type = uncoded_params->scan_type;
-        params->itvl = htole16(uncoded_params->scan_itvl);
-        params->window = htole16(uncoded_params->scan_window);
+		params->type = uncoded_params->scan_type;
+		params->itvl = htole16(uncoded_params->scan_itvl);
+		params->window = htole16(uncoded_params->scan_window);
 
-        len += sizeof(*params);
-        params++;
-    }
+		len += sizeof(*params);
+		params++;
+	}
 
-    if (coded_params) {
-        cmd->phys |= BLE_HCI_LE_PHY_CODED_PREF_MASK;
+	if (coded_params) {
+		cmd->phys |= BLE_HCI_LE_PHY_CODED_PREF_MASK;
 
-        params->type = coded_params->scan_type;
-        params->itvl = htole16(coded_params->scan_itvl);
-        params->window = htole16(coded_params->scan_window);
+		params->type = coded_params->scan_type;
+		params->itvl = htole16(coded_params->scan_itvl);
+		params->window = htole16(coded_params->scan_window);
 
-        len += sizeof(*params);
-        params++;
-    }
+		len += sizeof(*params);
+		params++;
+	}
 
-    if (!cmd->phys) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
+	if (!cmd->phys) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM),
-                             cmd, len, NULL, 0);
+	return ble_hs_hci_cmd_tx(
+		BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM), cmd, len, NULL, 0);
 }
 
-static int
-ble_gap_ext_disc_enable_tx(uint8_t enable, uint8_t filter_duplicates,
-                           uint16_t duration, uint16_t period)
+static int ble_gap_ext_disc_enable_tx(uint8_t enable, uint8_t filter_duplicates,
+                                      uint16_t duration, uint16_t period)
 {
-    struct ble_hci_le_set_ext_scan_enable_cp cmd;
+	struct ble_hci_le_set_ext_scan_enable_cp cmd;
 
-    cmd.enable = enable;
-    cmd.filter_dup = filter_duplicates;
-    cmd.duration = htole16(duration);
-    cmd.period = htole16(period);
+	cmd.enable = enable;
+	cmd.filter_dup = filter_duplicates;
+	cmd.duration = htole16(duration);
+	cmd.period = htole16(period);
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE),
-                             &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(
+		BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE), &cmd,
+		sizeof(cmd), NULL, 0);
 }
 #endif
 #endif
 #if NIMBLE_BLE_SCAN
 #if !MYNEWT_VAL(BLE_EXT_ADV)
-static int
-ble_gap_disc_enable_tx(int enable, int filter_duplicates)
+static int ble_gap_disc_enable_tx(int enable, int filter_duplicates)
 {
-    struct ble_hci_le_set_scan_enable_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_scan_enable_cp cmd;
+	uint16_t opcode;
 
-    cmd.enable = !!enable;
-    cmd.filter_duplicates = !!filter_duplicates;
+	cmd.enable = !!enable;
+	cmd.filter_duplicates = !!filter_duplicates;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_SCAN_ENABLE);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_SCAN_ENABLE);
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-static int
-ble_gap_disc_tx_params(uint8_t own_addr_type,
-                       const struct ble_gap_disc_params *disc_params)
+static int ble_gap_disc_tx_params(uint8_t own_addr_type,
+                                  const struct ble_gap_disc_params *disc_params)
 {
-    struct ble_hci_le_set_scan_params_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_scan_params_cp cmd;
+	uint16_t opcode;
 
-    if (disc_params->passive) {
-        cmd.scan_type = BLE_HCI_SCAN_TYPE_PASSIVE;
-    } else {
-        cmd.scan_type = BLE_HCI_SCAN_TYPE_ACTIVE;
-    }
+	if (disc_params->passive) {
+		cmd.scan_type = BLE_HCI_SCAN_TYPE_PASSIVE;
+	}
+	else {
+		cmd.scan_type = BLE_HCI_SCAN_TYPE_ACTIVE;
+	}
 
-    cmd.scan_itvl = htole16(disc_params->itvl);
-    cmd.scan_window = htole16(disc_params->window);
-    cmd.own_addr_type = own_addr_type;
-    cmd.filter_policy = disc_params->filter_policy;
+	cmd.scan_itvl = htole16(disc_params->itvl);
+	cmd.scan_window = htole16(disc_params->window);
+	cmd.own_addr_type = own_addr_type;
+	cmd.filter_policy = disc_params->filter_policy;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_SCAN_PARAMS);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_SCAN_PARAMS);
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 #endif
 
-static int
-ble_gap_disc_disable_tx(void)
+static int ble_gap_disc_disable_tx(void)
 {
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    return ble_gap_ext_disc_enable_tx(0, 0, 0, 0);
+	return ble_gap_ext_disc_enable_tx(0, 0, 0, 0);
 #else
-    return ble_gap_disc_enable_tx(0, 0);
+	return ble_gap_disc_enable_tx(0, 0);
 #endif
 }
 
-static int
-ble_gap_disc_cancel_no_lock(void)
+static int ble_gap_disc_cancel_no_lock(void)
 {
-    int rc;
+	int rc;
 
-    STATS_INC(ble_gap_stats, discover_cancel);
+	STATS_INC(ble_gap_stats, discover_cancel);
 
-    if (!ble_gap_disc_active()) {
-        rc = BLE_HS_EALREADY;
-        goto done;
-    }
+	if (!ble_gap_disc_active()) {
+		rc = BLE_HS_EALREADY;
+		goto done;
+	}
 
-    rc = ble_gap_disc_disable_tx();
-    if (rc != 0) {
-        goto done;
-    }
+	rc = ble_gap_disc_disable_tx();
+	if (rc != 0) {
+		goto done;
+	}
 
-    ble_gap_master_reset_state();
+	ble_gap_master_reset_state();
 
 done:
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, discover_cancel_fail);
-    }
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, discover_cancel_fail);
+	}
 
-    return rc;
+	return rc;
 }
 #endif
 
-int
-ble_gap_disc_cancel(void)
+int ble_gap_disc_cancel(void)
 {
 #if NIMBLE_BLE_SCAN
-    int rc;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
-    rc = ble_gap_disc_cancel_no_lock();
-    ble_hs_unlock();
+	ble_hs_lock();
+	rc = ble_gap_disc_cancel_no_lock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
 #if NIMBLE_BLE_SCAN
-static int
-ble_gap_disc_ext_validate(uint8_t own_addr_type)
+static int ble_gap_disc_ext_validate(uint8_t own_addr_type)
 {
-    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
-        return BLE_HS_EINVAL;
-    }
+	if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+		return BLE_HS_EINVAL;
+	}
 
-    if (ble_gap_conn_active()) {
-        return BLE_HS_EBUSY;
-    }
+	if (ble_gap_conn_active()) {
+		return BLE_HS_EBUSY;
+	}
 
-    if (ble_gap_disc_active()) {
-        return BLE_HS_EALREADY;
-    }
+	if (ble_gap_disc_active()) {
+		return BLE_HS_EALREADY;
+	}
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    if (ble_gap_is_preempted()) {
-        return BLE_HS_EPREEMPTED;
-    }
+	if (ble_gap_is_preempted()) {
+		return BLE_HS_EPREEMPTED;
+	}
 
-    return 0;
+	return 0;
 }
 #endif
 
 #if MYNEWT_VAL(BLE_EXT_ADV) && NIMBLE_BLE_SCAN
-static void
-ble_gap_ext_disc_fill_dflts(uint8_t limited,
-                            struct ble_hs_hci_ext_scan_param *disc_params)
+static void ble_gap_ext_disc_fill_dflts(uint8_t limited,
+                                        struct ble_hs_hci_ext_scan_param *disc_params)
 {
-   if (disc_params->scan_itvl == 0) {
-        if (limited) {
-            disc_params->scan_itvl = BLE_GAP_LIM_DISC_SCAN_INT;
-        } else {
-            disc_params->scan_itvl = BLE_GAP_SCAN_FAST_INTERVAL_MIN;
-        }
-    }
+	if (disc_params->scan_itvl == 0) {
+		if (limited) {
+			disc_params->scan_itvl = BLE_GAP_LIM_DISC_SCAN_INT;
+		}
+		else {
+			disc_params->scan_itvl = BLE_GAP_SCAN_FAST_INTERVAL_MIN;
+		}
+	}
 
-    if (disc_params->scan_window == 0) {
-        if (limited) {
-            disc_params->scan_window = BLE_GAP_LIM_DISC_SCAN_WINDOW;
-        } else {
-            disc_params->scan_window = BLE_GAP_SCAN_FAST_WINDOW;
-        }
-    }
+	if (disc_params->scan_window == 0) {
+		if (limited) {
+			disc_params->scan_window = BLE_GAP_LIM_DISC_SCAN_WINDOW;
+		}
+		else {
+			disc_params->scan_window = BLE_GAP_SCAN_FAST_WINDOW;
+		}
+	}
 }
 
-static void
-ble_gap_ext_scan_params_to_hci(const struct ble_gap_ext_disc_params *params,
-                               struct ble_hs_hci_ext_scan_param *hci_params)
+static void ble_gap_ext_scan_params_to_hci(const struct ble_gap_ext_disc_params *params,
+                                           struct ble_hs_hci_ext_scan_param *hci_params)
 {
+	memset(hci_params, 0, sizeof(*hci_params));
 
-    memset(hci_params, 0, sizeof(*hci_params));
-
-    if (params->passive) {
-        hci_params->scan_type =  BLE_HCI_SCAN_TYPE_PASSIVE;
-    } else {
-        hci_params->scan_type = BLE_HCI_SCAN_TYPE_ACTIVE;
-    }
+	if (params->passive) {
+		hci_params->scan_type = BLE_HCI_SCAN_TYPE_PASSIVE;
+	}
+	else {
+		hci_params->scan_type = BLE_HCI_SCAN_TYPE_ACTIVE;
+	}
 
-    hci_params->scan_itvl = params->itvl;
-    hci_params->scan_window = params->window;
+	hci_params->scan_itvl = params->itvl;
+	hci_params->scan_window = params->window;
 }
 #endif
 
-int
-ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
-                 uint8_t filter_duplicates, uint8_t filter_policy,
-                 uint8_t limited,
-                 const struct ble_gap_ext_disc_params *uncoded_params,
-                 const struct ble_gap_ext_disc_params *coded_params,
-                 ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
+                     uint8_t filter_duplicates, uint8_t filter_policy, uint8_t limited,
+                     const struct ble_gap_ext_disc_params *uncoded_params,
+                     const struct ble_gap_ext_disc_params *coded_params,
+                     ble_gap_event_fn *cb, void *cb_arg)
 {
 #if NIMBLE_BLE_SCAN && MYNEWT_VAL(BLE_EXT_ADV)
-    struct ble_hs_hci_ext_scan_param ucp;
-    struct ble_hs_hci_ext_scan_param cp;
-    int rc;
-
-    STATS_INC(ble_gap_stats, discover);
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    ble_hs_lock();
-
-    rc = ble_gap_disc_ext_validate(own_addr_type);
-    if (rc != 0) {
-        goto done;
-    }
-
-    /* Make a copy of the parameter structure and fill unspecified values with
-     * defaults.
-     */
-
-    if (uncoded_params) {
-        ble_gap_ext_scan_params_to_hci(uncoded_params, &ucp);
-        ble_gap_ext_disc_fill_dflts(limited, &ucp);
-
-        /* XXX: We should do it only once */
-        if (!uncoded_params->passive) {
-            rc = ble_hs_id_use_addr(own_addr_type);
-            if (rc != 0) {
-                goto done;
-            }
-        }
-    }
-
-    if (coded_params) {
-        ble_gap_ext_scan_params_to_hci(coded_params, &cp);
-        ble_gap_ext_disc_fill_dflts(limited, &cp);
-
-        /* XXX: We should do it only once */
-        if (!coded_params->passive) {
-            rc = ble_hs_id_use_addr(own_addr_type);
-            if (rc != 0) {
-                goto done;
-            }
-        }
-    }
-
-    ble_gap_master.disc.limited = limited;
-    ble_gap_master.cb = cb;
-    ble_gap_master.cb_arg = cb_arg;
-
-    rc = ble_gap_ext_disc_tx_params(own_addr_type, filter_policy,
-                                    uncoded_params ? &ucp : NULL,
-                                    coded_params ? &cp : NULL);
-    if (rc != 0) {
-        goto done;
-    }
-
-    ble_gap_master.op = BLE_GAP_OP_M_DISC;
-    ble_gap_master.legacy_discovery = 0;
-
-    rc = ble_gap_ext_disc_enable_tx(1, filter_duplicates, duration, period);
-    if (rc != 0) {
-        ble_gap_master_reset_state();
-        goto done;
-    }
-
-    rc = 0;
+	struct ble_hs_hci_ext_scan_param ucp;
+	struct ble_hs_hci_ext_scan_param cp;
+	int rc;
+
+	STATS_INC(ble_gap_stats, discover);
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	ble_hs_lock();
+
+	rc = ble_gap_disc_ext_validate(own_addr_type);
+	if (rc != 0) {
+		goto done;
+	}
+
+	/* Make a copy of the parameter structure and fill unspecified values with
+	 * defaults.
+	 */
+
+	if (uncoded_params) {
+		ble_gap_ext_scan_params_to_hci(uncoded_params, &ucp);
+		ble_gap_ext_disc_fill_dflts(limited, &ucp);
+
+		/* XXX: We should do it only once */
+		if (!uncoded_params->passive) {
+			rc = ble_hs_id_use_addr(own_addr_type);
+			if (rc != 0) {
+				goto done;
+			}
+		}
+	}
+
+	if (coded_params) {
+		ble_gap_ext_scan_params_to_hci(coded_params, &cp);
+		ble_gap_ext_disc_fill_dflts(limited, &cp);
+
+		/* XXX: We should do it only once */
+		if (!coded_params->passive) {
+			rc = ble_hs_id_use_addr(own_addr_type);
+			if (rc != 0) {
+				goto done;
+			}
+		}
+	}
+
+	ble_gap_master.disc.limited = limited;
+	ble_gap_master.cb = cb;
+	ble_gap_master.cb_arg = cb_arg;
+
+	rc = ble_gap_ext_disc_tx_params(own_addr_type, filter_policy,
+	                                uncoded_params ? &ucp : NULL,
+	                                coded_params ? &cp : NULL);
+	if (rc != 0) {
+		goto done;
+	}
+
+	ble_gap_master.op = BLE_GAP_OP_M_DISC;
+	ble_gap_master.legacy_discovery = 0;
+
+	rc = ble_gap_ext_disc_enable_tx(1, filter_duplicates, duration, period);
+	if (rc != 0) {
+		ble_gap_master_reset_state();
+		goto done;
+	}
+
+	rc = 0;
 
 done:
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, discover_fail);
-    }
-    return rc;
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, discover_fail);
+	}
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
 #if NIMBLE_BLE_SCAN && !MYNEWT_VAL(BLE_EXT_ADV)
-static void
-ble_gap_disc_fill_dflts(struct ble_gap_disc_params *disc_params)
+static void ble_gap_disc_fill_dflts(struct ble_gap_disc_params *disc_params)
 {
-   if (disc_params->itvl == 0) {
-        if (disc_params->limited) {
-            disc_params->itvl = BLE_GAP_LIM_DISC_SCAN_INT;
-        } else {
-            disc_params->itvl = BLE_GAP_SCAN_FAST_INTERVAL_MIN;
-        }
-    }
+	if (disc_params->itvl == 0) {
+		if (disc_params->limited) {
+			disc_params->itvl = BLE_GAP_LIM_DISC_SCAN_INT;
+		}
+		else {
+			disc_params->itvl = BLE_GAP_SCAN_FAST_INTERVAL_MIN;
+		}
+	}
 
-    if (disc_params->window == 0) {
-        if (disc_params->limited) {
-            disc_params->window = BLE_GAP_LIM_DISC_SCAN_WINDOW;
-        } else {
-            disc_params->window = BLE_GAP_SCAN_FAST_WINDOW;
-        }
-    }
+	if (disc_params->window == 0) {
+		if (disc_params->limited) {
+			disc_params->window = BLE_GAP_LIM_DISC_SCAN_WINDOW;
+		}
+		else {
+			disc_params->window = BLE_GAP_SCAN_FAST_WINDOW;
+		}
+	}
 }
 
-static int
-ble_gap_disc_validate(uint8_t own_addr_type,
-                      const struct ble_gap_disc_params *disc_params)
+static int ble_gap_disc_validate(uint8_t own_addr_type,
+                                 const struct ble_gap_disc_params *disc_params)
 {
-    if (disc_params == NULL) {
-        return BLE_HS_EINVAL;
-    }
+	if (disc_params == NULL) {
+		return BLE_HS_EINVAL;
+	}
 
-    /* Check interval and window */
-    if ((disc_params->itvl < BLE_HCI_SCAN_ITVL_MIN) ||
-        (disc_params->itvl > BLE_HCI_SCAN_ITVL_MAX) ||
-        (disc_params->window < BLE_HCI_SCAN_WINDOW_MIN) ||
-        (disc_params->window > BLE_HCI_SCAN_WINDOW_MAX) ||
-        (disc_params->itvl < disc_params->window)) {
-        return BLE_HS_EINVAL;
-    }
+	/* Check interval and window */
+	if ((disc_params->itvl < BLE_HCI_SCAN_ITVL_MIN) ||
+	    (disc_params->itvl > BLE_HCI_SCAN_ITVL_MAX) ||
+	    (disc_params->window < BLE_HCI_SCAN_WINDOW_MIN) ||
+	    (disc_params->window > BLE_HCI_SCAN_WINDOW_MAX) ||
+	    (disc_params->itvl < disc_params->window)) {
+		return BLE_HS_EINVAL;
+	}
 
-    /* Check scanner filter policy */
-    if (disc_params->filter_policy > BLE_HCI_SCAN_FILT_MAX) {
-        return BLE_HS_EINVAL;
-    }
+	/* Check scanner filter policy */
+	if (disc_params->filter_policy > BLE_HCI_SCAN_FILT_MAX) {
+		return BLE_HS_EINVAL;
+	}
 
-    return ble_gap_disc_ext_validate(own_addr_type);
+	return ble_gap_disc_ext_validate(own_addr_type);
 }
 #endif
 
-int
-ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
-             const struct ble_gap_disc_params *disc_params,
-             ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
+                 const struct ble_gap_disc_params *disc_params, ble_gap_event_fn *cb,
+                 void *cb_arg)
 {
 #if NIMBLE_BLE_SCAN
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    struct ble_gap_ext_disc_params p = {0};
-    int rc;
+	struct ble_gap_ext_disc_params p = {0};
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    p.itvl = disc_params->itvl;
-    p.passive = disc_params->passive;
-    p.window = disc_params->window;
+	p.itvl = disc_params->itvl;
+	p.passive = disc_params->passive;
+	p.window = disc_params->window;
 
-    if (duration_ms == BLE_HS_FOREVER) {
-        duration_ms = 0;
-    } else if (duration_ms == 0) {
-        duration_ms = BLE_GAP_DISC_DUR_DFLT;
-    }
+	if (duration_ms == BLE_HS_FOREVER) {
+		duration_ms = 0;
+	}
+	else if (duration_ms == 0) {
+		duration_ms = BLE_GAP_DISC_DUR_DFLT;
+	}
 
-    rc = ble_gap_ext_disc(own_addr_type, duration_ms/10, 0,
-                          disc_params->filter_duplicates,
-                          disc_params->filter_policy, disc_params->limited,
-                          &p, NULL, cb, cb_arg);
+	rc = ble_gap_ext_disc(own_addr_type, duration_ms / 10, 0,
+	                      disc_params->filter_duplicates, disc_params->filter_policy,
+	                      disc_params->limited, &p, NULL, cb, cb_arg);
 
-    ble_gap_master.legacy_discovery = 1;
+	ble_gap_master.legacy_discovery = 1;
 
-    return rc;
+	return rc;
 #else
-    struct ble_gap_disc_params params;
-    uint32_t duration_ticks = 0;
-    int rc;
-
-    STATS_INC(ble_gap_stats, discover);
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    ble_hs_lock();
-
-    /* Make a copy of the parameter strcuture and fill unspecified values with
-     * defaults.
-     */
-    params = *disc_params;
-    ble_gap_disc_fill_dflts(&params);
-
-    rc = ble_gap_disc_validate(own_addr_type, &params);
-    if (rc != 0) {
-        goto done;
-    }
-
-    if (duration_ms == 0) {
-        duration_ms = BLE_GAP_DISC_DUR_DFLT;
-    }
-
-    if (duration_ms != BLE_HS_FOREVER) {
-        rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
-        if (rc != 0) {
-            /* Duration too great. */
-            rc = BLE_HS_EINVAL;
-            goto done;
-        }
-    }
-
-    if (!params.passive) {
-        rc = ble_hs_id_use_addr(own_addr_type);
-        if (rc != 0) {
-            goto done;
-        }
-    }
-
-    ble_gap_master.disc.limited = params.limited;
-    ble_gap_master.cb = cb;
-    ble_gap_master.cb_arg = cb_arg;
-
-    BLE_HS_LOG(INFO, "GAP procedure initiated: discovery; ");
-    ble_gap_log_disc(own_addr_type, duration_ms, &params);
-    BLE_HS_LOG(INFO, "\n");
-
-    rc = ble_gap_disc_tx_params(own_addr_type, &params);
-    if (rc != 0) {
-        goto done;
-    }
-
-    ble_gap_master.op = BLE_GAP_OP_M_DISC;
-
-    rc = ble_gap_disc_enable_tx(1, params.filter_duplicates);
-    if (rc != 0) {
-        ble_gap_master_reset_state();
-        goto done;
-    }
-
-    if (duration_ms != BLE_HS_FOREVER) {
-        ble_gap_master_set_timer(duration_ticks);
-    }
-
-    rc = 0;
+	struct ble_gap_disc_params params;
+	uint32_t duration_ticks = 0;
+	int rc;
+
+	STATS_INC(ble_gap_stats, discover);
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	ble_hs_lock();
+
+	/* Make a copy of the parameter strcuture and fill unspecified values with
+	 * defaults.
+	 */
+	params = *disc_params;
+	ble_gap_disc_fill_dflts(&params);
+
+	rc = ble_gap_disc_validate(own_addr_type, &params);
+	if (rc != 0) {
+		goto done;
+	}
+
+	if (duration_ms == 0) {
+		duration_ms = BLE_GAP_DISC_DUR_DFLT;
+	}
+
+	if (duration_ms != BLE_HS_FOREVER) {
+		rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
+		if (rc != 0) {
+			/* Duration too great. */
+			rc = BLE_HS_EINVAL;
+			goto done;
+		}
+	}
+
+	if (!params.passive) {
+		rc = ble_hs_id_use_addr(own_addr_type);
+		if (rc != 0) {
+			goto done;
+		}
+	}
+
+	ble_gap_master.disc.limited = params.limited;
+	ble_gap_master.cb = cb;
+	ble_gap_master.cb_arg = cb_arg;
+
+	BLE_HS_LOG(INFO, "GAP procedure initiated: discovery; ");
+	ble_gap_log_disc(own_addr_type, duration_ms, &params);
+	BLE_HS_LOG(INFO, "\n");
+
+	rc = ble_gap_disc_tx_params(own_addr_type, &params);
+	if (rc != 0) {
+		goto done;
+	}
+
+	ble_gap_master.op = BLE_GAP_OP_M_DISC;
+
+	rc = ble_gap_disc_enable_tx(1, params.filter_duplicates);
+	if (rc != 0) {
+		ble_gap_master_reset_state();
+		goto done;
+	}
+
+	if (duration_ms != BLE_HS_FOREVER) {
+		ble_gap_master_set_timer(duration_ticks);
+	}
+
+	rc = 0;
 
 done:
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, discover_fail);
-    }
-    return rc;
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, discover_fail);
+	}
+	return rc;
 #endif
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_disc_active(void)
+int ble_gap_disc_active(void)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
-    /* Assume read is atomic; mutex not necessary. */
-    return ble_gap_master.op == BLE_GAP_OP_M_DISC;
+	/* Assume read is atomic; mutex not necessary. */
+	return ble_gap_master.op == BLE_GAP_OP_M_DISC;
 #else
-    return 0;
+	return 0;
 #endif
 }
 
@@ -5060,238 +4922,234 @@ ble_gap_disc_active(void)
  * $connection establishment procedures                                      *
  *****************************************************************************/
 
-static int
-ble_gap_conn_create_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                       const struct ble_gap_conn_params *params)
+static int ble_gap_conn_create_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
+                                  const struct ble_gap_conn_params *params)
 {
-    struct ble_hci_le_create_conn_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_create_conn_cp cmd;
+	uint16_t opcode;
 
-    cmd.scan_itvl = htole16(params->scan_itvl);
-    cmd.scan_window = htole16(params->scan_window);
-    if (peer_addr == NULL) {
-        /* Application wants to connect to any device in the white list.  The
-         * peer address type and peer address fields are ignored by the
-         * controller; fill them with dummy values.
-         */
-        cmd.filter_policy = BLE_HCI_CONN_FILT_USE_WL;
-        cmd.peer_addr_type = 0;
-        memset(cmd.peer_addr, 0, sizeof(cmd.peer_addr));
-    } else {
-        cmd.filter_policy = BLE_HCI_CONN_FILT_NO_WL;
-        cmd.peer_addr_type = peer_addr->type;
-        memcpy(cmd.peer_addr, peer_addr->val, sizeof(cmd.peer_addr));
-    }
+	cmd.scan_itvl = htole16(params->scan_itvl);
+	cmd.scan_window = htole16(params->scan_window);
+	if (peer_addr == NULL) {
+		/* Application wants to connect to any device in the white list.  The
+		 * peer address type and peer address fields are ignored by the
+		 * controller; fill them with dummy values.
+		 */
+		cmd.filter_policy = BLE_HCI_CONN_FILT_USE_WL;
+		cmd.peer_addr_type = 0;
+		memset(cmd.peer_addr, 0, sizeof(cmd.peer_addr));
+	}
+	else {
+		cmd.filter_policy = BLE_HCI_CONN_FILT_NO_WL;
+		cmd.peer_addr_type = peer_addr->type;
+		memcpy(cmd.peer_addr, peer_addr->val, sizeof(cmd.peer_addr));
+	}
 
-    cmd.own_addr_type = own_addr_type;
-    cmd.min_conn_itvl = htole16(params->itvl_min);
-    cmd.max_conn_itvl = htole16(params->itvl_max);
-    cmd.conn_latency = htole16(params->latency);
-    cmd.tmo = htole16(params->supervision_timeout);
-    cmd.min_ce = htole16(params->min_ce_len);
-    cmd.max_ce = htole16(params->max_ce_len);
+	cmd.own_addr_type = own_addr_type;
+	cmd.min_conn_itvl = htole16(params->itvl_min);
+	cmd.max_conn_itvl = htole16(params->itvl_max);
+	cmd.conn_latency = htole16(params->latency);
+	cmd.tmo = htole16(params->supervision_timeout);
+	cmd.min_ce = htole16(params->min_ce_len);
+	cmd.max_ce = htole16(params->max_ce_len);
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CREATE_CONN);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CREATE_CONN);
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 #endif
 
 #if MYNEWT_VAL(BLE_CONN_SUBRATING)
-int
-ble_gap_set_default_subrate(uint16_t subrate_min, uint16_t subrate_max, uint16_t max_latency,
-                            uint16_t cont_num, uint16_t supervision_tmo)
+int ble_gap_set_default_subrate(uint16_t subrate_min, uint16_t subrate_max,
+                                uint16_t max_latency, uint16_t cont_num,
+                                uint16_t supervision_tmo)
 {
-    struct ble_hci_le_set_default_subrate_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_default_subrate_cp cmd;
+	uint16_t opcode;
 
-    cmd.subrate_min = htole16(subrate_min);
-    cmd.subrate_max = htole16(subrate_max);
-    cmd.max_latency = htole16(max_latency);
-    cmd.cont_num = htole16(cont_num);
-    cmd.supervision_tmo = htole16(supervision_tmo);
+	cmd.subrate_min = htole16(subrate_min);
+	cmd.subrate_max = htole16(subrate_max);
+	cmd.max_latency = htole16(max_latency);
+	cmd.cont_num = htole16(cont_num);
+	cmd.supervision_tmo = htole16(supervision_tmo);
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_DEFAULT_SUBRATE);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_DEFAULT_SUBRATE);
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
-int
-ble_gap_subrate_req(uint16_t conn_handle, uint16_t subrate_min, uint16_t subrate_max,
-                    uint16_t max_latency, uint16_t cont_num,
-                    uint16_t supervision_tmo)
+int ble_gap_subrate_req(uint16_t conn_handle, uint16_t subrate_min,
+                        uint16_t subrate_max, uint16_t max_latency,
+                        uint16_t cont_num, uint16_t supervision_tmo)
 {
-    struct ble_hci_le_subrate_req_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_subrate_req_cp cmd;
+	uint16_t opcode;
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.subrate_min = htole16(subrate_min);
-    cmd.subrate_max = htole16(subrate_max);
-    cmd.max_latency = htole16(max_latency);
-    cmd.cont_num = htole16(cont_num);
-    cmd.supervision_tmo = htole16(supervision_tmo);
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.subrate_min = htole16(subrate_min);
+	cmd.subrate_max = htole16(subrate_max);
+	cmd.max_latency = htole16(max_latency);
+	cmd.cont_num = htole16(cont_num);
+	cmd.supervision_tmo = htole16(supervision_tmo);
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SUBRATE_REQ);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SUBRATE_REQ);
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 #endif
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
-static int
-ble_gap_check_conn_params(uint8_t phy, const struct ble_gap_conn_params *params)
-{
-    if (phy != BLE_HCI_LE_PHY_2M) {
-        /* Check scan interval and window */
-        if ((params->scan_itvl < BLE_HCI_SCAN_ITVL_MIN) ||
-            (params->scan_itvl > BLE_HCI_SCAN_ITVL_MAX) ||
-            (params->scan_window < BLE_HCI_SCAN_WINDOW_MIN) ||
-            (params->scan_window > BLE_HCI_SCAN_WINDOW_MAX) ||
-            (params->scan_itvl < params->scan_window)) {
-            return BLE_ERR_INV_HCI_CMD_PARMS;
-        }
-    }
-        /* Check connection interval min */
-    if ((params->itvl_min < BLE_HCI_CONN_ITVL_MIN) ||
-        (params->itvl_min > BLE_HCI_CONN_ITVL_MAX)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-    /* Check connection interval max */
-    if ((params->itvl_max < BLE_HCI_CONN_ITVL_MIN) ||
-        (params->itvl_max > BLE_HCI_CONN_ITVL_MAX) ||
-        (params->itvl_max < params->itvl_min)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    /* Check connection latency */
-    if (params->latency > BLE_HCI_CONN_LATENCY_MAX) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    /* Check supervision timeout */
-    if ((params->supervision_timeout < BLE_HCI_CONN_SPVN_TIMEOUT_MIN) ||
-        (params->supervision_timeout > BLE_HCI_CONN_SPVN_TIMEOUT_MAX)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    /* Check connection event length */
-    if (params->min_ce_len > params->max_ce_len) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    return 0;
-}
-
-static int
-ble_gap_ext_conn_create_tx(
-    uint8_t own_addr_type, const ble_addr_t *peer_addr, uint8_t phy_mask,
-    const struct ble_gap_conn_params *phy_1m_conn_params,
-    const struct ble_gap_conn_params *phy_2m_conn_params,
-    const struct ble_gap_conn_params *phy_coded_conn_params)
-{
-    struct ble_hci_le_ext_create_conn_cp *cmd;
-    struct conn_params *params;
-    uint8_t buf[sizeof(*cmd) + 3 * sizeof(*params)];
-    uint8_t len = sizeof(*cmd);
-    int rc;
-
-    /* Check own addr type */
-    if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    if (phy_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                    BLE_HCI_LE_PHY_2M_PREF_MASK |
-                    BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
-        return BLE_ERR_INV_HCI_CMD_PARMS;
-    }
-
-    cmd = (void *) buf;
-    params = cmd->conn_params;
-
-    if (peer_addr == NULL) {
-        /* Application wants to connect to any device in the white list.  The
-         * peer address type and peer address fields are ignored by the
-         * controller; fill them with dummy values.
-         */
-        cmd->filter_policy = BLE_HCI_CONN_FILT_USE_WL;
-        cmd->peer_addr_type = 0;
-        memset(cmd->peer_addr, 0, sizeof(cmd->peer_addr));
-    } else {
-        /* Check peer addr type */
-        if (peer_addr->type > BLE_HCI_CONN_PEER_ADDR_MAX) {
-            return BLE_ERR_INV_HCI_CMD_PARMS;
-        }
-
-        cmd->filter_policy = BLE_HCI_CONN_FILT_NO_WL;
-        cmd->peer_addr_type = peer_addr->type;
-        memcpy(cmd->peer_addr, peer_addr->val, sizeof(cmd->peer_addr));
-    }
-
-    cmd->own_addr_type = own_addr_type;
-    cmd->init_phy_mask = phy_mask;
-
-    if (phy_mask & BLE_GAP_LE_PHY_1M_MASK) {
-        rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_1M, phy_1m_conn_params);
-        if (rc) {
-            return rc;
-        }
-
-        params->scan_itvl = htole16(phy_1m_conn_params->scan_itvl);
-        params->scan_window = htole16(phy_1m_conn_params->scan_window);
-        params->conn_min_itvl = htole16(phy_1m_conn_params->itvl_min);
-        params->conn_max_itvl = htole16(phy_1m_conn_params->itvl_max);
-        params->conn_latency = htole16(phy_1m_conn_params->latency);
-        params->supervision_timeout = htole16(phy_1m_conn_params->supervision_timeout);
-        params->min_ce = htole16(phy_1m_conn_params->min_ce_len);
-        params->max_ce = htole16(phy_1m_conn_params->max_ce_len);
-
-        params++;
-        len += sizeof(*params);
-    }
-
-    if (phy_mask & BLE_GAP_LE_PHY_2M_MASK) {
-        rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_2M, phy_2m_conn_params);
-        if (rc) {
-            return rc;
-        }
-
-        params->scan_itvl = htole16(phy_2m_conn_params->scan_itvl);
-        params->scan_window = htole16(phy_2m_conn_params->scan_window);
-        params->conn_min_itvl = htole16(phy_2m_conn_params->itvl_min);
-        params->conn_max_itvl = htole16(phy_2m_conn_params->itvl_max);
-        params->conn_latency = htole16(phy_2m_conn_params->latency);
-        params->supervision_timeout = htole16(phy_2m_conn_params->supervision_timeout);
-        params->min_ce = htole16(phy_2m_conn_params->min_ce_len);
-        params->max_ce = htole16(phy_2m_conn_params->max_ce_len);
-
-        params++;
-        len += sizeof(*params);
-    }
-
-    if (phy_mask & BLE_GAP_LE_PHY_CODED_MASK) {
-        rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_CODED, phy_coded_conn_params);
-        if (rc) {
-            return rc;
-        }
-
-        params->scan_itvl = htole16(phy_coded_conn_params->scan_itvl);
-        params->scan_window = htole16(phy_coded_conn_params->scan_window);
-        params->conn_min_itvl = htole16(phy_coded_conn_params->itvl_min);
-        params->conn_max_itvl = htole16(phy_coded_conn_params->itvl_max);
-        params->conn_latency = htole16(phy_coded_conn_params->latency);
-        params->supervision_timeout = htole16(phy_coded_conn_params->supervision_timeout);
-        params->min_ce = htole16(phy_coded_conn_params->min_ce_len);
-        params->max_ce = htole16(phy_coded_conn_params->max_ce_len);
-
-        params++;
-        len += sizeof(*params);
-    }
-
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_EXT_CREATE_CONN),
-                                       cmd, len, NULL, 0);
+static int ble_gap_check_conn_params(uint8_t phy, const struct ble_gap_conn_params *params)
+{
+	if (phy != BLE_HCI_LE_PHY_2M) {
+		/* Check scan interval and window */
+		if ((params->scan_itvl < BLE_HCI_SCAN_ITVL_MIN) ||
+		    (params->scan_itvl > BLE_HCI_SCAN_ITVL_MAX) ||
+		    (params->scan_window < BLE_HCI_SCAN_WINDOW_MIN) ||
+		    (params->scan_window > BLE_HCI_SCAN_WINDOW_MAX) ||
+		    (params->scan_itvl < params->scan_window)) {
+			return BLE_ERR_INV_HCI_CMD_PARMS;
+		}
+	}
+	/* Check connection interval min */
+	if ((params->itvl_min < BLE_HCI_CONN_ITVL_MIN) ||
+	    (params->itvl_min > BLE_HCI_CONN_ITVL_MAX)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+	/* Check connection interval max */
+	if ((params->itvl_max < BLE_HCI_CONN_ITVL_MIN) ||
+	    (params->itvl_max > BLE_HCI_CONN_ITVL_MAX) ||
+	    (params->itvl_max < params->itvl_min)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	/* Check connection latency */
+	if (params->latency > BLE_HCI_CONN_LATENCY_MAX) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	/* Check supervision timeout */
+	if ((params->supervision_timeout < BLE_HCI_CONN_SPVN_TIMEOUT_MIN) ||
+	    (params->supervision_timeout > BLE_HCI_CONN_SPVN_TIMEOUT_MAX)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	/* Check connection event length */
+	if (params->min_ce_len > params->max_ce_len) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	return 0;
+}
+
+static int ble_gap_ext_conn_create_tx(
+	uint8_t own_addr_type, const ble_addr_t *peer_addr, uint8_t phy_mask,
+	const struct ble_gap_conn_params *phy_1m_conn_params,
+	const struct ble_gap_conn_params *phy_2m_conn_params,
+	const struct ble_gap_conn_params *phy_coded_conn_params)
+{
+	struct ble_hci_le_ext_create_conn_cp *cmd;
+	struct conn_params *params;
+	uint8_t buf[sizeof(*cmd) + 3 * sizeof(*params)];
+	uint8_t len = sizeof(*cmd);
+	int rc;
+
+	/* Check own addr type */
+	if (own_addr_type > BLE_HCI_ADV_OWN_ADDR_MAX) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	if (phy_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
+	                BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+		return BLE_ERR_INV_HCI_CMD_PARMS;
+	}
+
+	cmd = (void *) buf;
+	params = cmd->conn_params;
+
+	if (peer_addr == NULL) {
+		/* Application wants to connect to any device in the white list.  The
+		 * peer address type and peer address fields are ignored by the
+		 * controller; fill them with dummy values.
+		 */
+		cmd->filter_policy = BLE_HCI_CONN_FILT_USE_WL;
+		cmd->peer_addr_type = 0;
+		memset(cmd->peer_addr, 0, sizeof(cmd->peer_addr));
+	}
+	else {
+		/* Check peer addr type */
+		if (peer_addr->type > BLE_HCI_CONN_PEER_ADDR_MAX) {
+			return BLE_ERR_INV_HCI_CMD_PARMS;
+		}
+
+		cmd->filter_policy = BLE_HCI_CONN_FILT_NO_WL;
+		cmd->peer_addr_type = peer_addr->type;
+		memcpy(cmd->peer_addr, peer_addr->val, sizeof(cmd->peer_addr));
+	}
+
+	cmd->own_addr_type = own_addr_type;
+	cmd->init_phy_mask = phy_mask;
+
+	if (phy_mask & BLE_GAP_LE_PHY_1M_MASK) {
+		rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_1M, phy_1m_conn_params);
+		if (rc) {
+			return rc;
+		}
+
+		params->scan_itvl = htole16(phy_1m_conn_params->scan_itvl);
+		params->scan_window = htole16(phy_1m_conn_params->scan_window);
+		params->conn_min_itvl = htole16(phy_1m_conn_params->itvl_min);
+		params->conn_max_itvl = htole16(phy_1m_conn_params->itvl_max);
+		params->conn_latency = htole16(phy_1m_conn_params->latency);
+		params->supervision_timeout = htole16(phy_1m_conn_params->supervision_timeout);
+		params->min_ce = htole16(phy_1m_conn_params->min_ce_len);
+		params->max_ce = htole16(phy_1m_conn_params->max_ce_len);
+
+		params++;
+		len += sizeof(*params);
+	}
+
+	if (phy_mask & BLE_GAP_LE_PHY_2M_MASK) {
+		rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_2M, phy_2m_conn_params);
+		if (rc) {
+			return rc;
+		}
+
+		params->scan_itvl = htole16(phy_2m_conn_params->scan_itvl);
+		params->scan_window = htole16(phy_2m_conn_params->scan_window);
+		params->conn_min_itvl = htole16(phy_2m_conn_params->itvl_min);
+		params->conn_max_itvl = htole16(phy_2m_conn_params->itvl_max);
+		params->conn_latency = htole16(phy_2m_conn_params->latency);
+		params->supervision_timeout = htole16(phy_2m_conn_params->supervision_timeout);
+		params->min_ce = htole16(phy_2m_conn_params->min_ce_len);
+		params->max_ce = htole16(phy_2m_conn_params->max_ce_len);
+
+		params++;
+		len += sizeof(*params);
+	}
+
+	if (phy_mask & BLE_GAP_LE_PHY_CODED_MASK) {
+		rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_CODED, phy_coded_conn_params);
+		if (rc) {
+			return rc;
+		}
+
+		params->scan_itvl = htole16(phy_coded_conn_params->scan_itvl);
+		params->scan_window = htole16(phy_coded_conn_params->scan_window);
+		params->conn_min_itvl = htole16(phy_coded_conn_params->itvl_min);
+		params->conn_max_itvl = htole16(phy_coded_conn_params->itvl_max);
+		params->conn_latency = htole16(phy_coded_conn_params->latency);
+		params->supervision_timeout = htole16(phy_coded_conn_params->supervision_timeout);
+		params->min_ce = htole16(phy_coded_conn_params->min_ce_len);
+		params->max_ce = htole16(phy_coded_conn_params->max_ce_len);
+
+		params++;
+		len += sizeof(*params);
+	}
+
+	return ble_hs_hci_cmd_tx(
+		BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_EXT_CREATE_CONN), cmd, len, NULL, 0);
 }
 #endif
 
@@ -5346,333 +5204,315 @@ ble_gap_ext_conn_create_tx(
  *                                  connected;
  *                              Other nonzero on error.
  */
-int
-ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                int32_t duration_ms, uint8_t phy_mask,
-                const struct ble_gap_conn_params *phy_1m_conn_params,
-                const struct ble_gap_conn_params *phy_2m_conn_params,
-                const struct ble_gap_conn_params *phy_coded_conn_params,
-                ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
+                        int32_t duration_ms, uint8_t phy_mask,
+                        const struct ble_gap_conn_params *phy_1m_conn_params,
+                        const struct ble_gap_conn_params *phy_2m_conn_params,
+                        const struct ble_gap_conn_params *phy_coded_conn_params,
+                        ble_gap_event_fn *cb, void *cb_arg)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
-    ble_npl_time_t duration_ticks;
-    int rc;
-
-    STATS_INC(ble_gap_stats, initiate);
-
-    ble_hs_lock();
-
-    if (ble_gap_conn_active()) {
-        rc = BLE_HS_EALREADY;
-        goto done;
-    }
-
-    if (ble_gap_disc_active()) {
-        rc = BLE_HS_EBUSY;
-        goto done;
-    }
-
-    if (!ble_hs_is_enabled()) {
-        rc = BLE_HS_EDISABLED;
-        goto done;
-    }
-
-    if (ble_gap_is_preempted()) {
-        rc = BLE_HS_EPREEMPTED;
-        goto done;
-    }
-
-    if (!ble_hs_conn_can_alloc()) {
-        rc = BLE_HS_ENOMEM;
-        goto done;
-    }
-
-    if (peer_addr &&
-        peer_addr->type != BLE_ADDR_PUBLIC &&
-        peer_addr->type != BLE_ADDR_RANDOM &&
-        peer_addr->type != BLE_ADDR_PUBLIC_ID &&
-        peer_addr->type != BLE_ADDR_RANDOM_ID) {
-
-        rc = BLE_HS_EINVAL;
-        goto done;
-    }
-
-    if ((phy_mask & BLE_GAP_LE_PHY_1M_MASK) && phy_1m_conn_params == NULL) {
-        phy_1m_conn_params = &ble_gap_conn_params_dflt;
-    }
-
-    if ((phy_mask & BLE_GAP_LE_PHY_2M_MASK) && phy_2m_conn_params == NULL) {
-        phy_2m_conn_params = &ble_gap_conn_params_dflt;
-    }
-
-    if ((phy_mask & BLE_GAP_LE_PHY_CODED_MASK) &&
-        phy_coded_conn_params == NULL) {
-
-        phy_coded_conn_params = &ble_gap_conn_params_dflt;
-    }
-
-    if (duration_ms == 0) {
-        duration_ms = BLE_GAP_CONN_DUR_DFLT;
-    }
-
-    if (duration_ms != BLE_HS_FOREVER) {
-        rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
-        if (rc != 0) {
-            /* Duration too great. */
-            rc = BLE_HS_EINVAL;
-            goto done;
-        }
-    }
-
-    /* Verify peer not already connected. */
-    if (ble_hs_conn_find_by_addr(peer_addr) != NULL) {
-        rc = BLE_HS_EDONE;
-        goto done;
-    }
-
-    /* XXX: Verify conn_params. */
-
-    rc = ble_hs_id_use_addr(own_addr_type);
-    if (rc != 0) {
-        goto done;
-    }
-
-    ble_gap_master.cb = cb;
-    ble_gap_master.cb_arg = cb_arg;
-    ble_gap_master.conn.using_wl = peer_addr == NULL;
-    ble_gap_master.conn.our_addr_type = own_addr_type;
-
-    ble_gap_master.op = BLE_GAP_OP_M_CONN;
-
-    rc = ble_gap_ext_conn_create_tx(own_addr_type, peer_addr, phy_mask,
-                                    phy_1m_conn_params, phy_2m_conn_params,
-                                    phy_coded_conn_params);
-    if (rc != 0) {
-        ble_gap_master_reset_state();
-        goto done;
-    }
-
-    if (duration_ms != BLE_HS_FOREVER) {
-        ble_gap_master_set_timer(duration_ticks);
-    }
-
-    rc = 0;
+	ble_npl_time_t duration_ticks;
+	int rc;
+
+	STATS_INC(ble_gap_stats, initiate);
+
+	ble_hs_lock();
+
+	if (ble_gap_conn_active()) {
+		rc = BLE_HS_EALREADY;
+		goto done;
+	}
+
+	if (ble_gap_disc_active()) {
+		rc = BLE_HS_EBUSY;
+		goto done;
+	}
+
+	if (!ble_hs_is_enabled()) {
+		rc = BLE_HS_EDISABLED;
+		goto done;
+	}
+
+	if (ble_gap_is_preempted()) {
+		rc = BLE_HS_EPREEMPTED;
+		goto done;
+	}
+
+	if (!ble_hs_conn_can_alloc()) {
+		rc = BLE_HS_ENOMEM;
+		goto done;
+	}
+
+	if (peer_addr && peer_addr->type != BLE_ADDR_PUBLIC &&
+	    peer_addr->type != BLE_ADDR_RANDOM && peer_addr->type != BLE_ADDR_PUBLIC_ID &&
+	    peer_addr->type != BLE_ADDR_RANDOM_ID) {
+		rc = BLE_HS_EINVAL;
+		goto done;
+	}
+
+	if ((phy_mask & BLE_GAP_LE_PHY_1M_MASK) && phy_1m_conn_params == NULL) {
+		phy_1m_conn_params = &ble_gap_conn_params_dflt;
+	}
+
+	if ((phy_mask & BLE_GAP_LE_PHY_2M_MASK) && phy_2m_conn_params == NULL) {
+		phy_2m_conn_params = &ble_gap_conn_params_dflt;
+	}
+
+	if ((phy_mask & BLE_GAP_LE_PHY_CODED_MASK) && phy_coded_conn_params == NULL) {
+		phy_coded_conn_params = &ble_gap_conn_params_dflt;
+	}
+
+	if (duration_ms == 0) {
+		duration_ms = BLE_GAP_CONN_DUR_DFLT;
+	}
+
+	if (duration_ms != BLE_HS_FOREVER) {
+		rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
+		if (rc != 0) {
+			/* Duration too great. */
+			rc = BLE_HS_EINVAL;
+			goto done;
+		}
+	}
+
+	/* Verify peer not already connected. */
+	if (ble_hs_conn_find_by_addr(peer_addr) != NULL) {
+		rc = BLE_HS_EDONE;
+		goto done;
+	}
+
+	/* XXX: Verify conn_params. */
+
+	rc = ble_hs_id_use_addr(own_addr_type);
+	if (rc != 0) {
+		goto done;
+	}
+
+	ble_gap_master.cb = cb;
+	ble_gap_master.cb_arg = cb_arg;
+	ble_gap_master.conn.using_wl = peer_addr == NULL;
+	ble_gap_master.conn.our_addr_type = own_addr_type;
+
+	ble_gap_master.op = BLE_GAP_OP_M_CONN;
+
+	rc = ble_gap_ext_conn_create_tx(own_addr_type, peer_addr, phy_mask, phy_1m_conn_params,
+	                                phy_2m_conn_params, phy_coded_conn_params);
+	if (rc != 0) {
+		ble_gap_master_reset_state();
+		goto done;
+	}
+
+	if (duration_ms != BLE_HS_FOREVER) {
+		ble_gap_master_set_timer(duration_ticks);
+	}
+
+	rc = 0;
 
 done:
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, initiate_fail);
-    }
-    return rc;
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, initiate_fail);
+	}
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
-
 }
 #endif
 
-int
-ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                int32_t duration_ms,
-                const struct ble_gap_conn_params *conn_params,
-                ble_gap_event_fn *cb, void *cb_arg)
+int ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
+                    int32_t duration_ms, const struct ble_gap_conn_params *conn_params,
+                    ble_gap_event_fn *cb, void *cb_arg)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    return ble_gap_ext_connect(own_addr_type, peer_addr, duration_ms,
-                               BLE_GAP_LE_PHY_1M_MASK,
-                               conn_params, NULL, NULL, cb, cb_arg);
+	return ble_gap_ext_connect(own_addr_type, peer_addr, duration_ms,
+	                           BLE_GAP_LE_PHY_1M_MASK, conn_params, NULL, NULL, cb,
+	                           cb_arg);
 #else
-    uint32_t duration_ticks;
-    int rc;
-
-    STATS_INC(ble_gap_stats, initiate);
-
-    ble_hs_lock();
-
-    if (ble_gap_conn_active()) {
-        rc = BLE_HS_EALREADY;
-        goto done;
-    }
-
-    if (ble_gap_disc_active()) {
-        rc = BLE_HS_EBUSY;
-        goto done;
-    }
-
-    if (!ble_hs_is_enabled()) {
-        rc = BLE_HS_EDISABLED;
-        goto done;
-    }
-
-    if (ble_gap_is_preempted()) {
-        rc = BLE_HS_EPREEMPTED;
-        goto done;
-    }
-
-    if (!ble_hs_conn_can_alloc()) {
-        rc = BLE_HS_ENOMEM;
-        goto done;
-    }
-
-    if (peer_addr &&
-        peer_addr->type != BLE_ADDR_PUBLIC &&
-        peer_addr->type != BLE_ADDR_RANDOM &&
-        peer_addr->type != BLE_ADDR_PUBLIC_ID &&
-        peer_addr->type != BLE_ADDR_RANDOM_ID) {
-
-        rc = BLE_HS_EINVAL;
-        goto done;
-    }
-
-    if (conn_params == NULL) {
-        conn_params = &ble_gap_conn_params_dflt;
-    }
-
-    if (duration_ms == 0) {
-        duration_ms = BLE_GAP_CONN_DUR_DFLT;
-    }
-
-    if (duration_ms != BLE_HS_FOREVER) {
-        rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
-        if (rc != 0) {
-            /* Duration too great. */
-            rc = BLE_HS_EINVAL;
-            goto done;
-        }
-    }
-
-    /* Verify peer not already connected. */
-    if (ble_hs_conn_find_by_addr(peer_addr) != NULL) {
-        rc = BLE_HS_EDONE;
-        goto done;
-    }
-
-    /* XXX: Verify conn_params. */
-
-    rc = ble_hs_id_use_addr(own_addr_type);
-    if (rc != 0) {
-        goto done;
-    }
-
-    BLE_HS_LOG(INFO, "GAP procedure initiated: connect; ");
-    ble_gap_log_conn(own_addr_type, peer_addr, conn_params);
-    BLE_HS_LOG(INFO, "\n");
-
-    ble_gap_master.cb = cb;
-    ble_gap_master.cb_arg = cb_arg;
-    ble_gap_master.conn.using_wl = peer_addr == NULL;
-    ble_gap_master.conn.our_addr_type = own_addr_type;
-
-    ble_gap_master.op = BLE_GAP_OP_M_CONN;
-
-    rc = ble_gap_conn_create_tx(own_addr_type, peer_addr,
-                                conn_params);
-    if (rc != 0) {
-        ble_gap_master_reset_state();
-        goto done;
-    }
-
-    if (duration_ms != BLE_HS_FOREVER) {
-        ble_gap_master_set_timer(duration_ticks);
-    }
-
-    rc = 0;
+	uint32_t duration_ticks;
+	int rc;
+
+	STATS_INC(ble_gap_stats, initiate);
+
+	ble_hs_lock();
+
+	if (ble_gap_conn_active()) {
+		rc = BLE_HS_EALREADY;
+		goto done;
+	}
+
+	if (ble_gap_disc_active()) {
+		rc = BLE_HS_EBUSY;
+		goto done;
+	}
+
+	if (!ble_hs_is_enabled()) {
+		rc = BLE_HS_EDISABLED;
+		goto done;
+	}
+
+	if (ble_gap_is_preempted()) {
+		rc = BLE_HS_EPREEMPTED;
+		goto done;
+	}
+
+	if (!ble_hs_conn_can_alloc()) {
+		rc = BLE_HS_ENOMEM;
+		goto done;
+	}
+
+	if (peer_addr && peer_addr->type != BLE_ADDR_PUBLIC &&
+	    peer_addr->type != BLE_ADDR_RANDOM && peer_addr->type != BLE_ADDR_PUBLIC_ID &&
+	    peer_addr->type != BLE_ADDR_RANDOM_ID) {
+		rc = BLE_HS_EINVAL;
+		goto done;
+	}
+
+	if (conn_params == NULL) {
+		conn_params = &ble_gap_conn_params_dflt;
+	}
+
+	if (duration_ms == 0) {
+		duration_ms = BLE_GAP_CONN_DUR_DFLT;
+	}
+
+	if (duration_ms != BLE_HS_FOREVER) {
+		rc = ble_npl_time_ms_to_ticks(duration_ms, &duration_ticks);
+		if (rc != 0) {
+			/* Duration too great. */
+			rc = BLE_HS_EINVAL;
+			goto done;
+		}
+	}
+
+	/* Verify peer not already connected. */
+	if (ble_hs_conn_find_by_addr(peer_addr) != NULL) {
+		rc = BLE_HS_EDONE;
+		goto done;
+	}
+
+	/* XXX: Verify conn_params. */
+
+	rc = ble_hs_id_use_addr(own_addr_type);
+	if (rc != 0) {
+		goto done;
+	}
+
+	BLE_HS_LOG(INFO, "GAP procedure initiated: connect; ");
+	ble_gap_log_conn(own_addr_type, peer_addr, conn_params);
+	BLE_HS_LOG(INFO, "\n");
+
+	ble_gap_master.cb = cb;
+	ble_gap_master.cb_arg = cb_arg;
+	ble_gap_master.conn.using_wl = peer_addr == NULL;
+	ble_gap_master.conn.our_addr_type = own_addr_type;
+
+	ble_gap_master.op = BLE_GAP_OP_M_CONN;
+
+	rc = ble_gap_conn_create_tx(own_addr_type, peer_addr, conn_params);
+	if (rc != 0) {
+		ble_gap_master_reset_state();
+		goto done;
+	}
+
+	if (duration_ms != BLE_HS_FOREVER) {
+		ble_gap_master_set_timer(duration_ticks);
+	}
+
+	rc = 0;
 
 done:
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, initiate_fail);
-    }
-    return rc;
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, initiate_fail);
+	}
+	return rc;
 #endif
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
-
 }
 
-int
-ble_gap_conn_active(void)
+int ble_gap_conn_active(void)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
-    /* Assume read is atomic; mutex not necessary. */
-    return ble_gap_master.op == BLE_GAP_OP_M_CONN;
+	/* Assume read is atomic; mutex not necessary. */
+	return ble_gap_master.op == BLE_GAP_OP_M_CONN;
 #else
-    return 0;
+	return 0;
 #endif
 }
 
 /*****************************************************************************
  * $terminate connection procedure                                           *
  *****************************************************************************/
-int
-ble_gap_terminate_with_conn(struct ble_hs_conn *conn, uint8_t hci_reason)
+int ble_gap_terminate_with_conn(struct ble_hs_conn *conn, uint8_t hci_reason)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hci_lc_disconnect_cp cmd;
-    int rc;
-
-    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
-    if (conn->bhc_flags & BLE_HS_CONN_F_TERMINATING) {
-        return BLE_HS_EALREADY;
-    }
-
-    BLE_HS_LOG(INFO, "GAP procedure initiated: terminate connection; "
-                     "conn_handle=%d hci_reason=%d\n",
-                     conn->bhc_handle, hci_reason);
-
-    cmd.conn_handle = htole16(conn->bhc_handle);
-    cmd.reason = hci_reason;
-
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LINK_CTRL,
-                                      BLE_HCI_OCF_DISCONNECT_CMD),
-                                      &cmd, sizeof(cmd), NULL, 0);
-    if (rc != 0) {
-        return rc;
-    }
-
-    conn->bhc_flags |= BLE_HS_CONN_F_TERMINATING;
-    return 0;
+	struct ble_hci_lc_disconnect_cp cmd;
+	int rc;
+
+	BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
+	if (conn->bhc_flags & BLE_HS_CONN_F_TERMINATING) {
+		return BLE_HS_EALREADY;
+	}
+
+	BLE_HS_LOG(INFO,
+	           "GAP procedure initiated: terminate connection; "
+	           "conn_handle=%d hci_reason=%d\n",
+	           conn->bhc_handle, hci_reason);
+
+	cmd.conn_handle = htole16(conn->bhc_handle);
+	cmd.reason = hci_reason;
+
+	rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LINK_CTRL, BLE_HCI_OCF_DISCONNECT_CMD),
+	                       &cmd, sizeof(cmd), NULL, 0);
+	if (rc != 0) {
+		return rc;
+	}
+
+	conn->bhc_flags |= BLE_HS_CONN_F_TERMINATING;
+	return 0;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
+int ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
-    int rc;
+	struct ble_hs_conn *conn;
+	int rc;
 
-    STATS_INC(ble_gap_stats, terminate);
+	STATS_INC(ble_gap_stats, terminate);
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(conn_handle);
-    if (conn == NULL) {
-        rc = BLE_HS_ENOTCONN;
-        goto done;
-    }
+	conn = ble_hs_conn_find(conn_handle);
+	if (conn == NULL) {
+		rc = BLE_HS_ENOTCONN;
+		goto done;
+	}
 
-    rc = ble_gap_terminate_with_conn(conn, hci_reason);
+	rc = ble_gap_terminate_with_conn(conn, hci_reason);
 
 done:
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, terminate_fail);
-    }
-    return rc;
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, terminate_fail);
+	}
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
@@ -5681,71 +5521,66 @@ done:
  *****************************************************************************/
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_gap_conn_cancel_tx(void)
+static int ble_gap_conn_cancel_tx(void)
 {
-    int rc;
+	int rc;
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_CREATE_CONN_CANCEL),
-                           NULL, 0, NULL, 0);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_cmd_tx(
+		BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CREATE_CONN_CANCEL), NULL, 0, NULL, 0);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_gap_conn_cancel_no_lock(void)
+static int ble_gap_conn_cancel_no_lock(void)
 {
-    int rc;
+	int rc;
 
-    STATS_INC(ble_gap_stats, cancel);
+	STATS_INC(ble_gap_stats, cancel);
 
-    if (!ble_gap_conn_active()) {
-        rc = BLE_HS_EALREADY;
-        goto done;
-    }
+	if (!ble_gap_conn_active()) {
+		rc = BLE_HS_EALREADY;
+		goto done;
+	}
 
-    BLE_HS_LOG(INFO, "GAP procedure initiated: cancel connection\n");
+	BLE_HS_LOG(INFO, "GAP procedure initiated: cancel connection\n");
 
-    rc = ble_gap_conn_cancel_tx();
-    if (rc != 0) {
-        goto done;
-    }
+	rc = ble_gap_conn_cancel_tx();
+	if (rc != 0) {
+		goto done;
+	}
 
-    ble_gap_master.conn.cancel = 1;
-    rc = 0;
+	ble_gap_master.conn.cancel = 1;
+	rc = 0;
 
 done:
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, cancel_fail);
-    }
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, cancel_fail);
+	}
 
-    return rc;
+	return rc;
 }
 #endif
 
-int
-ble_gap_conn_cancel(void)
+int ble_gap_conn_cancel(void)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
-    int rc;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    ble_hs_lock();
-    rc = ble_gap_conn_cancel_no_lock();
-    ble_hs_unlock();
+	ble_hs_lock();
+	rc = ble_gap_conn_cancel_no_lock();
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
-
 }
 
 /*****************************************************************************
@@ -5753,687 +5588,651 @@ ble_gap_conn_cancel(void)
  *****************************************************************************/
 
 #if NIMBLE_BLE_CONNECT
-static struct ble_gap_update_entry *
-ble_gap_update_entry_alloc(void)
+static struct ble_gap_update_entry *ble_gap_update_entry_alloc(void)
 {
-    struct ble_gap_update_entry *entry;
+	struct ble_gap_update_entry *entry;
 
-    entry = os_memblock_get(&ble_gap_update_entry_pool);
-    if (entry != NULL) {
-        memset(entry, 0, sizeof *entry);
-    }
+	entry = os_memblock_get(&ble_gap_update_entry_pool);
+	if (entry != NULL) {
+		memset(entry, 0, sizeof *entry);
+	}
 
-    return entry;
+	return entry;
 }
 #endif
 
-static void
-ble_gap_update_entry_free(struct ble_gap_update_entry *entry)
+static void ble_gap_update_entry_free(struct ble_gap_update_entry *entry)
 {
-    int rc;
+	int rc;
 
-    if (entry != NULL) {
+	if (entry != NULL) {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-        memset(entry, 0xff, sizeof *entry);
+		memset(entry, 0xff, sizeof *entry);
 #endif
-        rc = os_memblock_put(&ble_gap_update_entry_pool, entry);
-        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
-    }
+		rc = os_memblock_put(&ble_gap_update_entry_pool, entry);
+		BLE_HS_DBG_ASSERT_EVAL(rc == 0);
+	}
 }
 
-static struct ble_gap_update_entry *
-ble_gap_update_entry_find(uint16_t conn_handle,
-                          struct ble_gap_update_entry **out_prev)
+static struct ble_gap_update_entry *ble_gap_update_entry_find(
+	uint16_t conn_handle, struct ble_gap_update_entry **out_prev)
 {
-    struct ble_gap_update_entry *entry;
-    struct ble_gap_update_entry *prev;
+	struct ble_gap_update_entry *entry;
+	struct ble_gap_update_entry *prev;
 
-    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
+	BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
-    prev = NULL;
-    SLIST_FOREACH(entry, &ble_gap_update_entries, next) {
-        if (entry->conn_handle == conn_handle) {
-            break;
-        }
+	prev = NULL;
+	SLIST_FOREACH(entry, &ble_gap_update_entries, next)
+	{
+		if (entry->conn_handle == conn_handle) {
+			break;
+		}
 
-        prev = entry;
-    }
+		prev = entry;
+	}
 
-    if (out_prev != NULL) {
-        *out_prev = prev;
-    }
+	if (out_prev != NULL) {
+		*out_prev = prev;
+	}
 
-    return entry;
+	return entry;
 }
 
-static struct ble_gap_update_entry *
-ble_gap_update_entry_remove(uint16_t conn_handle)
+static struct ble_gap_update_entry *ble_gap_update_entry_remove(uint16_t conn_handle)
 {
-    struct ble_gap_update_entry *entry;
-    struct ble_gap_update_entry *prev;
+	struct ble_gap_update_entry *entry;
+	struct ble_gap_update_entry *prev;
 
-    entry = ble_gap_update_entry_find(conn_handle, &prev);
-    if (entry != NULL) {
-        if (prev == NULL) {
-            SLIST_REMOVE_HEAD(&ble_gap_update_entries, next);
-        } else {
-            SLIST_NEXT(prev, next) = SLIST_NEXT(entry, next);
-        }
-        ble_hs_timer_resched();
-    }
+	entry = ble_gap_update_entry_find(conn_handle, &prev);
+	if (entry != NULL) {
+		if (prev == NULL) {
+			SLIST_REMOVE_HEAD(&ble_gap_update_entries, next);
+		}
+		else {
+			SLIST_NEXT(prev, next) = SLIST_NEXT(entry, next);
+		}
+		ble_hs_timer_resched();
+	}
 
-    return entry;
+	return entry;
 }
 
 #if NIMBLE_BLE_CONNECT
-static void
-ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void *arg)
+static void ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void *arg)
 {
-    struct ble_gap_update_entry *entry;
+	struct ble_gap_update_entry *entry;
 
-    /* Report failures and rejections.  Success gets reported when the
-     * controller sends the connection update complete event.
-     */
+	/* Report failures and rejections.  Success gets reported when the
+	 * controller sends the connection update complete event.
+	 */
 
-    ble_hs_lock();
-    entry = ble_gap_update_entry_remove(conn_handle);
-    ble_hs_unlock();
+	ble_hs_lock();
+	entry = ble_gap_update_entry_remove(conn_handle);
+	ble_hs_unlock();
 
-    if (entry != NULL) {
-        ble_gap_update_entry_free(entry);
-        if (status != 0) {
-            ble_gap_update_notify(conn_handle, status);
-        }
-        /* On success let's wait for the controller to notify about update */
-    }
+	if (entry != NULL) {
+		ble_gap_update_entry_free(entry);
+		if (status != 0) {
+			ble_gap_update_notify(conn_handle, status);
+		}
+		/* On success let's wait for the controller to notify about update */
+	}
 }
 
-static int
-ble_gap_tx_param_pos_reply(uint16_t conn_handle,
-                           struct ble_gap_upd_params *params)
+static int ble_gap_tx_param_pos_reply(uint16_t conn_handle,
+                                      struct ble_gap_upd_params *params)
 {
-    struct ble_hci_le_rem_conn_param_rr_cp cmd;
+	struct ble_hci_le_rem_conn_param_rr_cp cmd;
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.conn_itvl_min = htole16(params->itvl_min);
-    cmd.conn_itvl_max = htole16(params->itvl_max);
-    cmd.conn_latency = htole16(params->latency);
-    cmd.supervision_timeout = htole16(params->supervision_timeout);
-    cmd.min_ce = htole16(params->min_ce_len);
-    cmd.max_ce = htole16(params->max_ce_len);
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.conn_itvl_min = htole16(params->itvl_min);
+	cmd.conn_itvl_max = htole16(params->itvl_max);
+	cmd.conn_latency = htole16(params->latency);
+	cmd.supervision_timeout = htole16(params->supervision_timeout);
+	cmd.min_ce = htole16(params->min_ce_len);
+	cmd.max_ce = htole16(params->max_ce_len);
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_REM_CONN_PARAM_RR),
-                             &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REM_CONN_PARAM_RR),
+	                         &cmd, sizeof(cmd), NULL, 0);
 }
 
-static int
-ble_gap_tx_param_neg_reply(uint16_t conn_handle, uint8_t reject_reason)
+static int ble_gap_tx_param_neg_reply(uint16_t conn_handle, uint8_t reject_reason)
 {
-    struct ble_hci_le_rem_conn_params_nrr_cp cmd;
+	struct ble_hci_le_rem_conn_params_nrr_cp cmd;
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.reason = reject_reason;
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.reason = reject_reason;
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR),
-                                     &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR),
+	                         &cmd, sizeof(cmd), NULL, 0);
 }
 #endif
 
-void
-ble_gap_rx_param_req(const struct ble_hci_ev_le_subev_rem_conn_param_req *ev)
+void ble_gap_rx_param_req(const struct ble_hci_ev_le_subev_rem_conn_param_req *ev)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_upd_params peer_params;
-    struct ble_gap_upd_params self_params;
-    struct ble_gap_event event;
-    uint16_t conn_handle;
-    int rc;
-
-    memset(&event, 0, sizeof event);
-
-    peer_params.itvl_min = le16toh(ev->min_interval);
-    peer_params.itvl_max = le16toh(ev->max_interval);
-    peer_params.latency = le16toh(ev->latency);
-    peer_params.supervision_timeout = le16toh(ev->timeout);
-    peer_params.min_ce_len = 0;
-    peer_params.max_ce_len = 0;
-
-    /* Copy the peer params into the self params to make it easy on the
-     * application.  The application callback will change only the fields which
-     * it finds unsuitable.
-     */
-    self_params = peer_params;
-
-    conn_handle = le16toh(ev->conn_handle);
-
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_CONN_UPDATE_REQ;
-    event.conn_update_req.conn_handle = conn_handle;
-    event.conn_update_req.self_params = &self_params;
-    event.conn_update_req.peer_params = &peer_params;
-    rc = ble_gap_call_conn_event_cb(&event, conn_handle);
-    if (rc == 0) {
-        rc = ble_gap_tx_param_pos_reply(conn_handle, &self_params);
-        if (rc != 0) {
-            ble_gap_update_failed(conn_handle, rc);
-        }
-    } else {
-        ble_gap_tx_param_neg_reply(conn_handle, rc);
-    }
+	struct ble_gap_upd_params peer_params;
+	struct ble_gap_upd_params self_params;
+	struct ble_gap_event event;
+	uint16_t conn_handle;
+	int rc;
+
+	memset(&event, 0, sizeof event);
+
+	peer_params.itvl_min = le16toh(ev->min_interval);
+	peer_params.itvl_max = le16toh(ev->max_interval);
+	peer_params.latency = le16toh(ev->latency);
+	peer_params.supervision_timeout = le16toh(ev->timeout);
+	peer_params.min_ce_len = 0;
+	peer_params.max_ce_len = 0;
+
+	/* Copy the peer params into the self params to make it easy on the
+	 * application.  The application callback will change only the fields which
+	 * it finds unsuitable.
+	 */
+	self_params = peer_params;
+
+	conn_handle = le16toh(ev->conn_handle);
+
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_CONN_UPDATE_REQ;
+	event.conn_update_req.conn_handle = conn_handle;
+	event.conn_update_req.self_params = &self_params;
+	event.conn_update_req.peer_params = &peer_params;
+	rc = ble_gap_call_conn_event_cb(&event, conn_handle);
+	if (rc == 0) {
+		rc = ble_gap_tx_param_pos_reply(conn_handle, &self_params);
+		if (rc != 0) {
+			ble_gap_update_failed(conn_handle, rc);
+		}
+	}
+	else {
+		ble_gap_tx_param_neg_reply(conn_handle, rc);
+	}
 #endif
 }
 
 #if NIMBLE_BLE_CONNECT
-static int
-ble_gap_update_tx(uint16_t conn_handle,
-                  const struct ble_gap_upd_params *params)
+static int ble_gap_update_tx(uint16_t conn_handle, const struct ble_gap_upd_params *params)
 {
-    struct ble_hci_le_conn_update_cp cmd;
+	struct ble_hci_le_conn_update_cp cmd;
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.conn_itvl_min = htole16(params->itvl_min);
-    cmd.conn_itvl_max = htole16(params->itvl_max);
-    cmd.conn_latency = htole16(params->latency);
-    cmd.supervision_timeout = htole16(params->supervision_timeout);
-    cmd.min_ce_len = htole16(params->min_ce_len);
-    cmd.max_ce_len = htole16(params->max_ce_len);
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.conn_itvl_min = htole16(params->itvl_min);
+	cmd.conn_itvl_max = htole16(params->itvl_max);
+	cmd.conn_latency = htole16(params->latency);
+	cmd.supervision_timeout = htole16(params->supervision_timeout);
+	cmd.min_ce_len = htole16(params->min_ce_len);
+	cmd.max_ce_len = htole16(params->max_ce_len);
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_CONN_UPDATE),
-                                        &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CONN_UPDATE),
+	                         &cmd, sizeof(cmd), NULL, 0);
 }
 
-static bool
-ble_gap_validate_conn_params(const struct ble_gap_upd_params *params)
+static bool ble_gap_validate_conn_params(const struct ble_gap_upd_params *params)
 {
+	/* Requirements from Bluetooth spec. v4.2 [Vol 2, Part E], 7.8.18 */
+	if (params->itvl_min > params->itvl_max) {
+		return false;
+	}
 
-    /* Requirements from Bluetooth spec. v4.2 [Vol 2, Part E], 7.8.18 */
-    if (params->itvl_min > params->itvl_max) {
-        return false;
-    }
-
-    if (params->itvl_min < 0x0006 || params->itvl_max > 0x0C80) {
-        return false;
-    }
+	if (params->itvl_min < 0x0006 || params->itvl_max > 0x0C80) {
+		return false;
+	}
 
-    if (params->latency > 0x01F3) {
-        return false;
-    }
+	if (params->latency > 0x01F3) {
+		return false;
+	}
 
-    /* According to specification mentioned above we should make sure that:
-     * supervision_timeout_ms > (1 + latency) * 2 * max_interval_ms
-     *    =>
-     * supervision_timeout * 10 ms > (1 + latency) * 2 * itvl_max * 1.25ms
-     */
-    if (params->supervision_timeout <=
-                   (((1 + params->latency) * params->itvl_max) / 4)) {
-        return false;
-    }
+	/* According to specification mentioned above we should make sure that:
+	 * supervision_timeout_ms > (1 + latency) * 2 * max_interval_ms
+	 *    =>
+	 * supervision_timeout * 10 ms > (1 + latency) * 2 * itvl_max * 1.25ms
+	 */
+	if (params->supervision_timeout <= (((1 + params->latency) * params->itvl_max) / 4)) {
+		return false;
+	}
 
-    return true;
+	return true;
 }
 #endif
 
-int
-ble_gap_update_params(uint16_t conn_handle,
-                      const struct ble_gap_upd_params *params)
+int ble_gap_update_params(uint16_t conn_handle, const struct ble_gap_upd_params *params)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_l2cap_sig_update_params l2cap_params;
-    struct ble_gap_update_entry *entry;
-    struct ble_gap_update_entry *dup;
-    struct ble_hs_conn *conn;
-    int l2cap_update;
-    int rc;
-
-    l2cap_update = 0;
-
-    /* Validate parameters with a spec */
-    if (!ble_gap_validate_conn_params(params)) {
-        return BLE_HS_EINVAL;
-    }
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    STATS_INC(ble_gap_stats, update);
-    memset(&l2cap_params, 0, sizeof l2cap_params);
-    entry = NULL;
-
-    ble_hs_lock();
-
-    conn = ble_hs_conn_find(conn_handle);
-    if (conn == NULL) {
-        rc = BLE_HS_ENOTCONN;
-        goto done;
-    }
-
-    /* Don't allow two concurrent updates to the same connection. */
-    dup = ble_gap_update_entry_find(conn_handle, NULL);
-    if (dup != NULL) {
-        rc = BLE_HS_EALREADY;
-        goto done;
-    }
-
-    entry = ble_gap_update_entry_alloc();
-    if (entry == NULL) {
-        rc = BLE_HS_ENOMEM;
-        goto done;
-    }
-
-    entry->conn_handle = conn_handle;
-    entry->params = *params;
-
-    entry->exp_os_ticks = ble_npl_time_get() +
-                          ble_npl_time_ms_to_ticks32(BLE_GAP_UPDATE_TIMEOUT_MS);
-
-    BLE_HS_LOG(INFO, "GAP procedure initiated: ");
-    ble_gap_log_update(conn_handle, params);
-    BLE_HS_LOG(INFO, "\n");
-
-    /*
-     * If LL update procedure is not supported on this connection and we are
-     * the slave, fail over to the L2CAP update procedure.
-     */
-    if ((conn->supported_feat & BLE_HS_HCI_LE_FEAT_CONN_PARAM_REQUEST) == 0 &&
-            !(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
-        l2cap_update = 1;
-        rc = 0;
-    } else {
-        rc = ble_gap_update_tx(conn_handle, params);
-    }
+	struct ble_l2cap_sig_update_params l2cap_params;
+	struct ble_gap_update_entry *entry;
+	struct ble_gap_update_entry *dup;
+	struct ble_hs_conn *conn;
+	int l2cap_update;
+	int rc;
+
+	l2cap_update = 0;
+
+	/* Validate parameters with a spec */
+	if (!ble_gap_validate_conn_params(params)) {
+		return BLE_HS_EINVAL;
+	}
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	STATS_INC(ble_gap_stats, update);
+	memset(&l2cap_params, 0, sizeof l2cap_params);
+	entry = NULL;
+
+	ble_hs_lock();
+
+	conn = ble_hs_conn_find(conn_handle);
+	if (conn == NULL) {
+		rc = BLE_HS_ENOTCONN;
+		goto done;
+	}
+
+	/* Don't allow two concurrent updates to the same connection. */
+	dup = ble_gap_update_entry_find(conn_handle, NULL);
+	if (dup != NULL) {
+		rc = BLE_HS_EALREADY;
+		goto done;
+	}
+
+	entry = ble_gap_update_entry_alloc();
+	if (entry == NULL) {
+		rc = BLE_HS_ENOMEM;
+		goto done;
+	}
+
+	entry->conn_handle = conn_handle;
+	entry->params = *params;
+
+	entry->exp_os_ticks =
+		ble_npl_time_get() + ble_npl_time_ms_to_ticks32(BLE_GAP_UPDATE_TIMEOUT_MS);
+
+	BLE_HS_LOG(INFO, "GAP procedure initiated: ");
+	ble_gap_log_update(conn_handle, params);
+	BLE_HS_LOG(INFO, "\n");
+
+	/*
+	 * If LL update procedure is not supported on this connection and we are
+	 * the slave, fail over to the L2CAP update procedure.
+	 */
+	if ((conn->supported_feat & BLE_HS_HCI_LE_FEAT_CONN_PARAM_REQUEST) == 0 &&
+	    !(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
+		l2cap_update = 1;
+		rc = 0;
+	}
+	else {
+		rc = ble_gap_update_tx(conn_handle, params);
+	}
 
 done:
-    ble_hs_unlock();
-
-    if (!l2cap_update) {
-        ble_hs_timer_resched();
-    } else {
-        ble_gap_update_to_l2cap(params, &l2cap_params);
-
-        rc = ble_l2cap_sig_update(conn_handle, &l2cap_params,
-                                              ble_gap_update_l2cap_cb, NULL);
-    }
-
-    ble_hs_lock();
-    if (rc == 0) {
-        SLIST_INSERT_HEAD(&ble_gap_update_entries, entry, next);
-    } else {
-        ble_gap_update_entry_free(entry);
-        STATS_INC(ble_gap_stats, update_fail);
-    }
-    ble_hs_unlock();
-
-    return rc;
+	ble_hs_unlock();
+
+	if (!l2cap_update) {
+		ble_hs_timer_resched();
+	}
+	else {
+		ble_gap_update_to_l2cap(params, &l2cap_params);
+
+		rc =
+			ble_l2cap_sig_update(conn_handle, &l2cap_params, ble_gap_update_l2cap_cb, NULL);
+	}
+
+	ble_hs_lock();
+	if (rc == 0) {
+		SLIST_INSERT_HEAD(&ble_gap_update_entries, entry, next);
+	}
+	else {
+		ble_gap_update_entry_free(entry);
+		STATS_INC(ble_gap_stats, update_fail);
+	}
+	ble_hs_unlock();
+
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_set_data_len(uint16_t conn_handle, uint16_t tx_octets,
-                     uint16_t tx_time)
+int ble_gap_set_data_len(uint16_t conn_handle, uint16_t tx_octets, uint16_t tx_time)
 {
-    return ble_hs_hci_util_set_data_len(conn_handle, tx_octets, tx_time);
+	return ble_hs_hci_util_set_data_len(conn_handle, tx_octets, tx_time);
 }
 
-int
-ble_gap_read_sugg_def_data_len(uint16_t *out_sugg_max_tx_octets,
-                               uint16_t *out_sugg_max_tx_time)
+int ble_gap_read_sugg_def_data_len(uint16_t *out_sugg_max_tx_octets,
+                                   uint16_t *out_sugg_max_tx_time)
 {
-    return ble_hs_hci_util_read_sugg_def_data_len(out_sugg_max_tx_octets,
-                                                  out_sugg_max_tx_time);
+	return ble_hs_hci_util_read_sugg_def_data_len(out_sugg_max_tx_octets,
+	                                              out_sugg_max_tx_time);
 }
 
-int
-ble_gap_write_sugg_def_data_len(uint16_t sugg_max_tx_octets,
-                                uint16_t sugg_max_tx_time)
+int ble_gap_write_sugg_def_data_len(uint16_t sugg_max_tx_octets, uint16_t sugg_max_tx_time)
 {
-    return ble_hs_hci_util_write_sugg_def_data_len(sugg_max_tx_octets,
-                                                   sugg_max_tx_time);
+	return ble_hs_hci_util_write_sugg_def_data_len(sugg_max_tx_octets, sugg_max_tx_time);
 }
 
 /*****************************************************************************
-* $security                                                                  *
-*****************************************************************************/
-int
-ble_gap_security_initiate(uint16_t conn_handle)
+ * $security                                                                  *
+ *****************************************************************************/
+int ble_gap_security_initiate(uint16_t conn_handle)
 {
 #if NIMBLE_BLE_SM
-    struct ble_store_value_sec value_sec;
-    struct ble_store_key_sec key_sec;
-    struct ble_hs_conn_addrs addrs;
-    ble_hs_conn_flags_t conn_flags;
-    struct ble_hs_conn *conn;
-    int rc;
-
-    STATS_INC(ble_gap_stats, security_initiate);
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    ble_hs_lock();
-    conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
-        conn_flags = conn->bhc_flags;
-        ble_hs_conn_addrs(conn, &addrs);
-
-        memset(&key_sec, 0, sizeof key_sec);
-        key_sec.peer_addr = addrs.peer_id_addr;
-    }
-    ble_hs_unlock();
-
-    if (conn == NULL) {
-        rc = BLE_HS_ENOTCONN;
-        goto done;
-    }
-
-    if (conn_flags & BLE_HS_CONN_F_MASTER) {
-        /* Search the security database for an LTK for this peer.  If one
-         * is found, perform the encryption procedure rather than the pairing
-         * procedure.
-         */
-        rc = ble_store_read_peer_sec(&key_sec, &value_sec);
-        if (rc == 0 && value_sec.ltk_present) {
-            rc = ble_sm_enc_initiate(conn_handle, value_sec.key_size,
-                                     value_sec.ltk, value_sec.ediv,
-                                     value_sec.rand_num,
-                                     value_sec.authenticated);
-            if (rc != 0) {
-                goto done;
-            }
-        } else {
-            rc = ble_sm_pair_initiate(conn_handle);
-            if (rc != 0) {
-                goto done;
-            }
-        }
-    } else {
-        rc = ble_sm_slave_initiate(conn_handle);
-        if (rc != 0) {
-            goto done;
-        }
-    }
-
-    rc = 0;
+	struct ble_store_value_sec value_sec;
+	struct ble_store_key_sec key_sec;
+	struct ble_hs_conn_addrs addrs;
+	ble_hs_conn_flags_t conn_flags;
+	struct ble_hs_conn *conn;
+	int rc;
+
+	STATS_INC(ble_gap_stats, security_initiate);
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	ble_hs_lock();
+	conn = ble_hs_conn_find(conn_handle);
+	if (conn != NULL) {
+		conn_flags = conn->bhc_flags;
+		ble_hs_conn_addrs(conn, &addrs);
+
+		memset(&key_sec, 0, sizeof key_sec);
+		key_sec.peer_addr = addrs.peer_id_addr;
+	}
+	ble_hs_unlock();
+
+	if (conn == NULL) {
+		rc = BLE_HS_ENOTCONN;
+		goto done;
+	}
+
+	if (conn_flags & BLE_HS_CONN_F_MASTER) {
+		/* Search the security database for an LTK for this peer.  If one
+		 * is found, perform the encryption procedure rather than the pairing
+		 * procedure.
+		 */
+		rc = ble_store_read_peer_sec(&key_sec, &value_sec);
+		if (rc == 0 && value_sec.ltk_present) {
+			rc = ble_sm_enc_initiate(conn_handle, value_sec.key_size, value_sec.ltk,
+			                         value_sec.ediv, value_sec.rand_num,
+			                         value_sec.authenticated);
+			if (rc != 0) {
+				goto done;
+			}
+		}
+		else {
+			rc = ble_sm_pair_initiate(conn_handle);
+			if (rc != 0) {
+				goto done;
+			}
+		}
+	}
+	else {
+		rc = ble_sm_slave_initiate(conn_handle);
+		if (rc != 0) {
+			goto done;
+		}
+	}
+
+	rc = 0;
 
 done:
-    if (rc != 0) {
-        STATS_INC(ble_gap_stats, security_initiate_fail);
-    }
+	if (rc != 0) {
+		STATS_INC(ble_gap_stats, security_initiate_fail);
+	}
 
-    return rc;
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_pair_initiate(uint16_t conn_handle)
+int ble_gap_pair_initiate(uint16_t conn_handle)
 {
-    int rc;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    rc = ble_sm_pair_initiate(conn_handle);
+	rc = ble_sm_pair_initiate(conn_handle);
 
-    return rc;
+	return rc;
 }
 
-int
-ble_gap_encryption_initiate(uint16_t conn_handle,
-                            uint8_t key_size,
-                            const uint8_t *ltk,
-                            uint16_t ediv,
-                            uint64_t rand_val,
-                            int auth)
+int ble_gap_encryption_initiate(uint16_t conn_handle, uint8_t key_size,
+                                const uint8_t *ltk, uint16_t ediv, uint64_t rand_val,
+                                int auth)
 {
 #if NIMBLE_BLE_SM
-    ble_hs_conn_flags_t conn_flags;
-    int rc;
+	ble_hs_conn_flags_t conn_flags;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    rc = ble_hs_atomic_conn_flags(conn_handle, &conn_flags);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_atomic_conn_flags(conn_handle, &conn_flags);
+	if (rc != 0) {
+		return rc;
+	}
 
-    if (!(conn_flags & BLE_HS_CONN_F_MASTER)) {
-        return BLE_HS_EROLE;
-    }
+	if (!(conn_flags & BLE_HS_CONN_F_MASTER)) {
+		return BLE_HS_EROLE;
+	}
 
-    rc = ble_sm_enc_initiate(conn_handle, key_size, ltk,
-                             ediv, rand_val, auth);
-    return rc;
+	rc = ble_sm_enc_initiate(conn_handle, key_size, ltk, ediv, rand_val, auth);
+	return rc;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_unpair(const ble_addr_t *peer_addr)
+int ble_gap_unpair(const ble_addr_t *peer_addr)
 {
 #if NIMBLE_BLE_SM
-    int rc;
-    struct ble_hs_conn *conn;
+	int rc;
+	struct ble_hs_conn *conn;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    if (ble_addr_cmp(peer_addr, BLE_ADDR_ANY) == 0) {
-        return BLE_HS_EINVAL;
-    }
+	if (ble_addr_cmp(peer_addr, BLE_ADDR_ANY) == 0) {
+		return BLE_HS_EINVAL;
+	}
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find_by_addr(peer_addr);
-    if (conn != NULL) {
-        ble_gap_terminate_with_conn(conn, BLE_ERR_REM_USER_CONN_TERM);
-    }
+	conn = ble_hs_conn_find_by_addr(peer_addr);
+	if (conn != NULL) {
+		ble_gap_terminate_with_conn(conn, BLE_ERR_REM_USER_CONN_TERM);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    rc = ble_hs_pvcy_remove_entry(peer_addr->type,
-                             peer_addr->val);
+	rc = ble_hs_pvcy_remove_entry(peer_addr->type, peer_addr->val);
 
-    /* We allow BLE_ERR_UNK_CONN_ID as the IRK of the peer might not be
-     * present on the resolving list, but we still should be able to
-     * remove that entry.
-     */
-    if (rc != 0 && rc != (BLE_HS_ERR_HCI_BASE + BLE_ERR_UNK_CONN_ID)) {
-        return rc;
-    }
+	/* We allow BLE_ERR_UNK_CONN_ID as the IRK of the peer might not be
+	 * present on the resolving list, but we still should be able to
+	 * remove that entry.
+	 */
+	if (rc != 0 && rc != (BLE_HS_ERR_HCI_BASE + BLE_ERR_UNK_CONN_ID)) {
+		return rc;
+	}
 
-    return ble_store_util_delete_peer(peer_addr);
+	return ble_store_util_delete_peer(peer_addr);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_unpair_oldest_peer(void)
+int ble_gap_unpair_oldest_peer(void)
 {
 #if NIMBLE_BLE_SM
-    ble_addr_t oldest_peer_id_addr;
-    int num_peers;
-    int rc;
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    rc = ble_store_util_bonded_peers(
-            &oldest_peer_id_addr, &num_peers, 1);
-    if (rc != 0) {
-        return rc;
-    }
-
-    if (num_peers == 0) {
-        return BLE_HS_ENOENT;
-    }
-
-    rc = ble_gap_unpair(&oldest_peer_id_addr);
-    if (rc != 0) {
-        return rc;
-    }
-
-    return 0;
+	ble_addr_t oldest_peer_id_addr;
+	int num_peers;
+	int rc;
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	rc = ble_store_util_bonded_peers(&oldest_peer_id_addr, &num_peers, 1);
+	if (rc != 0) {
+		return rc;
+	}
+
+	if (num_peers == 0) {
+		return BLE_HS_ENOENT;
+	}
+
+	rc = ble_gap_unpair(&oldest_peer_id_addr);
+	if (rc != 0) {
+		return rc;
+	}
+
+	return 0;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_unpair_oldest_except(const ble_addr_t *peer_addr)
+int ble_gap_unpair_oldest_except(const ble_addr_t *peer_addr)
 {
 #if NIMBLE_BLE_SM
 #if MYNEWT_VAL(BLE_STORE_MAX_BONDS)
-    ble_addr_t peer_id_addrs[MYNEWT_VAL(BLE_STORE_MAX_BONDS)];
-    int num_peers;
-    int rc, i;
-
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
-
-    rc = ble_store_util_bonded_peers(
-            &peer_id_addrs[0], &num_peers, MYNEWT_VAL(BLE_STORE_MAX_BONDS));
-    if (rc != 0) {
-        return rc;
-    }
-
-    if (num_peers == 0) {
-        return BLE_HS_ENOENT;
-    }
-
-    for (i = 0; i < num_peers; i++) {
-        if (ble_addr_cmp(peer_addr, &peer_id_addrs[i]) != 0) {
-            break;
-        }
-    }
-
-    if (i >= num_peers) {
-        return BLE_HS_ENOMEM;
-    }
-
-    return ble_gap_unpair(&peer_id_addrs[i]);
+	ble_addr_t peer_id_addrs[MYNEWT_VAL(BLE_STORE_MAX_BONDS)];
+	int num_peers;
+	int rc, i;
+
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
+
+	rc = ble_store_util_bonded_peers(&peer_id_addrs[0], &num_peers,
+	                                 MYNEWT_VAL(BLE_STORE_MAX_BONDS));
+	if (rc != 0) {
+		return rc;
+	}
+
+	if (num_peers == 0) {
+		return BLE_HS_ENOENT;
+	}
+
+	for (i = 0; i < num_peers; i++) {
+		if (ble_addr_cmp(peer_addr, &peer_id_addrs[i]) != 0) {
+			break;
+		}
+	}
+
+	if (i >= num_peers) {
+		return BLE_HS_ENOMEM;
+	}
+
+	return ble_gap_unpair(&peer_id_addrs[i]);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-void
-ble_gap_passkey_event(uint16_t conn_handle,
-                      struct ble_gap_passkey_params *passkey_params)
+void ble_gap_passkey_event(uint16_t conn_handle,
+                           struct ble_gap_passkey_params *passkey_params)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    BLE_HS_LOG(DEBUG, "send passkey action request %d\n",
-               passkey_params->action);
+	BLE_HS_LOG(DEBUG, "send passkey action request %d\n", passkey_params->action);
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_PASSKEY_ACTION;
-    event.passkey.conn_handle = conn_handle;
-    event.passkey.params = *passkey_params;
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_PASSKEY_ACTION;
+	event.passkey.conn_handle = conn_handle;
+	event.passkey.params = *passkey_params;
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 #endif
 }
 
-void
-ble_gap_enc_event(uint16_t conn_handle, int status,
-                  int security_restored, int bonded)
+void ble_gap_enc_event(uint16_t conn_handle, int status, int security_restored, int bonded)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_ENC_CHANGE;
-    event.enc_change.conn_handle = conn_handle;
-    event.enc_change.status = status;
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_ENC_CHANGE;
+	event.enc_change.conn_handle = conn_handle;
+	event.enc_change.status = status;
 
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 
-    if (status != 0) {
-        return;
-    }
+	if (status != 0) {
+		return;
+	}
 
-    /* If encryption succeeded and encryption has been restored for bonded device,
-     * notify gatt server so it has chance to send notification/indication if needed.
-     */
-    if (security_restored) {
-        ble_gatts_bonding_restored(conn_handle);
-        return;
-    }
+	/* If encryption succeeded and encryption has been restored for bonded device,
+	 * notify gatt server so it has chance to send notification/indication if needed.
+	 */
+	if (security_restored) {
+		ble_gatts_bonding_restored(conn_handle);
+		return;
+	}
 
-    /* If this is fresh pairing and bonding has been established,
-     * notify gatt server about that so previous subscriptions (before bonding)
-     * can be stored.
-     */
-    if (bonded) {
-        ble_gatts_bonding_established(conn_handle);
-    }
+	/* If this is fresh pairing and bonding has been established,
+	 * notify gatt server about that so previous subscriptions (before bonding)
+	 * can be stored.
+	 */
+	if (bonded) {
+		ble_gatts_bonding_established(conn_handle);
+	}
 #endif
 }
 
-void
-ble_gap_identity_event(uint16_t conn_handle, const ble_addr_t *peer_id_addr)
+void ble_gap_identity_event(uint16_t conn_handle, const ble_addr_t *peer_id_addr)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    BLE_HS_LOG(DEBUG, "send identity changed");
+	BLE_HS_LOG(DEBUG, "send identity changed");
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_IDENTITY_RESOLVED;
-    event.identity_resolved.conn_handle = conn_handle;
-    event.identity_resolved.peer_id_addr = *peer_id_addr;
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_IDENTITY_RESOLVED;
+	event.identity_resolved.conn_handle = conn_handle;
+	event.identity_resolved.peer_id_addr = *peer_id_addr;
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 #endif
 }
 
-int
-ble_gap_repeat_pairing_event(const struct ble_gap_repeat_pairing *rp)
+int ble_gap_repeat_pairing_event(const struct ble_gap_repeat_pairing *rp)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
-    int rc;
-
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_REPEAT_PAIRING;
-    event.repeat_pairing = *rp;
-    rc = ble_gap_call_conn_event_cb(&event, rp->conn_handle);
-    return rc;
+	struct ble_gap_event event;
+	int rc;
+
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_REPEAT_PAIRING;
+	event.repeat_pairing = *rp;
+	rc = ble_gap_call_conn_event_cb(&event, rp->conn_handle);
+	return rc;
 #else
-    return 0;
+	return 0;
 #endif
 }
 
-void
-ble_gap_pairing_complete_event(uint16_t conn_handle, int status)
+void ble_gap_pairing_complete_event(uint16_t conn_handle, int status)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_PAIRING_COMPLETE;
-    event.pairing_complete.conn_handle = conn_handle;
-    event.pairing_complete.status = status;
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_PAIRING_COMPLETE;
+	event.pairing_complete.conn_handle = conn_handle;
+	event.pairing_complete.status = status;
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 #endif
 }
 
@@ -6441,59 +6240,56 @@ ble_gap_pairing_complete_event(uint16_t conn_handle, int status)
  * $rssi                                                                     *
  *****************************************************************************/
 
-int
-ble_gap_conn_rssi(uint16_t conn_handle, int8_t *out_rssi)
+int ble_gap_conn_rssi(uint16_t conn_handle, int8_t *out_rssi)
 {
-    int rc;
+	int rc;
 
-    if (!ble_hs_is_enabled()) {
-        return BLE_HS_EDISABLED;
-    }
+	if (!ble_hs_is_enabled()) {
+		return BLE_HS_EDISABLED;
+	}
 
-    rc = ble_hs_hci_util_read_rssi(conn_handle, out_rssi);
-    return rc;
+	rc = ble_hs_hci_util_read_rssi(conn_handle, out_rssi);
+	return rc;
 }
 
 /*****************************************************************************
  * $notify                                                                   *
  *****************************************************************************/
 
-void
-ble_gap_notify_rx_event(uint16_t conn_handle, uint16_t attr_handle,
-                        struct os_mbuf *om, int is_indication)
+void ble_gap_notify_rx_event(uint16_t conn_handle, uint16_t attr_handle,
+                             struct os_mbuf *om, int is_indication)
 {
 #if (MYNEWT_VAL(BLE_GATT_NOTIFY) || MYNEWT_VAL(BLE_GATT_INDICATE)) && NIMBLE_BLE_CONNECT
 
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_NOTIFY_RX;
-    event.notify_rx.conn_handle = conn_handle;
-    event.notify_rx.attr_handle = attr_handle;
-    event.notify_rx.om = om;
-    event.notify_rx.indication = is_indication;
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_NOTIFY_RX;
+	event.notify_rx.conn_handle = conn_handle;
+	event.notify_rx.attr_handle = attr_handle;
+	event.notify_rx.om = om;
+	event.notify_rx.indication = is_indication;
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 
-    os_mbuf_free_chain(event.notify_rx.om);
+	os_mbuf_free_chain(event.notify_rx.om);
 #endif
 }
 
-void
-ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
-                        int is_indication)
+void ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
+                             int is_indication)
 {
 #if (MYNEWT_VAL(BLE_GATT_NOTIFY) || MYNEWT_VAL(BLE_GATT_INDICATE)) && NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_NOTIFY_TX;
-    event.notify_tx.conn_handle = conn_handle;
-    event.notify_tx.status = status;
-    event.notify_tx.attr_handle = attr_handle;
-    event.notify_tx.indication = is_indication;
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_NOTIFY_TX;
+	event.notify_tx.conn_handle = conn_handle;
+	event.notify_tx.status = status;
+	event.notify_tx.attr_handle = attr_handle;
+	event.notify_tx.indication = is_indication;
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 #endif
 }
 
@@ -6501,33 +6297,30 @@ ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
  * $subscribe                                                                *
  *****************************************************************************/
 
-void
-ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
-                        uint8_t reason,
-                        uint8_t prev_notify, uint8_t cur_notify,
-                        uint8_t prev_indicate, uint8_t cur_indicate)
+void ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
+                             uint8_t reason, uint8_t prev_notify, uint8_t cur_notify,
+                             uint8_t prev_indicate, uint8_t cur_indicate)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    BLE_HS_DBG_ASSERT(prev_notify != cur_notify ||
-                      prev_indicate != cur_indicate);
-    BLE_HS_DBG_ASSERT(reason == BLE_GAP_SUBSCRIBE_REASON_WRITE ||
-                      reason == BLE_GAP_SUBSCRIBE_REASON_TERM  ||
-                      reason == BLE_GAP_SUBSCRIBE_REASON_RESTORE);
+	BLE_HS_DBG_ASSERT(prev_notify != cur_notify || prev_indicate != cur_indicate);
+	BLE_HS_DBG_ASSERT(reason == BLE_GAP_SUBSCRIBE_REASON_WRITE ||
+	                  reason == BLE_GAP_SUBSCRIBE_REASON_TERM ||
+	                  reason == BLE_GAP_SUBSCRIBE_REASON_RESTORE);
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_SUBSCRIBE;
-    event.subscribe.conn_handle = conn_handle;
-    event.subscribe.attr_handle = attr_handle;
-    event.subscribe.reason = reason;
-    event.subscribe.prev_notify = !!prev_notify;
-    event.subscribe.cur_notify = !!cur_notify;
-    event.subscribe.prev_indicate = !!prev_indicate;
-    event.subscribe.cur_indicate = !!cur_indicate;
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_SUBSCRIBE;
+	event.subscribe.conn_handle = conn_handle;
+	event.subscribe.attr_handle = attr_handle;
+	event.subscribe.reason = reason;
+	event.subscribe.prev_notify = !!prev_notify;
+	event.subscribe.cur_notify = !!cur_notify;
+	event.subscribe.prev_indicate = !!prev_indicate;
+	event.subscribe.cur_indicate = !!cur_indicate;
 
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 #endif
 }
 
@@ -6535,38 +6328,36 @@ ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
  * $mtu                                                                      *
  *****************************************************************************/
 
-void
-ble_gap_mtu_event(uint16_t conn_handle, uint16_t cid, uint16_t mtu)
+void ble_gap_mtu_event(uint16_t conn_handle, uint16_t cid, uint16_t mtu)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_MTU;
-    event.mtu.conn_handle = conn_handle;
-    event.mtu.channel_id = cid;
-    event.mtu.value = mtu;
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_MTU;
+	event.mtu.conn_handle = conn_handle;
+	event.mtu.channel_id = cid;
+	event.mtu.value = mtu;
 
-    ble_gap_event_listener_call(&event);
-    ble_gap_call_conn_event_cb(&event, conn_handle);
+	ble_gap_event_listener_call(&event);
+	ble_gap_call_conn_event_cb(&event, conn_handle);
 #endif
 }
 
 #if MYNEWT_VAL(BLE_HS_GAP_UNHANDLED_HCI_EVENT)
-void
-ble_gap_unhandled_hci_event(bool is_le_meta, bool is_vs, const void *buf,
-                            uint8_t len)
+void ble_gap_unhandled_hci_event(bool is_le_meta, bool is_vs, const void *buf,
+                                 uint8_t len)
 {
-    struct ble_gap_event event;
+	struct ble_gap_event event;
 
-    memset(&event, 0, sizeof event);
-    event.type = BLE_GAP_EVENT_UNHANDLED_HCI_EVENT;
-    event.unhandled_hci.is_le_meta = is_le_meta;
-    event.unhandled_hci.is_vs = is_vs;
-    event.unhandled_hci.ev = buf;
-    event.unhandled_hci.length = len;
+	memset(&event, 0, sizeof event);
+	event.type = BLE_GAP_EVENT_UNHANDLED_HCI_EVENT;
+	event.unhandled_hci.is_le_meta = is_le_meta;
+	event.unhandled_hci.is_vs = is_vs;
+	event.unhandled_hci.ev = buf;
+	event.unhandled_hci.length = len;
 
-    ble_gap_event_listener_call(&event);
+	ble_gap_event_listener_call(&event);
 }
 #endif
 
@@ -6574,43 +6365,42 @@ ble_gap_unhandled_hci_event(bool is_le_meta, bool is_vs, const void *buf,
  * $preempt                                                                  *
  *****************************************************************************/
 
-void
-ble_gap_preempt_no_lock(void)
+void ble_gap_preempt_no_lock(void)
 {
-    int rc;
-    int i;
+	int rc;
+	int i;
 
-    (void)rc;
-    (void)i;
+	(void) rc;
+	(void) i;
 
 #if NIMBLE_BLE_ADVERTISE
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        rc = ble_gap_ext_adv_stop_no_lock(i);
-        if (rc == 0) {
-            ble_gap_slave[i].preempted = 1;
-        }
-    }
+	for (i = 0; i < BLE_ADV_INSTANCES; i++) {
+		rc = ble_gap_ext_adv_stop_no_lock(i);
+		if (rc == 0) {
+			ble_gap_slave[i].preempted = 1;
+		}
+	}
 #else
-    rc = ble_gap_adv_stop_no_lock();
-    if (rc == 0) {
-        ble_gap_slave[0].preempted = 1;
-    }
+	rc = ble_gap_adv_stop_no_lock();
+	if (rc == 0) {
+		ble_gap_slave[0].preempted = 1;
+	}
 #endif
 #endif
 
 #if NIMBLE_BLE_CONNECT
-    rc = ble_gap_conn_cancel_no_lock();
-    if (rc == 0) {
-        ble_gap_master.preempted_op = BLE_GAP_OP_M_CONN;
-    }
+	rc = ble_gap_conn_cancel_no_lock();
+	if (rc == 0) {
+		ble_gap_master.preempted_op = BLE_GAP_OP_M_CONN;
+	}
 #endif
 
 #if NIMBLE_BLE_SCAN
-    rc = ble_gap_disc_cancel_no_lock();
-    if (rc == 0) {
-        ble_gap_master.preempted_op = BLE_GAP_OP_M_DISC;
-    }
+	rc = ble_gap_disc_cancel_no_lock();
+	if (rc == 0) {
+		ble_gap_master.preempted_op = BLE_GAP_OP_M_DISC;
+	}
 #endif
 }
 
@@ -6626,16 +6416,15 @@ ble_gap_preempt_no_lock(void)
  * reason code of BLE_HS_EPREEMPTED.  An attempt to initiate a new GAP
  * procedure during preemption fails with a return code of BLE_HS_EPREEMPTED.
  */
-void
-ble_gap_preempt(void)
+void ble_gap_preempt(void)
 {
-    ble_hs_lock();
+	ble_hs_lock();
 
-    if (!ble_gap_is_preempted()) {
-        ble_gap_preempt_no_lock();
-    }
+	if (!ble_gap_is_preempted()) {
+		ble_gap_preempt_no_lock();
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
 /**
@@ -6646,308 +6435,299 @@ ble_gap_preempt(void)
 
 static struct ble_npl_mutex preempt_done_mutex;
 
-void
-ble_gap_preempt_done(void)
+void ble_gap_preempt_done(void)
 {
-    struct ble_gap_event event;
-    ble_gap_event_fn *master_cb;
-    void *master_arg;
-    int disc_preempted;
-    int i;
-    static struct {
-        ble_gap_event_fn *cb;
-        void *arg;
-    } slaves[BLE_ADV_INSTANCES];
+	struct ble_gap_event event;
+	ble_gap_event_fn *master_cb;
+	void *master_arg;
+	int disc_preempted;
+	int i;
+	static struct {
+		ble_gap_event_fn *cb;
+		void *arg;
+	} slaves[BLE_ADV_INSTANCES];
 
-    master_cb = NULL;
-    master_arg = NULL;
+	master_cb = NULL;
+	master_arg = NULL;
 
-    disc_preempted = 0;
+	disc_preempted = 0;
 
-    /* Protects slaves from accessing by multiple threads */
-    ble_npl_mutex_pend(&preempt_done_mutex, 0xFFFFFFFF);
-    memset(slaves, 0, sizeof(slaves));
+	/* Protects slaves from accessing by multiple threads */
+	ble_npl_mutex_pend(&preempt_done_mutex, 0xFFFFFFFF);
+	memset(slaves, 0, sizeof(slaves));
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (ble_gap_slave[i].preempted) {
-            ble_gap_slave[i].preempted = 0;
-            slaves[i].cb = ble_gap_slave[i].cb;
-            slaves[i].arg = ble_gap_slave[i].cb_arg;
-        }
-    }
+	for (i = 0; i < BLE_ADV_INSTANCES; i++) {
+		if (ble_gap_slave[i].preempted) {
+			ble_gap_slave[i].preempted = 0;
+			slaves[i].cb = ble_gap_slave[i].cb;
+			slaves[i].arg = ble_gap_slave[i].cb_arg;
+		}
+	}
 
-    if (ble_gap_master.preempted_op == BLE_GAP_OP_M_DISC) {
-        ble_gap_master.preempted_op = BLE_GAP_OP_NULL;
-        disc_preempted = 1;
-        master_cb = ble_gap_master.cb;
-        master_arg = ble_gap_master.cb_arg;
-    }
+	if (ble_gap_master.preempted_op == BLE_GAP_OP_M_DISC) {
+		ble_gap_master.preempted_op = BLE_GAP_OP_NULL;
+		disc_preempted = 1;
+		master_cb = ble_gap_master.cb;
+		master_arg = ble_gap_master.cb_arg;
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    event.type = BLE_GAP_EVENT_ADV_COMPLETE;
-    event.adv_complete.reason = BLE_HS_EPREEMPTED;
+	event.type = BLE_GAP_EVENT_ADV_COMPLETE;
+	event.adv_complete.reason = BLE_HS_EPREEMPTED;
 
-    for (i = 0; i < BLE_ADV_INSTANCES; i++) {
-        if (slaves[i].cb) {
+	for (i = 0; i < BLE_ADV_INSTANCES; i++) {
+		if (slaves[i].cb) {
 #if MYNEWT_VAL(BLE_EXT_ADV)
-            event.adv_complete.instance = i;
-            event.adv_complete.conn_handle = i;
+			event.adv_complete.instance = i;
+			event.adv_complete.conn_handle = i;
 #endif
-            ble_gap_call_event_cb(&event, slaves[i].cb, slaves[i].arg);
-        }
-    }
-    ble_npl_mutex_release(&preempt_done_mutex);
+			ble_gap_call_event_cb(&event, slaves[i].cb, slaves[i].arg);
+		}
+	}
+	ble_npl_mutex_release(&preempt_done_mutex);
 
-    if (disc_preempted) {
-        event.type = BLE_GAP_EVENT_DISC_COMPLETE;
-        event.disc_complete.reason = BLE_HS_EPREEMPTED;
-        ble_gap_call_event_cb(&event, master_cb, master_arg);
-    }
+	if (disc_preempted) {
+		event.type = BLE_GAP_EVENT_DISC_COMPLETE;
+		event.disc_complete.reason = BLE_HS_EPREEMPTED;
+		ble_gap_call_event_cb(&event, master_cb, master_arg);
+	}
 }
 
-int
-ble_gap_event_listener_register(struct ble_gap_event_listener *listener,
-                                ble_gap_event_fn *fn, void *arg)
+int ble_gap_event_listener_register(struct ble_gap_event_listener *listener,
+                                    ble_gap_event_fn *fn, void *arg)
 {
-    struct ble_gap_event_listener *evl = NULL;
-    int rc;
+	struct ble_gap_event_listener *evl = NULL;
+	int rc;
 
-    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link) {
-        if (evl == listener) {
-            break;
-        }
-    }
+	SLIST_FOREACH(evl, &ble_gap_event_listener_list, link)
+	{
+		if (evl == listener) {
+			break;
+		}
+	}
 
-    if (!evl) {
-        if (fn) {
-            memset(listener, 0, sizeof(*listener));
-            listener->fn = fn;
-            listener->arg = arg;
-            SLIST_INSERT_HEAD(&ble_gap_event_listener_list, listener, link);
-            rc = 0;
-        } else {
-            rc = BLE_HS_EINVAL;
-        }
-    } else {
-        rc = BLE_HS_EALREADY;
-    }
+	if (!evl) {
+		if (fn) {
+			memset(listener, 0, sizeof(*listener));
+			listener->fn = fn;
+			listener->arg = arg;
+			SLIST_INSERT_HEAD(&ble_gap_event_listener_list, listener, link);
+			rc = 0;
+		}
+		else {
+			rc = BLE_HS_EINVAL;
+		}
+	}
+	else {
+		rc = BLE_HS_EALREADY;
+	}
 
-    return rc;
+	return rc;
 }
 
-int
-ble_gap_event_listener_unregister(struct ble_gap_event_listener *listener)
+int ble_gap_event_listener_unregister(struct ble_gap_event_listener *listener)
 {
-    struct ble_gap_event_listener *evl = NULL;
-    int rc;
+	struct ble_gap_event_listener *evl = NULL;
+	int rc;
 
-    /*
-     * We check if element exists on the list only for sanity to let caller
-     * know whether it registered its listener before.
-     */
+	/*
+	 * We check if element exists on the list only for sanity to let caller
+	 * know whether it registered its listener before.
+	 */
 
-    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link) {
-        if (evl == listener) {
-            break;
-        }
-    }
+	SLIST_FOREACH(evl, &ble_gap_event_listener_list, link)
+	{
+		if (evl == listener) {
+			break;
+		}
+	}
 
-    if (!evl) {
-        rc = BLE_HS_ENOENT;
-    } else {
-        SLIST_REMOVE(&ble_gap_event_listener_list, listener,
-                     ble_gap_event_listener, link);
-        rc = 0;
-    }
+	if (!evl) {
+		rc = BLE_HS_ENOENT;
+	}
+	else {
+		SLIST_REMOVE(&ble_gap_event_listener_list, listener, ble_gap_event_listener, link);
+		rc = 0;
+	}
 
-    return rc;
+	return rc;
 }
 
-static int
-ble_gap_event_listener_call(struct ble_gap_event *event)
+static int ble_gap_event_listener_call(struct ble_gap_event *event)
 {
-    struct ble_gap_event_listener *evl = NULL;
+	struct ble_gap_event_listener *evl = NULL;
 
-    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link) {
-        evl->fn(event, evl->arg);
-    }
+	SLIST_FOREACH(evl, &ble_gap_event_listener_list, link)
+	{
+		evl->fn(event, evl->arg);
+	}
 
-    return 0;
+	return 0;
 }
 
 /*****************************************************************************
  * $init                                                                     *
  *****************************************************************************/
 
-int
-ble_gap_init(void)
+int ble_gap_init(void)
 {
-    int rc;
+	int rc;
 
-    memset(&ble_gap_master, 0, sizeof(ble_gap_master));
-    memset(ble_gap_slave, 0, sizeof(ble_gap_slave));
+	memset(&ble_gap_master, 0, sizeof(ble_gap_master));
+	memset(ble_gap_slave, 0, sizeof(ble_gap_slave));
 
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-    memset(&ble_gap_sync, 0, sizeof(ble_gap_sync));
-#endif
-
-    rc = ble_npl_mutex_init(&preempt_done_mutex);
-
-    if (rc) {
-       BLE_HS_LOG(ERROR, "mutex init failed with reason %d \n", rc);
-       return rc;
-    }
-
-    SLIST_INIT(&ble_gap_update_entries);
-    SLIST_INIT(&ble_gap_event_listener_list);
-
-    rc = os_mempool_init(&ble_gap_update_entry_pool,
-                         MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE),
-                         sizeof (struct ble_gap_update_entry),
-                         ble_gap_update_entry_mem,
-                         "ble_gap_update");
-    switch (rc) {
-    case 0:
-        break;
-    case OS_ENOMEM:
-        rc = BLE_HS_ENOMEM;
-        goto err;
-    default:
-        rc = BLE_HS_EOS;
-        goto err;
-    }
-
-    rc = stats_init_and_reg(
-        STATS_HDR(ble_gap_stats), STATS_SIZE_INIT_PARMS(ble_gap_stats,
-        STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_gap_stats), "ble_gap");
-    if (rc != 0) {
-        goto err;
-    }
-
-    return 0;
+	memset(&ble_gap_sync, 0, sizeof(ble_gap_sync));
+#endif
+
+	rc = ble_npl_mutex_init(&preempt_done_mutex);
+
+	if (rc) {
+		BLE_HS_LOG(ERROR, "mutex init failed with reason %d \n", rc);
+		return rc;
+	}
+
+	SLIST_INIT(&ble_gap_update_entries);
+	SLIST_INIT(&ble_gap_event_listener_list);
+
+	rc = os_mempool_init(
+		&ble_gap_update_entry_pool, MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE),
+		sizeof(struct ble_gap_update_entry), ble_gap_update_entry_mem, "ble_gap_update");
+	switch (rc) {
+	case 0:
+		break;
+	case OS_ENOMEM:
+		rc = BLE_HS_ENOMEM;
+		goto err;
+	default:
+		rc = BLE_HS_EOS;
+		goto err;
+	}
+
+	rc = stats_init_and_reg(STATS_HDR(ble_gap_stats),
+	                        STATS_SIZE_INIT_PARMS(ble_gap_stats, STATS_SIZE_32),
+	                        STATS_NAME_INIT_PARMS(ble_gap_stats), "ble_gap");
+	if (rc != 0) {
+		goto err;
+	}
+
+	return 0;
 
 err:
-    return rc;
+	return rc;
 }
 
-int
-ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy, uint8_t *out_status, uint8_t *out_phy ,
-				      uint8_t *out_curr_tx_power_level, uint8_t *out_max_tx_power_level)
+int ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy,
+                                          uint8_t *out_status, uint8_t *out_phy,
+                                          uint8_t *out_curr_tx_power_level,
+                                          uint8_t *out_max_tx_power_level)
 
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
-    struct ble_hci_le_enh_read_transmit_power_level_cp cmd;
-    struct ble_hci_le_enh_read_transmit_power_level_rp rsp;
-    uint16_t opcode;
-    int rc;
+	struct ble_hci_le_enh_read_transmit_power_level_cp cmd;
+	struct ble_hci_le_enh_read_transmit_power_level_rp rsp;
+	uint16_t opcode;
+	int rc;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_ENH_READ_TRANSMIT_POWER_LEVEL);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_ENH_READ_TRANSMIT_POWER_LEVEL);
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.phy = phy;
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.phy = phy;
 
-    rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+	rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
 
-    if (rc!=0) {
-        return rc;
-    }
+	if (rc != 0) {
+		return rc;
+	}
 
-    *out_status = rc;
-    *out_phy = rsp.phy;
-    *out_curr_tx_power_level = rsp.curr_tx_power_level;
-    *out_max_tx_power_level = rsp.max_tx_power_level;
+	*out_status = rc;
+	*out_phy = rsp.phy;
+	*out_curr_tx_power_level = rsp.curr_tx_power_level;
+	*out_max_tx_power_level = rsp.max_tx_power_level;
 
-    return 0;
+	return 0;
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_read_remote_transmit_power_level(uint16_t conn_handle,
-				      uint8_t phy)
+int ble_gap_read_remote_transmit_power_level(uint16_t conn_handle, uint8_t phy)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
-    struct ble_hci_le_read_remote_transmit_power_level_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_read_remote_transmit_power_level_cp cmd;
+	uint16_t opcode;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL);
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.phy = phy;
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.phy = phy;
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_set_path_loss_reporting_param(uint16_t conn_handle,
-				      uint8_t high_threshold,
-				      uint8_t high_hysteresis,
-				      uint8_t low_threshold,
-				      uint8_t low_hysteresis,
-				      uint16_t min_time_spent)
+int ble_gap_set_path_loss_reporting_param(uint16_t conn_handle, uint8_t high_threshold,
+                                          uint8_t high_hysteresis,
+                                          uint8_t low_threshold, uint8_t low_hysteresis,
+                                          uint16_t min_time_spent)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
-    struct ble_hci_le_set_path_loss_report_param_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_path_loss_report_param_cp cmd;
+	uint16_t opcode;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_PARAM);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_PARAM);
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.high_threshold = high_threshold;
-    cmd.high_hysteresis = high_hysteresis;
-    cmd.low_threshold = low_threshold;
-    cmd.low_hysteresis = low_hysteresis;
-    cmd.min_time_spent = min_time_spent;
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.high_threshold = high_threshold;
+	cmd.high_hysteresis = high_hysteresis;
+	cmd.low_threshold = low_threshold;
+	cmd.low_hysteresis = low_hysteresis;
+	cmd.min_time_spent = min_time_spent;
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_set_path_loss_reporting_enable(uint16_t conn_handle,
-				       uint8_t enable)
+int ble_gap_set_path_loss_reporting_enable(uint16_t conn_handle, uint8_t enable)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
-    struct ble_hci_le_set_path_loss_report_enable_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_path_loss_report_enable_cp cmd;
+	uint16_t opcode;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_ENABLE);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_ENABLE);
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.enable = enable;
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.enable = enable;
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
 
-int
-ble_gap_set_transmit_power_reporting_enable(uint16_t conn_handle,
-					    uint8_t local_enable,
-					    uint8_t remote_enable)
+int ble_gap_set_transmit_power_reporting_enable(uint16_t conn_handle,
+                                                uint8_t local_enable,
+                                                uint8_t remote_enable)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
-    struct ble_hci_le_set_transmit_power_report_enable_cp cmd;
-    uint16_t opcode;
+	struct ble_hci_le_set_transmit_power_report_enable_cp cmd;
+	uint16_t opcode;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_TRANS_PWR_REPORT_ENABLE);
+	opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_TRANS_PWR_REPORT_ENABLE);
 
-    cmd.conn_handle = htole16(conn_handle);
-    cmd.local_enable = local_enable;
-    cmd.remote_enable = remote_enable;
+	cmd.conn_handle = htole16(conn_handle);
+	cmd.local_enable = local_enable;
+	cmd.remote_enable = remote_enable;
 
-    return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
+	return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 #else
-    return BLE_HS_ENOTSUP;
+	return BLE_HS_ENOTSUP;
 #endif
 }
diff --git a/nimble/host/src/ble_sm.c b/nimble/host/src/ble_sm.c
index 0b7c28db..4ab26c26 100644
--- a/nimble/host/src/ble_sm.c
+++ b/nimble/host/src/ble_sm.c
@@ -61,7 +61,7 @@
 #if NIMBLE_BLE_SM
 
 /** Procedure timeout; 30 seconds. */
-#define BLE_SM_TIMEOUT_MS             (30000)
+#define BLE_SM_TIMEOUT_MS (30000)
 
 STAILQ_HEAD(ble_sm_proc_list, ble_sm_proc);
 
@@ -81,38 +81,37 @@ static ble_sm_rx_fn ble_sm_id_addr_info_rx;
 static ble_sm_rx_fn ble_sm_sign_info_rx;
 static ble_sm_rx_fn ble_sm_sec_req_rx;
 
-static ble_sm_rx_fn * const ble_sm_dispatch[] = {
-   [BLE_SM_OP_PAIR_REQ] = ble_sm_pair_req_rx,
-   [BLE_SM_OP_PAIR_RSP] = ble_sm_pair_rsp_rx,
-   [BLE_SM_OP_PAIR_CONFIRM] = ble_sm_confirm_rx,
-   [BLE_SM_OP_PAIR_RANDOM] = ble_sm_random_rx,
-   [BLE_SM_OP_PAIR_FAIL] = ble_sm_fail_rx,
-   [BLE_SM_OP_ENC_INFO] = ble_sm_enc_info_rx,
-   [BLE_SM_OP_MASTER_ID] = ble_sm_master_id_rx,
-   [BLE_SM_OP_IDENTITY_INFO] = ble_sm_id_info_rx,
-   [BLE_SM_OP_IDENTITY_ADDR_INFO] = ble_sm_id_addr_info_rx,
-   [BLE_SM_OP_SIGN_INFO] = ble_sm_sign_info_rx,
-   [BLE_SM_OP_SEC_REQ] = ble_sm_sec_req_rx,
-   [BLE_SM_OP_PAIR_KEYPRESS_NOTIFY] = ble_sm_rx_noop,
+static ble_sm_rx_fn *const ble_sm_dispatch[] = {
+	[BLE_SM_OP_PAIR_REQ] = ble_sm_pair_req_rx,
+	[BLE_SM_OP_PAIR_RSP] = ble_sm_pair_rsp_rx,
+	[BLE_SM_OP_PAIR_CONFIRM] = ble_sm_confirm_rx,
+	[BLE_SM_OP_PAIR_RANDOM] = ble_sm_random_rx,
+	[BLE_SM_OP_PAIR_FAIL] = ble_sm_fail_rx,
+	[BLE_SM_OP_ENC_INFO] = ble_sm_enc_info_rx,
+	[BLE_SM_OP_MASTER_ID] = ble_sm_master_id_rx,
+	[BLE_SM_OP_IDENTITY_INFO] = ble_sm_id_info_rx,
+	[BLE_SM_OP_IDENTITY_ADDR_INFO] = ble_sm_id_addr_info_rx,
+	[BLE_SM_OP_SIGN_INFO] = ble_sm_sign_info_rx,
+	[BLE_SM_OP_SEC_REQ] = ble_sm_sec_req_rx,
+	[BLE_SM_OP_PAIR_KEYPRESS_NOTIFY] = ble_sm_rx_noop,
 #if MYNEWT_VAL(BLE_SM_SC)
-   [BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_sc_public_key_rx,
-   [BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_sc_dhkey_check_rx,
+	[BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_sc_public_key_rx,
+	[BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_sc_dhkey_check_rx,
 #else
-   [BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_rx_noop,
-   [BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_rx_noop,
+	[BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_rx_noop,
+	[BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_rx_noop,
 #endif
 };
 
-struct hci_start_encrypt
-{
-    uint16_t connection_handle;
-    uint16_t encrypted_diversifier;
-    uint64_t random_number;
-    uint8_t long_term_key[16];
+struct hci_start_encrypt {
+	uint16_t connection_handle;
+	uint16_t encrypted_diversifier;
+	uint64_t random_number;
+	uint8_t long_term_key[16];
 };
 
-typedef void ble_sm_state_fn(struct ble_sm_proc *proc,
-                             struct ble_sm_result *res, void *arg);
+typedef void ble_sm_state_fn(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                             void *arg);
 
 static ble_sm_state_fn ble_sm_pair_exec;
 static ble_sm_state_fn ble_sm_confirm_exec;
@@ -124,30 +123,27 @@ static ble_sm_state_fn ble_sm_enc_restore_exec;
 static ble_sm_state_fn ble_sm_key_exch_exec;
 static ble_sm_state_fn ble_sm_sec_req_exec;
 
-static ble_sm_state_fn * const
-ble_sm_state_dispatch[BLE_SM_PROC_STATE_CNT] = {
-    [BLE_SM_PROC_STATE_PAIR]          = ble_sm_pair_exec,
-    [BLE_SM_PROC_STATE_CONFIRM]       = ble_sm_confirm_exec,
-    [BLE_SM_PROC_STATE_RANDOM]        = ble_sm_random_exec,
-    [BLE_SM_PROC_STATE_LTK_START]     = ble_sm_ltk_start_exec,
-    [BLE_SM_PROC_STATE_LTK_RESTORE]   = ble_sm_ltk_restore_exec,
-    [BLE_SM_PROC_STATE_ENC_START]     = ble_sm_enc_start_exec,
-    [BLE_SM_PROC_STATE_ENC_RESTORE]   = ble_sm_enc_restore_exec,
-    [BLE_SM_PROC_STATE_KEY_EXCH]      = ble_sm_key_exch_exec,
-    [BLE_SM_PROC_STATE_SEC_REQ]       = ble_sm_sec_req_exec,
+static ble_sm_state_fn *const ble_sm_state_dispatch[BLE_SM_PROC_STATE_CNT] = {
+	[BLE_SM_PROC_STATE_PAIR] = ble_sm_pair_exec,
+	[BLE_SM_PROC_STATE_CONFIRM] = ble_sm_confirm_exec,
+	[BLE_SM_PROC_STATE_RANDOM] = ble_sm_random_exec,
+	[BLE_SM_PROC_STATE_LTK_START] = ble_sm_ltk_start_exec,
+	[BLE_SM_PROC_STATE_LTK_RESTORE] = ble_sm_ltk_restore_exec,
+	[BLE_SM_PROC_STATE_ENC_START] = ble_sm_enc_start_exec,
+	[BLE_SM_PROC_STATE_ENC_RESTORE] = ble_sm_enc_restore_exec,
+	[BLE_SM_PROC_STATE_KEY_EXCH] = ble_sm_key_exch_exec,
+	[BLE_SM_PROC_STATE_SEC_REQ] = ble_sm_sec_req_exec,
 #if MYNEWT_VAL(BLE_SM_SC)
-    [BLE_SM_PROC_STATE_PUBLIC_KEY]    = ble_sm_sc_public_key_exec,
-    [BLE_SM_PROC_STATE_DHKEY_CHECK]   = ble_sm_sc_dhkey_check_exec,
+	[BLE_SM_PROC_STATE_PUBLIC_KEY] = ble_sm_sc_public_key_exec,
+	[BLE_SM_PROC_STATE_DHKEY_CHECK] = ble_sm_sc_dhkey_check_exec,
 #else
-    [BLE_SM_PROC_STATE_PUBLIC_KEY]    = NULL,
-    [BLE_SM_PROC_STATE_DHKEY_CHECK]   = NULL,
+	[BLE_SM_PROC_STATE_PUBLIC_KEY] = NULL,
+	[BLE_SM_PROC_STATE_DHKEY_CHECK] = NULL,
 #endif
 };
 
-static os_membuf_t ble_sm_proc_mem[
-    OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_SM_MAX_PROCS),
-                    sizeof (struct ble_sm_proc))
-];
+static os_membuf_t ble_sm_proc_mem[OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_SM_MAX_PROCS),
+                                                   sizeof(struct ble_sm_proc))];
 
 static struct os_mempool ble_sm_proc_pool;
 
@@ -174,63 +170,54 @@ static uint8_t ble_sm_dbg_next_ltk_set;
 static uint8_t ble_sm_dbg_next_csrk[16];
 static uint8_t ble_sm_dbg_next_csrk_set;
 
-void
-ble_sm_dbg_set_next_pair_rand(uint8_t *next_pair_rand)
+void ble_sm_dbg_set_next_pair_rand(uint8_t *next_pair_rand)
 {
-    memcpy(ble_sm_dbg_next_pair_rand, next_pair_rand,
-           sizeof ble_sm_dbg_next_pair_rand);
-    ble_sm_dbg_next_pair_rand_set = 1;
+	memcpy(ble_sm_dbg_next_pair_rand, next_pair_rand, sizeof ble_sm_dbg_next_pair_rand);
+	ble_sm_dbg_next_pair_rand_set = 1;
 }
 
-void
-ble_sm_dbg_set_next_ediv(uint16_t next_ediv)
+void ble_sm_dbg_set_next_ediv(uint16_t next_ediv)
 {
-    ble_sm_dbg_next_ediv = next_ediv;
-    ble_sm_dbg_next_ediv_set = 1;
+	ble_sm_dbg_next_ediv = next_ediv;
+	ble_sm_dbg_next_ediv_set = 1;
 }
 
-void
-ble_sm_dbg_set_next_master_id_rand(uint64_t next_master_id_rand)
+void ble_sm_dbg_set_next_master_id_rand(uint64_t next_master_id_rand)
 {
-    ble_sm_dbg_next_master_id_rand = next_master_id_rand;
-    ble_sm_dbg_next_master_id_rand_set = 1;
+	ble_sm_dbg_next_master_id_rand = next_master_id_rand;
+	ble_sm_dbg_next_master_id_rand_set = 1;
 }
 
-void
-ble_sm_dbg_set_next_ltk(uint8_t *next_ltk)
+void ble_sm_dbg_set_next_ltk(uint8_t *next_ltk)
 {
-    memcpy(ble_sm_dbg_next_ltk, next_ltk,
-           sizeof ble_sm_dbg_next_ltk);
-    ble_sm_dbg_next_ltk_set = 1;
+	memcpy(ble_sm_dbg_next_ltk, next_ltk, sizeof ble_sm_dbg_next_ltk);
+	ble_sm_dbg_next_ltk_set = 1;
 }
 
-void
-ble_sm_dbg_set_next_csrk(uint8_t *next_csrk)
+void ble_sm_dbg_set_next_csrk(uint8_t *next_csrk)
 {
-    memcpy(ble_sm_dbg_next_csrk, next_csrk,
-           sizeof ble_sm_dbg_next_csrk);
-    ble_sm_dbg_next_csrk_set = 1;
+	memcpy(ble_sm_dbg_next_csrk, next_csrk, sizeof ble_sm_dbg_next_csrk);
+	ble_sm_dbg_next_csrk_set = 1;
 }
 
 #endif
 
-static void
-ble_sm_dbg_assert_no_cycles(void)
+static void ble_sm_dbg_assert_no_cycles(void)
 {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    ble_sm_num_procs();
+	ble_sm_num_procs();
 #endif
 }
 
-static void
-ble_sm_dbg_assert_not_inserted(struct ble_sm_proc *proc)
+static void ble_sm_dbg_assert_not_inserted(struct ble_sm_proc *proc)
 {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    struct ble_sm_proc *cur;
+	struct ble_sm_proc *cur;
 
-    STAILQ_FOREACH(cur, &ble_sm_procs, next) {
-        BLE_HS_DBG_ASSERT(cur != proc);
-    }
+	STAILQ_FOREACH(cur, &ble_sm_procs, next)
+	{
+		BLE_HS_DBG_ASSERT(cur != proc);
+	}
 #endif
 }
 
@@ -241,148 +228,138 @@ ble_sm_dbg_assert_not_inserted(struct ble_sm_proc *proc)
 /**
  * Calculates the number of active SM procedures.
  */
-int
-ble_sm_num_procs(void)
+int ble_sm_num_procs(void)
 {
-    struct ble_sm_proc *proc;
-    int cnt;
+	struct ble_sm_proc *proc;
+	int cnt;
 
-    cnt = 0;
-    STAILQ_FOREACH(proc, &ble_sm_procs, next) {
-        BLE_HS_DBG_ASSERT(cnt < MYNEWT_VAL(BLE_SM_MAX_PROCS));
-        cnt++;
-    }
+	cnt = 0;
+	STAILQ_FOREACH(proc, &ble_sm_procs, next)
+	{
+		BLE_HS_DBG_ASSERT(cnt < MYNEWT_VAL(BLE_SM_MAX_PROCS));
+		cnt++;
+	}
 
-    return cnt;
+	return cnt;
 }
 
-int
-ble_sm_gen_pair_rand(uint8_t *pair_rand)
+int ble_sm_gen_pair_rand(uint8_t *pair_rand)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_pair_rand_set) {
-        ble_sm_dbg_next_pair_rand_set = 0;
-        memcpy(pair_rand, ble_sm_dbg_next_pair_rand,
-               sizeof ble_sm_dbg_next_pair_rand);
-        return 0;
-    }
+	if (ble_sm_dbg_next_pair_rand_set) {
+		ble_sm_dbg_next_pair_rand_set = 0;
+		memcpy(pair_rand, ble_sm_dbg_next_pair_rand, sizeof ble_sm_dbg_next_pair_rand);
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(pair_rand, 16);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(pair_rand, 16);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_gen_ediv(struct ble_sm_master_id *master_id)
+static int ble_sm_gen_ediv(struct ble_sm_master_id *master_id)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_ediv_set) {
-        ble_sm_dbg_next_ediv_set = 0;
-        master_id->ediv = ble_sm_dbg_next_ediv;
-        return 0;
-    }
+	if (ble_sm_dbg_next_ediv_set) {
+		ble_sm_dbg_next_ediv_set = 0;
+		master_id->ediv = ble_sm_dbg_next_ediv;
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(&master_id->ediv, sizeof master_id->ediv);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(&master_id->ediv, sizeof master_id->ediv);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_gen_master_id_rand(struct ble_sm_master_id *master_id)
+static int ble_sm_gen_master_id_rand(struct ble_sm_master_id *master_id)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_master_id_rand_set) {
-        ble_sm_dbg_next_master_id_rand_set = 0;
-        master_id->rand_val = ble_sm_dbg_next_master_id_rand;
-        return 0;
-    }
+	if (ble_sm_dbg_next_master_id_rand_set) {
+		ble_sm_dbg_next_master_id_rand_set = 0;
+		master_id->rand_val = ble_sm_dbg_next_master_id_rand;
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(&master_id->rand_val, sizeof master_id->rand_val);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(&master_id->rand_val, sizeof master_id->rand_val);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_gen_ltk(struct ble_sm_proc *proc, uint8_t *ltk)
+static int ble_sm_gen_ltk(struct ble_sm_proc *proc, uint8_t *ltk)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_ltk_set) {
-        ble_sm_dbg_next_ltk_set = 0;
-        memcpy(ltk, ble_sm_dbg_next_ltk,
-               sizeof ble_sm_dbg_next_ltk);
-        return 0;
-    }
+	if (ble_sm_dbg_next_ltk_set) {
+		ble_sm_dbg_next_ltk_set = 0;
+		memcpy(ltk, ble_sm_dbg_next_ltk, sizeof ble_sm_dbg_next_ltk);
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(ltk, proc->key_size);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(ltk, proc->key_size);
+	if (rc != 0) {
+		return rc;
+	}
 
-    /* Ensure proper key size */
-    memset(ltk + proc->key_size, 0, sizeof proc->ltk - proc->key_size);
+	/* Ensure proper key size */
+	memset(ltk + proc->key_size, 0, sizeof proc->ltk - proc->key_size);
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_gen_csrk(struct ble_sm_proc *proc, uint8_t *csrk)
+static int ble_sm_gen_csrk(struct ble_sm_proc *proc, uint8_t *csrk)
 {
-    int rc;
+	int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    if (ble_sm_dbg_next_csrk_set) {
-        ble_sm_dbg_next_csrk_set = 0;
-        memcpy(csrk, ble_sm_dbg_next_csrk,
-               sizeof ble_sm_dbg_next_csrk);
-        return 0;
-    }
+	if (ble_sm_dbg_next_csrk_set) {
+		ble_sm_dbg_next_csrk_set = 0;
+		memcpy(csrk, ble_sm_dbg_next_csrk, sizeof ble_sm_dbg_next_csrk);
+		return 0;
+	}
 #endif
 
-    rc = ble_hs_hci_rand(csrk, 16);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_rand(csrk, 16);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static void
-ble_sm_proc_set_timer(struct ble_sm_proc *proc)
+static void ble_sm_proc_set_timer(struct ble_sm_proc *proc)
 {
-    proc->exp_os_ticks = ble_npl_time_get() +
-                         ble_npl_time_ms_to_ticks32(BLE_SM_TIMEOUT_MS);
-    ble_hs_timer_resched();
+	proc->exp_os_ticks =
+		ble_npl_time_get() + ble_npl_time_ms_to_ticks32(BLE_SM_TIMEOUT_MS);
+	ble_hs_timer_resched();
 }
 
-static ble_sm_rx_fn *
-ble_sm_dispatch_get(uint8_t op)
+static ble_sm_rx_fn *ble_sm_dispatch_get(uint8_t op)
 {
-    if (op >= sizeof ble_sm_dispatch / sizeof ble_sm_dispatch[0]) {
-        return NULL;
-    }
+	if (op >= sizeof ble_sm_dispatch / sizeof ble_sm_dispatch[0]) {
+		return NULL;
+	}
 
-    return ble_sm_dispatch[op];
+	return ble_sm_dispatch[op];
 }
 
 /**
@@ -390,225 +367,213 @@ ble_sm_dispatch_get(uint8_t op)
  *
  * @return                      An entry on success; null on failure.
  */
-static struct ble_sm_proc *
-ble_sm_proc_alloc(void)
+static struct ble_sm_proc *ble_sm_proc_alloc(void)
 {
-    struct ble_sm_proc *proc;
+	struct ble_sm_proc *proc;
 
-    proc = os_memblock_get(&ble_sm_proc_pool);
-    if (proc != NULL) {
-        memset(proc, 0, sizeof *proc);
-    }
+	proc = os_memblock_get(&ble_sm_proc_pool);
+	if (proc != NULL) {
+		memset(proc, 0, sizeof *proc);
+	}
 
-    return proc;
+	return proc;
 }
 
 /**
  * Frees the specified proc entry.  No-state if passed a null pointer.
  */
-static void
-ble_sm_proc_free(struct ble_sm_proc *proc)
+static void ble_sm_proc_free(struct ble_sm_proc *proc)
 {
-    int rc;
+	int rc;
 
-    if (proc != NULL) {
-        ble_sm_dbg_assert_not_inserted(proc);
+	if (proc != NULL) {
+		ble_sm_dbg_assert_not_inserted(proc);
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-        memset(proc, 0xff, sizeof *proc);
+		memset(proc, 0xff, sizeof *proc);
 #endif
-        rc = os_memblock_put(&ble_sm_proc_pool, proc);
-        BLE_HS_DBG_ASSERT_EVAL(rc == 0);
-    }
+		rc = os_memblock_put(&ble_sm_proc_pool, proc);
+		BLE_HS_DBG_ASSERT_EVAL(rc == 0);
+	}
 }
 
-static void
-ble_sm_proc_remove(struct ble_sm_proc *proc,
-                         struct ble_sm_proc *prev)
+static void ble_sm_proc_remove(struct ble_sm_proc *proc, struct ble_sm_proc *prev)
 {
-    if (prev == NULL) {
-        BLE_HS_DBG_ASSERT(STAILQ_FIRST(&ble_sm_procs) == proc);
-        STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
-    } else {
-        BLE_HS_DBG_ASSERT(STAILQ_NEXT(prev, next) == proc);
-        STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
-    }
+	if (prev == NULL) {
+		BLE_HS_DBG_ASSERT(STAILQ_FIRST(&ble_sm_procs) == proc);
+		STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
+	}
+	else {
+		BLE_HS_DBG_ASSERT(STAILQ_NEXT(prev, next) == proc);
+		STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
+	}
 
-    ble_sm_dbg_assert_no_cycles();
+	ble_sm_dbg_assert_no_cycles();
 }
 
-static void
-ble_sm_update_sec_state(uint16_t conn_handle, int encrypted,
-                        int authenticated, int bonded, int key_size)
+static void ble_sm_update_sec_state(uint16_t conn_handle, int encrypted,
+                                    int authenticated, int bonded, int key_size)
 {
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn *conn;
 
-    conn = ble_hs_conn_find(conn_handle);
-    if (conn != NULL) {
-        conn->bhc_sec_state.encrypted = encrypted;
+	conn = ble_hs_conn_find(conn_handle);
+	if (conn != NULL) {
+		conn->bhc_sec_state.encrypted = encrypted;
 
-        /* Authentication and bonding are never revoked from a secure link */
-        if (authenticated) {
-            conn->bhc_sec_state.authenticated = 1;
-        }
-        if (bonded) {
-            conn->bhc_sec_state.bonded = 1;
-        }
+		/* Authentication and bonding are never revoked from a secure link */
+		if (authenticated) {
+			conn->bhc_sec_state.authenticated = 1;
+		}
+		if (bonded) {
+			conn->bhc_sec_state.bonded = 1;
+		}
 
-        if (key_size) {
-            conn->bhc_sec_state.key_size = key_size;
-        }
-    }
+		if (key_size) {
+			conn->bhc_sec_state.key_size = key_size;
+		}
+	}
 }
 
-static void
-ble_sm_fill_store_value(const ble_addr_t *peer_addr,
-                        int authenticated,
-                        int sc,
-                        struct ble_sm_keys *keys,
-                        struct ble_store_value_sec *value_sec)
+static void ble_sm_fill_store_value(const ble_addr_t *peer_addr, int authenticated,
+                                    int sc, struct ble_sm_keys *keys,
+                                    struct ble_store_value_sec *value_sec)
 {
-    memset(value_sec, 0, sizeof *value_sec);
-
-    value_sec->peer_addr = *peer_addr;
+	memset(value_sec, 0, sizeof *value_sec);
+
+	value_sec->peer_addr = *peer_addr;
+
+	if (keys->ediv_rand_valid && keys->ltk_valid) {
+		value_sec->key_size = keys->key_size;
+		value_sec->ediv = keys->ediv;
+		value_sec->rand_num = keys->rand_val;
 
-    if (keys->ediv_rand_valid && keys->ltk_valid) {
-        value_sec->key_size = keys->key_size;
-        value_sec->ediv = keys->ediv;
-        value_sec->rand_num = keys->rand_val;
-
-        memcpy(value_sec->ltk, keys->ltk, sizeof value_sec->ltk);
-        value_sec->ltk_present = 1;
+		memcpy(value_sec->ltk, keys->ltk, sizeof value_sec->ltk);
+		value_sec->ltk_present = 1;
 
-        value_sec->authenticated = !!authenticated;
-        value_sec->sc = !!sc;
-    }
+		value_sec->authenticated = !!authenticated;
+		value_sec->sc = !!sc;
+	}
 
-    if (keys->irk_valid) {
-        memcpy(value_sec->irk, keys->irk, sizeof value_sec->irk);
-        value_sec->irk_present = 1;
-    }
+	if (keys->irk_valid) {
+		memcpy(value_sec->irk, keys->irk, sizeof value_sec->irk);
+		value_sec->irk_present = 1;
+	}
 
-    if (keys->csrk_valid) {
-        memcpy(value_sec->csrk, keys->csrk, sizeof value_sec->csrk);
-        value_sec->csrk_present = 1;
-    }
+	if (keys->csrk_valid) {
+		memcpy(value_sec->csrk, keys->csrk, sizeof value_sec->csrk);
+		value_sec->csrk_present = 1;
+	}
 }
 
-void
-ble_sm_ia_ra(struct ble_sm_proc *proc,
-             uint8_t *out_iat, uint8_t *out_ia,
-             uint8_t *out_rat, uint8_t *out_ra)
+void ble_sm_ia_ra(struct ble_sm_proc *proc, uint8_t *out_iat, uint8_t *out_ia,
+                  uint8_t *out_rat, uint8_t *out_ra)
 {
-    struct ble_hs_conn_addrs addrs;
-    struct ble_hs_conn *conn;
+	struct ble_hs_conn_addrs addrs;
+	struct ble_hs_conn *conn;
 
-    conn = ble_hs_conn_find_assert(proc->conn_handle);
+	conn = ble_hs_conn_find_assert(proc->conn_handle);
 
-    ble_hs_conn_addrs(conn, &addrs);
+	ble_hs_conn_addrs(conn, &addrs);
 
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        *out_iat = addrs.our_ota_addr.type;
-        memcpy(out_ia, addrs.our_ota_addr.val, 6);
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		*out_iat = addrs.our_ota_addr.type;
+		memcpy(out_ia, addrs.our_ota_addr.val, 6);
 
-        *out_rat = addrs.peer_ota_addr.type;
-        memcpy(out_ra, addrs.peer_ota_addr.val, 6);
-    } else {
-        *out_iat = addrs.peer_ota_addr.type;
-        memcpy(out_ia, addrs.peer_ota_addr.val, 6);
+		*out_rat = addrs.peer_ota_addr.type;
+		memcpy(out_ra, addrs.peer_ota_addr.val, 6);
+	}
+	else {
+		*out_iat = addrs.peer_ota_addr.type;
+		memcpy(out_ia, addrs.peer_ota_addr.val, 6);
 
-        *out_rat = addrs.our_ota_addr.type;
-        memcpy(out_ra, addrs.our_ota_addr.val, 6);
-    }
+		*out_rat = addrs.our_ota_addr.type;
+		memcpy(out_ra, addrs.our_ota_addr.val, 6);
+	}
 }
 
-static void
-ble_sm_persist_keys(struct ble_sm_proc *proc)
+static void ble_sm_persist_keys(struct ble_sm_proc *proc)
 {
-    struct ble_store_value_sec value_sec;
-    struct ble_hs_conn *conn;
-    ble_addr_t peer_addr;
-    int authenticated;
-    int identity_ev = 0;
-    int sc;
+	struct ble_store_value_sec value_sec;
+	struct ble_hs_conn *conn;
+	ble_addr_t peer_addr;
+	int authenticated;
+	int identity_ev = 0;
+	int sc;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    conn = ble_hs_conn_find(proc->conn_handle);
-    BLE_HS_DBG_ASSERT(conn != NULL);
+	conn = ble_hs_conn_find(proc->conn_handle);
+	BLE_HS_DBG_ASSERT(conn != NULL);
 
-    /* If we got an identity address, use that for key storage. */
-    if (proc->peer_keys.addr_valid) {
-        peer_addr.type = proc->peer_keys.addr_type;
-        memcpy(peer_addr.val, proc->peer_keys.addr, sizeof peer_addr.val);
+	/* If we got an identity address, use that for key storage. */
+	if (proc->peer_keys.addr_valid) {
+		peer_addr.type = proc->peer_keys.addr_type;
+		memcpy(peer_addr.val, proc->peer_keys.addr, sizeof peer_addr.val);
 
-        conn->bhc_peer_addr = peer_addr;
+		conn->bhc_peer_addr = peer_addr;
 
-        /* Update identity address in conn.
-         * If peer's rpa address is set then it means that the peer's address
-         * is an identity address. The peer's address type has to be
-         * set as 'ID' to allow resolve 'id' and 'ota' addresses properly in
-         * conn info.
-         */
-        if (memcmp(BLE_ADDR_ANY->val, &conn->bhc_peer_rpa_addr.val, 6) != 0) {
-            switch (peer_addr.type) {
-            case BLE_ADDR_PUBLIC:
-            case BLE_ADDR_PUBLIC_ID:
-                conn->bhc_peer_addr.type = BLE_ADDR_PUBLIC_ID;
-                break;
+		/* Update identity address in conn.
+		 * If peer's rpa address is set then it means that the peer's address
+		 * is an identity address. The peer's address type has to be
+		 * set as 'ID' to allow resolve 'id' and 'ota' addresses properly in
+		 * conn info.
+		 */
+		if (memcmp(BLE_ADDR_ANY->val, &conn->bhc_peer_rpa_addr.val, 6) != 0) {
+			switch (peer_addr.type) {
+			case BLE_ADDR_PUBLIC:
+			case BLE_ADDR_PUBLIC_ID:
+				conn->bhc_peer_addr.type = BLE_ADDR_PUBLIC_ID;
+				break;
 
-            case BLE_ADDR_RANDOM:
-            case BLE_ADDR_RANDOM_ID:
-                conn->bhc_peer_addr.type = BLE_ADDR_RANDOM_ID;
-                break;
-            }
+			case BLE_ADDR_RANDOM:
+			case BLE_ADDR_RANDOM_ID:
+				conn->bhc_peer_addr.type = BLE_ADDR_RANDOM_ID;
+				break;
+			}
 
-            identity_ev = 1;
-        }
-    } else {
-        peer_addr = conn->bhc_peer_addr;
-        peer_addr.type =
-            ble_hs_misc_peer_addr_type_to_id(conn->bhc_peer_addr.type);
-    }
+			identity_ev = 1;
+		}
+	}
+	else {
+		peer_addr = conn->bhc_peer_addr;
+		peer_addr.type = ble_hs_misc_peer_addr_type_to_id(conn->bhc_peer_addr.type);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (identity_ev) {
-        /* Use peer_addr since it does have proper addr type (i.e. 0/1, not 2/3) */
-        ble_gap_identity_event(proc->conn_handle, &peer_addr);
-    }
+	if (identity_ev) {
+		/* Use peer_addr since it does have proper addr type (i.e. 0/1, not 2/3) */
+		ble_gap_identity_event(proc->conn_handle, &peer_addr);
+	}
 
-    authenticated = proc->flags & BLE_SM_PROC_F_AUTHENTICATED;
-    sc = proc->flags & BLE_SM_PROC_F_SC;
+	authenticated = proc->flags & BLE_SM_PROC_F_AUTHENTICATED;
+	sc = proc->flags & BLE_SM_PROC_F_SC;
 
-    ble_sm_fill_store_value(&peer_addr, authenticated, sc, &proc->our_keys,
-                            &value_sec);
-    ble_store_write_our_sec(&value_sec);
+	ble_sm_fill_store_value(&peer_addr, authenticated, sc, &proc->our_keys, &value_sec);
+	ble_store_write_our_sec(&value_sec);
 
-    ble_sm_fill_store_value(&peer_addr, authenticated, sc, &proc->peer_keys,
-                            &value_sec);
-    ble_store_write_peer_sec(&value_sec);
+	ble_sm_fill_store_value(&peer_addr, authenticated, sc, &proc->peer_keys, &value_sec);
+	ble_store_write_peer_sec(&value_sec);
 }
 
-static int
-ble_sm_proc_matches(struct ble_sm_proc *proc, uint16_t conn_handle,
-                    uint8_t state, int is_initiator)
+static int ble_sm_proc_matches(struct ble_sm_proc *proc, uint16_t conn_handle,
+                               uint8_t state, int is_initiator)
 {
-    int proc_is_initiator;
+	int proc_is_initiator;
 
-    if (conn_handle != proc->conn_handle) {
-        return 0;
-    }
+	if (conn_handle != proc->conn_handle) {
+		return 0;
+	}
 
-    if (state != BLE_SM_PROC_STATE_NONE && state != proc->state) {
-        return 0;
-    }
+	if (state != BLE_SM_PROC_STATE_NONE && state != proc->state) {
+		return 0;
+	}
 
-    proc_is_initiator = !!(proc->flags & BLE_SM_PROC_F_INITIATOR);
-    if (is_initiator != -1 && is_initiator != proc_is_initiator) {
-        return 0;
-    }
+	proc_is_initiator = !!(proc->flags & BLE_SM_PROC_F_INITIATOR);
+	if (is_initiator != -1 && is_initiator != proc_is_initiator) {
+		return 0;
+	}
 
-    return 1;
+	return 1;
 }
 
 /**
@@ -627,224 +592,226 @@ ble_sm_proc_matches(struct ble_sm_proc *proc, uint16_t conn_handle,
  * @return                      The matching proc entry on success;
  *                                  null on failure.
  */
-struct ble_sm_proc *
-ble_sm_proc_find(uint16_t conn_handle, uint8_t state, int is_initiator,
-                 struct ble_sm_proc **out_prev)
+struct ble_sm_proc *ble_sm_proc_find(uint16_t conn_handle, uint8_t state,
+                                     int is_initiator, struct ble_sm_proc **out_prev)
 {
-    struct ble_sm_proc *proc;
-    struct ble_sm_proc *prev;
+	struct ble_sm_proc *proc;
+	struct ble_sm_proc *prev;
 
-    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
+	BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
-    prev = NULL;
-    STAILQ_FOREACH(proc, &ble_sm_procs, next) {
-        if (ble_sm_proc_matches(proc, conn_handle, state, is_initiator)) {
-            if (out_prev != NULL) {
-                *out_prev = prev;
-            }
-            break;
-        }
+	prev = NULL;
+	STAILQ_FOREACH(proc, &ble_sm_procs, next)
+	{
+		if (ble_sm_proc_matches(proc, conn_handle, state, is_initiator)) {
+			if (out_prev != NULL) {
+				*out_prev = prev;
+			}
+			break;
+		}
 
-        prev = proc;
-    }
+		prev = proc;
+	}
 
-    return proc;
+	return proc;
 }
 
-static void
-ble_sm_insert(struct ble_sm_proc *proc)
+static void ble_sm_insert(struct ble_sm_proc *proc)
 {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    struct ble_sm_proc *cur;
+	struct ble_sm_proc *cur;
 
-    STAILQ_FOREACH(cur, &ble_sm_procs, next) {
-        BLE_HS_DBG_ASSERT(cur != proc);
-    }
+	STAILQ_FOREACH(cur, &ble_sm_procs, next)
+	{
+		BLE_HS_DBG_ASSERT(cur != proc);
+	}
 #endif
 
-    STAILQ_INSERT_HEAD(&ble_sm_procs, proc, next);
+	STAILQ_INSERT_HEAD(&ble_sm_procs, proc, next);
 }
 
-static int32_t
-ble_sm_extract_expired(struct ble_sm_proc_list *dst_list)
+static int32_t ble_sm_extract_expired(struct ble_sm_proc_list *dst_list)
 {
-    struct ble_sm_proc *proc;
-    struct ble_sm_proc *prev;
-    struct ble_sm_proc *next;
-    ble_npl_time_t now;
-    ble_npl_stime_t next_exp_in;
-    ble_npl_stime_t time_diff;
+	struct ble_sm_proc *proc;
+	struct ble_sm_proc *prev;
+	struct ble_sm_proc *next;
+	ble_npl_time_t now;
+	ble_npl_stime_t next_exp_in;
+	ble_npl_stime_t time_diff;
 
-    now = ble_npl_time_get();
-    STAILQ_INIT(dst_list);
+	now = ble_npl_time_get();
+	STAILQ_INIT(dst_list);
 
-    /* Assume each event is either expired or has infinite duration. */
-    next_exp_in = BLE_HS_FOREVER;
+	/* Assume each event is either expired or has infinite duration. */
+	next_exp_in = BLE_HS_FOREVER;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    prev = NULL;
-    proc = STAILQ_FIRST(&ble_sm_procs);
-    while (proc != NULL) {
-        next = STAILQ_NEXT(proc, next);
+	prev = NULL;
+	proc = STAILQ_FIRST(&ble_sm_procs);
+	while (proc != NULL) {
+		next = STAILQ_NEXT(proc, next);
 
-        time_diff = proc->exp_os_ticks - now;
-        if (time_diff <= 0) {
-            /* Procedure has expired; move it to the destination list. */
-            if (prev == NULL) {
-                STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
-            } else {
-                STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
-            }
-            STAILQ_INSERT_HEAD(dst_list, proc, next);
-        } else {
-            if (time_diff < next_exp_in) {
-                next_exp_in = time_diff;
-            }
-        }
+		time_diff = proc->exp_os_ticks - now;
+		if (time_diff <= 0) {
+			/* Procedure has expired; move it to the destination list. */
+			if (prev == NULL) {
+				STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
+			}
+			else {
+				STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
+			}
+			STAILQ_INSERT_HEAD(dst_list, proc, next);
+		}
+		else {
+			if (time_diff < next_exp_in) {
+				next_exp_in = time_diff;
+			}
+		}
 
-        prev = proc;
-        proc = next;
-    }
+		prev = proc;
+		proc = next;
+	}
 
-    ble_sm_dbg_assert_no_cycles();
+	ble_sm_dbg_assert_no_cycles();
 
-    ble_hs_unlock();
+	ble_hs_unlock();
+
+	return next_exp_in;
+}
 
-    return next_exp_in;
+static void ble_sm_rx_noop(uint16_t conn_handle, struct os_mbuf **om,
+                           struct ble_sm_result *res)
+{
+	res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
+	res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
 }
 
-static void
-ble_sm_rx_noop(uint16_t conn_handle, struct os_mbuf **om,
-               struct ble_sm_result *res)
+static uint8_t ble_sm_build_authreq(void)
 {
-    res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-    res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
+	return ble_hs_cfg.sm_bonding << 0 | ble_hs_cfg.sm_mitm << 2 |
+	       ble_hs_cfg.sm_sc << 3 | ble_hs_cfg.sm_keypress << 4;
 }
 
-static uint8_t
-ble_sm_build_authreq(void)
+static uint8_t ble_sm_build_fake_authreq(void)
 {
-    return ble_hs_cfg.sm_bonding << 0  |
-           ble_hs_cfg.sm_mitm << 2     |
-           ble_hs_cfg.sm_sc << 3       |
-           ble_hs_cfg.sm_keypress << 4;
+#if MYNEWT_VAL(FAKE_AUTHREQ_BOND)
+	return MYNEWT_VAL(FAKE_AUTHREQ_BOND) << 0 | MYNEWT_VAL(FAKE_AUTHREQ_MITM) << 2 |
+	       MYNEWT_VAL(FAKE_AUTHREQ_SC) << 3 | MYNEWT_VAL(FAKE_AUTHREQ_KEYPRESS) << 4;
+#else
+	return ble_sm_build_authreq();
+#endif
 }
 
-static int
-ble_sm_io_action(struct ble_sm_proc *proc, uint8_t *action)
+static int ble_sm_io_action(struct ble_sm_proc *proc, uint8_t *action)
 {
-    if (proc->flags & BLE_SM_PROC_F_SC) {
-        return ble_sm_sc_io_action(proc, action);
-    } else {
-        return ble_sm_lgcy_io_action(proc, action);
-    }
+	if (proc->flags & BLE_SM_PROC_F_SC) {
+		return ble_sm_sc_io_action(proc, action);
+	}
+	else {
+		return ble_sm_lgcy_io_action(proc, action);
+	}
 }
 
-int
-ble_sm_ioact_state(uint8_t action)
+int ble_sm_ioact_state(uint8_t action)
 {
-    switch (action) {
-    case BLE_SM_IOACT_NONE:
-        return BLE_SM_PROC_STATE_NONE;
+	switch (action) {
+	case BLE_SM_IOACT_NONE:
+		return BLE_SM_PROC_STATE_NONE;
 
-    case BLE_SM_IOACT_NUMCMP:
-        return BLE_SM_PROC_STATE_DHKEY_CHECK;
+	case BLE_SM_IOACT_NUMCMP:
+		return BLE_SM_PROC_STATE_DHKEY_CHECK;
 
-    case BLE_SM_IOACT_OOB_SC:
-        return BLE_SM_PROC_STATE_RANDOM;
+	case BLE_SM_IOACT_OOB_SC:
+		return BLE_SM_PROC_STATE_RANDOM;
 
-    case BLE_SM_IOACT_OOB:
-    case BLE_SM_IOACT_INPUT:
-    case BLE_SM_IOACT_DISP:
-        return BLE_SM_PROC_STATE_CONFIRM;
+	case BLE_SM_IOACT_OOB:
+	case BLE_SM_IOACT_INPUT:
+	case BLE_SM_IOACT_DISP:
+		return BLE_SM_PROC_STATE_CONFIRM;
 
-    default:
-        BLE_HS_DBG_ASSERT(0);
-        return BLE_SM_PROC_STATE_NONE;
-    }
+	default:
+		BLE_HS_DBG_ASSERT(0);
+		return BLE_SM_PROC_STATE_NONE;
+	}
 }
 
-int
-ble_sm_proc_can_advance(struct ble_sm_proc *proc)
+int ble_sm_proc_can_advance(struct ble_sm_proc *proc)
 {
-    uint8_t ioact;
-    int rc;
+	uint8_t ioact;
+	int rc;
 
-    rc = ble_sm_io_action(proc, &ioact);
-    if (rc != 0) {
-        BLE_HS_DBG_ASSERT(0);
-    }
+	rc = ble_sm_io_action(proc, &ioact);
+	if (rc != 0) {
+		BLE_HS_DBG_ASSERT(0);
+	}
 
-    if (ble_sm_ioact_state(ioact) != proc->state) {
-        return 1;
-    }
+	if (ble_sm_ioact_state(ioact) != proc->state) {
+		return 1;
+	}
 
-    if (proc->flags & BLE_SM_PROC_F_IO_INJECTED &&
-        proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO) {
+	if (proc->flags & BLE_SM_PROC_F_IO_INJECTED &&
+	    proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO) {
+		return 1;
+	}
 
-        return 1;
-    }
-
-    return 0;
+	return 0;
 }
 
-static void
-ble_sm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res, void *arg)
+static void ble_sm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res, void *arg)
 {
-    ble_sm_state_fn *cb;
+	ble_sm_state_fn *cb;
 
-    memset(res, 0, sizeof *res);
+	memset(res, 0, sizeof *res);
 
-    if (!ble_hs_conn_exists(proc->conn_handle)) {
-        res->app_status = BLE_HS_ENOTCONN;
-    } else {
-        BLE_HS_DBG_ASSERT(proc->state < BLE_SM_PROC_STATE_CNT);
-        cb = ble_sm_state_dispatch[proc->state];
-        BLE_HS_DBG_ASSERT(cb != NULL);
-        cb(proc, res, arg);
-    }
+	if (!ble_hs_conn_exists(proc->conn_handle)) {
+		res->app_status = BLE_HS_ENOTCONN;
+	}
+	else {
+		BLE_HS_DBG_ASSERT(proc->state < BLE_SM_PROC_STATE_CNT);
+		cb = ble_sm_state_dispatch[proc->state];
+		BLE_HS_DBG_ASSERT(cb != NULL);
+		cb(proc, res, arg);
+	}
 }
 
-static void
-ble_sm_pair_fail_tx(uint16_t conn_handle, uint8_t reason)
+static void ble_sm_pair_fail_tx(uint16_t conn_handle, uint8_t reason)
 {
-    struct ble_sm_pair_fail *cmd;
-    struct os_mbuf *txom;
-    int rc;
+	struct ble_sm_pair_fail *cmd;
+	struct os_mbuf *txom;
+	int rc;
 
-    BLE_HS_DBG_ASSERT(reason > 0 && reason < BLE_SM_ERR_MAX_PLUS_1);
+	BLE_HS_DBG_ASSERT(reason > 0 && reason < BLE_SM_ERR_MAX_PLUS_1);
 
-    cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_FAIL, sizeof(*cmd), &txom);
-    if (cmd) {
-        cmd->reason = reason;
-        rc = ble_sm_tx(conn_handle, txom);
-        if (rc) {
-            BLE_HS_LOG(ERROR, "ble_sm_pair_fail_tx failed, rc = %d\n", rc);
-        }
-    }
+	cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_FAIL, sizeof(*cmd), &txom);
+	if (cmd) {
+		cmd->reason = reason;
+		rc = ble_sm_tx(conn_handle, txom);
+		if (rc) {
+			BLE_HS_LOG(ERROR, "ble_sm_pair_fail_tx failed, rc = %d\n", rc);
+		}
+	}
 }
 
 /**
  * Reads a bond from storage.
  */
-static int
-ble_sm_read_bond(uint16_t conn_handle, struct ble_store_value_sec *out_bond)
+static int ble_sm_read_bond(uint16_t conn_handle, struct ble_store_value_sec *out_bond)
 {
-    struct ble_store_key_sec key_sec;
-    struct ble_gap_conn_desc desc;
-    int rc;
+	struct ble_store_key_sec key_sec;
+	struct ble_gap_conn_desc desc;
+	int rc;
 
-    rc = ble_gap_conn_find(conn_handle, &desc);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_gap_conn_find(conn_handle, &desc);
+	if (rc != 0) {
+		return rc;
+	}
 
-    memset(&key_sec, 0, sizeof key_sec);
-    key_sec.peer_addr = desc.peer_id_addr;
+	memset(&key_sec, 0, sizeof key_sec);
+	key_sec.peer_addr = desc.peer_id_addr;
 
-    rc = ble_store_read_peer_sec(&key_sec, out_bond);
-    return rc;
+	rc = ble_store_read_peer_sec(&key_sec, out_bond);
+	return rc;
 }
 
 /**
@@ -861,1636 +828,1666 @@ ble_sm_read_bond(uint16_t conn_handle, struct ble_store_value_sec *out_bond)
  * @return                      0 if the procedure should continue;
  *                              nonzero if the request should be ignored.
  */
-static int
-ble_sm_chk_repeat_pairing(uint16_t conn_handle,
-                          ble_sm_proc_flags proc_flags,
-                          uint8_t key_size)
-{
-    struct ble_gap_repeat_pairing rp;
-    struct ble_store_value_sec bond;
-    int rc;
-
-    do {
-        /* If the peer isn't bonded, indicate that the pairing procedure should
-         * continue.
-         */
-        rc = ble_sm_read_bond(conn_handle, &bond);
-        switch (rc) {
-        case 0:
-            break;
-        case BLE_HS_ENOENT:
-            return 0;
-        default:
-            return rc;
-        }
-
-        /* Peer is already bonded.  Ask the application what to do about it. */
-        rp.conn_handle = conn_handle;
-        rp.cur_key_size = bond.key_size;
-        rp.cur_authenticated = bond.authenticated;
-        rp.cur_sc = bond.sc;
-
-        rp.new_key_size = key_size;
-        rp.new_authenticated = !!(proc_flags & BLE_SM_PROC_F_AUTHENTICATED);
-        rp.new_sc = !!(proc_flags & BLE_SM_PROC_F_SC);
-        rp.new_bonding = !!(proc_flags & BLE_SM_PROC_F_BONDING);
+static int ble_sm_chk_repeat_pairing(uint16_t conn_handle,
+                                     ble_sm_proc_flags proc_flags, uint8_t key_size)
+{
+	struct ble_gap_repeat_pairing rp;
+	struct ble_store_value_sec bond;
+	int rc;
+
+	do {
+		/* If the peer isn't bonded, indicate that the pairing procedure should
+		 * continue.
+		 */
+		rc = ble_sm_read_bond(conn_handle, &bond);
+		switch (rc) {
+		case 0:
+			break;
+		case BLE_HS_ENOENT:
+			return 0;
+		default:
+			return rc;
+		}
 
-        rc = ble_gap_repeat_pairing_event(&rp);
-    } while (rc == BLE_GAP_REPEAT_PAIRING_RETRY);
+		/* Peer is already bonded.  Ask the application what to do about it. */
+		rp.conn_handle = conn_handle;
+		rp.cur_key_size = bond.key_size;
+		rp.cur_authenticated = bond.authenticated;
+		rp.cur_sc = bond.sc;
 
-    BLE_HS_LOG(DEBUG, "silently ignoring pair request from bonded peer");
+		rp.new_key_size = key_size;
+		rp.new_authenticated = !!(proc_flags & BLE_SM_PROC_F_AUTHENTICATED);
+		rp.new_sc = !!(proc_flags & BLE_SM_PROC_F_SC);
+		rp.new_bonding = !!(proc_flags & BLE_SM_PROC_F_BONDING);
 
-    return BLE_HS_EALREADY;
-}
-
-void
-ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res,
-                      bool tx_fail)
-{
-    struct ble_sm_proc *prev;
-    struct ble_sm_proc *proc;
-    int rm;
+		rc = ble_gap_repeat_pairing_event(&rp);
+	} while (rc == BLE_GAP_REPEAT_PAIRING_RETRY);
 
-    rm = 0;
+	BLE_HS_LOG(DEBUG, "silently ignoring pair request from bonded peer");
 
-    while (1) {
-        ble_hs_lock();
-        proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1,
-                                &prev);
+	return BLE_HS_EALREADY;
+}
+
+void ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res, bool tx_fail)
+{
+	struct ble_sm_proc *prev;
+	struct ble_sm_proc *proc;
+	int rm;
 
-        if (proc != NULL) {
-            if (res->execute) {
-                ble_sm_exec(proc, res, res->state_arg);
-            }
+	rm = 0;
 
-            if (res->app_status != 0) {
-                rm = 1;
-            }
+	while (1) {
+		ble_hs_lock();
+		proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, &prev);
 
-            if (proc->state == BLE_SM_PROC_STATE_NONE) {
-                rm = 1;
-            }
+		if (proc != NULL) {
+			if (res->execute) {
+				ble_sm_exec(proc, res, res->state_arg);
+			}
 
-            if (rm) {
-                ble_sm_proc_remove(proc, prev);
-            } else {
-                ble_sm_proc_set_timer(proc);
-            }
-        }
+			if (res->app_status != 0) {
+				rm = 1;
+			}
 
-        if (res->sm_err != 0 && tx_fail) {
-            ble_sm_pair_fail_tx(conn_handle, res->sm_err);
-        }
+			if (proc->state == BLE_SM_PROC_STATE_NONE) {
+				rm = 1;
+			}
 
-        ble_hs_unlock();
+			if (rm) {
+				ble_sm_proc_remove(proc, prev);
+			}
+			else {
+				ble_sm_proc_set_timer(proc);
+			}
+		}
 
-        if (res->enc_cb &&
-            res->app_status != BLE_HS_ENOTCONN) {
-            /* Do not send this event on broken connection */
-            ble_gap_pairing_complete_event(conn_handle, res->sm_err);
-        }
+		if (res->sm_err != 0 && tx_fail) {
+			ble_sm_pair_fail_tx(conn_handle, res->sm_err);
+		}
 
-        if (proc == NULL) {
-            break;
-        }
+		ble_hs_unlock();
 
-        if (res->enc_cb) {
-            BLE_HS_DBG_ASSERT(proc == NULL || rm);
-            ble_gap_enc_event(conn_handle, res->app_status, res->restore, res->bonded);
-        }
+		if (res->enc_cb && res->app_status != BLE_HS_ENOTCONN) {
+			/* Do not send this event on broken connection */
+			ble_gap_pairing_complete_event(conn_handle, res->sm_err);
+		}
 
-        if (res->app_status == 0 &&
-            res->passkey_params.action != BLE_SM_IOACT_NONE) {
+		if (proc == NULL) {
+			break;
+		}
 
-            ble_gap_passkey_event(conn_handle, &res->passkey_params);
-        }
+		if (res->enc_cb) {
+			BLE_HS_DBG_ASSERT(proc == NULL || rm);
+			ble_gap_enc_event(conn_handle, res->app_status, res->restore, res->bonded);
+		}
 
-        /* Persist keys if bonding has successfully completed. */
-        if (res->app_status == 0    &&
-            rm                      &&
-            proc->flags & BLE_SM_PROC_F_BONDING) {
+		if (res->app_status == 0 && res->passkey_params.action != BLE_SM_IOACT_NONE) {
+			ble_gap_passkey_event(conn_handle, &res->passkey_params);
+		}
 
-            ble_sm_persist_keys(proc);
-        }
+		/* Persist keys if bonding has successfully completed. */
+		if (res->app_status == 0 && rm && proc->flags & BLE_SM_PROC_F_BONDING) {
+			ble_sm_persist_keys(proc);
+		}
 
-        if (rm) {
-            ble_sm_proc_free(proc);
-            break;
-        }
+		if (rm) {
+			ble_sm_proc_free(proc);
+			break;
+		}
 
-        if (!res->execute) {
-            break;
-        }
+		if (!res->execute) {
+			break;
+		}
 
-        memset(res, 0, sizeof *res);
-        res->execute = 1;
-    }
+		memset(res, 0, sizeof *res);
+		res->execute = 1;
+	}
 }
 
-static void
-ble_sm_key_dist(struct ble_sm_proc *proc,
-                uint8_t *out_init_key_dist, uint8_t *out_resp_key_dist)
+static void ble_sm_key_dist(struct ble_sm_proc *proc, uint8_t *out_init_key_dist,
+                            uint8_t *out_resp_key_dist)
 {
-    struct ble_sm_pair_cmd *pair_rsp;
+	struct ble_sm_pair_cmd *pair_rsp;
 
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+	pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
 
-    *out_init_key_dist = pair_rsp->init_key_dist;
-    *out_resp_key_dist = pair_rsp->resp_key_dist;
+	*out_init_key_dist = pair_rsp->init_key_dist;
+	*out_resp_key_dist = pair_rsp->resp_key_dist;
 
-    /* Encryption info and master ID are only sent in legacy pairing. */
-    if (proc->flags & BLE_SM_PROC_F_SC) {
-        *out_init_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
-        *out_resp_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
-    }
+	/* Encryption info and master ID are only sent in legacy pairing. */
+	if (proc->flags & BLE_SM_PROC_F_SC) {
+		*out_init_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
+		*out_resp_key_dist &= ~BLE_SM_PAIR_KEY_DIST_ENC;
+	}
 }
 
-static int
-ble_sm_chk_store_overflow_by_type(int obj_type, uint16_t conn_handle)
+static int ble_sm_chk_store_overflow_by_type(int obj_type, uint16_t conn_handle)
 {
 #if !MYNEWT_VAL(BLE_SM_BONDING)
-    return 0;
+	return 0;
 #endif
 
-    int count;
-    int rc;
+	int count;
+	int rc;
 
-    rc = ble_store_util_count(obj_type, &count);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_store_util_count(obj_type, &count);
+	if (rc != 0) {
+		return rc;
+	}
 
-    /* Pessimistically assume all active procs will persist bonds. */
-    ble_hs_lock();
-    count += ble_sm_num_procs();
-    ble_hs_unlock();
+	/* Pessimistically assume all active procs will persist bonds. */
+	ble_hs_lock();
+	count += ble_sm_num_procs();
+	ble_hs_unlock();
 
-    if (count < MYNEWT_VAL(BLE_STORE_MAX_BONDS)) {
-        /* There is sufficient capacity for another bond. */
-        return 0;
-    }
+	if (count < MYNEWT_VAL(BLE_STORE_MAX_BONDS)) {
+		/* There is sufficient capacity for another bond. */
+		return 0;
+	}
 
-    /* No capacity for an additional bond.  Tell the application to make
-     * room.
-     */
-    rc = ble_store_full_event(obj_type, conn_handle);
-    if (rc != 0) {
-        return rc;
-    }
+	/* No capacity for an additional bond.  Tell the application to make
+	 * room.
+	 */
+	rc = ble_store_full_event(obj_type, conn_handle);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
-static int
-ble_sm_chk_store_overflow(uint16_t conn_handle)
+static int ble_sm_chk_store_overflow(uint16_t conn_handle)
 {
-    int rc;
+	int rc;
 
-    rc = ble_sm_chk_store_overflow_by_type(BLE_STORE_OBJ_TYPE_PEER_SEC,
-                                           conn_handle);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_chk_store_overflow_by_type(BLE_STORE_OBJ_TYPE_PEER_SEC, conn_handle);
+	if (rc != 0) {
+		return rc;
+	}
 
-    rc = ble_sm_chk_store_overflow_by_type(BLE_STORE_OBJ_TYPE_OUR_SEC,
-                                           conn_handle);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_chk_store_overflow_by_type(BLE_STORE_OBJ_TYPE_OUR_SEC, conn_handle);
+	if (rc != 0) {
+		return rc;
+	}
 
-    return 0;
+	return 0;
 }
 
 /*****************************************************************************
  * $enc                                                                      *
  *****************************************************************************/
 
-static int
-ble_sm_start_encrypt_tx(struct hci_start_encrypt *params)
+static int ble_sm_start_encrypt_tx(struct hci_start_encrypt *params)
 {
-    struct ble_hci_le_start_encrypt_cp cmd;
+	struct ble_hci_le_start_encrypt_cp cmd;
 
-    cmd.conn_handle = htole16(params->connection_handle);
-    cmd.div = htole16(params->encrypted_diversifier);
-    cmd.rand = htole64(params->random_number);
-    memcpy(cmd.ltk, params->long_term_key, sizeof(cmd.ltk));
+	cmd.conn_handle = htole16(params->connection_handle);
+	cmd.div = htole16(params->encrypted_diversifier);
+	cmd.rand = htole64(params->random_number);
+	memcpy(cmd.ltk, params->long_term_key, sizeof(cmd.ltk));
+
+	return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_START_ENCRYPT),
+	                         &cmd, sizeof(cmd), NULL, 0);
+}
+
+static void ble_sm_enc_start_exec(struct ble_sm_proc *proc,
+                                  struct ble_sm_result *res, void *arg)
+{
+	struct hci_start_encrypt cmd;
+	int rc;
+
+	BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
+
+	cmd.connection_handle = proc->conn_handle;
+	cmd.encrypted_diversifier = 0;
+	cmd.random_number = 0;
+	memcpy(cmd.long_term_key, proc->ltk, sizeof cmd.long_term_key);
+
+	rc = ble_sm_start_encrypt_tx(&cmd);
+	if (rc != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->app_status = rc;
+		res->enc_cb = 1;
+	}
+}
+
+static void ble_sm_enc_restore_exec(struct ble_sm_proc *proc,
+                                    struct ble_sm_result *res, void *arg)
+{
+	struct hci_start_encrypt *cmd;
+
+	BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
+
+	cmd = arg;
+	BLE_HS_DBG_ASSERT(cmd != NULL);
+
+	res->app_status = ble_sm_start_encrypt_tx(cmd);
+}
+
+static void ble_sm_enc_event_rx(uint16_t conn_handle, uint8_t evt_status, int encrypted)
+{
+	struct ble_store_value_sec bond;
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	int authenticated;
+	int bonded;
+	int key_size;
+
+	memset(&res, 0, sizeof res);
+
+	/* Assume no change in authenticated and bonded statuses. */
+	authenticated = 0;
+	bonded = 0;
+	key_size = 0;
+
+	ble_hs_lock();
+
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	if (proc != NULL) {
+		switch (proc->state) {
+		case BLE_SM_PROC_STATE_ENC_START:
+			/* We are completing a pairing procedure; keys may need to be
+			 * exchanged.
+			 */
+			if (evt_status == 0) {
+				/* If the responder has any keys to send, it sends them
+				 * first.
+				 */
+				proc->state = BLE_SM_PROC_STATE_KEY_EXCH;
+				if (!(proc->flags & BLE_SM_PROC_F_INITIATOR) || proc->rx_key_flags == 0) {
+					res.execute = 1;
+				}
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_START_ENCRYPT),
-                             &cmd, sizeof(cmd), NULL, 0);
-}
-
-static void
-ble_sm_enc_start_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                      void *arg)
-{
-    struct hci_start_encrypt cmd;
-    int rc;
-
-    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
-
-    cmd.connection_handle = proc->conn_handle;
-    cmd.encrypted_diversifier = 0;
-    cmd.random_number = 0;
-    memcpy(cmd.long_term_key, proc->ltk, sizeof cmd.long_term_key);
-
-    rc = ble_sm_start_encrypt_tx(&cmd);
-    if (rc != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->app_status = rc;
-        res->enc_cb = 1;
-    }
-}
-
-static void
-ble_sm_enc_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                        void *arg)
-{
-    struct hci_start_encrypt *cmd;
-
-    BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
-
-    cmd = arg;
-    BLE_HS_DBG_ASSERT(cmd != NULL);
-
-    res->app_status = ble_sm_start_encrypt_tx(cmd);
-}
-
-static void
-ble_sm_enc_event_rx(uint16_t conn_handle, uint8_t evt_status, int encrypted)
-{
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    int authenticated;
-    int bonded;
-    int key_size;
-
-    memset(&res, 0, sizeof res);
-
-    /* Assume no change in authenticated and bonded statuses. */
-    authenticated = 0;
-    bonded = 0;
-    key_size = 0;
-
-    ble_hs_lock();
-
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    if (proc != NULL) {
-        switch (proc->state) {
-        case BLE_SM_PROC_STATE_ENC_START:
-            /* We are completing a pairing procedure; keys may need to be
-             * exchanged.
-             */
-            if (evt_status == 0) {
-                /* If the responder has any keys to send, it sends them
-                 * first.
-                 */
-                proc->state = BLE_SM_PROC_STATE_KEY_EXCH;
-                if (!(proc->flags & BLE_SM_PROC_F_INITIATOR) ||
-                    proc->rx_key_flags == 0) {
-
-                    res.execute = 1;
-                }
-
-                key_size = proc->key_size;
-            } else {
-                /* Failure or no keys to exchange; procedure is complete. */
-                proc->state = BLE_SM_PROC_STATE_NONE;
-            }
-            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
-                authenticated = 1;
-            }
-            break;
-
-        case BLE_SM_PROC_STATE_ENC_RESTORE:
-            /* A secure link is being restored via the encryption
-             * procedure.  Keys were exchanged during pairing; they don't
-             * get exchanged again now.  Procedure is complete.
-             */
-            BLE_HS_DBG_ASSERT(proc->rx_key_flags == 0);
-            proc->state = BLE_SM_PROC_STATE_NONE;
-            if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
-                authenticated = 1;
-            }
-            bonded = 1;
-            res.restore = 1;
-
-            key_size = proc->key_size;
-            break;
-
-        default:
-            /* The encryption change event is unexpected.  We take the
-             * controller at its word that the state has changed and we
-             * terminate the procedure.
-             */
-            proc->state = BLE_SM_PROC_STATE_NONE;
-            res.sm_err = BLE_SM_ERR_UNSPECIFIED;
-            break;
-        }
-    }
-
-    if (evt_status == 0) {
-        /* Set the encrypted state of the connection as indicated in the
-         * event.
-         */
-        ble_sm_update_sec_state(conn_handle, encrypted, authenticated, bonded,
-                                key_size);
-    }
-
-    /* Unless keys need to be exchanged, notify the application of the security
-     * change.  If key exchange is pending, the application callback is
-     * triggered after exchange completes.
-     */
-    if (proc == NULL || proc->state == BLE_SM_PROC_STATE_NONE) {
-        res.enc_cb = 1;
-        res.app_status = BLE_HS_HCI_ERR(evt_status);
-    }
-
-    ble_hs_unlock();
-
-    res.bonded = bonded;
-    ble_sm_process_result(conn_handle, &res, true);
-}
-
-void
-ble_sm_enc_change_rx(const struct ble_hci_ev_enrypt_chg *ev)
-{
-    /* For encrypted state: read LE-encryption bit; ignore BR/EDR and reserved
-     * bits.
-     */
-    ble_sm_enc_event_rx(le16toh(ev->connection_handle), ev->status,
-                        ev->enabled & 0x01);
-}
-
-void
-ble_sm_enc_key_refresh_rx(const struct ble_hci_ev_enc_key_refresh *ev)
-{
-    ble_sm_enc_event_rx(le16toh(ev->conn_handle), ev->status, 1);
+				key_size = proc->key_size;
+			}
+			else {
+				/* Failure or no keys to exchange; procedure is complete. */
+				proc->state = BLE_SM_PROC_STATE_NONE;
+			}
+			if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
+				authenticated = 1;
+			}
+			break;
+
+		case BLE_SM_PROC_STATE_ENC_RESTORE:
+			/* A secure link is being restored via the encryption
+			 * procedure.  Keys were exchanged during pairing; they don't
+			 * get exchanged again now.  Procedure is complete.
+			 */
+
+			if (evt_status != 0) {
+				if (ble_sm_read_bond(conn_handle, &bond)) {
+					if (bond.ltk_present) {
+						// We update the rejected pair flag
+						bond.rep = 0;
+						ble_store_write_peer_sec(&bond);
+					}
+				}
+			}
+			BLE_HS_DBG_ASSERT(proc->rx_key_flags == 0);
+			proc->state = BLE_SM_PROC_STATE_NONE;
+			if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
+				authenticated = 1;
+			}
+			bonded = 1;
+			res.restore = 1;
+
+			key_size = proc->key_size;
+
+			break;
+
+		default:
+			/* The encryption change event is unexpected.  We take the
+			 * controller at its word that the state has changed and we
+			 * terminate the procedure.
+			 */
+			proc->state = BLE_SM_PROC_STATE_NONE;
+			res.sm_err = BLE_SM_ERR_UNSPECIFIED;
+			break;
+		}
+	}
+
+	if (evt_status == 0) {
+		/* Set the encrypted state of the connection as indicated in the
+		 * event.
+		 */
+		ble_sm_update_sec_state(conn_handle, encrypted, authenticated, bonded, key_size);
+	}
+	// TODO: here if the encryption is off we patch it
+
+	/* Unless keys need to be exchanged, notify the application of the security
+	 * change.  If key exchange is pending, the application callback is
+	 * triggered after exchange completes.
+	 */
+	if (proc == NULL || proc->state == BLE_SM_PROC_STATE_NONE) {
+		res.enc_cb = 1;
+		res.app_status = BLE_HS_HCI_ERR(evt_status);
+	}
+
+	ble_hs_unlock();
+
+	res.bonded = bonded;
+	ble_sm_process_result(conn_handle, &res, true);
+}
+
+void ble_sm_enc_change_rx(const struct ble_hci_ev_enrypt_chg *ev)
+{
+	/* For encrypted state: read LE-encryption bit; ignore BR/EDR and reserved
+	 * bits.
+	 */
+	ble_sm_enc_event_rx(le16toh(ev->connection_handle), ev->status, ev->enabled & 0x01);
+}
+
+void ble_sm_enc_key_refresh_rx(const struct ble_hci_ev_enc_key_refresh *ev)
+{
+	ble_sm_enc_event_rx(le16toh(ev->conn_handle), ev->status, 1);
 }
 
 /*****************************************************************************
  * $ltk                                                                      *
  *****************************************************************************/
 
-static int
-ble_sm_retrieve_ltk(uint16_t ediv, uint64_t rand, uint8_t peer_addr_type,
-                    uint8_t *peer_addr, struct ble_store_value_sec *value_sec)
+static int ble_sm_retrieve_ltk(uint16_t ediv, uint64_t rand, uint8_t peer_addr_type,
+                               uint8_t *peer_addr, struct ble_store_value_sec *value_sec)
 {
-    struct ble_store_key_sec key_sec;
-    int rc;
+	struct ble_store_key_sec key_sec;
+	int rc;
 
-    /* Tell application to look up LTK by peer address and ediv/rand pair. */
-    memset(&key_sec, 0, sizeof key_sec);
-    key_sec.peer_addr.type = peer_addr_type;
-    memcpy(key_sec.peer_addr.val, peer_addr, 6);
+	/* Tell application to look up LTK by peer address and ediv/rand pair. */
+	memset(&key_sec, 0, sizeof key_sec);
+	key_sec.peer_addr.type = peer_addr_type;
+	memcpy(key_sec.peer_addr.val, peer_addr, 6);
 
-    rc = ble_store_read_our_sec(&key_sec, value_sec);
-    if (value_sec->ediv != ediv || value_sec->rand_num != rand) {
-        return BLE_HS_ENOENT;
-    }
-    return rc;
+	rc = ble_store_read_our_sec(&key_sec, value_sec);
+	if (value_sec->ediv != ediv || value_sec->rand_num != rand) {
+		return BLE_HS_ENOENT;
+	}
+	return rc;
 }
 
-static int
-ble_sm_ltk_req_reply_tx(uint16_t conn_handle, const uint8_t *ltk)
+static int ble_sm_ltk_req_reply_tx(uint16_t conn_handle, const uint8_t *ltk)
 {
-    struct ble_hci_le_lt_key_req_reply_cp cmd;
-    struct ble_hci_le_lt_key_req_reply_rp rsp;
-    int rc;
+	struct ble_hci_le_lt_key_req_reply_cp cmd;
+	struct ble_hci_le_lt_key_req_reply_rp rsp;
+	int rc;
 
-    cmd.conn_handle = htole16(conn_handle);
-    memcpy(cmd.ltk, ltk, 16);
+	cmd.conn_handle = htole16(conn_handle);
+	memcpy(cmd.ltk, ltk, 16);
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY),
+	                       &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+	if (rc != 0) {
+		return rc;
+	}
 
-    if (le16toh(rsp.conn_handle) != conn_handle) {
-        return BLE_HS_ECONTROLLER;
-    }
+	if (le16toh(rsp.conn_handle) != conn_handle) {
+		return BLE_HS_ECONTROLLER;
+	}
 
-    return 0;
+	return 0;
 }
-
-static int
-ble_sm_ltk_req_neg_reply_tx(uint16_t conn_handle)
-{
-    struct ble_hci_le_lt_key_req_neg_reply_cp cmd;
-    struct ble_hci_le_lt_key_req_neg_reply_cp rsp;
-    int rc;
-
-    cmd.conn_handle = htole16(conn_handle);
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
-    if (rc != 0) {
-        return rc;
-    }
-
-    if (le16toh(rsp.conn_handle) != conn_handle) {
-        return BLE_HS_ECONTROLLER;
-    }
-
-    return 0;
-}
-
-static void
-ble_sm_ltk_start_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                      void *arg)
-{
-    BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
-
-    res->app_status = ble_sm_ltk_req_reply_tx(proc->conn_handle, proc->ltk);
-    if (res->app_status == 0) {
-        proc->state = BLE_SM_PROC_STATE_ENC_START;
-    } else {
-        res->enc_cb = 1;
-    }
-}
-
-static void
-ble_sm_ltk_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                        void *arg)
-{
-    struct ble_store_value_sec *value_sec;
-
-    BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
-
-    value_sec = arg;
-
-    if (value_sec != NULL) {
-        /* Store provided a key; send it to the controller. */
-        res->app_status = ble_sm_ltk_req_reply_tx(
-            proc->conn_handle, value_sec->ltk);
-
-        if (res->app_status == 0) {
-            proc->key_size = value_sec->key_size;
-            if (value_sec->authenticated) {
-                proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
-            }
-        } else {
-            /* Notify the app if it provided a key and the procedure failed. */
-            res->enc_cb = 1;
-        }
-    } else {
-        /* Application does not have the requested key in its database.  Send a
-         * negative reply to the controller.
-         */
-        ble_sm_ltk_req_neg_reply_tx(proc->conn_handle);
-        res->app_status = BLE_HS_ENOENT;
-    }
-
-    if (res->app_status == 0) {
-        proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
-    }
-}
-
-int
-ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req *ev)
-{
-    struct ble_store_value_sec value_sec;
-    struct ble_hs_conn_addrs addrs;
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    struct ble_hs_conn *conn;
-    uint8_t peer_id_addr[6];
-    int store_rc;
-    int restore;
-
-    uint16_t conn_handle = le16toh(ev->conn_handle);
-
-    memset(&res, 0, sizeof res);
-
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, 0, NULL);
-    if (proc == NULL) {
-        /* The peer is attempting to restore a encrypted connection via the
-         * encryption procedure.  Create a proc entry to indicate that security
-         * establishment is in progress and execute the procedure after the
-         * mutex gets unlocked.
-         */
-        restore = 1;
-        proc = ble_sm_proc_alloc();
-        if (proc == NULL) {
-            res.app_status = BLE_HS_ENOMEM;
-        } else {
-            proc->conn_handle = conn_handle;
-            proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
-            ble_sm_insert(proc);
-
-            res.execute = 1;
-        }
-    } else if (proc->state == BLE_SM_PROC_STATE_SEC_REQ) {
-        /* Same as above, except we solicited the encryption procedure by
-         * sending a security request.
-         */
-        restore = 1;
-        proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
-        res.execute = 1;
-    } else if (proc->state == BLE_SM_PROC_STATE_LTK_START) {
-        /* Legacy pairing just completed.  Send the short term key to the
-         * controller.
-         */
-        restore = 0;
-        res.execute = 1;
-    } else {
-        /* The request is unexpected; nack and forget. */
-        restore = 0;
-        ble_sm_ltk_req_neg_reply_tx(conn_handle);
-        proc = NULL;
-    }
-
-    if (restore) {
-        conn = ble_hs_conn_find_assert(conn_handle);
-        ble_hs_conn_addrs(conn, &addrs);
-        memcpy(peer_id_addr, addrs.peer_id_addr.val, 6);
-    }
-
-    ble_hs_unlock();
-
-    if (proc == NULL) {
-        return res.app_status;
-    }
-
-    if (res.app_status == 0) {
-        if (restore) {
-            store_rc = ble_sm_retrieve_ltk(le16toh(ev->div), le64toh(ev->rand),
-                                            addrs.peer_id_addr.type,
-                                           peer_id_addr, &value_sec);
-            if (store_rc == 0) {
-                /* Send the key to the controller. */
-                res.state_arg = &value_sec;
-            } else {
-                /* Send a nack to the controller. */
-                res.state_arg = NULL;
-            }
-        }
-    }
-
-    ble_sm_process_result(conn_handle, &res, true);
-
-    return 0;
+
+static int ble_sm_ltk_req_neg_reply_tx(uint16_t conn_handle)
+{
+	struct ble_hci_le_lt_key_req_neg_reply_cp cmd;
+	struct ble_hci_le_lt_key_req_neg_reply_cp rsp;
+	int rc;
+
+	cmd.conn_handle = htole16(conn_handle);
+	rc =
+		ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY),
+	                    &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+	if (rc != 0) {
+		return rc;
+	}
+
+	if (le16toh(rsp.conn_handle) != conn_handle) {
+		return BLE_HS_ECONTROLLER;
+	}
+
+	return 0;
+}
+
+static void ble_sm_ltk_start_exec(struct ble_sm_proc *proc,
+                                  struct ble_sm_result *res, void *arg)
+{
+	BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
+
+	res->app_status = ble_sm_ltk_req_reply_tx(proc->conn_handle, proc->ltk);
+	if (res->app_status == 0) {
+		proc->state = BLE_SM_PROC_STATE_ENC_START;
+	}
+	else {
+		res->enc_cb = 1;
+	}
+}
+
+static void ble_sm_ltk_restore_exec(struct ble_sm_proc *proc,
+                                    struct ble_sm_result *res, void *arg)
+{
+	struct ble_store_value_sec *value_sec;
+
+	BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
+
+	value_sec = arg;
+
+	if (value_sec != NULL) {
+		/* Store provided a key; send it to the controller. */
+		res->app_status = ble_sm_ltk_req_reply_tx(proc->conn_handle, value_sec->ltk);
+
+		if (res->app_status == 0) {
+			proc->key_size = value_sec->key_size;
+			if (value_sec->authenticated) {
+				proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
+			}
+		}
+		else {
+			/* Notify the app if it provided a key and the procedure failed. */
+			res->enc_cb = 1;
+		}
+	}
+	else {
+		/* Application does not have the requested key in its database.  Send a
+		 * negative reply to the controller.
+		 */
+		ble_sm_ltk_req_neg_reply_tx(proc->conn_handle);
+		res->app_status = BLE_HS_ENOENT;
+	}
+
+	if (res->app_status == 0) {
+		proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
+	}
+}
+
+int ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req *ev)
+{
+	struct ble_store_value_sec value_sec;
+	struct ble_hs_conn_addrs addrs;
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	struct ble_hs_conn *conn;
+	uint8_t peer_id_addr[6];
+	int store_rc;
+	int restore;
+
+	uint16_t conn_handle = le16toh(ev->conn_handle);
+
+	memset(&res, 0, sizeof res);
+
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, 0, NULL);
+	if (proc == NULL) {
+		/* The peer is attempting to restore a encrypted connection via the
+		 * encryption procedure.  Create a proc entry to indicate that security
+		 * establishment is in progress and execute the procedure after the
+		 * mutex gets unlocked.
+		 */
+		restore = 1;
+		proc = ble_sm_proc_alloc();
+		if (proc == NULL) {
+			res.app_status = BLE_HS_ENOMEM;
+		}
+		else {
+			proc->conn_handle = conn_handle;
+			proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
+			ble_sm_insert(proc);
+
+			res.execute = 1;
+		}
+	}
+	else if (proc->state == BLE_SM_PROC_STATE_SEC_REQ) {
+		/* Same as above, except we solicited the encryption procedure by
+		 * sending a security request.
+		 */
+		restore = 1;
+		proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
+		res.execute = 1;
+	}
+	else if (proc->state == BLE_SM_PROC_STATE_LTK_START) {
+		/* Legacy pairing just completed.  Send the short term key to the
+		 * controller.
+		 */
+		restore = 0;
+		res.execute = 1;
+	}
+	else {
+		/* The request is unexpected; nack and forget. */
+		restore = 0;
+		ble_sm_ltk_req_neg_reply_tx(conn_handle);
+		proc = NULL;
+	}
+
+	if (restore) {
+		conn = ble_hs_conn_find_assert(conn_handle);
+		ble_hs_conn_addrs(conn, &addrs);
+		memcpy(peer_id_addr, addrs.peer_id_addr.val, 6);
+	}
+
+	ble_hs_unlock();
+
+	if (proc == NULL) {
+		return res.app_status;
+	}
+
+	if (res.app_status == 0) {
+		if (restore) {
+			store_rc = ble_sm_retrieve_ltk(le16toh(ev->div), le64toh(ev->rand),
+			                               addrs.peer_id_addr.type, peer_id_addr, &value_sec);
+			if (store_rc == 0) {
+				/* Send the key to the controller. */
+				res.state_arg = &value_sec;
+			}
+			else {
+				/* Send a nack to the controller. */
+				res.state_arg = NULL;
+			}
+		}
+	}
+
+	ble_sm_process_result(conn_handle, &res, true);
+
+	return 0;
 }
 
 /*****************************************************************************
  * $random                                                                   *
  *****************************************************************************/
 
-uint8_t *
-ble_sm_our_pair_rand(struct ble_sm_proc *proc)
+uint8_t *ble_sm_our_pair_rand(struct ble_sm_proc *proc)
 {
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        return proc->randm;
-    } else {
-        return proc->rands;
-    }
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		return proc->randm;
+	}
+	else {
+		return proc->rands;
+	}
 }
 
-uint8_t *
-ble_sm_peer_pair_rand(struct ble_sm_proc *proc)
+uint8_t *ble_sm_peer_pair_rand(struct ble_sm_proc *proc)
 {
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        return proc->rands;
-    } else {
-        return proc->randm;
-    }
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		return proc->rands;
+	}
+	else {
+		return proc->randm;
+	}
 }
 
-static void
-ble_sm_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                   void *arg)
+static void ble_sm_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                               void *arg)
 {
-    if (proc->flags & BLE_SM_PROC_F_SC) {
-        ble_sm_sc_random_exec(proc, res);
-    } else {
-        ble_sm_lgcy_random_exec(proc, res);
-    }
+	if (proc->flags & BLE_SM_PROC_F_SC) {
+		ble_sm_sc_random_exec(proc, res);
+	}
+	else {
+		ble_sm_lgcy_random_exec(proc, res);
+	}
 }
 
-static void
-ble_sm_random_rx(uint16_t conn_handle, struct os_mbuf **om,
-                 struct ble_sm_result *res)
+static void ble_sm_random_rx(uint16_t conn_handle, struct os_mbuf **om,
+                             struct ble_sm_result *res)
 {
-    struct ble_sm_pair_random *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_pair_random *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_pair_random *)(*om)->om_data;
+	cmd = (struct ble_sm_pair_random *) (*om)->om_data;
 
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_RANDOM, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-    } else {
-        memcpy(ble_sm_peer_pair_rand(proc), cmd->value, 16);
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_RANDOM, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+	}
+	else {
+		memcpy(ble_sm_peer_pair_rand(proc), cmd->value, 16);
 
-        if (proc->flags & BLE_SM_PROC_F_SC) {
-            ble_sm_sc_random_rx(proc, res);
-        } else {
-            ble_sm_lgcy_random_rx(proc, res);
-        }
-    }
-    ble_hs_unlock();
+		if (proc->flags & BLE_SM_PROC_F_SC) {
+			ble_sm_sc_random_rx(proc, res);
+		}
+		else {
+			ble_sm_lgcy_random_rx(proc, res);
+		}
+	}
+	ble_hs_unlock();
 }
 
 /*****************************************************************************
  * $confirm                                                                  *
  *****************************************************************************/
 
-static void
-ble_sm_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                    void *arg)
-{
-    if (!(proc->flags & BLE_SM_PROC_F_SC)) {
-        ble_sm_lgcy_confirm_exec(proc, res);
-    } else {
-        ble_sm_sc_confirm_exec(proc, res);
-    }
-}
-
-static void
-ble_sm_confirm_rx(uint16_t conn_handle, struct os_mbuf **om,
-                  struct ble_sm_result *res)
-{
-    struct ble_sm_pair_confirm *cmd;
-    struct ble_sm_proc *proc;
-    uint8_t ioact;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
-
-    cmd = (struct ble_sm_pair_confirm *)(*om)->om_data;
-
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_CONFIRM, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-    } else {
-        memcpy(proc->confirm_peer, cmd->value, 16);
-
-        if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-            proc->state = BLE_SM_PROC_STATE_RANDOM;
-            res->execute = 1;
-        } else {
-            int rc;
-
-            rc = ble_sm_io_action(proc, &ioact);
-            if (rc != 0) {
-                BLE_HS_DBG_ASSERT(0);
-            }
-
-            if (ble_sm_ioact_state(ioact) == proc->state) {
-                proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
-            }
-            if (ble_sm_proc_can_advance(proc)) {
-                res->execute = 1;
-            }
-        }
-    }
-    ble_hs_unlock();
+static void ble_sm_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                                void *arg)
+{
+	if (!(proc->flags & BLE_SM_PROC_F_SC)) {
+		ble_sm_lgcy_confirm_exec(proc, res);
+	}
+	else {
+		ble_sm_sc_confirm_exec(proc, res);
+	}
+}
+
+static void ble_sm_confirm_rx(uint16_t conn_handle, struct os_mbuf **om,
+                              struct ble_sm_result *res)
+{
+	struct ble_sm_pair_confirm *cmd;
+	struct ble_sm_proc *proc;
+	uint8_t ioact;
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
+
+	cmd = (struct ble_sm_pair_confirm *) (*om)->om_data;
+
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_CONFIRM, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+	}
+	else {
+		memcpy(proc->confirm_peer, cmd->value, 16);
+
+		if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+			proc->state = BLE_SM_PROC_STATE_RANDOM;
+			res->execute = 1;
+		}
+		else {
+			int rc;
+
+			rc = ble_sm_io_action(proc, &ioact);
+			if (rc != 0) {
+				BLE_HS_DBG_ASSERT(0);
+			}
+
+			if (ble_sm_ioact_state(ioact) == proc->state) {
+				proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
+			}
+			if (ble_sm_proc_can_advance(proc)) {
+				res->execute = 1;
+			}
+		}
+	}
+	ble_hs_unlock();
 }
 
 /*****************************************************************************
  * $pair                                                                     *
  *****************************************************************************/
 
-static uint8_t
-ble_sm_state_after_pair(struct ble_sm_proc *proc)
-{
-    if (proc->flags & BLE_SM_PROC_F_SC) {
-        return BLE_SM_PROC_STATE_PUBLIC_KEY;
-    } else {
-        return BLE_SM_PROC_STATE_CONFIRM;
-    }
-}
-
-static void
-ble_sm_pair_cfg(struct ble_sm_proc *proc)
-{
-    struct ble_sm_pair_cmd *pair_req, *pair_rsp;
-    uint8_t init_key_dist;
-    uint8_t resp_key_dist;
-    uint8_t rx_key_dist;
-    uint8_t ioact;
-    int rc;
-
-    pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
-
-    if (pair_req->authreq & BLE_SM_PAIR_AUTHREQ_SC &&
-        pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_SC) {
-
-        proc->flags |= BLE_SM_PROC_F_SC;
-    }
-
-    ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        rx_key_dist = resp_key_dist;
-    } else {
-        rx_key_dist = init_key_dist;
-    }
-
-    if (pair_req->authreq & BLE_SM_PAIR_AUTHREQ_BOND &&
-        pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
-
-        proc->flags |= BLE_SM_PROC_F_BONDING;
-    }
-
-    /* In legacy mode, bonding requires the exchange of keys
-     * at least from one side.  If no key exchange was specified,
-     * pretend bonding is not enabled.
-     */
-    if (!(proc->flags & BLE_SM_PROC_F_SC) &&
-        (init_key_dist == 0 && resp_key_dist == 0)) {
-
-        proc->flags &= ~BLE_SM_PROC_F_BONDING;
-    }
-
-    proc->rx_key_flags = 0;
-    if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
-        proc->rx_key_flags |= BLE_SM_KE_F_ENC_INFO |
-                              BLE_SM_KE_F_MASTER_ID;
-    }
-    if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
-        proc->rx_key_flags |= BLE_SM_KE_F_ID_INFO |
-                              BLE_SM_KE_F_ADDR_INFO;
-    }
-    if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
-        proc->rx_key_flags |= BLE_SM_KE_F_SIGN_INFO;
-    }
-
-    proc->key_size = min(pair_req->max_enc_key_size,
-                         pair_rsp->max_enc_key_size);
-
-    rc = ble_sm_io_action(proc, &ioact);
-    BLE_HS_DBG_ASSERT_EVAL(rc == 0);
-}
-
-static void
-ble_sm_pair_base_fill(struct ble_sm_pair_cmd *cmd)
-{
-    cmd->io_cap = ble_hs_cfg.sm_io_cap;
-    cmd->oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
-    cmd->authreq = ble_sm_build_authreq();
-    cmd->max_enc_key_size = BLE_SM_PAIR_KEY_SZ_MAX;
+static uint8_t ble_sm_state_after_pair(struct ble_sm_proc *proc)
+{
+	if (proc->flags & BLE_SM_PROC_F_SC) {
+		return BLE_SM_PROC_STATE_PUBLIC_KEY;
+	}
+	else {
+		return BLE_SM_PROC_STATE_CONFIRM;
+	}
+}
+
+static void ble_sm_pair_cfg(struct ble_sm_proc *proc)
+{
+	struct ble_sm_pair_cmd *pair_req, *pair_rsp;
+	uint8_t init_key_dist;
+	uint8_t resp_key_dist;
+	uint8_t rx_key_dist;
+	uint8_t ioact;
+	int rc;
+
+	pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+	pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+
+	if (pair_req->authreq & BLE_SM_PAIR_AUTHREQ_SC &&
+	    pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_SC) {
+		proc->flags |= BLE_SM_PROC_F_SC;
+	}
+
+	ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		rx_key_dist = resp_key_dist;
+	}
+	else {
+		rx_key_dist = init_key_dist;
+	}
+
+	if (pair_req->authreq & BLE_SM_PAIR_AUTHREQ_BOND &&
+	    pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
+		proc->flags |= BLE_SM_PROC_F_BONDING;
+	}
+
+	/* In legacy mode, bonding requires the exchange of keys
+	 * at least from one side.  If no key exchange was specified,
+	 * pretend bonding is not enabled.
+	 */
+	if (!(proc->flags & BLE_SM_PROC_F_SC) && (init_key_dist == 0 && resp_key_dist == 0)) {
+		proc->flags &= ~BLE_SM_PROC_F_BONDING;
+	}
+
+	proc->rx_key_flags = 0;
+	if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
+		proc->rx_key_flags |= BLE_SM_KE_F_ENC_INFO | BLE_SM_KE_F_MASTER_ID;
+	}
+	if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
+		proc->rx_key_flags |= BLE_SM_KE_F_ID_INFO | BLE_SM_KE_F_ADDR_INFO;
+	}
+	if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
+		proc->rx_key_flags |= BLE_SM_KE_F_SIGN_INFO;
+	}
+
+	proc->key_size = min(pair_req->max_enc_key_size, pair_rsp->max_enc_key_size);
+
+	rc = ble_sm_io_action(proc, &ioact);
+	BLE_HS_DBG_ASSERT_EVAL(rc == 0);
+}
+
+static void ble_sm_pair_base_fill(struct ble_sm_pair_cmd *cmd)
+{
+	cmd->io_cap = ble_hs_cfg.sm_io_cap;
+	cmd->oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
+	cmd->authreq = ble_sm_build_authreq();
+#if MYNEWT_VAL(CUSTOM_PAIRING_KEY_ENTROPY)
+	cmd->max_enc_key_size = MYNEWT_VAL(CUSTOM_PAIRING_KEY_ENTROPY);
+#else
+	cmd->max_enc_key_size = BLE_SM_PAIR_KEY_SZ_MAX;
+#endif
 }
 
-static void
-ble_sm_pair_req_fill(struct ble_sm_proc *proc)
+static void ble_sm_pair_req_fill(struct ble_sm_proc *proc)
 {
-    struct ble_sm_pair_cmd *req;
+	struct ble_sm_pair_cmd *req;
 
-    req = (void *)(proc->pair_req + 1);
+	req = (void *) (proc->pair_req + 1);
 
-    proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
-    ble_sm_pair_base_fill(req);
-    req->init_key_dist = ble_hs_cfg.sm_our_key_dist;
-    req->resp_key_dist = ble_hs_cfg.sm_their_key_dist;
+	proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
+	ble_sm_pair_base_fill(req);
+	req->init_key_dist = ble_hs_cfg.sm_our_key_dist;
+	req->resp_key_dist = ble_hs_cfg.sm_their_key_dist;
 }
 
-static void
-ble_sm_pair_rsp_fill(struct ble_sm_proc *proc)
+static void ble_sm_pair_rsp_fill(struct ble_sm_proc *proc)
 {
-    const struct ble_sm_pair_cmd *req;
-    struct ble_sm_pair_cmd *rsp;
+	const struct ble_sm_pair_cmd *req;
+	struct ble_sm_pair_cmd *rsp;
 
-    req = (void *)(proc->pair_req + 1);
-    rsp = (void *)(proc->pair_rsp + 1);
+	req = (void *) (proc->pair_req + 1);
+	rsp = (void *) (proc->pair_rsp + 1);
 
-    proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
-    ble_sm_pair_base_fill(rsp);
+	proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
+	ble_sm_pair_base_fill(rsp);
 
-    /* The response's key distribution flags field is the intersection of
-     * the peer's preferences and our capabilities.
-     */
-    rsp->init_key_dist = req->init_key_dist &
-                         ble_hs_cfg.sm_their_key_dist;
-    rsp->resp_key_dist = req->resp_key_dist &
-                         ble_hs_cfg.sm_our_key_dist;
+	/* The response's key distribution flags field is the intersection of
+	 * the peer's preferences and our capabilities.
+	 */
+	rsp->init_key_dist = req->init_key_dist & ble_hs_cfg.sm_their_key_dist;
+	rsp->resp_key_dist = req->resp_key_dist & ble_hs_cfg.sm_our_key_dist;
 }
 
-static void
-ble_sm_pair_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                 void *arg)
+static void ble_sm_pair_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                             void *arg)
 {
-    struct ble_sm_pair_cmd *cmd;
-    struct os_mbuf *txom;
-    uint8_t ioact;
-    int is_req;
-    int rc;
+	struct ble_sm_pair_cmd *cmd;
+	struct os_mbuf *txom;
+	uint8_t ioact;
+	int is_req;
+	int rc;
 
-    is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;
+	is_req = proc->flags & BLE_SM_PROC_F_INITIATOR;
 
-    cmd = ble_sm_cmd_get(is_req ? BLE_SM_OP_PAIR_REQ : BLE_SM_OP_PAIR_RSP,
-                         sizeof(*cmd), &txom);
-    if (cmd == NULL) {
-        rc = BLE_HS_ENOMEM;
-        goto err;
-    }
+	cmd = ble_sm_cmd_get(is_req ? BLE_SM_OP_PAIR_REQ : BLE_SM_OP_PAIR_RSP,
+	                     sizeof(*cmd), &txom);
+	if (cmd == NULL) {
+		rc = BLE_HS_ENOMEM;
+		goto err;
+	}
 
-    if (is_req) {
-        ble_sm_pair_req_fill(proc);
-        memcpy(cmd, proc->pair_req + 1, sizeof(*cmd));
-    } else {
-        /* The response was already generated when we processed the incoming
-         * request.
-         */
-        memcpy(cmd, proc->pair_rsp + 1, sizeof(*cmd));
+	if (is_req) {
+		ble_sm_pair_req_fill(proc);
+		memcpy(cmd, proc->pair_req + 1, sizeof(*cmd));
+	}
+	else {
+		/* The response was already generated when we processed the incoming
+		 * request.
+		 */
+		memcpy(cmd, proc->pair_rsp + 1, sizeof(*cmd));
 
-        proc->state = ble_sm_state_after_pair(proc);
+		proc->state = ble_sm_state_after_pair(proc);
 
-        rc = ble_sm_io_action(proc, &ioact);
-        BLE_HS_DBG_ASSERT(rc == 0);
+		rc = ble_sm_io_action(proc, &ioact);
+		BLE_HS_DBG_ASSERT(rc == 0);
 
-        if (ble_sm_ioact_state(ioact) == proc->state) {
-            res->passkey_params.action = ioact;
-        }
-    }
+		if (ble_sm_ioact_state(ioact) == proc->state) {
+			res->passkey_params.action = ioact;
+		}
+	}
 
-    rc = ble_sm_tx(proc->conn_handle, txom);
-    if (rc != 0) {
-        goto err;
-    }
+	rc = ble_sm_tx(proc->conn_handle, txom);
+	if (rc != 0) {
+		goto err;
+	}
 
-    res->app_status = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    return;
+	return;
 
 err:
-    res->app_status = rc;
-
-    if (!is_req) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    }
-}
-
-static bool
-ble_sm_verify_auth_requirements(uint8_t cmd)
-{
-    /* For now we check only SC only mode. I.e.: when remote indicates
-     * to not support SC pairing, let us make sure legacy pairing is supported
-     * on our side. If not, we can fail right away.
-     */
-    if (!(cmd & BLE_SM_PAIR_AUTHREQ_SC)) {
-        if (MYNEWT_VAL(BLE_SM_LEGACY) == 0) {
-            return false;
-        }
-    }
-    /* Fail if security level forces MITM protection and remote does not
-     * support it
-     */
-    if (MYNEWT_VAL(BLE_SM_LVL) >= 3 && !(cmd & BLE_SM_PAIR_AUTHREQ_MITM)) {
-        return false;
-    }
-    return true;
-}
-
-static void
-ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf **om,
-                   struct ble_sm_result *res)
-{
-    struct ble_sm_pair_cmd *req;
-    struct ble_sm_proc *proc;
-    struct ble_sm_proc *prev;
-    struct ble_hs_conn *conn;
-    ble_sm_proc_flags proc_flags;
-    uint8_t key_size;
-    int rc;
-
-    /* Silence spurious unused-variable warnings. */
-    proc_flags = 0;
-    key_size = 0;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*req));
-    if (res->app_status != 0) {
-        return;
-    }
-
-    req = (struct ble_sm_pair_cmd *)(*om)->om_data;
-
-    ble_hs_lock();
-
-    /* XXX: Check connection state; reject if not appropriate. */
-    /* XXX: Ensure enough time has passed since the previous failed pairing
-     * attempt.
-     */
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, &prev);
-    if (proc != NULL) {
-        /* Fail if procedure is in progress unless we sent a slave security
-         * request to peer.
-         */
-        if (proc->state != BLE_SM_PROC_STATE_SEC_REQ) {
-            res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_UNSPECIFIED);
-            ble_hs_unlock();
-            return;
-        }
-
-        /* Remove the procedure because it was allocated when
-         * sending the Slave Security Request and it will be allocated
-         * again later in this method. We should probably refactor this
-         * in the future.
-         */
-        ble_sm_proc_remove(proc, prev);
-        ble_sm_proc_free(proc);
-    }
-
-    ble_hs_unlock();
-
-    /* Check if there is storage capacity for a new bond.  If there isn't, ask
-     * the application to make room.
-     */
-    rc = ble_sm_chk_store_overflow(conn_handle);
-    if (rc != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->app_status = rc;
-        return;
-    }
-
-    ble_hs_lock();
-
-    proc = ble_sm_proc_alloc();
-    if (proc != NULL) {
-        proc->conn_handle = conn_handle;
-        proc->state = BLE_SM_PROC_STATE_PAIR;
-        ble_sm_insert(proc);
-
-        proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
-        memcpy(proc->pair_req + 1, req, sizeof(*req));
-
-        conn = ble_hs_conn_find_assert(proc->conn_handle);
-        if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
-            res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-        } else if (MYNEWT_VAL(BLE_SM_LVL) == 1) {
-            res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-        } else if (req->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
-            res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-        } else if (req->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
-            res->sm_err = BLE_SM_ERR_INVAL;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
-        } else if (MYNEWT_VAL(BLE_SM_SC_ONLY)) {
-            /* Fail if Secure Connections Only mode is on and remote does not
-             * meet key size requirements - MITM was checked in last step.
-             * Fail if SC is not supported by peer or key size is too small
-             */
-            if (!(req->authreq & BLE_SM_PAIR_AUTHREQ_SC)) {
-                res->sm_err = BLE_SM_ERR_AUTHREQ;
-                res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-            } else if (req->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX) {
-                res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
-                res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-            }
-        } else if (!ble_sm_verify_auth_requirements(req->authreq)) {
-            res->sm_err = BLE_SM_ERR_AUTHREQ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-        } else {
-            /* The request looks good.  Precalculate our pairing response and
-             * determine some properties of the imminent link.  We need this
-             * information in case this is a repeated pairing attempt (i.e., we
-             * are already bonded to this peer).  In that case, we include the
-             * information in a notification to the app.
-             */
-            ble_sm_pair_rsp_fill(proc);
-            ble_sm_pair_cfg(proc);
-
-            proc_flags = proc->flags;
-            key_size = proc->key_size;
-            res->execute = 1;
-        }
-    }
-
-    ble_hs_unlock();
-
-    /* Check if we are already bonded to this peer.  If so, give the
-     * application an opportunity to delete the old bond.
-     */
-    if (res->app_status == 0) {
-        rc = ble_sm_chk_repeat_pairing(conn_handle, proc_flags, key_size);
-        if (rc != 0) {
-            /* The app indicated that the pairing request should be ignored. */
-            res->app_status = rc;
-            res->execute = 0;
-        }
-    }
-}
-
-static void
-ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf **om,
-                   struct ble_sm_result *res)
-{
-    struct ble_sm_pair_cmd *rsp;
-    struct ble_sm_proc *proc;
-    uint8_t ioact;
-    int rc;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*rsp));
-    if (res->app_status != 0) {
-        res->enc_cb = 1;
-        return;
-    }
-
-    rsp = (struct ble_sm_pair_cmd *)(*om)->om_data;
-
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PAIR, 1, NULL);
-    if (proc != NULL) {
-        proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
-        memcpy(proc->pair_rsp + 1, rsp, sizeof(*rsp));
-
-        if (rsp->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
-            res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-        } else if (rsp->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
-            res->sm_err = BLE_SM_ERR_INVAL;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
-        } else if (MYNEWT_VAL(BLE_SM_SC_ONLY) && (rsp->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX)) {
-            /* Fail if Secure Connections Only mode is on and remote does not meet
-            * key size requirements - MITM was checked in last step
-            */
-            res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-        } else if (!ble_sm_verify_auth_requirements(rsp->authreq)) {
-            res->sm_err = BLE_SM_ERR_AUTHREQ;
-            res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-        } else {
-            ble_sm_pair_cfg(proc);
-
-            rc = ble_sm_io_action(proc, &ioact);
-            if (rc != 0) {
-                res->sm_err = BLE_SM_ERR_AUTHREQ;
-                res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-                res->enc_cb = 1;
-            } else {
-                proc->state = ble_sm_state_after_pair(proc);
-                if (ble_sm_ioact_state(ioact) == proc->state) {
-                    res->passkey_params.action = ioact;
-                }
-                if (ble_sm_proc_can_advance(proc)) {
-                    res->execute = 1;
-                }
-            }
-        }
-    }
-
-    ble_hs_unlock();
+	res->app_status = rc;
+
+	if (!is_req) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+}
+
+static bool ble_sm_verify_auth_requirements(uint8_t cmd)
+{
+	/* For now we check only SC only mode. I.e.: when remote indicates
+	 * to not support SC pairing, let us make sure legacy pairing is supported
+	 * on our side. If not, we can fail right away.
+	 */
+	if (!(cmd & BLE_SM_PAIR_AUTHREQ_SC)) {
+		if (MYNEWT_VAL(BLE_SM_LEGACY) == 0) {
+			return false;
+		}
+	}
+	/* Fail if security level forces MITM protection and remote does not
+	 * support it
+	 */
+	if (MYNEWT_VAL(BLE_SM_LVL) >= 3 && !(cmd & BLE_SM_PAIR_AUTHREQ_MITM)) {
+		return false;
+	}
+	return true;
+}
+
+static void ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf **om,
+                               struct ble_sm_result *res)
+{
+	struct ble_store_value_sec bond;
+	struct ble_sm_pair_cmd *req;
+	struct ble_sm_proc *proc;
+	struct ble_sm_proc *prev;
+	struct ble_hs_conn *conn;
+	ble_sm_proc_flags proc_flags;
+	uint8_t key_size;
+	int rc;
+
+	/* Silence spurious unused-variable warnings. */
+	proc_flags = 0;
+	key_size = 0;
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*req));
+	if (res->app_status != 0) {
+		return;
+	}
+
+	req = (struct ble_sm_pair_cmd *) (*om)->om_data;
+
+	ble_hs_lock();
+
+	/* XXX: Check connection state; reject if not appropriate. */
+	/* XXX: Ensure enough time has passed since the previous failed pairing
+	 * attempt.
+	 */
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, &prev);
+	if (proc != NULL) {
+		/* Fail if procedure is in progress unless we sent a slave security
+		 * request to peer.
+		 */
+		if (proc->state != BLE_SM_PROC_STATE_SEC_REQ) {
+			res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_UNSPECIFIED);
+			ble_hs_unlock();
+			return;
+		}
+
+		/* Remove the procedure because it was allocated when
+		 * sending the Slave Security Request and it will be allocated
+		 * again later in this method. We should probably refactor this
+		 * in the future.
+		 */
+		ble_sm_proc_remove(proc, prev);
+		ble_sm_proc_free(proc);
+	}
+
+	ble_hs_unlock();
+
+	/* Check if there is storage capacity for a new bond.  If there isn't, ask
+	 * the application to make room.
+	 */
+	rc = ble_sm_chk_store_overflow(conn_handle);
+	if (rc != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->app_status = rc;
+		return;
+	}
+
+	ble_hs_lock();
+
+	proc = ble_sm_proc_alloc();
+	if (proc != NULL) {
+		proc->conn_handle = conn_handle;
+		proc->state = BLE_SM_PROC_STATE_PAIR;
+		ble_sm_insert(proc);
+
+		proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
+		memcpy(proc->pair_req + 1, req, sizeof(*req));
+
+		conn = ble_hs_conn_find_assert(proc->conn_handle);
+		if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
+			res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
+		}
+		else if (MYNEWT_VAL(BLE_SM_LVL) == 1) {
+			res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
+		}
+		else if (req->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
+			res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
+		}
+		else if (req->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
+			res->sm_err = BLE_SM_ERR_INVAL;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
+		}
+		else if (MYNEWT_VAL(BLE_SM_SC_ONLY)) {
+			/* Fail if Secure Connections Only mode is on and remote does not
+			 * meet key size requirements - MITM was checked in last step.
+			 * Fail if SC is not supported by peer or key size is too small
+			 */
+			if (!(req->authreq & BLE_SM_PAIR_AUTHREQ_SC)) {
+				res->sm_err = BLE_SM_ERR_AUTHREQ;
+				res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+			}
+			else if (req->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX) {
+				res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
+				res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
+			}
+		}
+		else if (!ble_sm_verify_auth_requirements(req->authreq)) {
+			res->sm_err = BLE_SM_ERR_AUTHREQ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+		}
+		else {
+			/* The request looks good.  Precalculate our pairing response and
+			 * determine some properties of the imminent link.  We need this
+			 * information in case this is a repeated pairing attempt (i.e., we
+			 * are already bonded to this peer).  In that case, we include the
+			 * information in a notification to the app.
+			 */
+
+			rc = ble_sm_read_bond(conn_handle, &bond);
+			if (rc != 0) {
+				BLE_HS_LOG_INFO("Could not read bond from storage, this is a new pairing");
+			}
+			else {
+				if (bond.authreq != req->authreq || bond.key_size != req->max_enc_key_size) {
+					BLE_HS_LOG_INFO("Re-pairing downgrade detected, abort.");
+					res->sm_err = BLE_SM_ERR_AUTHREQ;
+					res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+				}
+			}
+
+			if (res->app_status == 0) {
+				ble_sm_pair_rsp_fill(proc);
+				ble_sm_pair_cfg(proc);
+
+				proc_flags = proc->flags;
+				key_size = proc->key_size;
+				res->execute = 1;
+			}
+		}
+	}
+
+
+	ble_hs_unlock();
+
+	/* Check if we are already bonded to this peer.  If so, give the
+	 * application an opportunity to delete the old bond.
+	 */
+	if (res->app_status == 0) {
+		rc = ble_sm_chk_repeat_pairing(conn_handle, proc_flags, key_size);
+		if (rc != 0) {
+			/* The app indicated that the pairing request should be ignored. */
+			res->app_status = rc;
+			res->execute = 0;
+		}
+	}
+}
+
+static void ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf **om,
+                               struct ble_sm_result *res)
+{
+	struct ble_store_value_sec bond;
+	struct ble_sm_pair_cmd *rsp;
+	struct ble_sm_proc *proc;
+	uint8_t ioact;
+	int rc;
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*rsp));
+	if (res->app_status != 0) {
+		res->enc_cb = 1;
+		return;
+	}
+
+	rsp = (struct ble_sm_pair_cmd *) (*om)->om_data;
+
+
+	ble_hs_lock();
+
+
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PAIR, 1, NULL);
+	if (proc != NULL) {
+		proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
+		memcpy(proc->pair_rsp + 1, rsp, sizeof(*rsp));
+
+		if (rsp->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
+			res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
+		}
+		else if (rsp->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
+			res->sm_err = BLE_SM_ERR_INVAL;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
+		}
+		else if (MYNEWT_VAL(BLE_SM_SC_ONLY) &&
+		         (rsp->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX)) {
+			/* Fail if Secure Connections Only mode is on and remote does not meet
+			 * key size requirements - MITM was checked in last step
+			 */
+			res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
+		}
+		else if (!ble_sm_verify_auth_requirements(rsp->authreq)) {
+			res->sm_err = BLE_SM_ERR_AUTHREQ;
+			res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+		}
+		else {
+			rc = ble_sm_read_bond(conn_handle, &bond);
+			if (rc != 0) {
+				BLE_HS_LOG_INFO("Could not read bond from storage, this is a new pairing");
+			}
+			else {
+				if (bond.authreq != rsp->authreq) {
+					BLE_HS_LOG_INFO("Mismatch in authreq value, abort pairing.");
+					res->sm_err = BLE_SM_ERR_AUTHREQ;
+					res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+					res->enc_cb = 1;
+					goto exit;
+				}
+			}
+
+
+			ble_sm_pair_cfg(proc);
+
+			rc = ble_sm_io_action(proc, &ioact);
+			if (rc != 0) {
+				res->sm_err = BLE_SM_ERR_AUTHREQ;
+				res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+				res->enc_cb = 1;
+			}
+			else {
+				proc->state = ble_sm_state_after_pair(proc);
+				if (ble_sm_ioact_state(ioact) == proc->state) {
+					res->passkey_params.action = ioact;
+				}
+				if (ble_sm_proc_can_advance(proc)) {
+					res->execute = 1;
+				}
+			}
+		}
+	}
+exit:
+	ble_hs_unlock();
 }
 
 /*****************************************************************************
  * $security request                                                         *
  *****************************************************************************/
 
-static void
-ble_sm_sec_req_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                    void *arg)
-{
-    struct ble_sm_sec_req *cmd;
-    struct os_mbuf *txom;
-    int rc;
-
-    cmd = ble_sm_cmd_get(BLE_SM_OP_SEC_REQ, sizeof(*cmd), &txom);
-    if (!cmd) {
-        res->app_status = BLE_HS_ENOMEM;
-        return;
-    }
-
-    cmd->authreq = ble_sm_build_authreq();
-    rc = ble_sm_tx(proc->conn_handle, txom);
-    if (rc != 0) {
-        res->app_status = rc;
-        return;
-    }
-}
-
-static void
-ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
-                  struct ble_sm_result *res)
-{
-    struct ble_store_value_sec value_sec;
-    struct ble_store_key_sec key_sec;
-    struct ble_hs_conn_addrs addrs;
-    struct ble_sm_sec_req *cmd;
-    struct ble_hs_conn *conn;
-    int authreq_mitm;
-
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        return;
-    }
-
-    cmd = (struct ble_sm_sec_req *)(*om)->om_data;
-
-    /* XXX: Reject if:
-     *     o authreq-reserved flags set?
-     */
-
-    ble_hs_lock();
-
-    conn = ble_hs_conn_find_assert(conn_handle);
-    if (!(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
-        res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-        res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
-    } else {
-        /* We will be querying the SM database for a key corresponding to the
-         * sender; remember the sender's address while the connection list is
-         * locked.
-         */
-        ble_hs_conn_addrs(conn, &addrs);
-        memset(&key_sec, 0, sizeof key_sec);
-        key_sec.peer_addr = addrs.peer_id_addr;
-    }
-
-    ble_hs_unlock();
-
-    if (res->app_status == 0) {
-        /* If the peer is requesting a bonded connection, query database for an
-         * LTK corresponding to the sender.
-         */
-        if (cmd->authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
-            res->app_status = ble_store_read_peer_sec(&key_sec, &value_sec);
-        } else {
-            res->app_status = BLE_HS_ENOENT;
-        }
-        if (res->app_status == 0) {
-            /* Found a key corresponding to this peer.  Make sure it meets the
-             * requested minimum authreq.
-             */
-            authreq_mitm = cmd->authreq & BLE_SM_PAIR_AUTHREQ_MITM;
-            if (authreq_mitm && !value_sec.authenticated) {
-                res->app_status = BLE_HS_EREJECT;
-            }
-        }
-
-        if (res->app_status == 0) {
-            res->app_status = ble_sm_enc_initiate(conn_handle,
-                                                  value_sec.key_size,
-                                                  value_sec.ltk,
-                                                  value_sec.ediv,
-                                                  value_sec.rand_num,
-                                                  value_sec.authenticated);
-        } else {
-            res->app_status = ble_sm_pair_initiate(conn_handle);
-        }
-    }
+static void ble_sm_sec_req_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                                void *arg)
+{
+	struct ble_sm_sec_req *cmd;
+	struct os_mbuf *txom;
+	int rc;
+
+	cmd = ble_sm_cmd_get(BLE_SM_OP_SEC_REQ, sizeof(*cmd), &txom);
+	if (!cmd) {
+		res->app_status = BLE_HS_ENOMEM;
+		return;
+	}
+
+	cmd->authreq = ble_sm_build_fake_authreq();
+	rc = ble_sm_tx(proc->conn_handle, txom);
+	if (rc != 0) {
+		res->app_status = rc;
+		return;
+	}
+}
+
+static void ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
+                              struct ble_sm_result *res)
+{
+	struct ble_store_value_sec value_sec;
+	struct ble_store_key_sec key_sec;
+	struct ble_hs_conn_addrs addrs;
+	struct ble_sm_sec_req *cmd;
+	struct ble_hs_conn *conn;
+	int authreq_mitm;
+
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		return;
+	}
+
+	cmd = (struct ble_sm_sec_req *) (*om)->om_data;
+
+	/* XXX: Reject if:
+	 *     o authreq-reserved flags set?
+	 */
+
+	ble_hs_lock();
+
+	conn = ble_hs_conn_find_assert(conn_handle);
+	if (!(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
+		res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
+		res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
+	}
+	else {
+		/* We will be querying the SM database for a key corresponding to the
+		 * sender; remember the sender's address while the connection list is
+		 * locked.
+		 */
+		ble_hs_conn_addrs(conn, &addrs);
+		memset(&key_sec, 0, sizeof key_sec);
+		key_sec.peer_addr = addrs.peer_id_addr;
+	}
+
+	ble_hs_unlock();
+
+	if (res->app_status == 0) {
+		/* If the peer is requesting a bonded connection, query database for an
+		 * LTK corresponding to the sender.
+		 */
+		if (cmd->authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
+			res->app_status = ble_store_read_peer_sec(&key_sec, &value_sec);
+		}
+		else {
+			res->app_status = BLE_HS_ENOENT;
+		}
+		if (res->app_status == 0) {
+			/* Found a key corresponding to this peer.  Make sure it meets the
+			 * requested minimum authreq.
+			 */
+			authreq_mitm = cmd->authreq & BLE_SM_PAIR_AUTHREQ_MITM;
+			if (authreq_mitm && !value_sec.authenticated) {
+				res->app_status = BLE_HS_EREJECT;
+			}
+			if (value_sec.rep == 0) {
+				// TODO: use a proper error code to notify GAP
+				// We reject the security request but the disconnection part is left to GAP
+				// (i.e., application)
+				ble_gap_enc_event(conn_handle, 37, 0, 0);
+				return;
+			}
+		}
+
+		if (res->app_status == 0) {
+			res->app_status = ble_sm_enc_initiate(
+				conn_handle, value_sec.key_size, value_sec.ltk, value_sec.ediv,
+				value_sec.rand_num, value_sec.authenticated);
+		}
+		else {
+			// Save the authreq value before starting the re-pairing
+			value_sec.authreq = cmd->authreq;
+			res->app_status = ble_sm_pair_initiate(conn_handle);
+		}
+	}
 }
 
 /*****************************************************************************
  * $key exchange                                                             *
  *****************************************************************************/
 
-static void
-ble_sm_key_exch_success(struct ble_sm_proc *proc, struct ble_sm_result *res)
-{
-    /* The procedure is now complete.  Update connection bonded state and
-     * terminate procedure.
-     */
-    int bonded = !!(proc->flags & BLE_SM_PROC_F_BONDING);
-    ble_sm_update_sec_state(proc->conn_handle, 1,
-                            !!(proc->flags & BLE_SM_PROC_F_AUTHENTICATED),
-                            bonded,
-                            proc->key_size);
-    proc->state = BLE_SM_PROC_STATE_NONE;
-
-    res->app_status = 0;
-    res->enc_cb = 1;
-    res->bonded = bonded;
-    res->sm_err = BLE_SM_ERR_SUCCESS;
-}
-
-static void
-ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                     void *arg)
-{
-    struct ble_sm_id_addr_info *addr_info;
-    struct ble_hs_conn_addrs addrs;
-    struct ble_sm_sign_info *sign_info;
-    struct ble_sm_master_id *master_id;
-    struct ble_sm_enc_info *enc_info;
-    struct ble_sm_id_info *id_info;
-    struct ble_hs_conn *conn;
-    uint8_t init_key_dist;
-    uint8_t resp_key_dist;
-    uint8_t our_key_dist;
-    struct os_mbuf *txom;
-    const uint8_t *irk;
-    struct ble_store_gen_key gen_key;
-    int ltk_gen = 0;
-    int rc;
-
-    ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        our_key_dist = init_key_dist;
-    } else {
-        our_key_dist = resp_key_dist;
-    }
-
-    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
-        /* Send encryption information. */
-        enc_info = ble_sm_cmd_get(BLE_SM_OP_ENC_INFO, sizeof(*enc_info), &txom);
-        if (!enc_info) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        proc->our_keys.key_size = proc->key_size;
-
-        if (ble_hs_cfg.store_gen_key_cb) {
-            memset(&gen_key, 0, sizeof(gen_key));
-            rc = ble_hs_cfg.store_gen_key_cb(BLE_STORE_GEN_KEY_LTK, &gen_key,
-                                             proc->conn_handle);
-            if (rc == 0) {
-                /* Trim LRK to keysize */
-                memset(gen_key.ltk_periph + proc->key_size, 0,
-                       16 - proc->key_size);
-
-                proc->our_keys.ediv = gen_key.ediv;
-                proc->our_keys.rand_val = gen_key.rand;
-                memcpy(proc->our_keys.ltk, gen_key.ltk_periph, 16);
-
-                ltk_gen = 1;
-            }
-        }
-
-        if (!ltk_gen) {
-            rc = ble_sm_gen_ltk(proc, enc_info->ltk);
-            if (rc != 0) {
-                os_mbuf_free_chain(txom);
-                goto err;
-            }
-
-            /* store LTK before sending since ble_sm_tx consumes tx mbuf */
-            memcpy(proc->our_keys.ltk, enc_info->ltk, 16);
-        } else {
-            memcpy(enc_info->ltk, proc->our_keys.ltk, 16);
-        }
-        proc->our_keys.ltk_valid = 1;
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-
-        /* Send master identification. */
-        master_id = ble_sm_cmd_get(BLE_SM_OP_MASTER_ID, sizeof(*master_id),
-                                   &txom);
-        if (!master_id) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        if (!ltk_gen) {
-            rc = ble_sm_gen_ediv(master_id);
-            if (rc != 0) {
-                os_mbuf_free_chain(txom);
-                goto err;
-            }
-            rc = ble_sm_gen_master_id_rand(master_id);
-            if (rc != 0) {
-                os_mbuf_free_chain(txom);
-                goto err;
-            }
-
-            proc->our_keys.rand_val = master_id->rand_val;
-            proc->our_keys.ediv = master_id->ediv;
-        } else {
-            master_id->ediv = proc->our_keys.ediv;
-            master_id->rand_val = proc->our_keys.rand_val;
-        }
-        proc->our_keys.ediv_rand_valid = 1;
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-    }
-
-    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
-        /* Send identity information. */
-        id_info = ble_sm_cmd_get(BLE_SM_OP_IDENTITY_INFO, sizeof(*id_info),
-                                 &txom);
-        if (!id_info) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        rc = ble_hs_pvcy_our_irk(&irk);
-        if (rc != 0) {
-            os_mbuf_free_chain(txom);
-            goto err;
-        }
-
-        memcpy(id_info->irk, irk, 16);
-        proc->our_keys.irk_valid = 1;
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-
-        /* Send identity address information. */
-        addr_info = ble_sm_cmd_get(BLE_SM_OP_IDENTITY_ADDR_INFO,
-                                   sizeof(*addr_info), &txom);
-        if (!addr_info) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        conn = ble_hs_conn_find_assert(proc->conn_handle);
-        ble_hs_conn_addrs(conn, &addrs);
-
-        addr_info->addr_type = addrs.our_id_addr.type;
-        memcpy(addr_info->bd_addr, addrs.our_id_addr.val, 6);
-
-        proc->our_keys.addr_valid = 1;
-        memcpy(proc->our_keys.irk, irk, 16);
-        proc->our_keys.addr_type = addr_info->addr_type;
-        memcpy(proc->our_keys.addr, addr_info->bd_addr, 6);
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-    }
-
-    if (our_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
-        /* Send signing information. */
-        sign_info = ble_sm_cmd_get(BLE_SM_OP_SIGN_INFO, sizeof(*sign_info),
-                                   &txom);
-        if (!sign_info) {
-            rc = BLE_HS_ENOMEM;
-            goto err;
-        }
-
-        if (ble_hs_cfg.store_gen_key_cb) {
-            memset(&gen_key, 0, sizeof(gen_key));
-            rc = ble_hs_cfg.store_gen_key_cb(BLE_STORE_GEN_KEY_CSRK, &gen_key,
-                                             proc->conn_handle);
-            if (rc == 0) {
-                memcpy(proc->our_keys.csrk, gen_key.csrk, 16);
-            }
-        } else {
-            rc = -1;
-        }
-
-        if (rc != 0) {
-            rc = ble_sm_gen_csrk(proc, sign_info->sig_key);
-            if (rc != 0) {
-                os_mbuf_free_chain(txom);
-                goto err;
-            }
-
-            memcpy(proc->our_keys.csrk, sign_info->sig_key, 16);
-        } else {
-            memcpy(sign_info->sig_key, proc->our_keys.csrk, 16);
-        }
-        proc->our_keys.csrk_valid = 1;
-
-        rc = ble_sm_tx(proc->conn_handle, txom);
-        if (rc != 0) {
-            goto err;
-        }
-    }
-
-    if (proc->flags & BLE_SM_PROC_F_INITIATOR || proc->rx_key_flags == 0) {
-        /* The procedure is now complete. */
-        ble_sm_key_exch_success(proc, res);
-    }
-
-    return;
+static void ble_sm_key_exch_success(struct ble_sm_proc *proc, struct ble_sm_result *res)
+{
+	/* The procedure is now complete.  Update connection bonded state and
+	 * terminate procedure.
+	 */
+	int bonded = !!(proc->flags & BLE_SM_PROC_F_BONDING);
+	ble_sm_update_sec_state(proc->conn_handle, 1,
+	                        !!(proc->flags & BLE_SM_PROC_F_AUTHENTICATED), bonded,
+	                        proc->key_size);
+	proc->state = BLE_SM_PROC_STATE_NONE;
+
+	res->app_status = 0;
+	res->enc_cb = 1;
+	res->bonded = bonded;
+	res->sm_err = BLE_SM_ERR_SUCCESS;
+}
+
+static void ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
+                                 void *arg)
+{
+	struct ble_sm_id_addr_info *addr_info;
+	struct ble_hs_conn_addrs addrs;
+	struct ble_sm_sign_info *sign_info;
+	struct ble_sm_master_id *master_id;
+	struct ble_sm_enc_info *enc_info;
+	struct ble_sm_id_info *id_info;
+	struct ble_hs_conn *conn;
+	uint8_t init_key_dist;
+	uint8_t resp_key_dist;
+	uint8_t our_key_dist;
+	struct os_mbuf *txom;
+	const uint8_t *irk;
+	struct ble_store_gen_key gen_key;
+	int ltk_gen = 0;
+	int rc;
+
+	ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+		our_key_dist = init_key_dist;
+	}
+	else {
+		our_key_dist = resp_key_dist;
+	}
+
+	if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
+		/* Send encryption information. */
+		enc_info = ble_sm_cmd_get(BLE_SM_OP_ENC_INFO, sizeof(*enc_info), &txom);
+		if (!enc_info) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		proc->our_keys.key_size = proc->key_size;
+
+		if (ble_hs_cfg.store_gen_key_cb) {
+			memset(&gen_key, 0, sizeof(gen_key));
+			rc = ble_hs_cfg.store_gen_key_cb(BLE_STORE_GEN_KEY_LTK, &gen_key,
+			                                 proc->conn_handle);
+			if (rc == 0) {
+				/* Trim LRK to keysize */
+				memset(gen_key.ltk_periph + proc->key_size, 0, 16 - proc->key_size);
+
+				proc->our_keys.ediv = gen_key.ediv;
+				proc->our_keys.rand_val = gen_key.rand;
+				memcpy(proc->our_keys.ltk, gen_key.ltk_periph, 16);
+
+				ltk_gen = 1;
+			}
+		}
+
+		if (!ltk_gen) {
+			rc = ble_sm_gen_ltk(proc, enc_info->ltk);
+			if (rc != 0) {
+				os_mbuf_free_chain(txom);
+				goto err;
+			}
+
+			/* store LTK before sending since ble_sm_tx consumes tx mbuf */
+			memcpy(proc->our_keys.ltk, enc_info->ltk, 16);
+		}
+		else {
+			memcpy(enc_info->ltk, proc->our_keys.ltk, 16);
+		}
+		proc->our_keys.ltk_valid = 1;
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+
+		/* Send master identification. */
+		master_id = ble_sm_cmd_get(BLE_SM_OP_MASTER_ID, sizeof(*master_id), &txom);
+		if (!master_id) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		if (!ltk_gen) {
+			rc = ble_sm_gen_ediv(master_id);
+			if (rc != 0) {
+				os_mbuf_free_chain(txom);
+				goto err;
+			}
+			rc = ble_sm_gen_master_id_rand(master_id);
+			if (rc != 0) {
+				os_mbuf_free_chain(txom);
+				goto err;
+			}
+
+			proc->our_keys.rand_val = master_id->rand_val;
+			proc->our_keys.ediv = master_id->ediv;
+		}
+		else {
+			master_id->ediv = proc->our_keys.ediv;
+			master_id->rand_val = proc->our_keys.rand_val;
+		}
+		proc->our_keys.ediv_rand_valid = 1;
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+	}
+
+	if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
+		/* Send identity information. */
+		id_info = ble_sm_cmd_get(BLE_SM_OP_IDENTITY_INFO, sizeof(*id_info), &txom);
+		if (!id_info) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		rc = ble_hs_pvcy_our_irk(&irk);
+		if (rc != 0) {
+			os_mbuf_free_chain(txom);
+			goto err;
+		}
+
+		memcpy(id_info->irk, irk, 16);
+		proc->our_keys.irk_valid = 1;
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+
+		/* Send identity address information. */
+		addr_info = ble_sm_cmd_get(BLE_SM_OP_IDENTITY_ADDR_INFO, sizeof(*addr_info), &txom);
+		if (!addr_info) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		conn = ble_hs_conn_find_assert(proc->conn_handle);
+		ble_hs_conn_addrs(conn, &addrs);
+
+		addr_info->addr_type = addrs.our_id_addr.type;
+		memcpy(addr_info->bd_addr, addrs.our_id_addr.val, 6);
+
+		proc->our_keys.addr_valid = 1;
+		memcpy(proc->our_keys.irk, irk, 16);
+		proc->our_keys.addr_type = addr_info->addr_type;
+		memcpy(proc->our_keys.addr, addr_info->bd_addr, 6);
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+	}
+
+	if (our_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
+		/* Send signing information. */
+		sign_info = ble_sm_cmd_get(BLE_SM_OP_SIGN_INFO, sizeof(*sign_info), &txom);
+		if (!sign_info) {
+			rc = BLE_HS_ENOMEM;
+			goto err;
+		}
+
+		if (ble_hs_cfg.store_gen_key_cb) {
+			memset(&gen_key, 0, sizeof(gen_key));
+			rc = ble_hs_cfg.store_gen_key_cb(BLE_STORE_GEN_KEY_CSRK, &gen_key,
+			                                 proc->conn_handle);
+			if (rc == 0) {
+				memcpy(proc->our_keys.csrk, gen_key.csrk, 16);
+			}
+		}
+		else {
+			rc = -1;
+		}
+
+		if (rc != 0) {
+			rc = ble_sm_gen_csrk(proc, sign_info->sig_key);
+			if (rc != 0) {
+				os_mbuf_free_chain(txom);
+				goto err;
+			}
+
+			memcpy(proc->our_keys.csrk, sign_info->sig_key, 16);
+		}
+		else {
+			memcpy(sign_info->sig_key, proc->our_keys.csrk, 16);
+		}
+		proc->our_keys.csrk_valid = 1;
+
+		rc = ble_sm_tx(proc->conn_handle, txom);
+		if (rc != 0) {
+			goto err;
+		}
+	}
+
+	if (proc->flags & BLE_SM_PROC_F_INITIATOR || proc->rx_key_flags == 0) {
+		/* The procedure is now complete. */
+		ble_sm_key_exch_success(proc, res);
+	}
+
+	return;
 
 err:
-    res->app_status = rc;
-    res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    res->enc_cb = 1;
+	res->app_status = rc;
+	res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	res->enc_cb = 1;
 }
 
-static void
-ble_sm_key_rxed(struct ble_sm_proc *proc, struct ble_sm_result *res)
+static void ble_sm_key_rxed(struct ble_sm_proc *proc, struct ble_sm_result *res)
 {
-    BLE_HS_LOG(DEBUG, "rx_key_flags=0x%02x\n", proc->rx_key_flags);
+	BLE_HS_LOG(DEBUG, "rx_key_flags=0x%02x\n", proc->rx_key_flags);
 
-    if (proc->rx_key_flags == 0) {
-        /* The peer is done sending keys.  If we are the initiator, we need to
-         * send ours.  If we are the responder, the procedure is complete.
-         */
-        if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-            res->execute = 1;
-        } else {
-            ble_sm_key_exch_success(proc, res);
-        }
-    }
+	if (proc->rx_key_flags == 0) {
+		/* The peer is done sending keys.  If we are the initiator, we need to
+		 * send ours.  If we are the responder, the procedure is complete.
+		 */
+		if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+			res->execute = 1;
+		}
+		else {
+			ble_sm_key_exch_success(proc, res);
+		}
+	}
 }
 
-static void
-ble_sm_enc_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                   struct ble_sm_result *res)
+static void ble_sm_enc_info_rx(uint16_t conn_handle, struct os_mbuf **om,
+                               struct ble_sm_result *res)
 {
-    struct ble_sm_enc_info *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_enc_info *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_enc_info *)(*om)->om_data;
+	cmd = (struct ble_sm_enc_info *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_ENC_INFO;
-        proc->peer_keys.ltk_valid = 1;
-        memcpy(proc->peer_keys.ltk, cmd->ltk, 16);
-        proc->peer_keys.key_size = proc->key_size;
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_ENC_INFO;
+		proc->peer_keys.ltk_valid = 1;
+		memcpy(proc->peer_keys.ltk, cmd->ltk, 16);
+		proc->peer_keys.key_size = proc->key_size;
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
-static void
-ble_sm_master_id_rx(uint16_t conn_handle, struct os_mbuf **om,
-                    struct ble_sm_result *res)
+static void ble_sm_master_id_rx(uint16_t conn_handle, struct os_mbuf **om,
+                                struct ble_sm_result *res)
 {
-    struct ble_sm_master_id *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_master_id *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_master_id *)(*om)->om_data;
+	cmd = (struct ble_sm_master_id *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_MASTER_ID;
-        proc->peer_keys.ediv_rand_valid = 1;
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_MASTER_ID;
+		proc->peer_keys.ediv_rand_valid = 1;
 
-        proc->peer_keys.ediv = le16toh(cmd->ediv);
-        proc->peer_keys.rand_val = le64toh(cmd->rand_val);
+		proc->peer_keys.ediv = le16toh(cmd->ediv);
+		proc->peer_keys.rand_val = le64toh(cmd->rand_val);
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
-static void
-ble_sm_id_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                  struct ble_sm_result *res)
+static void ble_sm_id_info_rx(uint16_t conn_handle, struct os_mbuf **om,
+                              struct ble_sm_result *res)
 {
-    struct ble_sm_id_info *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_id_info *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_id_info *)(*om)->om_data;
+	cmd = (struct ble_sm_id_info *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_ID_INFO;
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_ID_INFO;
 
-        memcpy(proc->peer_keys.irk, cmd->irk, 16);
-        proc->peer_keys.irk_valid = 1;
+		memcpy(proc->peer_keys.irk, cmd->irk, 16);
+		proc->peer_keys.irk_valid = 1;
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
-static void
-ble_sm_id_addr_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                       struct ble_sm_result *res)
+static void ble_sm_id_addr_info_rx(uint16_t conn_handle, struct os_mbuf **om,
+                                   struct ble_sm_result *res)
 {
-    struct ble_sm_id_addr_info *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_id_addr_info *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_id_addr_info *)(*om)->om_data;
+	cmd = (struct ble_sm_id_addr_info *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_ADDR_INFO;
-        proc->peer_keys.addr_valid = 1;
-        proc->peer_keys.addr_type = cmd->addr_type;
-        memcpy(proc->peer_keys.addr, cmd->bd_addr, 6);
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_ADDR_INFO;
+		proc->peer_keys.addr_valid = 1;
+		proc->peer_keys.addr_type = cmd->addr_type;
+		memcpy(proc->peer_keys.addr, cmd->bd_addr, 6);
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
-static void
-ble_sm_sign_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                    struct ble_sm_result *res)
+static void ble_sm_sign_info_rx(uint16_t conn_handle, struct os_mbuf **om,
+                                struct ble_sm_result *res)
 {
-    struct ble_sm_sign_info *cmd;
-    struct ble_sm_proc *proc;
+	struct ble_sm_sign_info *cmd;
+	struct ble_sm_proc *proc;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status != 0) {
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+		res->enc_cb = 1;
+		return;
+	}
 
-    cmd = (struct ble_sm_sign_info *)(*om)->om_data;
+	cmd = (struct ble_sm_sign_info *) (*om)->om_data;
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
-    if (proc == NULL) {
-        res->app_status = BLE_HS_ENOENT;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        proc->rx_key_flags &= ~BLE_SM_KE_F_SIGN_INFO;
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_KEY_EXCH, -1, NULL);
+	if (proc == NULL) {
+		res->app_status = BLE_HS_ENOENT;
+		res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+	}
+	else {
+		proc->rx_key_flags &= ~BLE_SM_KE_F_SIGN_INFO;
 
-        memcpy(proc->peer_keys.csrk, cmd->sig_key, 16);
-        proc->peer_keys.csrk_valid = 1;
+		memcpy(proc->peer_keys.csrk, cmd->sig_key, 16);
+		proc->peer_keys.csrk_valid = 1;
 
-        ble_sm_key_rxed(proc, res);
-    }
+		ble_sm_key_rxed(proc, res);
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 }
 
 /*****************************************************************************
  * $fail                                                                     *
  *****************************************************************************/
 
-static void
-ble_sm_fail_rx(uint16_t conn_handle, struct os_mbuf **om,
-               struct ble_sm_result *res)
+static void ble_sm_fail_rx(uint16_t conn_handle, struct os_mbuf **om,
+                           struct ble_sm_result *res)
 {
-    struct ble_sm_pair_fail *cmd;
+	struct ble_sm_pair_fail *cmd;
 
-    res->enc_cb = 1;
+	res->enc_cb = 1;
 
-    res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
-    if (res->app_status == 0) {
-        cmd = (struct ble_sm_pair_fail *)(*om)->om_data;
+	res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
+	if (res->app_status == 0) {
+		cmd = (struct ble_sm_pair_fail *) (*om)->om_data;
 
-        res->app_status = BLE_HS_SM_PEER_ERR(cmd->reason);
-        res->sm_err =  cmd->reason;
-    }
+		res->app_status = BLE_HS_SM_PEER_ERR(cmd->reason);
+		res->sm_err = cmd->reason;
+	}
 }
 
 /*****************************************************************************
@@ -2503,513 +2500,507 @@ ble_sm_fail_rx(uint16_t conn_handle, struct os_mbuf **om,
  * @return                      The number of ticks until this function should
  *                                  be called again.
  */
-int32_t
-ble_sm_timer(void)
+int32_t ble_sm_timer(void)
 {
-    struct ble_sm_proc_list exp_list;
-    struct ble_sm_proc *proc;
-    int32_t ticks_until_exp;
+	struct ble_sm_proc_list exp_list;
+	struct ble_sm_proc *proc;
+	int32_t ticks_until_exp;
 
-    /* Remove timed-out procedures from the main list and insert them into a
-     * temporary list.  This function also calculates the number of ticks until
-     * the next expiration will occur.
-     */
-    ticks_until_exp = ble_sm_extract_expired(&exp_list);
+	/* Remove timed-out procedures from the main list and insert them into a
+	 * temporary list.  This function also calculates the number of ticks until
+	 * the next expiration will occur.
+	 */
+	ticks_until_exp = ble_sm_extract_expired(&exp_list);
 
-    /* Notify application of each failure and free the corresponding procedure
-     * object.
-     * XXX: Mark connection as tainted; don't allow any subsequent SMP
-     * procedures without reconnect.
-     */
-    while ((proc = STAILQ_FIRST(&exp_list)) != NULL) {
-        ble_gap_enc_event(proc->conn_handle, BLE_HS_ETIMEOUT, 0, 0);
+	/* Notify application of each failure and free the corresponding procedure
+	 * object.
+	 * XXX: Mark connection as tainted; don't allow any subsequent SMP
+	 * procedures without reconnect.
+	 */
+	while ((proc = STAILQ_FIRST(&exp_list)) != NULL) {
+		ble_gap_enc_event(proc->conn_handle, BLE_HS_ETIMEOUT, 0, 0);
 
-        STAILQ_REMOVE_HEAD(&exp_list, next);
-        ble_sm_proc_free(proc);
-    }
+		STAILQ_REMOVE_HEAD(&exp_list, next);
+		ble_sm_proc_free(proc);
+	}
 
-    return ticks_until_exp;
+	return ticks_until_exp;
 }
 
 /**
  * Initiates the pairing procedure for the specified connection.
  */
-int
-ble_sm_pair_initiate(uint16_t conn_handle)
+int ble_sm_pair_initiate(uint16_t conn_handle)
 {
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    int rc;
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	int rc;
 
-    memset(&res, 0, sizeof(res));
+	memset(&res, 0, sizeof(res));
 
-    /* Make sure a procedure isn't already in progress for this connection. */
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    ble_hs_unlock();
+	/* Make sure a procedure isn't already in progress for this connection. */
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	ble_hs_unlock();
 
-    if (proc != NULL) {
-        res.app_status = BLE_HS_EALREADY;
-        return BLE_HS_EALREADY;
-    }
+	if (proc != NULL) {
+		res.app_status = BLE_HS_EALREADY;
+		return BLE_HS_EALREADY;
+	}
 
-    /* Check if there is storage capacity for a new bond.  If there isn't, ask
-     * the application to make room.
-     */
-    rc = ble_sm_chk_store_overflow(conn_handle);
-    if (rc != 0) {
-        return rc;
-    }
+	/* Check if there is storage capacity for a new bond.  If there isn't, ask
+	 * the application to make room.
+	 */
+	rc = ble_sm_chk_store_overflow(conn_handle);
+	if (rc != 0) {
+		return rc;
+	}
 
-    proc = ble_sm_proc_alloc();
-    if (proc == NULL) {
-        res.app_status = BLE_HS_ENOMEM;
-    } else {
-        proc->conn_handle = conn_handle;
-        proc->state = BLE_SM_PROC_STATE_PAIR;
-        proc->flags |= BLE_SM_PROC_F_INITIATOR;
+	proc = ble_sm_proc_alloc();
+	if (proc == NULL) {
+		res.app_status = BLE_HS_ENOMEM;
+	}
+	else {
+		proc->conn_handle = conn_handle;
+		proc->state = BLE_SM_PROC_STATE_PAIR;
+		proc->flags |= BLE_SM_PROC_F_INITIATOR;
 
-        ble_hs_lock();
-        ble_sm_insert(proc);
-        ble_hs_unlock();
+		ble_hs_lock();
+		ble_sm_insert(proc);
+		ble_hs_unlock();
 
-        res.execute = 1;
-    }
+		res.execute = 1;
+	}
 
-    if (proc != NULL) {
-        ble_sm_process_result(conn_handle, &res, true);
-    }
+	if (proc != NULL) {
+		ble_sm_process_result(conn_handle, &res, true);
+	}
 
-    return res.app_status;
+	return res.app_status;
 }
 
-int
-ble_sm_slave_initiate(uint16_t conn_handle)
+int ble_sm_slave_initiate(uint16_t conn_handle)
 {
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
 
-    memset(&res, 0, sizeof(res));
+	memset(&res, 0, sizeof(res));
 
-    ble_hs_lock();
+	ble_hs_lock();
 
-    /* Make sure a procedure isn't already in progress for this connection. */
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    if (proc != NULL) {
-        res.app_status = BLE_HS_EALREADY;
+	/* Make sure a procedure isn't already in progress for this connection. */
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	if (proc != NULL) {
+		res.app_status = BLE_HS_EALREADY;
 
-        /* Set pointer to null so that existing entry doesn't get freed. */
-        proc = NULL;
-    } else {
-        proc = ble_sm_proc_alloc();
-        if (proc == NULL) {
-            res.app_status = BLE_HS_ENOMEM;
-        } else {
-            proc->conn_handle = conn_handle;
-            proc->state = BLE_SM_PROC_STATE_SEC_REQ;
-            ble_sm_insert(proc);
+		/* Set pointer to null so that existing entry doesn't get freed. */
+		proc = NULL;
+	}
+	else {
+		proc = ble_sm_proc_alloc();
+		if (proc == NULL) {
+			res.app_status = BLE_HS_ENOMEM;
+		}
+		else {
+			proc->conn_handle = conn_handle;
+			proc->state = BLE_SM_PROC_STATE_SEC_REQ;
+			ble_sm_insert(proc);
 
-            res.execute = 1;
-        }
-    }
+			res.execute = 1;
+		}
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    if (proc != NULL) {
-        ble_sm_process_result(conn_handle, &res, true);
-    }
+	if (proc != NULL) {
+		ble_sm_process_result(conn_handle, &res, true);
+	}
 
-    return res.app_status;
+	return res.app_status;
 }
 
 /**
  * Initiates the encryption procedure for the specified connection.
  */
-int
-ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size,
-                    const uint8_t *ltk, uint16_t ediv,
-                    uint64_t rand_val, int auth)
+int ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size, const uint8_t *ltk,
+                        uint16_t ediv, uint64_t rand_val, int auth)
 {
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    struct hci_start_encrypt cmd;
-
-    memset(&res, 0, sizeof res);
-
-    /* Make sure a procedure isn't already in progress for this connection. */
-    ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    if (proc != NULL) {
-        res.app_status = BLE_HS_EALREADY;
-
-        /* Set pointer to null so that existing entry doesn't get freed. */
-        proc = NULL;
-    } else {
-        proc = ble_sm_proc_alloc();
-        if (proc == NULL) {
-            res.app_status = BLE_HS_ENOMEM;
-        } else {
-            proc->conn_handle = conn_handle;
-            proc->key_size = key_size;
-            proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
-            proc->flags |= BLE_SM_PROC_F_INITIATOR;
-            if (auth) {
-                proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
-            }
-            ble_sm_insert(proc);
-
-            cmd.connection_handle = conn_handle;
-            cmd.encrypted_diversifier = ediv;
-            cmd.random_number = rand_val;
-            memcpy(cmd.long_term_key, ltk, sizeof cmd.long_term_key);
-
-            res.execute = 1;
-            res.state_arg = &cmd;
-        }
-    }
-
-    ble_hs_unlock();
-
-    ble_sm_process_result(conn_handle, &res, true);
-
-    return res.app_status;
-}
-
-static int
-ble_sm_rx(struct ble_l2cap_chan *chan)
-{
-    struct ble_sm_result res;
-    ble_sm_rx_fn *rx_cb;
-    uint8_t op;
-    uint16_t conn_handle;
-    struct os_mbuf **om;
-    int rc;
-
-    STATS_INC(ble_l2cap_stats, sm_rx);
-
-    conn_handle = ble_l2cap_get_conn_handle(chan);
-    if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
-        return BLE_HS_ENOTCONN;
-    }
-
-    om = &chan->rx_buf;
-    BLE_HS_DBG_ASSERT(*om != NULL);
-
-    rc = os_mbuf_copydata(*om, 0, 1, &op);
-    if (rc != 0) {
-        return BLE_HS_EBADDATA;
-    }
-
-    /* Strip L2CAP SM header from the front of the mbuf. */
-    os_mbuf_adj(*om, 1);
-
-    rx_cb = ble_sm_dispatch_get(op);
-    if (rx_cb != NULL) {
-        memset(&res, 0, sizeof res);
-
-        rx_cb(conn_handle, om, &res);
-        ble_sm_process_result(conn_handle, &res, op == BLE_SM_OP_PAIR_FAIL ?
-                              false : true);
-        rc = res.app_status;
-    } else {
-        rc = BLE_HS_ENOTSUP;
-    }
-
-    return rc;
-}
-
-int
-ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io *pkey)
-{
-    struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    int rc;
-    uint8_t action;
-
-    memset(&res, 0, sizeof res);
-
-    ble_hs_lock();
-
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
-    if (proc == NULL) {
-        rc = BLE_HS_ENOENT;
-    } else if (proc->flags & BLE_SM_PROC_F_IO_INJECTED) {
-        rc = BLE_HS_EALREADY;
-    } else if ((ble_sm_io_action(proc, &action) == 0) && pkey->action != action) {
-        /* Application provided incorrect IO type. */
-        rc = BLE_HS_EINVAL;
-    } else if (ble_sm_ioact_state(pkey->action) != proc->state) {
-        /* Procedure is not ready for user input. */
-        rc = BLE_HS_EINVAL;
-    } else {
-        /* Assume valid input. */
-        rc = 0;
-
-        switch (pkey->action) {
-        case BLE_SM_IOACT_OOB:
-            proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
-            memcpy(proc->tk, pkey->oob, 16);
-            if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
-                (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
-
-                res.execute = 1;
-            }
-            break;
-
-        case BLE_SM_IOACT_INPUT:
-        case BLE_SM_IOACT_DISP:
-            if (pkey->passkey > 999999) {
-                rc = BLE_HS_EINVAL;
-            } else {
-                proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
-                memset(proc->tk, 0, 16);
-                proc->tk[0] = (pkey->passkey >> 0) & 0xff;
-                proc->tk[1] = (pkey->passkey >> 8) & 0xff;
-                proc->tk[2] = (pkey->passkey >> 16) & 0xff;
-                proc->tk[3] = (pkey->passkey >> 24) & 0xff;
-                if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
-                    (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
-
-                    res.execute = 1;
-                }
-            }
-            break;
-
-        case BLE_SM_IOACT_NUMCMP:
-            if (!pkey->numcmp_accept) {
-                res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_NUMCMP);
-                res.sm_err = BLE_SM_ERR_NUMCMP;
-            } else {
-                proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
-                if (proc->flags & BLE_SM_PROC_F_INITIATOR ||
-                    proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO) {
-
-                    res.execute = 1;
-                }
-            }
-            break;
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	struct hci_start_encrypt cmd;
+
+	memset(&res, 0, sizeof res);
+
+	/* Make sure a procedure isn't already in progress for this connection. */
+	ble_hs_lock();
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	if (proc != NULL) {
+		res.app_status = BLE_HS_EALREADY;
+
+		/* Set pointer to null so that existing entry doesn't get freed. */
+		proc = NULL;
+	}
+	else {
+		proc = ble_sm_proc_alloc();
+		if (proc == NULL) {
+			res.app_status = BLE_HS_ENOMEM;
+		}
+		else {
+			proc->conn_handle = conn_handle;
+			proc->key_size = key_size;
+			proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
+			proc->flags |= BLE_SM_PROC_F_INITIATOR;
+			if (auth) {
+				proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
+			}
+			ble_sm_insert(proc);
+
+			cmd.connection_handle = conn_handle;
+			cmd.encrypted_diversifier = ediv;
+			cmd.random_number = rand_val;
+			memcpy(cmd.long_term_key, ltk, sizeof cmd.long_term_key);
+
+			res.execute = 1;
+			res.state_arg = &cmd;
+		}
+	}
+
+	ble_hs_unlock();
+
+	ble_sm_process_result(conn_handle, &res, true);
+
+	return res.app_status;
+}
+
+static int ble_sm_rx(struct ble_l2cap_chan *chan)
+{
+	struct ble_sm_result res;
+	ble_sm_rx_fn *rx_cb;
+	uint8_t op;
+	uint16_t conn_handle;
+	struct os_mbuf **om;
+	int rc;
+
+	STATS_INC(ble_l2cap_stats, sm_rx);
+
+	conn_handle = ble_l2cap_get_conn_handle(chan);
+	if (conn_handle == BLE_HS_CONN_HANDLE_NONE) {
+		return BLE_HS_ENOTCONN;
+	}
+
+	om = &chan->rx_buf;
+	BLE_HS_DBG_ASSERT(*om != NULL);
+
+	rc = os_mbuf_copydata(*om, 0, 1, &op);
+	if (rc != 0) {
+		return BLE_HS_EBADDATA;
+	}
+
+	/* Strip L2CAP SM header from the front of the mbuf. */
+	os_mbuf_adj(*om, 1);
+
+	rx_cb = ble_sm_dispatch_get(op);
+	if (rx_cb != NULL) {
+		memset(&res, 0, sizeof res);
+
+		rx_cb(conn_handle, om, &res);
+		ble_sm_process_result(conn_handle, &res, op == BLE_SM_OP_PAIR_FAIL ? false : true);
+		rc = res.app_status;
+	}
+	else {
+		rc = BLE_HS_ENOTSUP;
+	}
+
+	return rc;
+}
+
+int ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io *pkey)
+{
+	struct ble_sm_result res;
+	struct ble_sm_proc *proc;
+	int rc;
+	uint8_t action;
+
+	memset(&res, 0, sizeof res);
+
+	ble_hs_lock();
+
+	proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
+	if (proc == NULL) {
+		rc = BLE_HS_ENOENT;
+	}
+	else if (proc->flags & BLE_SM_PROC_F_IO_INJECTED) {
+		rc = BLE_HS_EALREADY;
+	}
+	else if ((ble_sm_io_action(proc, &action) == 0) && pkey->action != action) {
+		/* Application provided incorrect IO type. */
+		rc = BLE_HS_EINVAL;
+	}
+	else if (ble_sm_ioact_state(pkey->action) != proc->state) {
+		/* Procedure is not ready for user input. */
+		rc = BLE_HS_EINVAL;
+	}
+	else {
+		/* Assume valid input. */
+		rc = 0;
+
+		switch (pkey->action) {
+		case BLE_SM_IOACT_OOB:
+			proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
+			memcpy(proc->tk, pkey->oob, 16);
+			if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
+			    (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
+				res.execute = 1;
+			}
+			break;
+
+		case BLE_SM_IOACT_INPUT:
+		case BLE_SM_IOACT_DISP:
+			if (pkey->passkey > 999999) {
+				rc = BLE_HS_EINVAL;
+			}
+			else {
+				proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
+				memset(proc->tk, 0, 16);
+				proc->tk[0] = (pkey->passkey >> 0) & 0xff;
+				proc->tk[1] = (pkey->passkey >> 8) & 0xff;
+				proc->tk[2] = (pkey->passkey >> 16) & 0xff;
+				proc->tk[3] = (pkey->passkey >> 24) & 0xff;
+				if ((proc->flags & BLE_SM_PROC_F_INITIATOR) ||
+				    (proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO)) {
+					res.execute = 1;
+				}
+			}
+			break;
+
+		case BLE_SM_IOACT_NUMCMP:
+			if (!pkey->numcmp_accept) {
+				res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_NUMCMP);
+				res.sm_err = BLE_SM_ERR_NUMCMP;
+			}
+			else {
+				proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
+				if (proc->flags & BLE_SM_PROC_F_INITIATOR ||
+				    proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO) {
+					res.execute = 1;
+				}
+			}
+			break;
 
 #if MYNEWT_VAL(BLE_SM_SC)
-        case BLE_SM_IOACT_OOB_SC:
-            if (!ble_sm_sc_oob_data_check(proc,
-                                          (pkey->oob_sc_data.local != NULL),
-                                          (pkey->oob_sc_data.remote != NULL))) {
-                res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_OOB);
-                res.sm_err = BLE_SM_ERR_OOB;
-            } else {
-                proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
-                proc->oob_data_local = pkey->oob_sc_data.local;
-                proc->oob_data_remote = pkey->oob_sc_data.remote;
-
-                /* Execute Confirm step */
-                ble_sm_sc_oob_confirm(proc, &res);
-            }
-            break;
+		case BLE_SM_IOACT_OOB_SC:
+			if (!ble_sm_sc_oob_data_check(proc, (pkey->oob_sc_data.local != NULL),
+			                              (pkey->oob_sc_data.remote != NULL))) {
+				res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_OOB);
+				res.sm_err = BLE_SM_ERR_OOB;
+			}
+			else {
+				proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
+				proc->oob_data_local = pkey->oob_sc_data.local;
+				proc->oob_data_remote = pkey->oob_sc_data.remote;
+
+				/* Execute Confirm step */
+				ble_sm_sc_oob_confirm(proc, &res);
+			}
+			break;
 #endif
 
-        default:
-            BLE_HS_DBG_ASSERT(0);
-            rc = BLE_HS_EINVAL;
-            break;
-        }
-    }
+		default:
+			BLE_HS_DBG_ASSERT(0);
+			rc = BLE_HS_EINVAL;
+			break;
+		}
+	}
 
-    ble_hs_unlock();
+	ble_hs_unlock();
 
-    /* If application provided invalid input, return error without modifying
-     * SMP state.
-     */
-    if (rc != 0) {
-        return rc;
-    }
+	/* If application provided invalid input, return error without modifying
+	 * SMP state.
+	 */
+	if (rc != 0) {
+		return rc;
+	}
 
-    ble_sm_process_result(conn_handle, &res, true);
-    return res.app_status;
+	ble_sm_process_result(conn_handle, &res, true);
+	return res.app_status;
 }
 
-void
-ble_sm_connection_broken(uint16_t conn_handle)
+void ble_sm_connection_broken(uint16_t conn_handle)
 {
-    struct ble_sm_result res;
+	struct ble_sm_result res;
 
-    memset(&res, 0, sizeof res);
-    res.app_status = BLE_HS_ENOTCONN;
-    res.enc_cb = 1;
+	memset(&res, 0, sizeof res);
+	res.app_status = BLE_HS_ENOTCONN;
+	res.enc_cb = 1;
 
-    ble_sm_process_result(conn_handle, &res, true);
+	ble_sm_process_result(conn_handle, &res, true);
 }
 
-int
-ble_sm_init(void)
+int ble_sm_init(void)
 {
-    int rc;
+	int rc;
 
-    STAILQ_INIT(&ble_sm_procs);
+	STAILQ_INIT(&ble_sm_procs);
 
-    rc = os_mempool_init(&ble_sm_proc_pool,
-                         MYNEWT_VAL(BLE_SM_MAX_PROCS),
-                         sizeof (struct ble_sm_proc),
-                         ble_sm_proc_mem,
-                         "ble_sm_proc_pool");
-    if (rc != 0) {
-        return rc;
-    }
+	rc =
+		os_mempool_init(&ble_sm_proc_pool, MYNEWT_VAL(BLE_SM_MAX_PROCS),
+	                  sizeof(struct ble_sm_proc), ble_sm_proc_mem, "ble_sm_proc_pool");
+	if (rc != 0) {
+		return rc;
+	}
 
-    ble_sm_sc_init();
+	ble_sm_sc_init();
 
-    return 0;
+	return 0;
 }
 #else
 /* if pairing is not supported it is only needed to reply with Pairing
  * Failed with 'Pairing not Supported' reason so this function can be very
  * simple
  */
-static int
-ble_sm_rx(struct ble_l2cap_chan *chan)
+static int ble_sm_rx(struct ble_l2cap_chan *chan)
 {
-    struct ble_sm_pair_fail *cmd;
-    struct os_mbuf *txom;
-    uint16_t handle;
-    int rc;
+	struct ble_sm_pair_fail *cmd;
+	struct os_mbuf *txom;
+	uint16_t handle;
+	int rc;
 
-    handle = ble_l2cap_get_conn_handle(chan);
-    if (!handle) {
-        return BLE_HS_ENOTCONN;
-    }
+	handle = ble_l2cap_get_conn_handle(chan);
+	if (!handle) {
+		return BLE_HS_ENOTCONN;
+	}
 
-    cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_FAIL, sizeof(*cmd), &txom);
-    if (cmd == NULL) {
-        return BLE_HS_ENOMEM;
-    }
+	cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_FAIL, sizeof(*cmd), &txom);
+	if (cmd == NULL) {
+		return BLE_HS_ENOMEM;
+	}
 
-    cmd->reason = BLE_SM_ERR_PAIR_NOT_SUPP;
+	cmd->reason = BLE_SM_ERR_PAIR_NOT_SUPP;
 
-    ble_hs_lock();
-    rc = ble_sm_tx(handle, txom);
-    ble_hs_unlock();
+	ble_hs_lock();
+	rc = ble_sm_tx(handle, txom);
+	ble_hs_unlock();
 
-    return rc;
+	return rc;
 }
 #endif
 
-struct ble_l2cap_chan *
-ble_sm_create_chan(uint16_t conn_handle)
+struct ble_l2cap_chan *ble_sm_create_chan(uint16_t conn_handle)
 {
-    struct ble_l2cap_chan *chan;
+	struct ble_l2cap_chan *chan;
 
-    chan = ble_l2cap_chan_alloc(conn_handle);
-    if (chan == NULL) {
-        return NULL;
-    }
+	chan = ble_l2cap_chan_alloc(conn_handle);
+	if (chan == NULL) {
+		return NULL;
+	}
 
-    chan->scid = BLE_L2CAP_CID_SM;
-    chan->dcid = BLE_L2CAP_CID_SM;
-    chan->my_mtu = BLE_SM_MTU;
-    chan->rx_fn = ble_sm_rx;
+	chan->scid = BLE_L2CAP_CID_SM;
+	chan->dcid = BLE_L2CAP_CID_SM;
+	chan->my_mtu = BLE_SM_MTU;
+	chan->rx_fn = ble_sm_rx;
 
-    return chan;
+	return chan;
 }
 
 #if MYNEWT_VAL(BLE_SM_CSIS_SIRK)
-int
-ble_sm_csis_decrypt_sirk(const uint8_t *ltk, const uint8_t *enc_sirk, uint8_t *out)
+int ble_sm_csis_decrypt_sirk(const uint8_t *ltk, const uint8_t *enc_sirk, uint8_t *out)
 {
-    int rc;
+	int rc;
 
-    /* Decrypt SIRK with sdf(K, EncSIRK)  */
-    rc = ble_sm_alg_csis_sdf(ltk, enc_sirk, out);
+	/* Decrypt SIRK with sdf(K, EncSIRK)  */
+	rc = ble_sm_alg_csis_sdf(ltk, enc_sirk, out);
 
-    return rc;
+	return rc;
 }
 
-int
-ble_sm_csis_resolve_rsi(const uint8_t *rsi, const uint8_t *sirk,
-                        const ble_addr_t *ltk_peer_addr)
+int ble_sm_csis_resolve_rsi(const uint8_t *rsi, const uint8_t *sirk,
+                            const ble_addr_t *ltk_peer_addr)
 {
-    struct ble_store_key_sec key_sec;
-    struct ble_store_value_sec value_sec;
-    uint8_t plaintext_sirk[16] = {0};
-    uint8_t local_hash[3] = {0};
-    uint8_t prand[3] = {0};
-    uint8_t hash[3] = {0};
-    int rc;
+	struct ble_store_key_sec key_sec;
+	struct ble_store_value_sec value_sec;
+	uint8_t plaintext_sirk[16] = {0};
+	uint8_t local_hash[3] = {0};
+	uint8_t prand[3] = {0};
+	uint8_t hash[3] = {0};
+	int rc;
 
-    memcpy(hash, rsi, 3);
-    memcpy(prand, rsi + 3, 3);
+	memcpy(hash, rsi, 3);
+	memcpy(prand, rsi + 3, 3);
 
-    if (ltk_peer_addr) {
-        memset(&key_sec, 0, sizeof(key_sec));
-        key_sec.peer_addr = *ltk_peer_addr;
+	if (ltk_peer_addr) {
+		memset(&key_sec, 0, sizeof(key_sec));
+		key_sec.peer_addr = *ltk_peer_addr;
 
-        rc = ble_store_read_peer_sec(&key_sec, &value_sec);
-        if (rc != 0) {
-            return rc;
-        } else if (!value_sec.ltk_present) {
-            return BLE_HS_ENOENT;
-        }
+		rc = ble_store_read_peer_sec(&key_sec, &value_sec);
+		if (rc != 0) {
+			return rc;
+		}
+		else if (!value_sec.ltk_present) {
+			return BLE_HS_ENOENT;
+		}
 
-        rc = ble_sm_csis_decrypt_sirk(value_sec.ltk, sirk, plaintext_sirk);
-        if (rc != 0) {
-            return rc;
-        }
-    } else {
-        memcpy(plaintext_sirk, sirk, 16);
-    }
+		rc = ble_sm_csis_decrypt_sirk(value_sec.ltk, sirk, plaintext_sirk);
+		if (rc != 0) {
+			return rc;
+		}
+	}
+	else {
+		memcpy(plaintext_sirk, sirk, 16);
+	}
 
-    rc = ble_sm_alg_csis_sih(plaintext_sirk, prand, local_hash);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_alg_csis_sih(plaintext_sirk, prand, local_hash);
+	if (rc != 0) {
+		return rc;
+	}
 
-    if (memcmp(local_hash, hash, 3)) {
-        return BLE_HS_EAUTHEN;
-    }
+	if (memcmp(local_hash, hash, 3)) {
+		return BLE_HS_EAUTHEN;
+	}
 
-    return 0;
+	return 0;
 }
 
-int
-ble_sm_csis_encrypt_sirk(const uint8_t *ltk, const uint8_t *plaintext_sirk, uint8_t *out)
+int ble_sm_csis_encrypt_sirk(const uint8_t *ltk, const uint8_t *plaintext_sirk,
+                             uint8_t *out)
 {
-    int rc;
+	int rc;
 
-    /* Encrypt SIRK with sef(K, SIRK) */
-    rc = ble_sm_alg_csis_sef(ltk, plaintext_sirk, out);
+	/* Encrypt SIRK with sef(K, SIRK) */
+	rc = ble_sm_alg_csis_sef(ltk, plaintext_sirk, out);
 
-    return rc;
+	return rc;
 }
 
-int
-ble_sm_csis_generate_rsi(const uint8_t *sirk, uint8_t *out)
+int ble_sm_csis_generate_rsi(const uint8_t *sirk, uint8_t *out)
 {
-    const uint8_t prand_check_all_set[3] = {0xff, 0xff, 0xef};
-    const uint8_t prand_check_all_reset[3] = {0x0, 0x0, 0x40};
-    uint8_t prand[3] = {0};
-    uint8_t hash[3] = {0};
-    int rc;
+	const uint8_t prand_check_all_set[3] = {0xff, 0xff, 0xef};
+	const uint8_t prand_check_all_reset[3] = {0x0, 0x0, 0x40};
+	uint8_t prand[3] = {0};
+	uint8_t hash[3] = {0};
+	int rc;
 
-    do {
-        rc = ble_hs_hci_rand(prand, 3);
-        if (rc != 0) {
-            return rc;
-        }
-        /* Two MSBs of prand shall be equal to 0 and 1 */
-        prand[2] &= ~0xc0;
-        prand[2] |= 0x40;
+	do {
+		rc = ble_hs_hci_rand(prand, 3);
+		if (rc != 0) {
+			return rc;
+		}
+		/* Two MSBs of prand shall be equal to 0 and 1 */
+		prand[2] &= ~0xc0;
+		prand[2] |= 0x40;
 
-        /* prand's random part shall not be all 0s nor all 1s */
-    } while (memcmp(prand, prand_check_all_set, 3) ||
-             memcmp(prand, prand_check_all_reset, 3));
+		/* prand's random part shall not be all 0s nor all 1s */
+	} while (memcmp(prand, prand_check_all_set, 3) ||
+	         memcmp(prand, prand_check_all_reset, 3));
 
-    rc = ble_sm_alg_csis_sih(sirk, prand, hash);
-    if (rc != 0) {
-        return rc;
-    }
+	rc = ble_sm_alg_csis_sih(sirk, prand, hash);
+	if (rc != 0) {
+		return rc;
+	}
 
-    memcpy(out, hash, 3);
-    memcpy(out + 3, prand, 3);
+	memcpy(out, hash, 3);
+	memcpy(out + 3, prand, 3);
 
-    return 0;
+	return 0;
 }
 
 #endif
diff --git a/nimble/host/src/ble_sm_sc.c b/nimble/host/src/ble_sm_sc.c
index 0cd2b2ee..02d565e5 100644
--- a/nimble/host/src/ble_sm_sc.c
+++ b/nimble/host/src/ble_sm_sc.c
@@ -27,8 +27,8 @@
 #if NIMBLE_BLE_CONNECT
 #if MYNEWT_VAL(BLE_SM_SC)
 
-#define BLE_SM_SC_PASSKEY_BYTES     4
-#define BLE_SM_SC_PASSKEY_BITS      20
+#define BLE_SM_SC_PASSKEY_BYTES 4
+#define BLE_SM_SC_PASSKEY_BITS 20
 
 static uint8_t ble_sm_sc_pub_key[64];
 static uint8_t ble_sm_sc_priv_key[32];
@@ -43,25 +43,24 @@ static uint8_t ble_sm_sc_keys_generated;
  * Create some shortened names for the passkey actions so that the table is
  * easier to read.
  */
-#define IOACT_NONE      BLE_SM_IOACT_NONE
-#define IOACT_OOB       BLE_SM_IOACT_OOB
-#define IOACT_INPUT     BLE_SM_IOACT_INPUT
-#define IOACT_DISP      BLE_SM_IOACT_DISP
-#define IOACT_NUMCMP    BLE_SM_IOACT_NUMCMP
+#define IOACT_NONE BLE_SM_IOACT_NONE
+#define IOACT_OOB BLE_SM_IOACT_OOB
+#define IOACT_INPUT BLE_SM_IOACT_INPUT
+#define IOACT_DISP BLE_SM_IOACT_DISP
+#define IOACT_NUMCMP BLE_SM_IOACT_NUMCMP
 
 /**
  * This table expresses the required initiator IO action.  Inputs are:
  *     o Responder IO capabilities (from pair response).
  *     o Initiator IO capabilities (from pair request).
  */
-static const uint8_t ble_sm_sc_init_ioa[5 /*resp*/ ][5 /*init*/ ] =
-{
-      /* init */
-/*r*/ {IOACT_NONE,    IOACT_NONE,   IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
-/*e*/ {IOACT_NONE,    IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
-/*s*/ {IOACT_DISP,    IOACT_DISP,   IOACT_INPUT, IOACT_NONE, IOACT_DISP},
-/*p*/ {IOACT_NONE,    IOACT_NONE,   IOACT_NONE,  IOACT_NONE, IOACT_NONE},
-      {IOACT_DISP,    IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
+static const uint8_t ble_sm_sc_init_ioa[5 /*resp*/][5 /*init*/] = {
+    /* init */
+    /*r*/ {IOACT_NONE, IOACT_NONE, IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
+    /*e*/ {IOACT_NONE, IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
+    /*s*/ {IOACT_DISP, IOACT_DISP, IOACT_INPUT, IOACT_NONE, IOACT_DISP},
+    /*p*/ {IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE},
+    {IOACT_DISP, IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
 };
 
 /**
@@ -69,14 +68,13 @@ static const uint8_t ble_sm_sc_init_ioa[5 /*resp*/ ][5 /*init*/ ] =
  *     o Responder IO capabilities (from pair response).
  *     o Initiator IO capabilities (from pair request).
  */
-static const uint8_t ble_sm_sc_resp_ioa[5 /*resp*/ ][5 /*init*/ ] =
-{
-      /* init */
-/*r*/ {IOACT_NONE,    IOACT_NONE,   IOACT_DISP,  IOACT_NONE, IOACT_DISP},
-/*e*/ {IOACT_NONE,    IOACT_NUMCMP, IOACT_DISP,  IOACT_NONE, IOACT_NUMCMP},
-/*s*/ {IOACT_INPUT,   IOACT_INPUT,  IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
-/*p*/ {IOACT_NONE,    IOACT_NONE,   IOACT_NONE,  IOACT_NONE, IOACT_NONE},
-      {IOACT_INPUT,   IOACT_NUMCMP, IOACT_DISP,  IOACT_NONE, IOACT_NUMCMP},
+static const uint8_t ble_sm_sc_resp_ioa[5 /*resp*/][5 /*init*/] = {
+    /* init */
+    /*r*/ {IOACT_NONE, IOACT_NONE, IOACT_DISP, IOACT_NONE, IOACT_DISP},
+    /*e*/ {IOACT_NONE, IOACT_NUMCMP, IOACT_DISP, IOACT_NONE, IOACT_NUMCMP},
+    /*s*/ {IOACT_INPUT, IOACT_INPUT, IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
+    /*p*/ {IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE},
+    {IOACT_INPUT, IOACT_NUMCMP, IOACT_DISP, IOACT_NONE, IOACT_NUMCMP},
 };
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
@@ -86,38 +84,40 @@ static uint8_t ble_sm_dbg_sc_priv_key[32];
 static uint8_t ble_sm_dbg_sc_keys_set;
 
 void
-ble_sm_dbg_set_sc_keys(uint8_t *pubkey, uint8_t *privkey)
+ble_sm_dbg_set_sc_keys(uint8_t* pubkey, uint8_t* privkey)
 {
-    memcpy(ble_sm_dbg_sc_pub_key, pubkey,
-           sizeof ble_sm_dbg_sc_pub_key);
-    memcpy(ble_sm_dbg_sc_priv_key, privkey,
-           sizeof ble_sm_dbg_sc_priv_key);
+    memcpy(ble_sm_dbg_sc_pub_key, pubkey, sizeof ble_sm_dbg_sc_pub_key);
+    memcpy(ble_sm_dbg_sc_priv_key, privkey, sizeof ble_sm_dbg_sc_priv_key);
     ble_sm_dbg_sc_keys_set = 1;
 }
 
 #endif
 
 int
-ble_sm_sc_io_action(struct ble_sm_proc *proc, uint8_t *action)
+ble_sm_sc_io_action(struct ble_sm_proc* proc, uint8_t* action)
 {
     struct ble_sm_pair_cmd *pair_req, *pair_rsp;
 
-    pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+    pair_req = (struct ble_sm_pair_cmd*)&proc->pair_req[1];
+    pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
 
     if (pair_req->oob_data_flag == BLE_SM_PAIR_OOB_YES ||
         pair_rsp->oob_data_flag == BLE_SM_PAIR_OOB_YES) {
         *action = BLE_SM_IOACT_OOB_SC;
-    } else if (!(pair_req->authreq & BLE_SM_PAIR_AUTHREQ_MITM) &&
-               !(pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_MITM)) {
+    }
+    else if (!(pair_req->authreq & BLE_SM_PAIR_AUTHREQ_MITM) &&
+             !(pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_MITM)) {
 
         *action = BLE_SM_IOACT_NONE;
-    } else if (pair_req->io_cap >= BLE_SM_IO_CAP_RESERVED ||
-               pair_rsp->io_cap >= BLE_SM_IO_CAP_RESERVED) {
+    }
+    else if (pair_req->io_cap >= BLE_SM_IO_CAP_RESERVED ||
+             pair_rsp->io_cap >= BLE_SM_IO_CAP_RESERVED) {
         *action = BLE_SM_IOACT_NONE;
-    } else if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+    }
+    else if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         *action = ble_sm_sc_init_ioa[pair_rsp->io_cap][pair_req->io_cap];
-    } else {
+    }
+    else {
         *action = ble_sm_sc_resp_ioa[pair_rsp->io_cap][pair_req->io_cap];
     }
 
@@ -151,7 +151,7 @@ ble_sm_sc_io_action(struct ble_sm_proc *proc, uint8_t *action)
 }
 
 static int
-ble_sm_gen_pub_priv(uint8_t *pub, uint8_t *priv)
+ble_sm_gen_pub_priv(uint8_t* pub, uint8_t* priv)
 {
     int rc;
 
@@ -202,7 +202,7 @@ ble_sm_sc_ensure_keys_generated(void)
  * (vol. 3, part H, 2.3.5.6.2)
  */
 static int
-ble_sm_sc_initiator_txes_confirm(struct ble_sm_proc *proc)
+ble_sm_sc_initiator_txes_confirm(struct ble_sm_proc* proc)
 {
     BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_SC);
 
@@ -217,7 +217,7 @@ ble_sm_sc_initiator_txes_confirm(struct ble_sm_proc *proc)
  * (vol. 3, part H, 2.3.5.6.2)
  */
 static int
-ble_sm_sc_responder_verifies_random(struct ble_sm_proc *proc)
+ble_sm_sc_responder_verifies_random(struct ble_sm_proc* proc)
 {
     BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_SC);
 
@@ -230,7 +230,7 @@ ble_sm_sc_responder_verifies_random(struct ble_sm_proc *proc)
  * written to the supplied procedure object.
  */
 static int
-ble_sm_sc_gen_ri(struct ble_sm_proc *proc)
+ble_sm_sc_gen_ri(struct ble_sm_proc* proc)
 {
     int byte;
     int bit;
@@ -261,7 +261,7 @@ ble_sm_sc_gen_ri(struct ble_sm_proc *proc)
 }
 
 void
-ble_sm_sc_oob_confirm(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_oob_confirm(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
     int err;
     bool match;
@@ -298,10 +298,10 @@ ble_sm_sc_oob_confirm(struct ble_sm_proc *proc, struct ble_sm_result *res)
 }
 
 void
-ble_sm_sc_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_confirm_exec(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
-    struct ble_sm_pair_confirm *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_pair_confirm* cmd;
+    struct os_mbuf* txom;
     int rc;
 
     rc = ble_sm_sc_gen_ri(proc);
@@ -345,15 +345,16 @@ ble_sm_sc_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
 }
 
 static void
-ble_sm_sc_gen_numcmp(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_gen_numcmp(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
-    uint8_t *pka;
-    uint8_t *pkb;
+    uint8_t* pka;
+    uint8_t* pkb;
 
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         pka = ble_sm_sc_pub_key;
         pkb = proc->pub_key_peer.x;
-    } else {
+    }
+    else {
         pka = proc->pub_key_peer.x;
         pkb = ble_sm_sc_pub_key;
     }
@@ -370,7 +371,7 @@ ble_sm_sc_gen_numcmp(struct ble_sm_proc *proc, struct ble_sm_result *res)
  * completed the random state.
  */
 static int
-ble_sm_sc_random_advance(struct ble_sm_proc *proc)
+ble_sm_sc_random_advance(struct ble_sm_proc* proc)
 {
     int rc;
 
@@ -378,7 +379,8 @@ ble_sm_sc_random_advance(struct ble_sm_proc *proc)
         proc->passkey_bits_exchanged >= BLE_SM_SC_PASSKEY_BITS) {
 
         proc->state = BLE_SM_PROC_STATE_DHKEY_CHECK;
-    } else {
+    }
+    else {
         proc->state = BLE_SM_PROC_STATE_CONFIRM;
         rc = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
         if (rc != 0) {
@@ -390,10 +392,10 @@ ble_sm_sc_random_advance(struct ble_sm_proc *proc)
 }
 
 void
-ble_sm_sc_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_random_exec(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
-    struct ble_sm_pair_random *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_pair_random* cmd;
+    struct os_mbuf* txom;
     uint8_t ioact;
     int rc;
 
@@ -438,7 +440,7 @@ ble_sm_sc_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
 }
 
 void
-ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_random_rx(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
     uint8_t confirm_val[16];
     uint8_t ia[6];
@@ -448,17 +450,16 @@ ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
     uint8_t rat;
     int rc;
 
-    if (proc->pair_alg != BLE_SM_PAIR_ALG_OOB && (
-        proc->flags & BLE_SM_PROC_F_INITIATOR ||
-        ble_sm_sc_responder_verifies_random(proc))) {
+    if (proc->pair_alg != BLE_SM_PAIR_ALG_OOB &&
+        (proc->flags & BLE_SM_PROC_F_INITIATOR ||
+         ble_sm_sc_responder_verifies_random(proc))) {
 
         BLE_HS_LOG(DEBUG, "tk=");
         ble_hs_log_flat_buf(proc->tk, 16);
         BLE_HS_LOG(DEBUG, "\n");
 
         rc = ble_sm_alg_f4(proc->pub_key_peer.x, ble_sm_sc_pub_key,
-                           ble_sm_peer_pair_rand(proc), proc->ri,
-                           confirm_val);
+                           ble_sm_peer_pair_rand(proc), proc->ri, confirm_val);
         if (rc != 0) {
             res->app_status = rc;
             res->sm_err = BLE_SM_ERR_UNSPECIFIED;
@@ -475,10 +476,14 @@ ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
         }
     }
 
+    // here we read bond
+    // ble_sm_read_bond()
+    // if bond exists, we do an extra kdf round with old ltk and this ltk. thus overwriting it.
+
     /* Calculate the mac key and ltk. */
     ble_sm_ia_ra(proc, &iat, ia, &rat, ra);
-    rc = ble_sm_alg_f5(proc->dhkey, proc->randm, proc->rands,
-                       iat, ia, rat, ra, proc->mackey, proc->ltk);
+    rc = ble_sm_alg_f5(proc->dhkey, proc->randm, proc->rands, iat, ia, rat, ra,
+                       proc->mackey, proc->ltk);
     if (rc != 0) {
         res->app_status = rc;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
@@ -518,25 +523,28 @@ ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
             res->passkey_params.action = ioact;
             BLE_HS_DBG_ASSERT(ioact == BLE_SM_IOACT_NUMCMP);
             ble_sm_sc_gen_numcmp(proc, res);
-        } else {
+        }
+        else {
             res->execute = 1;
         }
-    } else {
+    }
+    else {
         if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB &&
             !(proc->flags & BLE_SM_PROC_F_IO_INJECTED)) {
             proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
-        } else {
+        }
+        else {
             res->execute = 1;
         }
     }
 }
 
 void
-ble_sm_sc_public_key_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                          void *arg)
+ble_sm_sc_public_key_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                          void* arg)
 {
-    struct ble_sm_public_key *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_public_key* cmd;
+    struct os_mbuf* txom;
     uint8_t ioact;
     int rc;
 
@@ -568,7 +576,8 @@ ble_sm_sc_public_key_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
     if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
         if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
             proc->state = BLE_SM_PROC_STATE_RANDOM;
-        } else {
+        }
+        else {
             proc->state = BLE_SM_PROC_STATE_CONFIRM;
         }
 
@@ -590,11 +599,11 @@ ble_sm_sc_public_key_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
 }
 
 void
-ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **om,
-                        struct ble_sm_result *res)
+ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf** om,
+                        struct ble_sm_result* res)
 {
-    struct ble_sm_public_key *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_public_key* cmd;
+    struct ble_sm_proc* proc;
     uint8_t ioact;
     int rc;
 
@@ -611,7 +620,7 @@ ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_public_key *)(*om)->om_data;
+    cmd = (struct ble_sm_public_key*)(*om)->om_data;
     /* Check if the peer public key is same as our generated public key.
      * Return fail if the public keys match. */
     if (memcmp(cmd, ble_sm_sc_pub_key, 64) == 0) {
@@ -621,32 +630,33 @@ ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **om,
     }
 
     ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PUBLIC_KEY, -1,
-                            NULL);
+    proc =
+        ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PUBLIC_KEY, -1, NULL);
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
+    }
+    else {
         memcpy(&proc->pub_key_peer, cmd, sizeof(*cmd));
-        rc = ble_sm_alg_gen_dhkey(proc->pub_key_peer.x,
-                                  proc->pub_key_peer.y,
-                                  ble_sm_sc_priv_key,
-                                  proc->dhkey);
+        rc = ble_sm_alg_gen_dhkey(proc->pub_key_peer.x, proc->pub_key_peer.y,
+                                  ble_sm_sc_priv_key, proc->dhkey);
         if (rc != 0) {
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_DHKEY);
             res->sm_err = BLE_SM_ERR_DHKEY;
             res->enc_cb = 1;
-        } else {
+        }
+        else {
             if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
                 if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
                     proc->state = BLE_SM_PROC_STATE_RANDOM;
-                } else {
+                }
+                else {
                     proc->state = BLE_SM_PROC_STATE_CONFIRM;
                 }
 
                 rc = ble_sm_sc_io_action(proc, &ioact);
                 if (rc != 0) {
-                        BLE_HS_DBG_ASSERT(0);
+                    BLE_HS_DBG_ASSERT(0);
                 }
 
                 if (ble_sm_ioact_state(ioact) == proc->state) {
@@ -658,7 +668,8 @@ ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **om,
 
                     res->execute = 1;
                 }
-            } else {
+            }
+            else {
                 res->execute = 1;
             }
         }
@@ -667,11 +678,11 @@ ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **om,
 }
 
 static void
-ble_sm_sc_dhkey_addrs(struct ble_sm_proc *proc, ble_addr_t *our_addr,
-                      ble_addr_t *peer_addr)
+ble_sm_sc_dhkey_addrs(struct ble_sm_proc* proc, ble_addr_t* our_addr,
+                      ble_addr_t* peer_addr)
 {
     struct ble_hs_conn_addrs addrs;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     conn = ble_hs_conn_find_assert(proc->conn_handle);
 
@@ -682,32 +693,34 @@ ble_sm_sc_dhkey_addrs(struct ble_sm_proc *proc, ble_addr_t *our_addr,
 }
 
 void
-ble_sm_sc_dhkey_check_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                           void *arg)
+ble_sm_sc_dhkey_check_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                           void* arg)
 {
-    struct ble_sm_dhkey_check *cmd;
+    struct ble_sm_dhkey_check* cmd;
     ble_addr_t our_addr;
     ble_addr_t peer_addr;
-    struct os_mbuf *txom;
-    uint8_t *iocap;
+    struct os_mbuf* txom;
+    uint8_t* iocap;
     int rc;
 
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        struct ble_sm_pair_cmd *pair_req;
+        struct ble_sm_pair_cmd* pair_req;
 
-        pair_req  = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+        pair_req = (struct ble_sm_pair_cmd*)&proc->pair_req[1];
         iocap = &pair_req->io_cap;
-    } else {
-        struct ble_sm_pair_cmd *pair_rsp;
+    }
+    else {
+        struct ble_sm_pair_cmd* pair_rsp;
 
-        pair_rsp  = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+        pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
         iocap = &pair_rsp->io_cap;
     }
 
     if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
         if (proc->oob_data_remote) {
             memcpy(proc->tk, proc->oob_data_remote->r, 16);
-        } else {
+        }
+        else {
             memset(proc->tk, 0, 16);
         }
     }
@@ -747,40 +760,43 @@ err:
 }
 
 static void
-ble_sm_dhkey_check_process(struct ble_sm_proc *proc,
-                           struct ble_sm_dhkey_check *cmd,
-                           struct ble_sm_result *res)
+ble_sm_dhkey_check_process(struct ble_sm_proc* proc,
+                           struct ble_sm_dhkey_check* cmd,
+                           struct ble_sm_result* res)
 {
     uint8_t exp_value[16];
     ble_addr_t our_addr;
     ble_addr_t peer_addr;
-    uint8_t *iocap;
+    uint8_t* iocap;
     uint8_t ioact;
     int rc;
 
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        struct ble_sm_pair_cmd *pair_rsp;
+        struct ble_sm_pair_cmd* pair_rsp;
 
-        pair_rsp  = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+        pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
         iocap = &pair_rsp->io_cap;
 
         if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
             if (pair_rsp->oob_data_flag) {
                 memcpy(proc->tk, proc->oob_data_local->r, 16);
-            } else {
+            }
+            else {
                 memset(proc->tk, 0, 16);
             }
         }
-    } else {
-        struct ble_sm_pair_cmd *pair_req;
+    }
+    else {
+        struct ble_sm_pair_cmd* pair_req;
 
-        pair_req  = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+        pair_req = (struct ble_sm_pair_cmd*)&proc->pair_req[1];
         iocap = &pair_req->io_cap;
 
         if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
             if (pair_req->oob_data_flag) {
                 memcpy(proc->tk, proc->oob_data_local->r, 16);
-            } else {
+            }
+            else {
                 memset(proc->tk, 0, 16);
             }
         }
@@ -791,13 +807,10 @@ ble_sm_dhkey_check_process(struct ble_sm_proc *proc,
     ble_hs_log_flat_buf(proc->tk, 16);
     BLE_HS_LOG(DEBUG, "\n");
 
-    res->app_status = ble_sm_alg_f6(proc->mackey,
-                                    ble_sm_peer_pair_rand(proc),
-                                    ble_sm_our_pair_rand(proc),
-                                    proc->tk, iocap,
+    res->app_status = ble_sm_alg_f6(proc->mackey, ble_sm_peer_pair_rand(proc),
+                                    ble_sm_our_pair_rand(proc), proc->tk, iocap,
                                     peer_addr.type, peer_addr.val,
-                                    our_addr.type, our_addr.val,
-                                    exp_value);
+                                    our_addr.type, our_addr.val, exp_value);
     if (res->app_status != 0) {
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
         res->enc_cb = 1;
@@ -831,11 +844,11 @@ ble_sm_dhkey_check_process(struct ble_sm_proc *proc,
 }
 
 void
-ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf **om,
-                         struct ble_sm_result *res)
+ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf** om,
+                         struct ble_sm_result* res)
 {
-    struct ble_sm_dhkey_check *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_dhkey_check* cmd;
+    struct ble_sm_proc* proc;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status != 0) {
@@ -844,43 +857,44 @@ ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_dhkey_check *)(*om)->om_data;
+    cmd = (struct ble_sm_dhkey_check*)(*om)->om_data;
 
     ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_DHKEY_CHECK, -1,
-                            NULL);
+    proc =
+        ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_DHKEY_CHECK, -1, NULL);
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
-    } else {
+    }
+    else {
         ble_sm_dhkey_check_process(proc, cmd, res);
     }
     ble_hs_unlock();
 }
 
 bool
-ble_sm_sc_oob_data_check(struct ble_sm_proc *proc,
-                         bool oob_data_local_present,
+ble_sm_sc_oob_data_check(struct ble_sm_proc* proc, bool oob_data_local_present,
                          bool oob_data_remote_present)
 {
-    struct ble_sm_pair_cmd *pair_req;
-    struct ble_sm_pair_cmd *pair_rsp;
+    struct ble_sm_pair_cmd* pair_req;
+    struct ble_sm_pair_cmd* pair_rsp;
     bool req_oob_present;
     bool rsp_oob_present;
 
-    pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+    pair_req = (struct ble_sm_pair_cmd*)&proc->pair_req[1];
+    pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
     req_oob_present = pair_req->oob_data_flag == BLE_SM_PAIR_OOB_YES;
     rsp_oob_present = pair_rsp->oob_data_flag == BLE_SM_PAIR_OOB_YES;
 
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         return req_oob_present == oob_data_remote_present;
-    } else {
+    }
+    else {
         return rsp_oob_present == oob_data_remote_present;
     }
 }
 
 int
-ble_sm_sc_oob_generate_data(struct ble_sm_sc_oob_data *oob_data)
+ble_sm_sc_oob_generate_data(struct ble_sm_sc_oob_data* oob_data)
 {
     int rc;
 
@@ -914,5 +928,5 @@ ble_sm_sc_init(void)
     ble_sm_sc_keys_generated = 0;
 }
 
-#endif  /* MYNEWT_VAL(BLE_SM_SC) */
+#endif /* MYNEWT_VAL(BLE_SM_SC) */
 #endif
